

SQL> DROP TABLE IF EXISTS T_RBO_1;

Succeed.

SQL> CREATE TABLE T_RBO_1(F_INT INT, F_CHAR VARCHAR(20), F_REAL REAL, F_DOUBLE DOUBLE);

Succeed.

SQL> CREATE INDEX IDX_1_1 ON T_RBO_1(F_REAL);

Succeed.

SQL> CREATE UNIQUE INDEX IDX_1_2 ON T_RBO_1(F_INT, F_CHAR);

Succeed.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE F_INT=1 AND F_CHAR='1' AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | IDX_1_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 1                                       
   2 - access: F_CHAR = '1' AND F_INT = 1                       

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE F_INT=1 AND F_CHAR>='1' AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_1_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_INT = 1 AND F_CHAR >= '1'                      
   2 - access: F_REAL = 1                                       

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE F_INT=1 AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_1_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_INT = 1                                        
   2 - access: F_REAL = 1                                       

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE (F_INT=1 OR F_INT=2) AND F_CHAR='1' AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_1_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 1                                       
   2 - access: F_INT = 1 OR F_INT = 2 AND F_CHAR = '1'          

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE (F_INT=1 OR F_INT IS NULL) AND F_CHAR='1' AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_1_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 1                                       
   2 - access: F_INT = 1 OR F_INT IS NULL AND F_CHAR = '1'      

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_1 WHERE (F_INT=NULL OR F_INT IS NULL) AND F_CHAR='1' AND F_REAL=1.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_1_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 1                                       
   2 - access: F_INT = NULL OR F_INT IS NULL AND F_CHAR = '1'   

11 rows fetched.

SQL> DROP TABLE IF EXISTS T_RBO_2;

Succeed.

SQL> CREATE TABLE T_RBO_2(F_INT INT, F_CHAR VARCHAR(20), F_REAL REAL, F_DOUBLE DOUBLE);

Succeed.

SQL> CREATE INDEX IDX_2_1 ON T_RBO_2(F_CHAR);

Succeed.

SQL> CREATE INDEX IDX_2_2 ON T_RBO_2(F_REAL);

Succeed.

SQL> CREATE UNIQUE INDEX IDX_2_3 ON T_RBO_2(F_INT, F_CHAR);

Succeed.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_2 WHERE F_INT=1 AND F_CHAR='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | IDX_2_3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_CHAR = '1' AND F_INT = 1                       

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_2 WHERE F_INT=1 AND F_CHAR>='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_2_3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 1 AND F_CHAR >= '1'                      

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_2 WHERE F_INT=1 AND F_CHAR='1' AND F_REAL=8.0 ORDER BY F_REAL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |         |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | IDX_2_3 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F_REAL = 8                                       
   3 - access: F_CHAR = '1' AND F_INT = 1                       

12 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT F_INT, F_CHAR FROM T_RBO_2 WHERE F_INT=1 AND F_CHAR>='1' ORDER BY F_CHAR;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | T_RBO_2 |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IDX_2_3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 1 AND F_CHAR >= '1'                      

10 rows fetched.

SQL> DROP TABLE IF EXISTS T_RBO_3;

Succeed.

SQL> CREATE TABLE T_RBO_3(F_INT INT, F_CHAR VARCHAR(20), F_REAL REAL)
  2 PARTITION BY RANGE(F_REAL)
  3 (
  4  PARTITION P1 VALUES LESS THAN(10),
  5  PARTITION P2 VALUES LESS THAN(20),
  6  PARTITION P3 VALUES LESS THAN(30),
  7  PARTITION P4 VALUES LESS THAN(MAXVALUE)
  8 );

Succeed.

SQL> CREATE INDEX IDX_3_1 ON T_RBO_3(F_CHAR) LOCAL;

Succeed.

SQL> CREATE UNIQUE INDEX  IDX_3_2 ON T_RBO_3(F_INT, F_CHAR);

Succeed.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_3 WHERE F_INT=1 AND F_CHAR='1' AND F_REAL=8.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | T_RBO_3 |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN                      | SYS   | IDX_3_2 |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 8                                       
   2 - access: F_CHAR = '1' AND F_INT = 1                       

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_3 WHERE F_INT>1 AND F_CHAR>'1' AND F_REAL=8.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | T_RBO_3 |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | IDX_3_1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 8 AND F_INT > 1                         
   2 - access: F_CHAR > '1'                                     

11 rows fetched.

SQL> DROP TABLE IF EXISTS T_RBO_4;

Succeed.

SQL> CREATE TABLE T_RBO_4(F_INT INT, F_CHAR VARCHAR(20), F_REAL REAL, F_DOUBLE DOUBLE);

Succeed.

SQL> CREATE INDEX IDX_4_1 ON T_RBO_4(F_INT,F_CHAR);

Succeed.

SQL> CREATE INDEX IDX_4_2 ON T_RBO_4(F_CHAR,F_REAL);

Succeed.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_4 WHERE F_INT=1 AND F_CHAR ='1' AND F_REAL=8.0 ORDER BY F_DOUBLE;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |         |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_4 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_4_1 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F_REAL = 8                                       
   3 - access: F_CHAR = '1' AND F_INT = 1                       

12 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_4 WHERE F_INT=1 AND F_CHAR ='1' AND F_REAL=8.0 ORDER BY F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_4 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_4_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_REAL = 8                                       
   2 - access: F_CHAR = '1' AND F_INT = 1                       

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_4 WHERE F_INT=1 AND F_CHAR ='1' AND F_REAL=8.0 ORDER BY F_REAL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_4 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_4_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_INT = 1                                        
   2 - access: F_REAL = 8 AND F_CHAR = '1'                      

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_4 WHERE F_INT=1 AND F_CHAR >='1' ORDER BY F_CHAR;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_4 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_4_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 1 AND F_CHAR >= '1'                      

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_4 WHERE F_INT>1 AND F_CHAR >='1' ORDER BY F_CHAR;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |         |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_4 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_4_1 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F_INT > 1 AND F_CHAR >= '1'                      

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT F_INT,F_CHAR FROM T_RBO_4 WHERE F_INT=1 AND F_CHAR ='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | T_RBO_4 |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IDX_4_1 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_CHAR = '1' AND F_INT = 1                       

10 rows fetched.

SQL> DROP TABLE IF EXISTS T_RBO_5;

Succeed.

SQL> CREATE TABLE T_RBO_5(F_INT INT, F_CHAR VARCHAR(20), F_REAL REAL, F_DOUBLE DOUBLE, F_DATE DATE);

Succeed.

SQL> CREATE INDEX IDX_5_1 ON T_RBO_5(F_INT,F_CHAR,F_REAL);

Succeed.

SQL> CREATE INDEX IDX_5_2 ON T_RBO_5(F_CHAR,F_REAL);

Succeed.

SQL> CREATE INDEX IDX_5_3 ON T_RBO_5(F_INT,F_CHAR,F_DOUBLE,F_DATE);

Succeed.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_5 WHERE F_INT=1 AND F_CHAR >'1' AND F_REAL>8.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_5 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_5_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 1 AND F_CHAR > '1' AND F_REAL > 8        

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_5 WHERE F_INT=1 AND F_CHAR ='1' AND F_DOUBLE=8.0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_5 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_5_3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_DOUBLE = 8 AND F_INT = 1 AND F_CHAR = '1'      

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT MAX(F_INT) FROM T_RBO_5 WHERE F_INT > 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |         |      |      |       |        |
| 1   |   INDEX AGGR                      |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY    | SYS   | T_RBO_5 |      |      |       |        |
| 3   |       INDEX RANGE SCAN DESCENDING | SYS   | IDX_5_1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F_INT > 10 AND F_INT IS NOT NULL                 

11 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_5 WHERE F_CHAR IN ('aa','bb','cc');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_5 |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_5_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_CHAR IN('aa', 'bb', 'cc')                      

10 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_RBO_5 WHERE F_CHAR = 'aa' AND F_REAL IN (123,456);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_5 |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_5_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_CHAR = 'aa' AND F_REAL IN(123, 456)            

10 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T1.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_1_1    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F_DOUBLE = T2.F_DOUBLE                        
   3 - access: T1.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T2.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_2_2    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_DOUBLE = T1.F_DOUBLE                        
   3 - access: T2.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_REAL = T2.F_REAL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_2_2    |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.F_REAL = T2.F_REAL                            

12 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 LEFT JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T1.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)             |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_1_1    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F_DOUBLE = T2.F_DOUBLE                        
   3 - access: T1.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 LEFT JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T2.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_2_2    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_DOUBLE = T1.F_DOUBLE                        
   3 - access: T2.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 LEFT JOIN T_RBO_2 T2 ON T1.F_REAL = T2.F_REAL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_2_2    |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.F_REAL = T2.F_REAL                            

12 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 RIGHT JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T1.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_1_1    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F_DOUBLE = T2.F_DOUBLE                        
   3 - access: T1.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 RIGHT JOIN T_RBO_2 T2 ON T1.F_DOUBLE = T2.F_DOUBLE WHERE T2.F_REAL=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)             |       |            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_2_2    |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_DOUBLE = T1.F_DOUBLE                        
   3 - access: T2.F_REAL = 10                                   

13 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 RIGHT JOIN T_RBO_2 T2 ON T1.F_REAL = T2.F_REAL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_RBO_2 T2 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 T1 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_1_1    |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.F_REAL = T2.F_REAL                            

12 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT LEFT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |            |      |      |       |        |
| 1   |   NESTED LOOPS OUTER               |       |            |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_2_3    |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID    | SYS   | T_RBO_4 T4 |      |      |       |        |
| 7   |       INDEX RANGE SCAN             | SYS   | IDX_4_1    |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.F_INT = T2.F_INT                              
   7 - access: T1.F_INT = T4.F_INT                              

16 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT RIGHT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |            |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)               |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | T_RBO_4 T4 |      |      |       |        |
| 3   |     NESTED LOOPS                   |       |            |      |      |       |        |
| 4   |       TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | IDX_2_3    |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T4.F_INT = T1.F_INT                              
   6 - access: T1.F_INT = T2.F_INT                              

15 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 LEFT JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |            |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |            |      |      |       |        |
| 2   |     NESTED LOOPS OUTER             |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_2_3    |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID    | SYS   | T_RBO_4 T4 |      |      |       |        |
| 7   |       INDEX RANGE SCAN             | SYS   | IDX_4_1    |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.F_INT = T2.F_INT                              
   7 - access: T1.F_INT = T4.F_INT                              

16 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 RIGHT JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |            |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |            |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_RBO_2 T2 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_1 T1 |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_1_2    |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID    | SYS   | T_RBO_4 T4 |      |      |       |        |
| 7   |       INDEX RANGE SCAN             | SYS   | IDX_4_1    |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.F_INT = T2.F_INT                              
   7 - access: T4.F_INT = T2.F_INT AND T1.F_INT = T4.F_INT      

16 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT LEFT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT RIGHT JOIN T_RBO_5 T5 ON T4.F_INT=T5.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |            |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL                | SYS   | T_RBO_5 T5 |      |      |       |        |
| 3   |     NESTED LOOPS OUTER               |       |            |      |      |       |        |
| 4   |       NESTED LOOPS                   |       |            |      |      |       |        |
| 5   |         TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | IDX_2_3    |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ROWID    | SYS   | T_RBO_4 T4 |      |      |       |        |
| 9   |         INDEX RANGE SCAN             | SYS   | IDX_4_1    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T5.F_INT = T4.F_INT                              
   7 - access: T1.F_INT = T2.F_INT                              
   9 - access: T1.F_INT = T4.F_INT                              

19 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_1 T1 JOIN T_RBO_2 T2 ON T1.F_INT=T2.F_INT RIGHT JOIN T_RBO_4 T4 ON T1.F_INT=T4.F_INT LEFT JOIN T_RBO_5 T5 ON T4.F_INT=T5.F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |            |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                 |       |            |      |      |       |        |
| 2   |     HASH JOIN OUTER(R)               |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL              | SYS   | T_RBO_4 T4 |      |      |       |        |
| 4   |       NESTED LOOPS                   |       |            |      |      |       |        |
| 5   |         TABLE ACCESS FULL            | SYS   | T_RBO_1 T1 |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_2 T2 |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | IDX_2_3    |      |      |       |        |
| 8   |     TABLE ACCESS BY INDEX ROWID      | SYS   | T_RBO_5 T5 |      |      |       |        |
| 9   |       INDEX RANGE SCAN               | SYS   | IDX_5_1    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T4.F_INT = T1.F_INT                              
   7 - access: T1.F_INT = T2.F_INT                              
   9 - access: T4.F_INT = T5.F_INT                              

19 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T_RBO_1;

Succeed.

SQL> DROP TABLE IF EXISTS T_RBO_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_RBO_3;

Succeed.

SQL> DROP TABLE IF EXISTS T_RBO_4;

Succeed.

SQL> DROP TABLE IF EXISTS T_RBO_5;

Succeed.

SQL> 
SQL> select * from dual where rowid = to_char('00086364160');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('A00863641600000');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863641600002');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863846400000') or rowid = to_char('000863641600001');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863846400000') or rowid = to_char('000863641700000');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863846400000') and rowid = to_char('000863641700000');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863846400000') and rowid = to_char('000863846400000');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = to_char('000863846400000') and rowid = to_char('000863846400000') and rowid = to_char('000863641700000');

CT-00639, The row ID was invalid
SQL> select * from dual where rowid in (to_char('000863846400000'), to_char('000863641700000'), to_char('000863641700000'), to_char('000863641700000'), to_char('000863846400000'));

CT-00639, The row ID was invalid
SQL> select * from dual where rowid = '000863846400000' or rowid = '000863641600001';

CT-00639, The row ID was invalid
SQL> 
SQL> DROP TABLE IF EXISTS T1;

Succeed.

SQL> DROP TABLE IF EXISTS T2;

Succeed.

SQL> DROP TABLE IF EXISTS T3;

Succeed.

SQL> DROP TABLE IF EXISTS T4;

Succeed.

SQL> 
SQL> create table t1(f_int1 int, f_int2 int, f_varchar1 varchar(32));

Succeed.

SQL> create index idx_t1 on t1(f_int1);

Succeed.

SQL> create table t2(f_int1 int, f_int2 int, f_varchar1 varchar(32));

Succeed.

SQL> create index idx_t2 on t2(f_int1);

Succeed.

SQL> create table t3(f_int1 int, f_int2 int, f_varchar1 varchar(32));

Succeed.

SQL> create index idx_t3 on t3(f_int1);

Succeed.

SQL> create table t4(f_int1 int, f_int2 int, f_varchar1 varchar(32));

Succeed.

SQL> create index idx_t4 on t4(f_int1);

Succeed.

SQL> 
SQL> explain select t1.f_varchar1, t2.f_varchar1 from t1 join t2 on t1.f_int2=t2.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------
| Id  | Description            | Owner | Name | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |      |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |      |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T1   |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F_INT2 = T2.F_INT2                            

11 rows fetched.

SQL> explain select t1.f_varchar1, tt2.f_varchar1 from t1 join (select f_int1, f_varchar1, count(*) from t2 group by f_int1, f_varchar1) tt2 on t1.f_int2 = tt2.f_int1 where t1.f_int1 > 0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name   | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |        |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |        |      |      |       |        |
| 2   |     SUBSELECT                    |       | TT2    |      |      |       |        |
| 3   |       HASH GROUP BY              |       |        |      |      |       |        |
| 4   |         TABLE ACCESS FULL        | SYS   | T2     |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T1     |      |      |       |        |
| 6   |       INDEX RANGE SCAN           | SYS   | IDX_T1 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: TT2.F_INT1 = T1.F_INT2                           
   6 - access: T1.F_INT1 > 0                                    

15 rows fetched.

SQL> explain select t1.f_varchar1, tt2.f_varchar1 from t1 join (select f_int1, f_varchar1, count(*) from t2 group by f_int1, f_varchar1) tt2 on t1.f_int2 = tt2.f_int1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description                | Owner | Name | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |      |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |      |      |      |       |        |
| 2   |     SUBSELECT              |       | TT2  |      |      |       |        |
| 3   |       HASH GROUP BY        |       |      |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
| 5   |     TABLE ACCESS FULL      | SYS   | T1   |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: TT2.F_INT1 = T1.F_INT2                           

13 rows fetched.

SQL> explain select tt1.f_varchar1, tt2.f_varchar1 from (select f_int1, f_varchar1, count(*) from t1 group by f_int1, f_varchar1) tt1 join (select f_int1, f_varchar1, count(*) from t2 group by f_int1, f_varchar1) tt2 on tt1.f_int1 = tt2.f_int1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description                | Owner | Name | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |      |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |      |      |      |       |        |
| 2   |     SUBSELECT              |       | TT1  |      |      |       |        |
| 3   |       HASH GROUP BY        |       |      |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T1   |      |      |       |        |
| 5   |     SUBSELECT              |       | TT2  |      |      |       |        |
| 6   |       HASH GROUP BY        |       |      |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: TT1.F_INT1 = TT2.F_INT1                          

15 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1 from t1 join t2 on t1.f_int2=t2.f_int2 join t3 on t2.f_int2= t3.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------
| Id  | Description              | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |      |      |      |       |        |
| 1   |   HASH JOIN(L)           |       |      |      |      |       |        |
| 2   |     HASH JOIN(L)         |       |      |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T1   |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
| 5   |     TABLE ACCESS FULL    | SYS   | T3   |      |      |       |        |
--------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_INT2 = T3.F_INT2 AND T1.F_INT2 = T3.F_INT2  
   2 - access: T1.F_INT2 = T2.F_INT2                            

14 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1 from t1 join t2 on t1.f_int1=t2.f_int1 join t3 on t2.f_int2= t3.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |        |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |        |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |        |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T1     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T2     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T2 |      |      |       |        |
| 6   |     TABLE ACCESS FULL              | SYS   | T3     |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_INT2 = T3.F_INT2                            
   5 - access: T1.F_INT1 = T2.F_INT1                            

15 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1 from t1 join t2 on t1.f_int2=t2.f_int2 join t3 on t2.f_int1= t3.f_int1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |        |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |        |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |        |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T2     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T3     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T3 |      |      |       |        |
| 6   |     TABLE ACCESS FULL              | SYS   | T1     |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F_INT2 = T1.F_INT2                            
   5 - access: T2.F_INT1 = T3.F_INT1                            

15 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1 from t1, t2 join t3 on t2.f_int2= t3.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------
| Id  | Description              | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |      |      |      |       |        |
| 1   |   NESTED LOOPS           |       |      |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | T1   |      |      |       |        |
| 3   |     HASH JOIN(L)         |       |      |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | T3   |      |      |       |        |
--------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T2.F_INT2 = T3.F_INT2                            

13 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1, t4.f_varchar1 from t1 join t2 on t1.f_int2=t2.f_int2, t3 join t4 on t3.f_int2=t4.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------
| Id  | Description              | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |      |      |      |       |        |
| 1   |   NESTED LOOPS           |       |      |      |      |       |        |
| 2   |     HASH JOIN(L)         |       |      |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T1   |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T2   |      |      |       |        |
| 5   |     HASH JOIN(L)         |       |      |      |      |       |        |
| 6   |       TABLE ACCESS FULL  | SYS   | T3   |      |      |       |        |
| 7   |       TABLE ACCESS FULL  | SYS   | T4   |      |      |       |        |
--------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.F_INT2 = T2.F_INT2                            
   5 - access: T3.F_INT2 = T4.F_INT2                            

16 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1, t4.f_varchar1 from t1 join t2 on t1.f_int2=t2.f_int2, t3 join t4 on t3.f_int1=t4.f_int1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |        |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |        |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |        |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T3     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T4     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T4 |      |      |       |        |
| 6   |     HASH JOIN(L)                   |       |        |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | T1     |      |      |       |        |
| 8   |       TABLE ACCESS FULL            | SYS   | T2     |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T3.F_INT1 = T4.F_INT1                            
   6 - access: T1.F_INT2 = T2.F_INT2                            

17 rows fetched.

SQL> explain select t1.f_varchar1, t2.f_varchar1, t3.f_varchar1, t4.f_varchar1 from t1 join t2 on t1.f_int1=t2.f_int1, t3 join t4 on t3.f_int2=t4.f_int2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |        |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |        |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |        |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T1     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T2     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T2 |      |      |       |        |
| 6   |     HASH JOIN(L)                   |       |        |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | T3     |      |      |       |        |
| 8   |       TABLE ACCESS FULL            | SYS   | T4     |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.F_INT1 = T2.F_INT1                            
   6 - access: T3.F_INT2 = T4.F_INT2                            

17 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T1;

Succeed.

SQL> DROP TABLE IF EXISTS T2;

Succeed.

SQL> DROP TABLE IF EXISTS T3;

Succeed.

SQL> DROP TABLE IF EXISTS T4;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_RBO_6;

Succeed.

SQL> CREATE TABLE T_RBO_6(F_INT INT, F_DATE DATE, F_VARCHAR VARCHAR(128));

Succeed.

SQL> CREATE INDEX IDX_6_1 ON T_RBO_6(F_INT);

Succeed.

SQL> CREATE INDEX IDX_6_2 ON T_RBO_6(F_DATE);

Succeed.

SQL> EXPLAIN SELECT * FROM T_RBO_6 WHERE F_INT = COS(0);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 1                                        

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_6 WHERE F_INT = COS(0)+1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 2                                        

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_6 WHERE F_DATE = SYSDATE;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_DATE = SYSDATE                                 

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_6 WHERE F_DATE = SYSDATE+10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_DATE = SYSDATE + 10                            

10 rows fetched.

SQL> EXPLAIN SELECT F_INT, COUNT(*) FROM T_RBO_6 WHERE F_INT >10 GROUP BY F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name    | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_RBO_6 |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_6_1 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F_INT > 10                                       

11 rows fetched.

SQL> EXPLAIN SELECT F_INT, COUNT(*) FROM T_RBO_6 GROUP BY F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name    | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_RBO_6 |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_6_1 |      |      |       |        |
------------------------------------------------------------------------------------------

8 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_6 ORDER BY F_INT;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------

7 rows fetched.

SQL> EXPLAIN SELECT * FROM T_RBO_6 ORDER BY F_INT DESC;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX FULL SCAN DESCENDING | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------

7 rows fetched.

SQL> EXPLAIN SELECT MIN(F_INT) FROM T_RBO_6;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name    | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |         |      |      |       |        |
| 1   |   INDEX AGGR                    |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_RBO_6 |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_6_1 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F_INT IS NOT NULL                                

11 rows fetched.

SQL> EXPLAIN SELECT MAX(F_INT) FROM T_RBO_6;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |         |      |      |       |        |
| 1   |   INDEX AGGR                     |       |         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY   | SYS   | T_RBO_6 |      |      |       |        |
| 3   |       INDEX FULL SCAN DESCENDING | SYS   | IDX_6_1 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F_INT IS NOT NULL                                

11 rows fetched.

SQL> DROP VIEW IF EXISTS V_RBO_1;

Succeed.

SQL> DROP VIEW IF EXISTS V_RBO_2;

Succeed.

SQL> CREATE VIEW V_RBO_1 AS SELECT * FROM T_RBO_6;

Succeed.

SQL> CREATE VIEW V_RBO_2 AS SELECT * FROM V_RBO_1;

Succeed.

SQL> EXPLAIN SELECT * FROM (SELECT * FROM V_RBO_1) WHERE F_INT = 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 10                                       

10 rows fetched.

SQL> EXPLAIN SELECT * FROM V_RBO_2 WHERE F_INT = 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_RBO_6 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_6_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT = 10                                       

10 rows fetched.

SQL> DROP TABLE IF EXISTS t_dlvr_1;

Succeed.

SQL> DROP TABLE IF EXISTS t_dlvr_2;

Succeed.

SQL> DROP TABLE IF EXISTS t_dlvr_3;

Succeed.

SQL> DROP TABLE IF EXISTS t_dlvr_4;

Succeed.

SQL> create table t_dlvr_1(a int, b int, c int);

Succeed.

SQL> create table t_dlvr_2(a int, b int, c int);

Succeed.

SQL> create table t_dlvr_3(a int, b int, c int);

Succeed.

SQL> create table t_dlvr_4(a int, b int, c int);

Succeed.

SQL> create index idx_t_dlvr_1_1 on t_dlvr_1(a);

Succeed.

SQL> explain select t1.* from t_dlvr_1 t1 join t_dlvr_2 t2 on t1.a=t2.a where t2.a=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_DLVR_1 T1    |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_T_DLVR_1_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_DLVR_2 T2    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
   3 - access: T1.A = 1                                         
   4 - filter: T2.A = 1                                         

14 rows fetched.

SQL> 
SQL> create index idx_t_dlvr_2_1 on t_dlvr_2(a,b);

Succeed.

SQL> create index idx_t_dlvr_3_1 on t_dlvr_3(a,b);

Succeed.

SQL> explain select t4.* from t_dlvr_4 t4 join t_dlvr_2 t2 on t4.a=t2.a join t_dlvr_3 t3 on t3.a=t2.a where t3.b=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name           | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                |      |      |       |        |
| 1   |   NESTED LOOPS                    |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | T_DLVR_4 T4    |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_DLVR_3 T3    |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_T_DLVR_3_1 |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ONLY    | SYS   | T_DLVR_2 T2    |      |      |       |        |
| 7   |       INDEX RANGE SCAN            | SYS   | IDX_T_DLVR_2_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T3.B = 2 AND T3.A = T4.A                         
   7 - access: T3.A = T2.A AND T2.A = T4.A                      

16 rows fetched.

SQL> DROP TABLE IF EXISTS T_TEST_ZENITH_T1;

Succeed.

SQL> DROP TABLE IF EXISTS T_TEST_ZENITH_T2;

Succeed.

SQL> CREATE TABLE T_TEST_ZENITH_T1(ID INT, NAME VARCHAR2(100), SQLTEXT VARCHAR2(1000));

Succeed.

SQL> CREATE UNIQUE INDEX UNIQ_IDX_T1 ON T_TEST_ZENITH_T1(ID);

Succeed.

SQL> CREATE TABLE T_TEST_ZENITH_T2(ID INT, NAME VARCHAR2(100), SQLTEXT VARCHAR2(1000));

Succeed.

SQL> CREATE UNIQUE INDEX UNIQ_IDX_T2 ON T_TEST_ZENITH_T2(ID);

Succeed.

SQL> CREATE OR REPLACE VIEW V_TEST_ZENITH_T1 AS SELECT * FROM T_TEST_ZENITH_T1;

Succeed.

SQL> CREATE OR REPLACE VIEW V_TEST_ZENITH_T2 AS SELECT * FROM T_TEST_ZENITH_T2;

Succeed.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A LEFT JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE A.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = 1                          
   4 - filter: T_TEST_ZENITH_T1.ID = T_TEST_ZENITH_T2.ID        
   5 - access: T_TEST_ZENITH_T2.ID = 1                          

15 rows fetched.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A LEFT JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE B.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = 1                          
   4 - filter: T_TEST_ZENITH_T2.ID = T_TEST_ZENITH_T1.ID        
   5 - access: T_TEST_ZENITH_T2.ID = 1                          

15 rows fetched.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE A.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = 1                          
   4 - filter: T_TEST_ZENITH_T1.ID = T_TEST_ZENITH_T2.ID        
   5 - access: T_TEST_ZENITH_T2.ID = 1                          

15 rows fetched.

SQL> EXPLAIN SELECT * FROM T_TEST_ZENITH_T1 T1 JOIN T_TEST_ZENITH_T2 T2 ON T1.ID=T2.ID WHERE T2.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                     |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                     |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1         |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2         |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.ID = 1                                        
   4 - filter: T2.ID = T1.ID                                    
   5 - access: T2.ID = 1                                        

15 rows fetched.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A FULL JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE A.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = 1                          
   4 - filter: T_TEST_ZENITH_T1.ID = T_TEST_ZENITH_T2.ID        
   5 - access: T_TEST_ZENITH_T2.ID = 1                          

15 rows fetched.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A FULL JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE B.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T2.ID = 1                          
   4 - filter: T_TEST_ZENITH_T1.ID = T_TEST_ZENITH_T2.ID        
   5 - access: T_TEST_ZENITH_T1.ID = 1                          

15 rows fetched.

SQL> EXPLAIN SELECT * FROM V_TEST_ZENITH_T1 A FULL JOIN V_TEST_ZENITH_T2 B ON A.ID = B.ID WHERE A.ID =1 AND B.ID = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T1      |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T2      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = 1                          
   4 - filter: T_TEST_ZENITH_T1.ID = T_TEST_ZENITH_T2.ID        
   5 - access: T_TEST_ZENITH_T2.ID = 1                          

15 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T_TEST_ZENITH_T1;

Succeed.

SQL> CREATE TABLE T_TEST_ZENITH_T1(ID INT, NAME VARCHAR2(100), SQLTEXT VARCHAR2(1000));

Succeed.

SQL> CREATE UNIQUE INDEX UNIQ_IDX_T1 ON T_TEST_ZENITH_T1(ID);

Succeed.

SQL> CREATE OR REPLACE VIEW V_TEST_ZENITH_T1 AS SELECT * FROM T_TEST_ZENITH_T1;

Succeed.

SQL> EXPLAIN SELECT (SELECT COUNT(*) FROM V_TEST_ZENITH_T1 B WHERE B.ID = A.ID AND ROWNUM > 0) FROM V_TEST_ZENITH_T1 A WHERE ID >= 1 AND ID <= 100;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name               | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                    |      |      |       |        |
| 1   |   AGGR                            |       |                    |      |      |       |        |
| 2   |     ROWNUM FILTER                 |       |                    |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_T1   |      |      |       |        |
| 4   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T1        |      |      |       |        |
| 5   |   VIEW                            | SYS   | V_TEST_ZENITH_T1 A |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ONLY    | SYS   | T_TEST_ZENITH_T1   |      |      |       |        |
| 7   |       INDEX RANGE SCAN            | SYS   | UNIQ_IDX_T1        |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_TEST_ZENITH_T1.ID = A.ID                       
   7 - access: ID >= 1 AND ID <= 100                            

16 rows fetched.

SQL> EXPLAIN SELECT (SELECT (SELECT COUNT(*) FROM V_TEST_ZENITH_T1 B WHERE B.ID = A.ID) FROM V_TEST_ZENITH_T1) FROM V_TEST_ZENITH_T1 A WHERE ID >= 1 AND ID <= 100;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name               | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                    |      |      |       |        |
| 1   |   AGGR                          |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_T1   |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T1        |      |      |       |        |
| 4   |   VIEW                          | SYS   | V_TEST_ZENITH_T1   |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_T1   |      |      |       |        |
| 6   |       INDEX FAST FULL SCAN      | SYS   | UNIQ_IDX_T1        |      |      |       |        |
| 7   |   VIEW                          | SYS   | V_TEST_ZENITH_T1 A |      |      |       |        |
| 8   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_T1   |      |      |       |        |
| 9   |       INDEX RANGE SCAN          | SYS   | UNIQ_IDX_T1        |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T_TEST_ZENITH_T1.ID = A.ID                       
   9 - access: ID >= 1 AND ID <= 100                            

18 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS RBO_T1;

Succeed.

SQL> DROP TABLE IF EXISTS RBO_T2;

Succeed.

SQL> DROP TABLE IF EXISTS RBO_T3;

Succeed.

SQL> DROP TABLE IF EXISTS RBO_T4;

Succeed.

SQL> DROP TABLE IF EXISTS RBO_T5;

Succeed.

SQL> CREATE TABLE RBO_T1(C1 INT, C2 INT, C3 INT, C4 INT);

Succeed.

SQL> CREATE TABLE RBO_T2(C1 INT, C2 INT, C3 INT, C4 INT);

Succeed.

SQL> CREATE TABLE RBO_T3(C1 INT, C2 INT, C3 INT, C4 INT);

Succeed.

SQL> CREATE TABLE RBO_T4(C1 INT, C2 INT, C3 INT, C4 INT);

Succeed.

SQL> CREATE TABLE RBO_T5(C1 INT, C2 INT, C3 INT, C4 INT);

Succeed.

SQL> EXPLAIN SELECT * FROM RBO_T1 T1, RBO_T2 T2, RBO_T3 T3 LEFT JOIN RBO_T4 T4 ON (T3.C1 = T4.C1), RBO_T5 T5 WHERE T1.C1 = T5.C1 AND T2.C2 = T5.C2 AND T3.C1 = T5.C1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |           |      |      |       |        |
| 1   |   HASH JOIN(L)               |       |           |      |      |       |        |
| 2   |     HASH JOIN(L)             |       |           |      |      |       |        |
| 3   |       HASH JOIN(L)           |       |           |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | RBO_T1 T1 |      |      |       |        |
| 5   |         HASH JOIN OUTER(R)   |       |           |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | RBO_T3 T3 |      |      |       |        |
| 7   |           TABLE ACCESS FULL  | SYS   | RBO_T4 T4 |      |      |       |        |
| 8   |       TABLE ACCESS FULL      | SYS   | RBO_T5 T5 |      |      |       |        |
| 9   |     TABLE ACCESS FULL        | SYS   | RBO_T2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T5.C2 = T2.C2                                    
   2 - access: T3.C1 = T5.C1 AND T1.C1 = T5.C1                  
   3 - access: T1.C1 = T3.C1                                    
   5 - access: T3.C1 = T4.C1                                    

20 rows fetched.

SQL> CREATE INDEX IDX_RBO_T1_1 ON RBO_T1(C1,C2);

Succeed.

SQL> CREATE INDEX IDX_RBO_T2_1 ON RBO_T2(C1,C2);

Succeed.

SQL> CREATE INDEX IDX_RBO_T3_1 ON RBO_T3(C1,C2);

Succeed.

SQL> CREATE INDEX IDX_RBO_T4_1 ON RBO_T4(C1,C2);

Succeed.

SQL> CREATE INDEX IDX_RBO_T5_1 ON RBO_T5(C1,C2);

Succeed.

SQL> EXPLAIN SELECT * FROM RBO_T1 T1, RBO_T2 T2, RBO_T3 T3 LEFT JOIN RBO_T4 T4 ON (T3.C2 = T4.C2) WHERE T1.C1 = T2.C1 AND T2.C1 = T3.C1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |              |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | RBO_T1 T1    |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | RBO_T2 T2    |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_RBO_T2_1 |      |      |       |        |
| 6   |     HASH JOIN OUTER(R)             |       |              |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | RBO_T3 T3    |      |      |       |        |
| 8   |       TABLE ACCESS FULL            | SYS   | RBO_T4 T4    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.C1 = T3.C1 AND T2.C1 = T3.C1                  
   5 - access: T1.C1 = T2.C1                                    
   6 - access: T3.C2 = T4.C2                                    

18 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T_EDGE;

Succeed.

SQL> CREATE TABLE T_EDGE
  2 (
  3 IGS_EDGEID       VARBINARY(16),
  4 IGS_RELCATEGORY  VARCHAR(128 BYTE),
  5 IGS_STARTID      VARBINARY(16),
  6 IGS_STARTTYPE    VARCHAR(128 BYTE),
  7 IGS_TYPE         NUMBER(11),
  8 IGS_ENDID        VARBINARY(16),
  9 IGS_ENDTYPE      VARCHAR(128 BYTE),
 10 IGS_NAME         VARCHAR(256 BYTE),
 11 IGS_COLLECTORID  VARCHAR(128 BYTE),
 12 IGS_UNIQUEKEY    VARCHAR(255 BYTE),
 13 IGS_REPORTSN     NUMBER(20),
 14 IGS_PROPERTY     CLOB
 15 );

Succeed.

SQL> CREATE INDEX IDX_TYPE_EDGEID ON T_EDGE ( IGS_TYPE, IGS_EDGEID );

Succeed.

SQL> CREATE INDEX IDX_EDGE_IDTYPE ON T_EDGE ( IGS_STARTID, IGS_TYPE, IGS_ENDID );

Succeed.

SQL> EXPLAIN SELECT * FROM T_EDGE WHERE (IGS_TYPE = 106 AND IGS_STARTID = UNHEX(REPLACE('4520F1B6-6F90-642C-9416-27464745653F', '-', ''))) ORDER BY T_EDGE.IGS_EDGEID ASC LIMIT 201;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                 |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                 |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                 |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_EDGE          |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_EDGE_IDTYPE |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: IGS_STARTID = '4520F1B66F90642C941627464745653F' AND IGS_TYPE = 106

12 rows fetched.

SQL> DROP TABLE IF EXISTS T_EDGE;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_P_GTRXCHAN_A4;

Succeed.

SQL> DROP TABLE IF EXISTS T_P_GTRXIUO_A4;

Succeed.

SQL> DROP TABLE IF EXISTS T_RL_GTRX_A4;

Succeed.

SQL> DROP TABLE IF EXISTS T_CELLSP_UPTGCELL_EXTTP_A41;

Succeed.

SQL> 
SQL> CREATE TABLE T_P_GTRXCHAN_A4
  2 (
  3   PLANID NUMBER(10) NOT NULL,
  4   CMENEID NUMBER(10) NOT NULL,
  5   TRXID NUMBER(10) NOT NULL,
  6   CHNO NUMBER(3) NOT NULL,
  7   CHTYPE NUMBER(3),
  8   CELLID NUMBER(10) NOT NULL,
  9   BTSID NUMBER(10),
 10   UCMAPPINGCHANTYPE NUMBER(3),
 11   RESERVEDPARA1 NUMBER(3),
 12   RESERVEDPARA2 NUMBER(3),
 13   TSPRIORITY NUMBER(3),
 14   UPBTSPORTNO NUMBER(3),
 15   UPBTSTSNO NUMBER(3),
 16   REVBTSUPPORTNO NUMBER(3),
 17   REVUPBTSTSNO NUMBER(3),
 18   TRANSTYPE NUMBER(3),
 19   ADMSTAT NUMBER(3),
 20   FLEXABISMODE NUMBER(3),
 21   ABISMODE NUMBER(3),
 22   UPOUTBSCSUBRACKNO NUMBER(3),
 23   UPOUTBSCSLOTNO NUMBER(3),
 24   UPOUTBSCE1PORTNO NUMBER(10),
 25   UPOUTBSCTSNO NUMBER(3),
 26   REVUPOUTBSCSUBRACKNO NUMBER(3),
 27   REVUPOUTBSCSLOTNO NUMBER(3),
 28   REVUPOUTBSCE1PORTNO NUMBER(10),
 29   REVUPOUTBSCTSNO NUMBER(3),
 30   GPRSCHPRI NUMBER(3),
 31   ACTSTATUS NUMBER(17),
 32   TSPROPFLAG NUMBER(3),
 33   TSASSIGNFLAG NUMBER(10),
 34   CHANRSV NUMBER(3)
 35 );

Succeed.

SQL> CREATE UNIQUE INDEX IDX_T_P_GTRXCHAN_A4 ON T_P_GTRXCHAN_A4(PLANID, CMENEID, TRXID, CHNO, CELLID);

Succeed.

SQL> 
SQL> CREATE TABLE T_P_GTRXIUO_A4
  2 (
  3   PLANID NUMBER(10) NOT NULL,
  4   CMENEID NUMBER(10) NOT NULL,
  5   TRXID NUMBER(10) NOT NULL,
  6   IUO NUMBER(3),
  7   CELLID NUMBER(10) NOT NULL
  8 );

Succeed.

SQL> CREATE UNIQUE INDEX IDX_T_P_GTRXIUO_A4 ON T_P_GTRXIUO_A4(PLANID, CMENEID, TRXID, CELLID);

Succeed.

SQL> 
SQL> CREATE TABLE T_RL_GTRX_A4
  2 (
  3   PLANID NUMBER(10) NOT NULL,
  4   CMENEID NUMBER(10) NOT NULL,
  5   TRXID NUMBER(10) NOT NULL,
  6   ACTSTATUS NUMBER(3),
  7   TRXNAME VARCHAR(102 BYTE),
  8   FREQ NUMBER(10),
  9   TRXNO NUMBER(3),
 10   QTRUPRIARITY NUMBER(3),
 11   ABISMODE NUMBER(3),
 12   SPUSUBRACKNO NUMBER(3),
 13   SPUSLOTNO NUMBER(3),
 14   SPUCPUNO NUMBER(3),
 15   UPRSLPORTNO NUMBER(3),
 16   UPRSLTSNO NUMBER(3),
 17   UPRSLLOGICNO NUMBER(10),
 18   RESERVEDPARA VARCHAR(63 BYTE),
 19   RACKGRPNO NUMBER(3),
 20   REVUPRSLPORTNO NUMBER(3),
 21   REVUPRSLTSNO NUMBER(3),
 22   TRANSTYPE NUMBER(3),
 23   COTRXNOFORDYNPBT NUMBER(3),
 24   INHDLCINDEX NUMBER(10),
 25   HUBHDLCINDEX NUMBER(10),
 26   REVINHDLCINDEX NUMBER(10),
 27   TRXNOINHUB NUMBER(3),
 28   TRXABILITY NUMBER(3),
 29   CABINETNO NUMBER(3),
 30   ISTOWEREQUIPPED NUMBER(3),
 31   UCPRIORITY NUMBER(3),
 32   DIVERSITYMODE NUMBER(3),
 33   BTSID NUMBER(10),
 34   CELLID NUMBER(10) NOT NULL,
 35   ADMSTAT NUMBER(3),
 36   BOARDTYPE NUMBER(3),
 37   TEI NUMBER(3),
 38   FREQOPA VARCHAR(387 BYTE),
 39   SRN NUMBER(3),
 40   SN NUMBER(3),
 41   TRXPN NUMBER(3),
 42   ISMAINBCCH NUMBER(3),
 43   UPOUTBSCSUBRACKNO NUMBER(3),
 44   UPOUTBSCSLOTNO NUMBER(3),
 45   UPOUTBSCE1PORTNO NUMBER(10),
 46   UPOUTBSCTSNO NUMBER(3),
 47   REVUPOUTBSCSUBRACKNO NUMBER(3),
 48   REVUPOUTBSCSLOTNO NUMBER(3),
 49   REVUPOUTBSCE1PORTNO NUMBER(10),
 50   REVUPOUTBSCTSNO NUMBER(3),
 51   TSPROPFLAG NUMBER(3),
 52   TRXPN1 NUMBER(3),
 53   ANTPASSNO NUMBER(3),
 54   TSASSIGNFLAG NUMBER(10),
 55   MRRUSPTSHARING NUMBER(3),
 56   ACTSTATUSFORUPGRADE NUMBER(3),
 57   TRXNOMANUL NUMBER(3),
 58   CPUID NUMBER(17),
 59   NEWTRXNAME VARCHAR(102 BYTE),
 60   ISTMPTRX NUMBER(3),
 61   GTRXGROUPID NUMBER(17),
 62   DISPERFDATADEATRX NUMBER(3),
 63   TRXSHAREFLAG NUMBER(17),
 64   ANT1CN NUMBER(3),
 65   ANT1SRN NUMBER(3),
 66   ANT1SN NUMBER(3),
 67   ANT1N NUMBER(3),
 68   ANTTYPE1 NUMBER(3),
 69   ANT2CN NUMBER(3),
 70   ANT2SRN NUMBER(3),
 71   ANT2SN NUMBER(3),
 72   ANT2N NUMBER(3),
 73   ANTTYPE2 NUMBER(3),
 74   ANT3CN NUMBER(3),
 75   ANT3SRN NUMBER(3),
 76   ANT3SN NUMBER(3),
 77   ANT3N NUMBER(3),
 78   ANTTYPE3 NUMBER(3),
 79   ANT4CN NUMBER(3),
 80   ANT4SRN NUMBER(3),
 81   ANT4SN NUMBER(3),
 82   ANT4N NUMBER(3),
 83   ANTTYPE4 NUMBER(3),
 84   ANT5CN NUMBER(3),
 85   ANT5SRN NUMBER(3),
 86   ANT5SN NUMBER(3),
 87   ANT5N NUMBER(3),
 88   ANTTYPE5 NUMBER(3),
 89   ANT6CN NUMBER(3),
 90   ANT6SRN NUMBER(3),
 91   ANT6SN NUMBER(3),
 92   ANT6N NUMBER(3),
 93   ANTTYPE6 NUMBER(3),
 94   ANT7CN NUMBER(3),
 95   ANT7SRN NUMBER(3),
 96   ANT7SN NUMBER(3),
 97   ANT7N NUMBER(3),
 98   ANTTYPE7 NUMBER(3),
 99   ANT8CN NUMBER(3),
100   ANT8SRN NUMBER(3),
101   ANT8SN NUMBER(3),
102   ANT8N NUMBER(3),
103   ANTTYPE8 NUMBER(3),
104   BUFZONETRXSHAREFLAG NUMBER(17)
105 );

Succeed.

SQL> CREATE UNIQUE INDEX IDX_T_RL_GTRX_A4 ON T_RL_GTRX_A4(PLANID, CMENEID, TRXID, CELLID);

Succeed.

SQL> 
SQL> CREATE GLOBAL TEMPORARY TABLE T_CELLSP_UPTGCELL_EXTTP_A41
  2 (
  3   PLANID NUMBER(10),
  4   CMENEID NUMBER(10),
  5   BTSID NUMBER(10),
  6   CELLID NUMBER(10),
  7   RECID NUMBER(10)
  8 )ON COMMIT DELETE ROWS;

Succeed.

SQL> 
SQL> explain delete from t_P_GTRXCHAN_A4
  2  where rowid in (select a.rowid
  3                    from t_P_GTRXCHAN_A4 a
  4                    join t_P_GTRXIUO_A4 b
  5                      on a.PlanID = b.PlanID
  6                     and a.CMENEID = b.CMENEID
  7                     and a.TRXID = b.TRXID
  8                    join t_RL_GTRX_A4 c
  9                      on a.PlanID = c.PlanID
 10                     and a.CMENEID = c.CMENEID
 11                     and a.TRXID = c.TRXID
 12                    join t_CELLsp_UptGCELL_EXTTP_A41 d
 13                      on c.PlanID = d.PlanID
 14                     and c.CMENEID = d.CMENEID
 15                     and c.CELLID = d.CELLID
 16                   where a.PlanID = 51
 17                     and a.CMENEID = 231
 18                     and a.CHNO in (1, 3, 5, 7)
 19                     and b.IUO = 2 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------
| Id  | Description                               | Owner | Name                          | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                          |       |                               |      |      |       |        |
| 1   |   NESTED LOOPS                            |       |                               |      |      |       |        |
| 2   |     SUBSELECT                             |       |                               |      |      |       |        |
| 3   |       HASH DISTINCT                       |       |                               |      |      |       |        |
| 4   |         NESTED LOOPS                      |       |                               |      |      |       |        |
| 5   |           NESTED LOOPS                    |       |                               |      |      |       |        |
| 6   |             NESTED LOOPS                  |       |                               |      |      |       |        |
| 7   |               TABLE ACCESS FULL           | SYS   | T_CELLSP_UPTGCELL_EXTTP_A41 D |      |      |       |        |
| 8   |               TABLE ACCESS BY INDEX ONLY  | SYS   | T_P_GTRXCHAN_A4 A             |      |      |       |        |
| 9   |                 INDEX RANGE SCAN          | SYS   | IDX_T_P_GTRXCHAN_A4           |      |      |       |        |
| 10  |             TABLE ACCESS BY INDEX ONLY    | SYS   | T_RL_GTRX_A4 C                |      |      |       |        |
| 11  |               INDEX UNIQUE SCAN           | SYS   | IDX_T_RL_GTRX_A4              |      |      |       |        |
| 12  |           TABLE ACCESS BY INDEX ROWID     | SYS   | T_P_GTRXIUO_A4 B              |      |      |       |        |
| 13  |             INDEX RANGE SCAN              | SYS   | IDX_T_P_GTRXIUO_A4            |      |      |       |        |
| 14  |     TABLE ACCESS BY ROWID                 | SYS   | T_P_GTRXCHAN_A4               |      |      |       |        |
| 15  |       ROWID SCAN                          |       |                               |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - filter: D.PLANID = 51 AND D.CMENEID = 231                
   9 - access: A.CMENEID = 231 AND A.PLANID = D.PLANID AND A.CHNO IN(1, 3, 5, 7) AND A.CMENEID = D.CMENEID AND 
               A.PLANID = 51                                    
   11 - access: C.PLANID = 51 AND C.CMENEID = 231 AND C.PLANID = D.PLANID AND C.CELLID = D.CELLID AND A.CMENEID = C.CMENEID AND 
               A.TRXID = C.TRXID AND A.PLANID = C.PLANID AND C.CMENEID = D.CMENEID
   12 - filter: B.IUO = 2                                       
   13 - access: B.CMENEID = 231 AND D.CMENEID = B.CMENEID AND C.CMENEID = B.CMENEID AND D.PLANID = B.PLANID AND 
               C.PLANID = B.PLANID AND A.TRXID = B.TRXID AND A.CMENEID = B.CMENEID AND B.PLANID = 51 AND 
               A.PLANID = B.PLANID AND C.TRXID = B.TRXID                 
   15 - access: ROWID = ROWID                                   

32 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS hash_join_com_tbl_001_1;

Succeed.

SQL> DROP TABLE IF EXISTS hash_join_com_tbl_001_2;

Succeed.

SQL> DROP TABLE IF EXISTS hash_join_com_tbl_001;

Succeed.

SQL> create table hash_join_com_tbl_001_1(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> create table hash_join_com_tbl_001_2(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> create table hash_join_com_tbl_001(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> create unique index hash_join_indx_001_1 ON hash_join_com_tbl_001(c_id,c_d_id);

Succeed.

SQL> create index hash_join_indx_001_2 ON hash_join_com_tbl_001(c_id);

Succeed.

SQL> create unique index hash_join_indx_001_3 ON hash_join_com_tbl_001(c_big);

Succeed.

SQL> create index hash_join_indx_001_4 ON hash_join_com_tbl_001(c_first,c_binary);

Succeed.

SQL> create index hash_join_indx_001_5 ON hash_join_com_tbl_001(c_id,c_d_id,c_varbinary);

Succeed.

SQL> create index hash_join_indx_001_6 ON hash_join_com_tbl_001(c_id,c_d_id,c_street_1,c_raw);

Succeed.

SQL> create index index_primary_key ON hash_join_com_tbl_001(c_id,c_d_id,c_w_id);

Succeed.

SQL> 
SQL> 
SQL> explain select a.c_id, a.c_first
  2   from hash_join_com_tbl_001_1 a
  3  inner join hash_join_com_tbl_001_2 b
  4     on (a.c_id = b.c_id and mod(a.c_id, 5) = mod(b.c_id, 7))
  5     or (a.c_id + 100 = b.c_id and a.c_first < 'AAis9')
  6  right join hash_join_com_tbl_001 c
  7     on a.c_id + 1 = (b.c_id - 10) * 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS OUTER            |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | HASH_JOIN_COM_TBL_001 C   |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | HASH_JOIN_INDX_001_1      |      |      |       |        |
| 4   |     NESTED LOOPS                |       |                           |      |      |       |        |
| 5   |       TABLE ACCESS FULL         | SYS   | HASH_JOIN_COM_TBL_001_1 A |      |      |       |        |
| 6   |       TABLE ACCESS FULL         | SYS   | HASH_JOIN_COM_TBL_001_2 B |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.C_ID + 1 = B.C_ID - 10 * 2                     
   6 - filter: A.C_ID = B.C_ID AND MOD(A.C_ID, 5) = MOD(B.C_ID, 7) OR A.C_ID + 100 = B.C_ID AND A.C_FIRST < 'AAis9'

15 rows fetched.

SQL> 
SQL> drop table if exists t_test_zenith_1;

Succeed.

SQL> drop table if exists t_test_zenith_2;

Succeed.

SQL> drop table if exists t_test_zenith_3;

Succeed.

SQL> create table t_test_zenith_1(id int, name varchar2(100), sqltext varchar2(1000));

Succeed.

SQL> create unique index uniq_idx_t_1 on t_test_zenith_1(id);

Succeed.

SQL> create table t_test_zenith_2(id int, name varchar2(100), sqltext varchar2(1000));

Succeed.

SQL> create table t_test_zenith_3(id int, name varchar2(100), sqltext varchar2(1000));

Succeed.

SQL> create or replace view v_test_zenith_1 as select id from t_test_zenith_1;

Succeed.

SQL> create or replace view v_test_zenith_2 as select b.id from t_test_zenith_2 a left join t_test_zenith_1 b on a.name=b.name;

Succeed.

SQL> create or replace view v_test_zenith_3 as select c.id from t_test_zenith_3 a left join t_test_zenith_2 b on a.name=b.name left join t_test_zenith_1 c on a.name=c.name;

Succeed.

SQL> explain select /*+use_nl(a b)*/* from v_test_zenith_1 a left join v_test_zenith_1 b on a.id = b.id where a.id = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name              | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS OUTER              |       |                   |      |      |       |        |
| 2   |     VIEW                          | SYS   | V_TEST_ZENITH_1 A |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 4   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 5   |     VIEW                          | SYS   | V_TEST_ZENITH_1 B |      |      |       |        |
| 6   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 7   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_TEST_ZENITH_1.ID = 1                           
   5 - filter: A.ID = B.ID                                      
   6 - filter: T_TEST_ZENITH_1.ID = A.ID                        
   7 - access: T_TEST_ZENITH_1.ID = 1                           

18 rows fetched.

SQL> explain select /*+use_nl(a b)*/a.* from v_test_zenith_1 a left join v_test_zenith_1 b on a.id = b.id where a.id = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name              | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS OUTER              |       |                   |      |      |       |        |
| 2   |     VIEW                          | SYS   | V_TEST_ZENITH_1 A |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 4   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 5   |     VIEW                          | SYS   | V_TEST_ZENITH_1 B |      |      |       |        |
| 6   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 7   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_TEST_ZENITH_1.ID = 1                           
   5 - filter: A.ID = B.ID                                      
   6 - filter: T_TEST_ZENITH_1.ID = A.ID                        
   7 - access: T_TEST_ZENITH_1.ID = 1                           

18 rows fetched.

SQL> explain select /*+use_nl(a b)*/* from v_test_zenith_1 a join v_test_zenith_1 b on a.id = b.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name              | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS                    |       |                   |      |      |       |        |
| 2   |     VIEW                          | SYS   | V_TEST_ZENITH_1 A |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 5   |     VIEW                          | SYS   | V_TEST_ZENITH_1 B |      |      |       |        |
| 6   |       TABLE ACCESS BY INDEX ONLY  | SYS   | T_TEST_ZENITH_1   |      |      |       |        |
| 7   |         INDEX UNIQUE SCAN         | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: A.ID = B.ID                                      
   7 - access: T_TEST_ZENITH_1.ID = A.ID                        

16 rows fetched.

SQL> explain select /*+use_nl(a b)*/* from t_test_zenith_1 a left join v_test_zenith_2 b on a.id=b.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                 |       |                   |      |      |       |        |
| 2   |     TABLE ACCESS FULL                | SYS   | T_TEST_ZENITH_1 A |      |      |       |        |
| 3   |     VIEW                             | SYS   | V_TEST_ZENITH_2 B |      |      |       |        |
| 4   |       HASH JOIN(L)                   |       |                   |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_1 B |      |      |       |        |
| 6   |           INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 7   |         TABLE ACCESS FULL            | SYS   | T_TEST_ZENITH_2 A |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: A.ID = B.ID                                      
   4 - access: B.NAME = A.NAME                                  
   6 - access: B.ID = A.ID                                      

17 rows fetched.

SQL> explain select /*+use_nl(a b)*/* from t_test_zenith_1 a left join v_test_zenith_3 b on a.id=b.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                 |       |                   |      |      |       |        |
| 2   |     TABLE ACCESS FULL                | SYS   | T_TEST_ZENITH_1 A |      |      |       |        |
| 3   |     VIEW                             | SYS   | V_TEST_ZENITH_3 B |      |      |       |        |
| 4   |       HASH JOIN(L)                   |       |                   |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_1 C |      |      |       |        |
| 6   |           INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 7   |         HASH JOIN OUTER(R)           |       |                   |      |      |       |        |
| 8   |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_3 A |      |      |       |        |
| 9   |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_2 B |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: A.ID = B.ID                                      
   4 - access: C.NAME = A.NAME                                  
   6 - access: C.ID = A.ID                                      
   7 - access: A.NAME = B.NAME                                  

20 rows fetched.

SQL> explain select /*+use_nl(a b c)*/* from t_test_zenith_1 a join v_test_zenith_2 b on a.id=b.id join v_test_zenith_3 c on a.id=c.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name              | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS                         |       |                   |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |                   |      |      |       |        |
| 3   |       VIEW                             | SYS   | V_TEST_ZENITH_2 B |      |      |       |        |
| 4   |         HASH JOIN(L)                   |       |                   |      |      |       |        |
| 5   |           TABLE ACCESS FULL            | SYS   | T_TEST_ZENITH_2 A |      |      |       |        |
| 6   |           TABLE ACCESS FULL            | SYS   | T_TEST_ZENITH_1 B |      |      |       |        |
| 7   |       VIEW                             | SYS   | V_TEST_ZENITH_3 C |      |      |       |        |
| 8   |         HASH JOIN(L)                   |       |                   |      |      |       |        |
| 9   |           TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_1 C |      |      |       |        |
| 10  |             INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 11  |           HASH JOIN OUTER(R)           |       |                   |      |      |       |        |
| 12  |             TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_3 A |      |      |       |        |
| 13  |             TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_2 B |      |      |       |        |
| 14  |     TABLE ACCESS BY INDEX ROWID        | SYS   | T_TEST_ZENITH_1 A |      |      |       |        |
| 15  |       INDEX UNIQUE SCAN                | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: A.NAME = B.NAME                                  
   7 - filter: B.ID = C.ID                                      
   8 - access: C.NAME = A.NAME                                  
   10 - access: C.ID = B.ID                                     
   11 - access: A.NAME = B.NAME                                 
   14 - filter: A.ID = B.ID                                     
   15 - access: A.ID = C.ID                                     

29 rows fetched.

SQL> explain select /*+use_nl(a b c)*/* from t_test_zenith_1 a join v_test_zenith_2 b on a.id=b.id left join v_test_zenith_3 c on a.id=c.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                   |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                 |       |                   |      |      |       |        |
| 2   |     NESTED LOOPS                     |       |                   |      |      |       |        |
| 3   |       VIEW                           | SYS   | V_TEST_ZENITH_2 B |      |      |       |        |
| 4   |         HASH JOIN(L)                 |       |                   |      |      |       |        |
| 5   |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_2 A |      |      |       |        |
| 6   |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_1 B |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ROWID    | SYS   | T_TEST_ZENITH_1 A |      |      |       |        |
| 8   |         INDEX UNIQUE SCAN            | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 9   |     VIEW                             | SYS   | V_TEST_ZENITH_3 C |      |      |       |        |
| 10  |       HASH JOIN(L)                   |       |                   |      |      |       |        |
| 11  |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_ZENITH_1 C |      |      |       |        |
| 12  |           INDEX UNIQUE SCAN          | SYS   | UNIQ_IDX_T_1      |      |      |       |        |
| 13  |         HASH JOIN OUTER(R)           |       |                   |      |      |       |        |
| 14  |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_3 A |      |      |       |        |
| 15  |           TABLE ACCESS FULL          | SYS   | T_TEST_ZENITH_2 B |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: A.NAME = B.NAME                                  
   8 - access: A.ID = B.ID                                      
   9 - filter: A.ID = C.ID                                      
   10 - access: C.NAME = A.NAME                                 
   12 - access: C.ID = A.ID                                     
   13 - access: A.NAME = B.NAME                                 

28 rows fetched.

SQL> declare 
  2     i integer;
  3 begin
  4     for i in 1 .. 1000 loop
  5         insert into t_test_zenith_1 values(i, i || 'abcdefg', lpad(' ', 1000, ' '));  
  6         insert into t_test_zenith_2 values(i, i || 'abcdefg', lpad(' ', 1000, ' '));
  7         insert into t_test_zenith_3 values(i, i || 'abcdefg', lpad(' ', 1000, ' '));		
  8     end loop;
  9     commit;
 10 end;
 11 /

PL/SQL procedure successfully completed.

SQL> select /*+use_nl(a b)*/* from v_test_zenith_1 a left join v_test_zenith_1 b on a.id = b.id where a.id = 1;

ID           ID          
------------ ------------
1            1           

1 rows fetched.

SQL> select /*+use_nl(a b)*/* from v_test_zenith_1 a join v_test_zenith_1 b on a.id = b.id where a.id = 1;

ID           ID          
------------ ------------
1            1           

1 rows fetched.

SQL> select /*+use_nl(a b)*/* from t_test_zenith_1 a left join v_test_zenith_2 b on a.id=b.id where a.id = 1;

ID           NAME                                                             SQLTEXT                                                          ID          
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ------------
1            1abcdefg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  1           

1 rows fetched.

SQL> select /*+use_nl(a b)*/* from t_test_zenith_1 a left join v_test_zenith_3 b on a.id=b.id where a.id = 1;

ID           NAME                                                             SQLTEXT                                                          ID          
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ------------
1            1abcdefg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  1           

1 rows fetched.

SQL> select /*+use_nl(a b c)*/* from t_test_zenith_1 a join v_test_zenith_2 b on a.id=b.id join v_test_zenith_3 c on a.id=c.id where a.id = 1;

ID           NAME                                                             SQLTEXT                                                          ID           ID          
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------
1            1abcdefg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  1            1           

1 rows fetched.

SQL> select /*+use_nl(a b c)*/* from t_test_zenith_1 a join v_test_zenith_2 b on a.id=b.id left join v_test_zenith_3 c on a.id=c.id where a.id = 1;

ID           NAME                                                             SQLTEXT                                                          ID           ID          
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------
1            1abcdefg                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  1            1           

1 rows fetched.

SQL> 
SQL> drop table if exists index_t1;

Succeed.

SQL> drop table if exists index_t2;

Succeed.

SQL> drop table if exists index_t3;

Succeed.

SQL> create table index_t1(a int, b int, c int);

Succeed.

SQL> create index idx_t1_index_1 on index_t1(a);

Succeed.

SQL> create index idx_t1_index_2 on index_t1(b);

Succeed.

SQL> create table index_t2(a int, b int, c int);

Succeed.

SQL> create index idx_t2_index_1 on index_t2(a);

Succeed.

SQL> create index idx_t2_index_2 on index_t2(b);

Succeed.

SQL> create table index_t3(a int, b int, c int);

Succeed.

SQL> explain select * from index_t1 where a=1 or a=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1       |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 1 OR A = 2                                   

10 rows fetched.

SQL> explain select * from index_t1 where a=1 or b=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   CONCATENATION                  |       |                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1       |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_2 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: A = 1 OR B = 2                                   
   3 - access: A = 1                                            
   4 - filter: A = 1 OR B = 2                                   
   5 - access: B = 2                                            

16 rows fetched.

SQL> explain select * from index_t1 t1 join index_t2 t2 on t1.a=t2.a or t1.b=t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                |      |      |       |        |
| 1   |   SUBSELECT                          |       |                |      |      |       |        |
| 2   |     UNION ALL                        |       |                |      |      |       |        |
| 3   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 6   |           INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 7   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 8   |         TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 9   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 10  |           INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - access: T1.A = T2.A                                      
   9 - filter: FALSE != LNNVL(T1.A = T2.A)                      
   10 - access: T1.B = T2.A                                     

20 rows fetched.

SQL> explain select * from index_t1 t1 join index_t2 t2 on t1.a=t2.a or t1.b=t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                |      |      |       |        |
| 1   |   SUBSELECT                          |       |                |      |      |       |        |
| 2   |     UNION ALL                        |       |                |      |      |       |        |
| 3   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 6   |           INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 7   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 8   |         TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 9   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 10  |           INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - access: T1.A = T2.A                                      
   9 - filter: FALSE != LNNVL(T1.A = T2.A)                      
   10 - access: T1.B = T2.B                                     

20 rows fetched.

SQL> explain select * from index_t1 t1 join index_t3 t3 on t1.a=t3.a or t1.b=t3.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                |      |      |       |        |
| 1   |   SUBSELECT                          |       |                |      |      |       |        |
| 2   |     UNION ALL                        |       |                |      |      |       |        |
| 3   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | INDEX_T3 T3    |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 6   |           INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
| 7   |       NESTED LOOPS                   |       |                |      |      |       |        |
| 8   |         TABLE ACCESS FULL            | SYS   | INDEX_T3 T3    |      |      |       |        |
| 9   |         TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 10  |           INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_2 |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - access: T1.A = T3.A                                      
   9 - filter: FALSE != LNNVL(T1.A = T3.A)                      
   10 - access: T1.B = T3.B                                     

20 rows fetched.

SQL> explain select * from index_t1 t1 left join index_t2 t2 on t1.a=t2.a or t1.b=t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name           | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                |      |      |       |        |
| 1   |   NESTED LOOPS OUTER               |       |                |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | INDEX_T1 T1    |      |      |       |        |
| 3   |     CONCATENATION                  |       |                |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 6   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 7   |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: T1.A = T2.A OR T1.B = T2.B                       
   5 - access: T1.A = T2.A                                      
   6 - filter: T1.A = T2.A OR T1.B = T2.B                       
   7 - access: T1.B = T2.B                                      

18 rows fetched.

SQL> explain select * from index_t1 t1 join index_t2 t2 on t1.a=t2.a where t1.a=1 or t1.b=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name           | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                |      |      |       |        |
| 1   |   CONCATENATION                    |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 7   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 9   |         INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_2 |      |      |       |        |
| 10  |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 11  |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: T1.A = 1 OR T1.B = 2                             
   4 - access: T1.A = 1                                         
   6 - access: T1.A = T2.A                                      
   8 - filter: T1.A = 1 OR T1.B = 2                             
   9 - access: T1.B = 2                                         
   11 - access: T1.A = T2.A                                     

24 rows fetched.

SQL> explain select * from index_t1 t1 join index_t2 t2 on t1.a=t2.a or t1.b=t2.b where t1.a=1 or t1.b=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                |      |      |       |        |
| 1   |   SUBSELECT                            |       |                |      |      |       |        |
| 2   |     UNION ALL                          |       |                |      |      |       |        |
| 3   |       CONCATENATION                    |       |                |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 6   |             INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 8   |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 9   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 10  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 11  |             INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_2 |      |      |       |        |
| 12  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 13  |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 14  |       CONCATENATION                    |       |                |      |      |       |        |
| 15  |         NESTED LOOPS                   |       |                |      |      |       |        |
| 16  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 17  |             INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_1 |      |      |       |        |
| 18  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 19  |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
| 20  |         NESTED LOOPS                   |       |                |      |      |       |        |
| 21  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 T1    |      |      |       |        |
| 22  |             INDEX RANGE SCAN           | SYS   | IDX_T1_INDEX_2 |      |      |       |        |
| 23  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 24  |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: T1.A = 1 OR T1.B = 2                             
   6 - access: T1.A = 1                                         
   8 - access: T1.A = T2.A                                      
   10 - filter: T1.A = 1 OR T1.B = 2                            
   11 - access: T1.B = 2                                        
   13 - access: T1.A = T2.A                                     
   16 - filter: T1.A = 1 OR T1.B = 2                            
   17 - access: T1.A = 1                                        
   18 - filter: FALSE != LNNVL(T1.A = T2.A)                     
   19 - access: T1.B = T2.B                                     
   21 - filter: T1.A = 1 OR T1.B = 2                            
   22 - access: T1.B = 2                                        
   23 - filter: FALSE != LNNVL(T1.A = T2.A)                     
   24 - access: T1.B = T2.B                                     

45 rows fetched.

SQL> explain select * from (select * from index_t1) t1 join index_t2 t2 on t1.a=t2.a or t1.b=t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name           | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                |      |      |       |        |
| 1   |   CONCATENATION                    |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | INDEX_T1       |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 6   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | INDEX_T1       |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 9   |         INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: INDEX_T1.A = T2.A OR INDEX_T1.B = T2.B           
   5 - access: INDEX_T1.A = T2.A                                
   8 - filter: INDEX_T1.A = T2.A OR INDEX_T1.B = T2.B           
   9 - access: INDEX_T1.B = T2.B                                

20 rows fetched.

SQL> explain select * from index_t1 t1 join index_t2 t2 on t1.a=t2.a or t1.b=t2.b join index_t3 t3 on t2.c=t3.c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                |      |      |       |        |
| 1   |   SUBSELECT                            |       |                |      |      |       |        |
| 2   |     UNION ALL                          |       |                |      |      |       |        |
| 3   |       HASH JOIN(L)                     |       |                |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 5   |           TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 7   |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL              | SYS   | INDEX_T3 T3    |      |      |       |        |
| 9   |       HASH JOIN(L)                     |       |                |      |      |       |        |
| 10  |         NESTED LOOPS                   |       |                |      |      |       |        |
| 11  |           TABLE ACCESS FULL            | SYS   | INDEX_T1 T1    |      |      |       |        |
| 12  |           TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 T2    |      |      |       |        |
| 13  |             INDEX RANGE SCAN           | SYS   | IDX_T2_INDEX_2 |      |      |       |        |
| 14  |         TABLE ACCESS FULL              | SYS   | INDEX_T3 T3    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T2.C = T3.C                                      
   7 - access: T1.A = T2.A                                      
   9 - access: T2.C = T3.C                                      
   12 - filter: FALSE != LNNVL(T1.A = T2.A)                     
   13 - access: T1.B = T2.B                                     

26 rows fetched.

SQL> drop table if exists index_t1;

Succeed.

SQL> drop table if exists index_t2;

Succeed.

SQL> drop table if exists index_t3;

Succeed.

SQL> 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> drop table if exists t_join_base_102;

Succeed.

SQL> create table t_join_base_001(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);

Succeed.

SQL> create table t_join_base_101(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);

Succeed.

SQL> create table t_join_base_102(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);

Succeed.

SQL> 
SQL> create index idx_join_base_001_1 on t_join_base_001(c_int);

Succeed.

SQL> create index idx_join_base_001_2 on t_join_base_001(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_001_3 on t_join_base_001(c_int,c_vchar,c_date);

Succeed.

SQL> 
SQL> create index idx_join_base_101_1 on t_join_base_101(c_int);

Succeed.

SQL> create index idx_join_base_101_2 on t_join_base_101(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_101_3 on t_join_base_101(c_int,c_vchar,c_date);

Succeed.

SQL> 
SQL> create index idx_join_base_102_1 on t_join_base_102(c_int);

Succeed.

SQL> create index idx_join_base_102_2 on t_join_base_102(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_102_3 on t_join_base_102(c_int,c_vchar,c_date);

Succeed.

SQL> 
SQL> insert into t_join_base_001 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_101 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_102 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> 
SQL> select count(*) from t_join_base_001 t1 left join (t_join_base_101 t2 left join t_join_base_102 t3 on t2.c_vchar=t3.c_vchar) on t1.c_int=t2.c_int;

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> --test temp
SQL> drop table if exists temp_t1;

Succeed.

SQL> drop table if exists temp_t2;

Succeed.

SQL> create global temporary table temp_t1(a int, b int, c int);

Succeed.

SQL> create table temp_t2 (a int, b int, c int);

Succeed.

SQL> create index idx_temp_t2_1 on temp_t2(a);

Succeed.

SQL> explain select t1.a, t2.a from temp_t1 t1 join temp_t2 t2 on t1.a=t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name          | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |               |      |      |       |        |
| 1   |   NESTED LOOPS                  |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | TEMP_T1 T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEMP_T2 T2    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_TEMP_T2_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      

12 rows fetched.

SQL> explain select t1.a, t2.a from temp_t1 t1 join temp_t2 t2 on t1.a=t2.a where t2.a >10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name          | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |               |      |      |       |        |
| 1   |   NESTED LOOPS                  |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | TEMP_T1 T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEMP_T2 T2    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_TEMP_T2_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: T2.A > 10                                        
   4 - access: T1.A = T2.A                                      

13 rows fetched.

SQL> drop table if exists temp_t1;

Succeed.

SQL> drop table if exists temp_t2;

Succeed.

SQL> 
SQL> --test sub-select push down
SQL> drop table if exists test_push_t1;

Succeed.

SQL> drop table if exists test_push_t2;

Succeed.

SQL> create table test_push_t1(a int, b int, c int);

Succeed.

SQL> create table test_push_t2(a int, b int, c int);

Succeed.

SQL> create index idx_test_push_t1_1 on test_push_t1(a);

Succeed.

SQL> insert into test_push_t1 values(1,1,1);

1 rows affected.

SQL> insert into test_push_t1 values(2,2,2);

1 rows affected.

SQL> insert into test_push_t1 values(3,3,3);

1 rows affected.

SQL> insert into test_push_t2 values(1,1,1);

1 rows affected.

SQL> insert into test_push_t2 values(2,2,2);

1 rows affected.

SQL> insert into test_push_t2 values(3,3,3);

1 rows affected.

SQL> explain select * from (select * from test_push_t1) tt where tt.a=(select a from test_push_t2 where a=1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_PUSH_T1       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_PUSH_T1_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | TEST_PUSH_T2       |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TEST_PUSH_T1.A = (SELECT A FROM TEST_PUSH_T2 WHERE A = 1)
   4 - filter: A = 1                                            

13 rows fetched.

SQL> select * from (select * from test_push_t1) tt where tt.a=(select a from test_push_t2 where a=1);

A            B            C           
------------ ------------ ------------
1            1            1           

1 rows fetched.

SQL> --DTS2019011608160
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> create table t_join_base_001(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> 
SQL> create table t_join_base_101(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> 
SQL> explain select count(*) from t_join_base_001 t1 
  2 where exists (select max(t11.c_int) over(partition by t1.c_int) from t_join_base_101 t11 
  3 where t11.c_number=t1.c_number);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                     |      |      |       |        |
| 1   |   AGGR                     |       |                     |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |                     |      |      |       |        |
| 3   |       SUBSELECT            |       |                     |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_101 T11 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_001 T1  |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T11.C_NUMBER = T1.C_NUMBER                       

13 rows fetched.

SQL> --hash materialize
SQL> DROP TABLE IF EXISTS "T_D_TYPRABBASIC_B4";

Succeed.

SQL> CREATE TABLE "T_D_TYPRABBASIC_B4"
  2 (
  3   "SAVEPOINTID" NUMBER(10) NOT NULL,
  4   "OPERTYPE" NUMBER(3) NOT NULL,
  5   "PLANID" NUMBER(10) NOT NULL,
  6   "CMENEID" NUMBER(10) NOT NULL,
  7   "RABINDEX" NUMBER(3) NOT NULL,
  8   "APPLIEDDIRECT" NUMBER(3),
  9   "CNDOMAINID" NUMBER(3),
 10   "TRAFFICCLASS" NUMBER(3),
 11   "MAXBITRATE" NUMBER(17),
 12   "SSD" NUMBER(3),
 13   "TYPCFGSUPPORT" NUMBER(3),
 14   "BETAC" NUMBER(3),
 15   "BETAD" NUMBER(3),
 16   "SHIND" NUMBER(3),
 17   "REQ2GCAP" NUMBER(3),
 18   "ULFPMODE" NUMBER(3),
 19   "ACTSTATUS" NUMBER(3),
 20   "EUTRANSHIND" NUMBER(3),
 21   "ULDPCH10MSMODEBETAC" NUMBER(3),
 22   "ULDPCH10MSMODEBETAD" NUMBER(3),
 23   "LOGUPTID" VARCHAR(383 BYTE),
 24   "NBI_RECID" NUMBER(10),
 25   "ISGENMML" NUMBER(3)
 26 );

Succeed.

SQL> create index primary_key_T_D_B4 on T_D_TYPRABBASIC_B4("PLANID", "CMENEID", "RABINDEX", "OPERTYPE", "SAVEPOINTID");

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "T_P_TYPRABRLC_B4";

Succeed.

SQL> CREATE TABLE "T_P_TYPRABRLC_B4"
  2 (
  3   "PLANID" NUMBER(10) NOT NULL,
  4   "CMENEID" NUMBER(10) NOT NULL,
  5   "RABINDEX" NUMBER(3),
  6   "SUBFLOWINDEX" NUMBER(3),
  7   "TRCHTYPE" NUMBER(3),
  8   "DELAYCLASS" NUMBER(3),
  9   "OPPOSITETRCHTYPE" NUMBER(3),
 10   "RLCMODE" NUMBER(3),
 11   "AMRLCCFGPARA" NUMBER(3),
 12   "AMRLCDISCARDMODE" NUMBER(10),
 13   "UMTMRLCDISCARDMODE" NUMBER(10),
 14   "EXPLICITTIMERMRW" NUMBER(3),
 15   "EXPLICITTIMERDISCARD" NUMBER(3),
 16   "EXPLICITMAXMRW" NUMBER(3),
 17   "NOEXPLICITTIMERDISCARD" NUMBER(3),
 18   "MAXDAT" NUMBER(3),
 19   "TIMERMRW" NUMBER(3),
 20   "MAXMRW" NUMBER(3),
 21   "NODISCARDMAXDAT" NUMBER(3),
 22   "TXWINDOWSIZE" NUMBER(3),
 23   "TXWINDOWSIZELIMIT" NUMBER(3),
 24   "TIMERRST" NUMBER(3),
 25   "MAXRST" NUMBER(3),
 26   "RXWINDOWSIZE" NUMBER(3),
 27   "RXWINDOWSIZELIMIT" NUMBER(3),
 28   "MISSINGPDUIND" NUMBER(3),
 29   "TIMERSTATUSPROHIBIT" NUMBER(3),
 30   "TIMERSTATUSPERIODIC" NUMBER(3),
 31   "LASTTXPDUPOLL" NUMBER(3),
 32   "LASTRETXPDUPOLL" NUMBER(3),
 33   "TIMERPOLLPROHIBIT" NUMBER(3),
 34   "TIMERPOLL" NUMBER(3),
 35   "POLLPDU" NUMBER(3),
 36   "POLLSDU" NUMBER(3),
 37   "POLLWINDOW" NUMBER(3),
 38   "TIMERPOLLPERIODIC" NUMBER(3),
 39   "ULSEGIND" NUMBER(3),
 40   "DLSEGIND" NUMBER(3),
 41   "TIMETOMONITER" NUMBER(17),
 42   "MONITERPRD" NUMBER(10),
 43   "RETRANSRATIOFILTERCOEF" NUMBER(3),
 44   "EVENTATHRED" NUMBER(10),
 45   "TIMETOTRIGGERA" NUMBER(10),
 46   "PENDINGTIMEA" NUMBER(10),
 47   "EVENTBTHRED" NUMBER(10),
 48   "TIMETOTRIGGERB" NUMBER(10),
 49   "PENDINGTIMEB" NUMBER(10),
 50   "INSEQUENCEDELIVERYORDER" NUMBER(3),
 51   "CFGPOLLINGPARA" NUMBER(3),
 52   "EVENTAREPORTDELAY" NUMBER(10),
 53   "RLCDISCARDMODE" NUMBER(10),
 54   "POLLPDUFORENL2" NUMBER(3),
 55   "POLLSDUFORENL2" NUMBER(3),
 56   "POLLPDUFORDLENL2" NUMBER(17),
 57   "POLLSDUFORDLENL2" NUMBER(17),
 58   "POLLPDUFORULENL2" NUMBER(17),
 59   "POLLSDUFORULENL2" NUMBER(17),
 60   "RNCMAXRST" NUMBER(3),
 61   "RNCNODISCARDMAXDAT" NUMBER(3),
 62   "CMERECORDID" VARCHAR(383 BYTE) NOT NULL
 63 );

Succeed.

SQL> create index primary_key_T_P_B4 on T_P_TYPRABRLC_B4("PLANID", "CMENEID", "CMERECORDID");

Succeed.

SQL> 
SQL> explain select distinct 'B4' , a.PlanID , a.CMENEID , 'CMENEID:' || to_char(7381) || ',RABINDEX:' || to_char(a.RABINDEX ) as MoID , 'TYPRABBASIC' , 'RADIO_RAB_DELAYCLASS_RLC_CONFUSE' from t_D_TYPRABBASIC_B4 a 
  2 join t_P_TYPRABRLC_B4 b on a.PlanID = b.PlanID and a.CMENEID = b.CMENEID and a.RABINDEX = b.RABINDEX where a.PlanID = 1 and a.CMENEID = 3076 and a.OperType in (2 , 4 )  
  3 and a.ACTSTATUS = 1 and b.RLCMODE = 1 and b.AMRLCCFGPARA = 0 
  4 and (select count(1) from t_P_TYPRABRLC_B4 c where a.PlanID = 1 and a.PlanID = c.PlanID and a.CMENEID = c.CMENEID and a.RABINDEX = c.RABINDEX 
  5 and c.AMRLCCFGPARA = 1 and c.RLCMODE = 1 and c.TRCHTYPE = b.TRCHTYPE 
  6 and  c.OPPOSITETRCHTYPE = b.OPPOSITETRCHTYPE and  c.SUBFLOWINDEX = b.SUBFLOWINDEX and c.DELAYCLASS = b.DELAYCLASS ) = 0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name                 | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                      |      |      |       |        |
| 1   |   HASH DISTINCT                        |       |                      |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |                      |      |      |       |        |
| 3   |       KERNEL FILTER                    |       |                      |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ROWID    | SYS   | T_D_TYPRABBASIC_B4 A |      |      |       |        |
| 5   |           INDEX RANGE SCAN             | SYS   | PRIMARY_KEY_T_D_B4   |      |      |       |        |
| 6   |         HASH MATERIALIZE               |       |                      |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ROWID  | SYS   | T_P_TYPRABRLC_B4 C   |      |      |       |        |
| 8   |             INDEX RANGE SCAN           | SYS   | PRIMARY_KEY_T_P_B4   |      |      |       |        |
| 9   |       KERNEL FILTER                    |       |                      |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ROWID    | SYS   | T_P_TYPRABRLC_B4 B   |      |      |       |        |
| 11  |           INDEX RANGE SCAN             | SYS   | PRIMARY_KEY_T_P_B4   |      |      |       |        |
| 12  |         HASH MATERIALIZE               |       |                      |      |      |       |        |
| 13  |           TABLE ACCESS BY INDEX ROWID  | SYS   | T_P_TYPRABRLC_B4 C   |      |      |       |        |
| 14  |             INDEX RANGE SCAN           | SYS   | PRIMARY_KEY_T_P_B4   |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: A.ACTSTATUS = 1                                  
   5 - access: A.PLANID = 1 AND A.CMENEID = 3076 AND A.PLANID = A.ACTSTATUS AND A.OPERTYPE IN(2, 4)
   6 - access: C.DELAYCLASS = B.DELAYCLASS AND C.RLCMODE = A.PLANID AND C.PLANID = A.PLANID AND C.CMENEID = A.CMENEID AND 
               C.RABINDEX = A.RABINDEX AND C.AMRLCCFGPARA = A.PLANID AND C.TRCHTYPE = B.TRCHTYPE AND C.OPPOSITETRCHTYPE = B.OPPOSITETRCHTYPE AND 
               C.SUBFLOWINDEX = B.SUBFLOWINDEX AND 1 = A.PLANID 
   7 - filter: C.RLCMODE = 1 AND C.AMRLCCFGPARA = C.RLCMODE AND C.AMRLCCFGPARA = 1
   8 - access: C.PLANID = 1 AND C.CMENEID = 3076 AND C.PLANID = C.RLCMODE AND C.PLANID = C.AMRLCCFGPARA
   10 - filter: B.RLCMODE = 1 AND A.ACTSTATUS = B.RLCMODE AND (SELECT COUNT(1) FROM T_P_TYPRABRLC_B4 C WHERE C.RLCMODE = 1 AND 
               C.AMRLCCFGPARA = 1 AND C.PLANID = C.RLCMODE AND C.PLANID = C.AMRLCCFGPARA AND C.AMRLCCFGPARA = C.RLCMODE GROUP BY 
               C.DELAYCLASS,C.RLCMODE,C.PLANID,C.CMENEID,C.RABINDEX,C.AMRLCCFGPARA,C.TRCHTYPE,C.OPPOSITETRCHTYPE,
               C.SUBFLOWINDEX,1) = 0 AND A.RABINDEX = B.RABINDEX AND B.AMRLCCFGPARA = 0 AND A.PLANID = B.RLCMODE
   11 - access: B.PLANID = 1 AND B.CMENEID = 3076 AND B.RLCMODE = B.PLANID AND A.ACTSTATUS = B.PLANID AND 
               A.CMENEID = B.CMENEID AND A.PLANID = B.PLANID    
   12 - access: C.DELAYCLASS = B.DELAYCLASS AND C.RLCMODE = A.PLANID AND C.PLANID = A.PLANID AND C.CMENEID = A.CMENEID AND 
               C.RABINDEX = A.RABINDEX AND C.AMRLCCFGPARA = A.PLANID AND C.TRCHTYPE = B.TRCHTYPE AND C.OPPOSITETRCHTYPE = B.OPPOSITETRCHTYPE AND 
               C.SUBFLOWINDEX = B.SUBFLOWINDEX AND 1 = A.PLANID 
   13 - filter: C.RLCMODE = 1 AND C.AMRLCCFGPARA = C.RLCMODE AND C.AMRLCCFGPARA = 1
   14 - access: C.PLANID = 1 AND C.CMENEID = 3076 AND C.PLANID = C.RLCMODE AND C.PLANID = C.AMRLCCFGPARA

39 rows fetched.

SQL> 
SQL> --DTS2019011506478
SQL> drop table if exists t_subselect_dept;

Succeed.

SQL> create table t_subselect_dept(
  2        deptno number(10),
  3        dname varchar2(30),
  4        loc varchar2(30)
  5 );

Succeed.

SQL> drop table if exists t_subselect_emp;

Succeed.

SQL> create table t_subselect_emp(
  2        empno number(10),
  3        ename varchar2(30),
  4        job varchar2(30),
  5        mgr varchar2(30),
  6        hiredate number(10),
  7        sal number(10),
  8        comm number(10),
  9        deptno number(10)
 10 );

Succeed.

SQL> insert into t_subselect_dept values(1, 'aaa' ,'bbb');

1 rows affected.

SQL> insert into t_subselect_dept values(2, 'SALES' ,'ccc');

1 rows affected.

SQL> insert into t_subselect_dept values(3, 'ddd' ,'eee');

1 rows affected.

SQL> insert into t_subselect_emp values(1, 'fff', 'CLERK' ,'ggg', 20011109, 2000, 1000, 3);

1 rows affected.

SQL> insert into t_subselect_emp values(2, 'SMITH', 'CLERK' ,'hhh', 20120101, 2000, 800, 6);

1 rows affected.

SQL> insert into t_subselect_emp values(3, 'jjj', 'MANAGER' ,'kkk', 20080808, 9000, 4000, 3);

1 rows affected.

SQL> 
SQL> select a.deptno,a.dname,a.loc,b.job,b.sal
  2 from t_subselect_dept a,t_subselect_emp b where b.sal = (select STDDEV(c.sal) from t_subselect_emp c where a.deptno=c.deptno) order by a.deptno,a.dname,a.loc,b.job,b.sal;

DEPTNO                                   DNAME                          LOC                            JOB                            SAL                                     
---------------------------------------- ------------------------------ ------------------------------ ------------------------------ ----------------------------------------

0 rows fetched.

SQL> 
SQL> explain plan for select a.deptno,a.dname,a.loc,b.job,b.sal
  2 from t_subselect_dept a,t_subselect_emp b where b.sal = (select STDDEV(c.sal) from t_subselect_emp c where a.deptno=c.deptno group by c.deptno) order by a.deptno,a.dname,a.loc,b.job,b.sal;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |                    |      |      |       |        |
| 2   |     NESTED LOOPS             |       |                    |      |      |       |        |
| 3   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_SUBSELECT_DEPT A |      |      |       |        |
| 5   |         HASH GROUP BY        |       |                    |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP C  |      |      |       |        |
| 7   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | T_SUBSELECT_EMP B  |      |      |       |        |
| 9   |         HASH GROUP BY        |       |                    |      |      |       |        |
| 10  |           TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP C  |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - filter: C.DEPTNO = A.DEPTNO                              
   8 - filter: B.SAL = (SELECT STDDEV(C.SAL) FROM T_SUBSELECT_EMP C WHERE C.DEPTNO = A.DEPTNO GROUP BY 
               C.DEPTNO)                                        
   10 - filter: C.DEPTNO = A.DEPTNO                             

21 rows fetched.

SQL> 
SQL> --DTS2019011714785
SQL> drop table if exists t_subselect_dept;

Succeed.

SQL> create table t_subselect_dept(
  2        deptno int,
  3        dname varchar(30) UNIQUE,
  4        loc varchar(30),
  5     mgr varchar(30)
  6 );

Succeed.

SQL> create unique index idx_pk_subselect_dept on t_subselect_dept(deptno);

Succeed.

SQL> 
SQL> drop table if exists t_subselect_emp;

Succeed.

SQL> create table t_subselect_emp(
  2        empno int,
  3        ename varchar(30) not null,
  4        job varchar(30),
  5        mgr varchar(30),
  6        hiredate int,
  7        sal int not null,
  8        comm int check(comm<10000),
  9        deptno int
 10 );

Succeed.

SQL> create unique index idx_pk_subselect_emp on t_subselect_emp(empno);

Succeed.

SQL> 
SQL> explain
  2 select  a.deptno, a.dname, a.loc, b.job, b.sal
  3   from t_subselect_dept a
  4  inner join t_subselect_emp b
  5     on a.deptno = b.deptno
  6  where ascii(b.sal) = (select ascii(min(rownum))
  7                          from t_subselect_emp c
  8                         inner join t_subselect_dept d
  9                            on d.mgr = c.mgr
 10                         where a.deptno = c.deptno
 11                           and c.sal >= 2000)
 12  order by a.deptno, a.dname, a.loc, b.job, b.sal;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                       |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                     |       |                       |      |      |       |        |
| 3   |       KERNEL FILTER                  |       |                       |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | T_SUBSELECT_EMP B     |      |      |       |        |
| 5   |         AGGR                         |       |                       |      |      |       |        |
| 6   |           ROWNUM COUNT               |       |                       |      |      |       |        |
| 7   |             NESTED LOOPS             |       |                       |      |      |       |        |
| 8   |               TABLE ACCESS FULL      | SYS   | T_SUBSELECT_EMP C     |      |      |       |        |
| 9   |               TABLE ACCESS FULL      | SYS   | T_SUBSELECT_DEPT D    |      |      |       |        |
| 10  |       KERNEL FILTER                  |       |                       |      |      |       |        |
| 11  |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_SUBSELECT_DEPT A    |      |      |       |        |
| 12  |           INDEX UNIQUE SCAN          | SYS   | IDX_PK_SUBSELECT_DEPT |      |      |       |        |
| 13  |         AGGR                         |       |                       |      |      |       |        |
| 14  |           ROWNUM COUNT               |       |                       |      |      |       |        |
| 15  |             NESTED LOOPS             |       |                       |      |      |       |        |
| 16  |               TABLE ACCESS FULL      | SYS   | T_SUBSELECT_EMP C     |      |      |       |        |
| 17  |               TABLE ACCESS FULL      | SYS   | T_SUBSELECT_DEPT D    |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   8 - filter: C.SAL >= 2000 AND C.DEPTNO = A.DEPTNO            
   9 - filter: D.MGR = C.MGR                                    
   11 - filter: ASCII(B.SAL) = (SELECT ASCII(MIN(ROWNUM)) FROM T_SUBSELECT_EMP C INNER JOIN T_SUBSELECT_DEPT D WHERE C.SAL >= 2000 AND 
               D.MGR = C.MGR AND C.DEPTNO = A.DEPTNO)           
   12 - access: A.DEPTNO = B.DEPTNO                             
   16 - filter: C.SAL >= 2000 AND C.DEPTNO = A.DEPTNO           
   17 - filter: D.MGR = C.MGR                                   

31 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS PULL_UP_T1;

Succeed.

SQL> DROP TABLE IF EXISTS PULL_UP_T2;

Succeed.

SQL> CREATE TABLE PULL_UP_T1(A INT, B INT, C INT);

Succeed.

SQL> CREATE INDEX IDX_PULL_UP_T1_1 ON PULL_UP_T1(A,B);

Succeed.

SQL> CREATE TABLE PULL_UP_T2(A INT, B INT, C INT);

Succeed.

SQL> EXPLAIN SELECT * FROM PULL_UP_T1 T1 WHERE EXISTS (SELECT * FROM PULL_UP_T2 T2 WHERE T2.A > T1.A AND T1.A=2 AND T1.B=2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | PULL_UP_T1 T1    |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_PULL_UP_T1_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | PULL_UP_T2 T2    |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.A = T1.B AND EXISTS(SELECT 1 FROM PULL_UP_T2 T2 WHERE T1.A = 2 AND T1.B = 2 AND T2.A > T1.A)
   3 - access: T1.A = 2 AND T1.B = 2                            
   4 - filter: T1.A = 2 AND T2.A > T1.A AND T1.B = 2            

14 rows fetched.

SQL> EXPLAIN SELECT * FROM PULL_UP_T1 T1 WHERE T1.C IN (SELECT T2.C FROM PULL_UP_T2 T2 WHERE T2.A > T1.A AND T1.A=2 AND T1.B=2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | PULL_UP_T1 T1    |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_PULL_UP_T1_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | PULL_UP_T2 T2    |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.A = T1.B AND EXISTS(SELECT 1 FROM PULL_UP_T2 T2 WHERE T1.A = 2 AND T1.B = 2 AND T1.C = T2.C AND 
               T2.A > T1.A)                                     
   3 - access: T1.A = 2 AND T1.B = 2                            
   4 - filter: T1.A = 2 AND T1.C = T2.C AND T1.B = 2 AND T2.A > T1.A

15 rows fetched.

SQL> EXPLAIN SELECT * FROM PULL_UP_T1 T1 WHERE NOT EXISTS (SELECT * FROM PULL_UP_T2 T2 WHERE T2.A > T1.A AND T1.A=2 AND T1.B=2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   KERNEL FILTER        |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | PULL_UP_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | PULL_UP_T2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: NOT EXISTS(SELECT 1 FROM PULL_UP_T2 T2 WHERE T1.A = 2 AND T1.B = 2 AND T2.A > T1.A)
   3 - filter: T1.A = 2 AND T2.A > T1.A AND T1.B = 2            

12 rows fetched.

SQL> EXPLAIN SELECT * FROM PULL_UP_T1 T1 WHERE T1.C NOT IN (SELECT T2.C FROM PULL_UP_T2 T2 WHERE T2.A > T1.A AND T1.A=2 AND T1.B=2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   KERNEL FILTER        |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | PULL_UP_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | PULL_UP_T2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.C NOT IN((SELECT C FROM PULL_UP_T2 T2 WHERE T1.A = 2 AND T1.B = 2 AND T2.A > T1.A))
   3 - filter: T1.A = 2 AND T2.A > T1.A AND T1.B = 2            

12 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS "TBL_OBJECTINSTANCE" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "TBL_OBJECTINSTANCE"
  2 (
  3   "OBJECTTYPEID" BINARY_INTEGER NOT NULL,
  4   "OBJECTNO" BINARY_INTEGER NOT NULL,
  5   "INVALIDTIME" DATE,
  6   "OBJECTPARAMETER" VARCHAR(64 BYTE),
  7   "NEFDN" VARCHAR(120 BYTE) NOT NULL,
  8   "NENAME" VARCHAR(200 BYTE) NOT NULL,
  9   "MEMBERNUM" BINARY_INTEGER NOT NULL,
 10   "OBJECTMEMBER0" VARCHAR(255 BYTE),
 11   "OBJECTMEMNAME0" VARCHAR(512 BYTE),
 12   "OBJECTMEMBER1" VARCHAR(255 BYTE),
 13   "OBJECTMEMNAME1" VARCHAR(255 BYTE),
 14   "OBJECTMEMBER2" VARCHAR(255 BYTE),
 15   "OBJECTMEMNAME2" VARCHAR(255 BYTE),
 16   "OBJECTMEMBER3" VARCHAR(255 BYTE),
 17   "OBJECTMEMNAME3" VARCHAR(255 BYTE),
 18   "OBJECTMEMBER4" VARCHAR(255 BYTE),
 19   "OBJECTMEMNAME4" VARCHAR(255 BYTE),
 20   "OBJECTMEMBER5" VARCHAR(255 BYTE),
 21   "OBJECTMEMNAME5" VARCHAR(255 BYTE),
 22   "OBJECTDESCRIPTION" VARCHAR(192 BYTE),
 23   "BAMOBJECTSTR" VARCHAR(255 BYTE),
 24   "MEASUREMENTSTATE" BINARY_INTEGER NOT NULL,
 25   UNIQUE("OBJECTTYPEID", "OBJECTNO")
 26 );

Succeed.

SQL> CREATE INDEX "INDEXNEFDN" ON "TBL_OBJECTINSTANCE"("OBJECTTYPEID", "NEFDN", "BAMOBJECTSTR");

Succeed.

SQL> CREATE INDEX "INDEXOBJECTTYPEID" ON "TBL_OBJECTINSTANCE"("OBJECTTYPEID");

Succeed.

SQL> CREATE INDEX "INDEXPURENEFDN" ON "TBL_OBJECTINSTANCE"("NEFDN");

Succeed.

SQL> CREATE INDEX "INVALIDTIMEINDEX" ON "TBL_OBJECTINSTANCE"("INVALIDTIME");

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "TBL_OBJMEASREC_1526726666" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "TBL_OBJMEASREC_1526726666"
  2 (
  3   "OBJECTNO" BINARY_INTEGER NOT NULL,
  4   "STARTTIME" DATE NOT NULL,
  5   "ENDTIME" DATE,
  6   "TIMEZONEOFFSET" BINARY_INTEGER NOT NULL,
  7   "STARTTIMEDSTOFFSET" BINARY_INTEGER NOT NULL,
  8   "ENDTIMEDSTOFFSET" BINARY_INTEGER NOT NULL
  9 );

Succeed.

SQL> ALTER TABLE "TBL_OBJMEASREC_1526726666" ADD CONSTRAINT "I_TBL_OBJMEASREC_1526726666" PRIMARY KEY("OBJECTNO", "STARTTIME");

Succeed.

SQL> explain select ObjectNo from tbl_ObjectInstance where ObjectTypeId = 1526726666 and NeFdn = 'NE=6699' and MeasurementState = 1 and InvalidTime is null and ObjectNo not in (select ObjectNo from tbl_ObjMeasRec_1526726666 where EndTime is null); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)              |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_OBJECTINSTANCE        |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | INDEXNEFDN                |      |      |       |        |
| 4   |     SUBSELECT                    |       |                           |      |      |       |        |
| 5   |       TABLE ACCESS FULL          | SYS   | TBL_OBJMEASREC_1526726666 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: OBJECTNO = TBL_OBJMEASREC_1526726666.OBJECTNO    
   2 - filter: MEASUREMENTSTATE = 1 AND INVALIDTIME IS NULL     
   3 - access: OBJECTTYPEID = 1526726666 AND NEFDN = 'NE=6699'  
   5 - filter: ENDTIME IS NULL                                  

16 rows fetched.

SQL> DROP TABLE IF EXISTS t_join_drv_1 CASCADE CONSTRAINTS;

Succeed.

SQL> DROP TABLE IF EXISTS t_join_drv_2 CASCADE CONSTRAINTS;

Succeed.

SQL> create table t_join_drv_1(a int, b int, c int);

Succeed.

SQL> create table t_join_drv_2(a int, b int, c int);

Succeed.

SQL> create index idx_t1_1 on t_join_drv_1(a);

Succeed.

SQL> explain select * from t_join_drv_1 t1 join t_join_drv_2 t2 on t1.a=t2.a where t1.a=100;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_JOIN_DRV_1 T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_T1_1        |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_JOIN_DRV_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
   3 - access: T1.A = 100                                       
   4 - filter: T2.A = 100                                       

14 rows fetched.

SQL> explain select * from t_join_drv_1 t1 join t_join_drv_2 t2 on t1.a=t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_JOIN_DRV_2 T2 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_JOIN_DRV_1 T1 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T1_1        |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      

12 rows fetched.

SQL> explain select * from t_join_drv_2 t2 join t_join_drv_1 t1 on t1.a=t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_JOIN_DRV_2 T2 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_JOIN_DRV_1 T1 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T1_1        |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      

12 rows fetched.

SQL> explain select * from t_join_drv_2 t2 left join t_join_drv_1 t1 on t1.a=10 and t1.b=t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)             |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_JOIN_DRV_2 T2 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_JOIN_DRV_1 T1 |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T1_1        |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.B = T1.B                                      
   4 - access: T1.A = 10                                        

13 rows fetched.

SQL> DROP TABLE IF EXISTS t_join_drv_1 CASCADE CONSTRAINTS;

Succeed.

SQL> 
SQL> --DTS2019022809303
SQL> drop table if exists t_subselect_dept;

Succeed.

SQL> create table t_subselect_dept(deptno int,dname varchar(30),loc varchar(30),mgr varchar(30));

Succeed.

SQL> 
SQL> drop table if exists t_subselect_emp;

Succeed.

SQL> create table t_subselect_emp(empno int,ename varchar(30),job varchar(30),mgr varchar(30),hiredate int,sal int,comm int,deptno int);

Succeed.

SQL> 
SQL> drop table if exists t_subselect_dept_null;

Succeed.

SQL> create table t_subselect_dept_null(deptno int primary key,dname varchar(30),loc varchar(30),mgr varchar(30));

Succeed.

SQL> 
SQL> drop table if exists t_subselect_emp_null;

Succeed.

SQL> create table t_subselect_emp_null(empno int primary key,ename varchar(30) not null,job varchar(30),mgr varchar(30),hiredate int,sal int,comm int check(comm<10000),deptno int);

Succeed.

SQL> 
SQL> drop table if exists t_subselect_family;

Succeed.

SQL> create table t_subselect_family(empno int,family_name varchar(100),family_sal int);

Succeed.

SQL> 
SQL> drop view if exists t_subselect_emp_view;

Succeed.

SQL> create view t_subselect_emp_view as select * from t_subselect_emp;

Succeed.

SQL> drop view if exists t_subselect_dept_view;

Succeed.

SQL> create view t_subselect_dept_view as select * from t_subselect_dept;

Succeed.

SQL> 
SQL> explain select a.deptno,a.dname,a.loc,b.job,b.sal
  2 from t_subselect_dept_view a inner join t_subselect_emp_view b on a.deptno=b.deptno where b.sal = (select sum(c.sal) from t_subselect_emp_view c inner join t_subselect_dept_view d on d.mgr=c.mgr  where a.deptno=c.deptno and c.sal >=2000) order by a.deptno,a.dname,a.loc,b.job,b.sal;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |                         |      |      |       |        |
| 2   |     HASH JOIN(L)               |       |                         |      |      |       |        |
| 3   |       KERNEL FILTER            |       |                         |      |      |       |        |
| 4   |         VIEW                   | SYS   | T_SUBSELECT_DEPT_VIEW A |      |      |       |        |
| 5   |           TABLE ACCESS FULL    | SYS   | T_SUBSELECT_DEPT        |      |      |       |        |
| 6   |         HASH MATERIALIZE       |       |                         |      |      |       |        |
| 7   |           NESTED LOOPS         |       |                         |      |      |       |        |
| 8   |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP         |      |      |       |        |
| 9   |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_DEPT        |      |      |       |        |
| 10  |       KERNEL FILTER            |       |                         |      |      |       |        |
| 11  |         VIEW                   | SYS   | T_SUBSELECT_EMP_VIEW B  |      |      |       |        |
| 12  |           TABLE ACCESS FULL    | SYS   | T_SUBSELECT_EMP         |      |      |       |        |
| 13  |         HASH MATERIALIZE       |       |                         |      |      |       |        |
| 14  |           NESTED LOOPS         |       |                         |      |      |       |        |
| 15  |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP         |      |      |       |        |
| 16  |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_DEPT        |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A.DEPTNO = B.DEPTNO                              
       filter: B.SAL = (SELECT SUM(T_SUBSELECT_EMP.SAL) FROM T_SUBSELECT_EMP INNER JOIN T_SUBSELECT_DEPT WHERE T_SUBSELECT_EMP.SAL >= 2000 AND 
               T_SUBSELECT_DEPT.MGR = T_SUBSELECT_EMP.MGR GROUP BY T_SUBSELECT_EMP.DEPTNO)
   6 - access: T_SUBSELECT_EMP.DEPTNO = A.DEPTNO                
   8 - filter: T_SUBSELECT_EMP.SAL >= 2000                      
   9 - filter: T_SUBSELECT_DEPT.MGR = T_SUBSELECT_EMP.MGR       
   13 - access: T_SUBSELECT_EMP.DEPTNO = A.DEPTNO               
   15 - filter: T_SUBSELECT_EMP.SAL >= 2000                     
   16 - filter: T_SUBSELECT_DEPT.MGR = T_SUBSELECT_EMP.MGR      

32 rows fetched.

SQL> 
SQL> explain select a.deptno,a.dname,a.loc,b.job,b.sal
  2 from t_subselect_dept a inner join t_subselect_emp b on a.deptno=b.deptno where ascii(b.sal) = (select ascii(min(c.sal)) from (select sal,mgr,deptno from t_subselect_emp) c inner join (select deptno,dname,loc,mgr from t_subselect_dept d) as d on d.mgr=c.mgr  where a.deptno=c.deptno and c.sal >=2000) order by a.deptno,a.dname,a.loc,b.job,b.sal;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |                    |      |      |       |        |
| 2   |     HASH JOIN(L)               |       |                    |      |      |       |        |
| 3   |       KERNEL FILTER            |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL      | SYS   | T_SUBSELECT_DEPT A |      |      |       |        |
| 5   |         HASH MATERIALIZE       |       |                    |      |      |       |        |
| 6   |           NESTED LOOPS         |       |                    |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP    |      |      |       |        |
| 8   |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_DEPT D |      |      |       |        |
| 9   |       KERNEL FILTER            |       |                    |      |      |       |        |
| 10  |         TABLE ACCESS FULL      | SYS   | T_SUBSELECT_EMP B  |      |      |       |        |
| 11  |         HASH MATERIALIZE       |       |                    |      |      |       |        |
| 12  |           NESTED LOOPS         |       |                    |      |      |       |        |
| 13  |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_EMP    |      |      |       |        |
| 14  |             TABLE ACCESS FULL  | SYS   | T_SUBSELECT_DEPT D |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A.DEPTNO = B.DEPTNO                              
       filter: ASCII(B.SAL) = (SELECT ASCII(MIN(T_SUBSELECT_EMP.SAL)) FROM T_SUBSELECT_EMP INNER JOIN T_SUBSELECT_DEPT D WHERE T_SUBSELECT_EMP.SAL >= 2000 AND 
               D.MGR = T_SUBSELECT_EMP.MGR GROUP BY T_SUBSELECT_EMP.DEPTNO)
   5 - access: T_SUBSELECT_EMP.DEPTNO = A.DEPTNO                
   7 - filter: T_SUBSELECT_EMP.SAL >= 2000                      
   8 - filter: D.MGR = T_SUBSELECT_EMP.MGR                      
   11 - access: T_SUBSELECT_EMP.DEPTNO = A.DEPTNO               
   13 - filter: T_SUBSELECT_EMP.SAL >= 2000                     
   14 - filter: D.MGR = T_SUBSELECT_EMP.MGR                     

30 rows fetched.

SQL> 
SQL> drop table if exists t_dlvr_1;

Succeed.

SQL> drop table if exists t_dlvr_2;

Succeed.

SQL> drop table if exists t_dlvr_3;

Succeed.

SQL> drop table if exists t_dlvr_4;

Succeed.

SQL> create table t_dlvr_1(a int, b int, c int);

Succeed.

SQL> create table t_dlvr_2(a int, b int, c int)
  2 PARTITION BY RANGE(a)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30),
  7  PARTITION p4 values less than(MAXVALUE)
  8 );

Succeed.

SQL> create table t_dlvr_3(a int, b int, c int)
  2 PARTITION BY RANGE(b)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30),
  7  PARTITION p4 values less than(MAXVALUE)
  8 );

Succeed.

SQL> create table t_dlvr_4(a int, b int, c int)
  2 PARTITION BY RANGE(a)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30),
  7  PARTITION p4 values less than(MAXVALUE)
  8 );

Succeed.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a where t1.b=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name        | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL Filter:[0,4) | SYS   | T_DLVR_2 T2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
   2 - filter: T1.B = 10                                        

12 rows fetched.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a where t1.a=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name        | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
   2 - filter: T1.A = 10                                        
   3 - filter: T2.A = 10                                        

13 rows fetched.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a left join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |             |      |      |       |        |
| 2   |     HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[0,4)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = T3.B                                      
   2 - access: T1.A = T2.A                                      
   3 - filter: T1.A = 10                                        
   4 - filter: T2.A = 10                                        

16 rows fetched.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a left join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10 and t1.b=20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |             |      |      |       |        |
| 2   |     HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[2,3)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = T3.B                                      
   2 - access: T1.A = T2.A                                      
   3 - filter: T1.B = 20 AND T1.A = 10                          
   4 - filter: T2.A = 10                                        
   5 - filter: T3.B = 20                                        

17 rows fetched.

SQL> explain select * from t_dlvr_1 t1 right join t_dlvr_2 t2 on t1.a=t2.a left join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |             |      |      |       |        |
| 2   |     HASH JOIN(L)                     |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
| 4   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[0,4)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = T3.B                                      
   2 - access: T2.A = T1.A                                      
   3 - filter: T2.A = 10                                        
   4 - filter: T1.A = 10                                        

16 rows fetched.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a right join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN(L)                       |       |             |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[0,4)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
| 3   |     HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 4   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 5   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T3.B = T1.B                                      
   3 - access: T1.A = T2.A                                      
   4 - filter: T1.A = 10                                        
   5 - filter: T2.A = 10                                        

16 rows fetched.

SQL> explain select * from t_dlvr_1 t1 right join t_dlvr_2 t2 on t1.a=t2.a left join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10 and t1.b=20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |             |      |      |       |        |
| 2   |     HASH JOIN(L)                     |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
| 4   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[2,3)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = T3.B                                      
   2 - access: T2.A = T1.A                                      
   3 - filter: T2.A = 10                                        
   4 - filter: T1.B = 20 AND T1.A = 10                          
   5 - filter: T3.B = 20                                        

17 rows fetched.

SQL> explain select * from t_dlvr_1 t1 left join t_dlvr_2 t2 on t1.a=t2.a right join t_dlvr_3 t3 on t1.b=t3.b where t1.a=10 and t1.b=20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN(L)                       |       |             |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
| 3   |     HASH JOIN OUTER(R)               |       |             |      |      |       |        |
| 4   |       TABLE ACCESS FULL              | SYS   | T_DLVR_1 T1 |      |      |       |        |
| 5   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T3.B = T1.B                                      
   2 - filter: T3.B = 20                                        
   3 - access: T1.A = T2.A                                      
   4 - filter: T1.B = 20 AND T1.A = 10                          
   5 - filter: T2.A = 10                                        

17 rows fetched.

SQL> explain select * from t_dlvr_2 t2 left join t_dlvr_4 t4 on t2.a=t4.a left join t_dlvr_3 t3 on t4.b=t3.b where t4.a=10 and t4.b=20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |             |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |             |      |      |       |        |
| 2   |     HASH JOIN(L)                     |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_2 T2 |      |      |       |        |
| 4   |       TABLE ACCESS FULL Filter:[1,2) | SYS   | T_DLVR_4 T4 |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[2,3)   | SYS   | T_DLVR_3 T3 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T4.B = T3.B                                      
   2 - access: T2.A = T4.A                                      
   3 - filter: T2.A = 10                                        
   4 - filter: T4.B = 20 AND T4.A = 10                          
   5 - filter: T3.B = 20                                        

17 rows fetched.

SQL> 
SQL> -- SR.IREQ02305460.001
SQL> drop table if exists test;

Succeed.

SQL> create table  test (a int, b int, c int);

Succeed.

SQL> create index ix_1 on test (a);

Succeed.

SQL> create index ix_2 on test (a, b);

Succeed.

SQL> 
SQL> explain select a from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> explain select b from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> explain select c from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> 
SQL> explain select a from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select c from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select a, b from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select a, c from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> 
SQL> drop table if exists test;

Succeed.

SQL> create table  test (a int, b int, c int);

Succeed.

SQL> create index ix_2 on test (a, b);

Succeed.

SQL> create index ix_1 on test (a);

Succeed.

SQL> 
SQL> explain select a from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> explain select b from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> explain select c from test where a = 40;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 40                                           

10 rows fetched.

SQL> 
SQL> explain select a from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select c from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select a, b from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> explain select a, c from test where a = 40 and b = 20;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: B = 20 AND A = 40                                

10 rows fetched.

SQL> 
SQL> drop table if exists t_push_1;

Succeed.

SQL> drop table if exists t_push_2;

Succeed.

SQL> drop table if exists t_push_3;

Succeed.

SQL> drop table if exists t_push_4;

Succeed.

SQL> drop table if exists t_push_5;

Succeed.

SQL> drop table if exists t_push_6;

Succeed.

SQL> create table t_push_1(a int, b int, c int);

Succeed.

SQL> create table t_push_2(a int, b int, c int);

Succeed.

SQL> create table t_push_3(a int, b int, c int);

Succeed.

SQL> create table t_push_4(a int, b int, c int);

Succeed.

SQL> create table t_push_5(a int, b int, c int);

Succeed.

SQL> create table t_push_6(a int, b int, c int);

Succeed.

SQL> 
SQL> create index idx_t_push_2 on t_push_2(a);

Succeed.

SQL> create index idx_t_push_4 on t_push_4(a);

Succeed.

SQL> create index idx_t_push_5 on t_push_5(a);

Succeed.

SQL> create index idx_t_push_6 on t_push_6(a);

Succeed.

SQL> 
SQL> create or replace view v_push_1 as select * from t_push_1;

Succeed.

SQL> create or replace view v_push_2 as select * from t_push_2;

Succeed.

SQL> create or replace view v_push_3 as select * from v_push_1;

Succeed.

SQL> create or replace view v_push_4 as select * from v_push_2;

Succeed.

SQL> create or replace view v_push_5 as select t2.a t2a,t4.a t4a from t_push_2 t2 join t_push_4 t4 on t2.a=t4.a;

Succeed.

SQL> create or replace view v_push_6 as select t5.a t5a,t6.a t6a from t_push_5 t5 left join t_push_6 t6 on t5.a=t6.a;

Succeed.

SQL> create or replace view v_push_7 as select t1.a t1a,t3.a t3a,t3.b t3b from t_push_1 t1 left join t_push_3 t3 on t1.a=t3.a;

Succeed.

SQL> 
SQL> explain select * from t_push_2 t2 join v_push_1 v1 on t2.a=v1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T2.A = T_PUSH_1.A                                

12 rows fetched.

SQL> explain select * from v_push_1 v1 join t_push_2 t2 on t2.a=v1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T2.A = T_PUSH_1.A                                

12 rows fetched.

SQL> explain select * from t_push_1 t1 join v_push_2 v2 on t1.a=v2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T_PUSH_2.A                                

12 rows fetched.

SQL> explain select * from t_push_2 t2 join v_push_2 v2 on t2.a=v2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T2.A = T_PUSH_2.A                                

12 rows fetched.

SQL> explain select * from t_push_1 t1 join v_push_4 v4 on t1.a=v4.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T_PUSH_2.A                                

12 rows fetched.

SQL> explain select * from t_push_2 t2 join v_push_4 v4 on t2.a=v4.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T2.A = T_PUSH_2.A                                

12 rows fetched.

SQL> explain select * from t_push_2 t2 join v_push_7 v7 on t2.a=v7.t1a and t2.b=v7.t3b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     VIEW                         | SYS   | V_PUSH_7 V7  |      |      |       |        |
| 3   |       HASH JOIN(L)               |       |              |      |      |       |        |
| 4   |         TABLE ACCESS FULL        | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 5   |         TABLE ACCESS FULL        | SYS   | T_PUSH_3 T3  |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 7   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T3.A                                      
   6 - filter: T2.B = V7.T3B                                    
   7 - access: T2.A = V7.T1A                                    

17 rows fetched.

SQL> explain select * from v_push_1 v1 join v_push_2 v2 on v1.a = v2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_PUSH_1.A = T_PUSH_2.A                          

12 rows fetched.

SQL> explain select * from v_push_1 v1 left join v_push_2 v2 on v1.a = v2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_PUSH_1.A = T_PUSH_2.A                          

12 rows fetched.

SQL> explain select * from v_push_2 v2 join v_push_1 v1 on v2.a = v1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_PUSH_2.A = T_PUSH_1.A                          

12 rows fetched.

SQL> explain select * from v_push_3 v3 join v_push_4 v4 on v3.a = v4.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_PUSH_1.A = T_PUSH_2.A                          

12 rows fetched.

SQL> explain select * from v_push_4 v4 join v_push_3 v3 on v3.a = v4.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_PUSH_1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_PUSH_1.A = T_PUSH_2.A                          

12 rows fetched.

SQL> explain select * from v_push_5 v5 join v_push_6 v6 on v5.t2a=v6.t5a and v5.t4a=v6.t6a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                      |       |              |      |      |       |        |
| 2   |     VIEW                            | SYS   | V_PUSH_5 V5  |      |      |       |        |
| 3   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 5   |           INDEX FAST FULL SCAN      | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_4 T4  |      |      |       |        |
| 7   |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_4 |      |      |       |        |
| 8   |     VIEW                            | SYS   | V_PUSH_6 V6  |      |      |       |        |
| 9   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_5 T5  |      |      |       |        |
| 11  |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_5 |      |      |       |        |
| 12  |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_6 T6  |      |      |       |        |
| 13  |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_6 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - access: T2.A = T4.A                                      
   8 - filter: V5.T4A = V6.T6A AND V5.T2A = V6.T5A              
   10 - filter: T5.A = V5.T2A                                   
   11 - access: T5.A = V5.T4A                                   
   12 - filter: T6.A = V5.T2A AND T5.A = T6.A                   
   13 - access: T6.A = V5.T4A                                   

26 rows fetched.

SQL> explain select * from v_push_6 v6 join v_push_5 v5 on v5.t2a=v6.t5a and v5.t4a=v6.t6a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                      |       |              |      |      |       |        |
| 2   |     VIEW                            | SYS   | V_PUSH_6 V6  |      |      |       |        |
| 3   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_5 T5  |      |      |       |        |
| 5   |           INDEX FAST FULL SCAN      | SYS   | IDX_T_PUSH_5 |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_6 T6  |      |      |       |        |
| 7   |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_6 |      |      |       |        |
| 8   |     VIEW                            | SYS   | V_PUSH_5 V5  |      |      |       |        |
| 9   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 11  |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 12  |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_4 T4  |      |      |       |        |
| 13  |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_4 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - access: T5.A = T6.A                                      
   8 - filter: V5.T4A = V6.T6A AND V5.T2A = V6.T5A              
   10 - filter: T2.A = V6.T6A                                   
   11 - access: T2.A = V6.T5A                                   
   12 - filter: T4.A = V6.T6A AND T2.A = T4.A                   
   13 - access: T4.A = V6.T5A                                   

26 rows fetched.

SQL> explain select * from v_push_5 v5 join v_push_7 v7 on v5.t2a=v7.t1a and v5.t4a=v7.t3a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |              |      |      |       |        |
| 1   |   HASH JOIN(L)                      |       |              |      |      |       |        |
| 2   |     VIEW                            | SYS   | V_PUSH_5 V5  |      |      |       |        |
| 3   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 5   |           INDEX FAST FULL SCAN      | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_4 T4  |      |      |       |        |
| 7   |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_4 |      |      |       |        |
| 8   |     VIEW                            | SYS   | V_PUSH_7 V7  |      |      |       |        |
| 9   |       HASH JOIN(L)                  |       |              |      |      |       |        |
| 10  |         TABLE ACCESS FULL           | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 11  |         TABLE ACCESS FULL           | SYS   | T_PUSH_3 T3  |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: V5.T4A = V7.T3A AND V5.T2A = V7.T1A              
   7 - access: T2.A = T4.A                                      
   9 - access: T1.A = T3.A                                      

21 rows fetched.

SQL> explain select * from v_push_7 v7 join v_push_5 v5 on v5.t2a=v7.t1a and v5.t4a=v7.t3a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                      |       |              |      |      |       |        |
| 2   |     VIEW                            | SYS   | V_PUSH_7 V7  |      |      |       |        |
| 3   |       HASH JOIN(L)                  |       |              |      |      |       |        |
| 4   |         TABLE ACCESS FULL           | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 5   |         TABLE ACCESS FULL           | SYS   | T_PUSH_3 T3  |      |      |       |        |
| 6   |     VIEW                            | SYS   | V_PUSH_5 V5  |      |      |       |        |
| 7   |       NESTED LOOPS                  |       |              |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_2 T2  |      |      |       |        |
| 9   |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_PUSH_4 T4  |      |      |       |        |
| 11  |           INDEX RANGE SCAN          | SYS   | IDX_T_PUSH_4 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T3.A                                      
   6 - filter: V5.T4A = V7.T3A AND V5.T2A = V7.T1A              
   8 - filter: T2.A = V7.T3A                                    
   9 - access: T2.A = V7.T1A                                    
   10 - filter: T4.A = V7.T3A AND T2.A = T4.A                   
   11 - access: T4.A = V7.T1A                                   

24 rows fetched.

SQL> explain select * from t_push_1 t1 join v_push_1 v1 on t1.b=v1.b join v_push_2 v2 on t1.a=v2.a and v1.b=v2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |              |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 6   |     TABLE ACCESS FULL              | SYS   | T_PUSH_1     |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T_PUSH_2.B = T_PUSH_1.B AND T1.B = T_PUSH_1.B    
   4 - filter: T1.B = T_PUSH_2.B                                
   5 - access: T1.A = T_PUSH_2.A                                

16 rows fetched.

SQL> explain select * from t_push_1 t1 join v_push_1 v1 on t1.b=v1.b join v_push_2 v2 on t1.a=v2.a and v1.a=v2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |              |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 6   |     TABLE ACCESS FULL              | SYS   | T_PUSH_1     |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T_PUSH_1.A AND T_PUSH_2.A = T_PUSH_1.A AND T1.B = T_PUSH_1.B
   5 - access: T1.A = T_PUSH_2.A                                

15 rows fetched.

SQL> explain select * from t_push_1 t1 join v_push_2 v2 on t1.a=v2.a join v_push_4 v4 on t1.a=v4.a and v2.a=v4.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |              |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | T_PUSH_1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_PUSH_2     |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_T_PUSH_2 |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID    | SYS   | T_PUSH_2     |      |      |       |        |
| 7   |       INDEX RANGE SCAN             | SYS   | IDX_T_PUSH_2 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.A = T_PUSH_2.A                                
   6 - filter: T1.A = T_PUSH_2.A                                
   7 - access: T_PUSH_2.A = T_PUSH_2.A                          

17 rows fetched.

SQL> 
SQL> EXPLAIN SELECT A.TABLE_NAME, A.COLUMN_NAME, B.TABLE_NAME, B.COLUMN_NAME
  2   FROM (SELECT TABLE_NAME, COLUMN_NAME
  3           FROM USER_PART_COL_STATISTICS
  4          WHERE TABLE_NAME = 'T_USER_PART_COL_STATISTICS_001') A,
  5        (SELECT TABLE_NAME, COLUMN_NAME
  6           FROM USER_PART_COL_STATISTICS
  7          WHERE TABLE_NAME = 't_stack_test_n2') B
  8  WHERE A.COLUMN_NAME = B.COLUMN_NAME
  9  ORDER BY A.TABLE_NAME, A.COLUMN_NAME, B.TABLE_NAME, B.COLUMN_NAME;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                             |       |                          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                        |       |                          |      |      |       |        |
| 2   |     HASH JOIN(L)                             |       |                          |      |      |       |        |
| 3   |       VIEW                                   | SYS   | USER_PART_COL_STATISTICS |      |      |       |        |
| 4   |         NESTED LOOPS OUTER                   |       |                          |      |      |       |        |
| 5   |           NESTED LOOPS                       |       |                          |      |      |       |        |
| 6   |             NESTED LOOPS                     |       |                          |      |      |       |        |
| 7   |               NESTED LOOPS                   |       |                          |      |      |       |        |
| 8   |                 TABLE ACCESS FULL            | SYS   | DV_ME M                  |      |      |       |        |
| 9   |                 TABLE ACCESS BY INDEX ROWID  | SYS   | SYS_TABLES T             |      |      |       |        |
| 10  |                   INDEX UNIQUE SCAN          | SYS   | IX_TABLE$001             |      |      |       |        |
| 11  |               TABLE ACCESS BY INDEX ROWID    | SYS   | SYS_TABLE_PARTS TP       |      |      |       |        |
| 12  |                 INDEX RANGE SCAN             | SYS   | IX_TABLEPART$001         |      |      |       |        |
| 13  |             TABLE ACCESS BY INDEX ROWID      | SYS   | SYS_COLUMNS C            |      |      |       |        |
| 14  |               INDEX RANGE SCAN               | SYS   | IX_COLUMN$001            |      |      |       |        |
| 15  |           TABLE ACCESS BY INDEX ROWID        | SYS   | SYS_HISTGRAM_ABSTR HH    |      |      |       |        |
| 16  |             INDEX RANGE SCAN                 | SYS   | IX_HIST_HEAD_003         |      |      |       |        |
| 17  |       VIEW                                   | SYS   | USER_PART_COL_STATISTICS |      |      |       |        |
| 18  |         NESTED LOOPS OUTER                   |       |                          |      |      |       |        |
| 19  |           NESTED LOOPS                       |       |                          |      |      |       |        |
| 20  |             NESTED LOOPS                     |       |                          |      |      |       |        |
| 21  |               NESTED LOOPS                   |       |                          |      |      |       |        |
| 22  |                 TABLE ACCESS FULL            | SYS   | DV_ME M                  |      |      |       |        |
| 23  |                 TABLE ACCESS BY INDEX ROWID  | SYS   | SYS_TABLES T             |      |      |       |        |
| 24  |                   INDEX UNIQUE SCAN          | SYS   | IX_TABLE$001             |      |      |       |        |
| 25  |               TABLE ACCESS BY INDEX ROWID    | SYS   | SYS_TABLE_PARTS TP       |      |      |       |        |
| 26  |                 INDEX RANGE SCAN             | SYS   | IX_TABLEPART$001         |      |      |       |        |
| 27  |             TABLE ACCESS BY INDEX ROWID      | SYS   | SYS_COLUMNS C            |      |      |       |        |
| 28  |               INDEX RANGE SCAN               | SYS   | IX_COLUMN$001            |      |      |       |        |
| 29  |           TABLE ACCESS BY INDEX ROWID        | SYS   | SYS_HISTGRAM_ABSTR HH    |      |      |       |        |
| 30  |             INDEX RANGE SCAN                 | SYS   | IX_HIST_HEAD_003         |      |      |       |        |
------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: USER_PART_COL_STATISTICS.NAME = USER_PART_COL_STATISTICS.NAME
   10 - access: T.USER# = M.USER_ID AND NAME = 'T_USER_PART_COL_STATISTICS_001'
   12 - access: T.USER# = TP.USER# AND T.ID = TP.TABLE#         
   14 - access: TP.USER# = C.USER# AND TP.TABLE# = C.TABLE#     
   16 - access: C.USER# = HH.USER# AND C.ID = HH.COL# AND C.TABLE# = HH.TAB# AND HH.SPARE1 = TP.PART#
   24 - access: T.USER# = M.USER_ID AND NAME = 't_stack_test_n2'
   26 - access: T.USER# = TP.USER# AND T.ID = TP.TABLE#         
   28 - access: TP.USER# = C.USER# AND TP.TABLE# = C.TABLE#     
   30 - access: C.USER# = HH.USER# AND C.ID = HH.COL# AND C.TABLE# = HH.TAB# AND HH.SPARE1 = TP.PART#

46 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS "F_TNN000061_RNCUNCELL_H" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "F_TNN000061_RNCUNCELL_H"
  2 (
  3   "STARTTIME" DATE NOT NULL,
  4   "NEID" NUMBER(19) NOT NULL,
  5   "MONTH" NUMBER(3) NOT NULL,
  6   "DAY" NUMBER(3) NOT NULL,
  7   "HOUR" NUMBER(3) NOT NULL,
  8   "DSTOFFSET" NUMBER(5),
  9   "RNCUNCELLID" NUMBER(19) NOT NULL,
 10   "PERIOD" NUMBER(10),
 11   "RESULTNO" NUMBER(10) NOT NULL,
 12   "DELETEFLAG" NUMBER(10),
 13   "SUBDELETEFLAG" NUMBER(10),
 14   "PREINTEGRITY" NUMBER(10),
 15   "INTEGRITY" NUMBER(10),
 16   "C73393995" NUMBER(25, 5),
 17   "C73394011" NUMBER(25, 5),
 18   "C73394010" NUMBER(25, 5),
 19   "C73394009" NUMBER(25, 5),
 20   "C73394008" NUMBER(25, 5),
 21   "C73394007" NUMBER(25, 5),
 22   "C73394006" NUMBER(25, 5),
 23   "C73394005" NUMBER(25, 5),
 24   "C73394003" NUMBER(25, 5),
 25   "C73394002" NUMBER(25, 5),
 26   "C73394001" NUMBER(25, 5),
 27   "C73394000" NUMBER(25, 5),
 28   "C73393999" NUMBER(25, 5),
 29   "C73393998" NUMBER(25, 5),
 30   "C67183491" NUMBER(25, 5),
 31   "C73393994" NUMBER(25, 5),
 32   "C73393993" NUMBER(25, 5),
 33   "C73393992" NUMBER(25, 5),
 34   "C73393991" NUMBER(25, 5),
 35   "C73393990" NUMBER(25, 5),
 36   "C73393989" NUMBER(25, 5),
 37   "C73393988" NUMBER(25, 5),
 38   "C67189911" NUMBER(25, 5),
 39   "C67189910" NUMBER(25, 5),
 40   "C67189909" NUMBER(25, 5),
 41   "C67183494" NUMBER(25, 5),
 42   "C67183493" NUMBER(25, 5),
 43   "C67183492" NUMBER(25, 5),
 44   "C73394004" NUMBER(25, 5),
 45   "C73394033" NUMBER(25, 5),
 46   "C73394032" NUMBER(25, 5),
 47   "C73394031" NUMBER(25, 5),
 48   "C73394030" NUMBER(25, 5),
 49   "C73394029" NUMBER(25, 5),
 50   "C73394028" NUMBER(25, 5),
 51   "C73394027" NUMBER(25, 5),
 52   "C73394026" NUMBER(25, 5),
 53   "C67183489" NUMBER(25, 5),
 54   "C73393997" NUMBER(25, 5),
 55   "C73393996" NUMBER(25, 5),
 56   "C67190711" NUMBER(25, 5),
 57   "C67190710" NUMBER(25, 5),
 58   "C67190709" NUMBER(25, 5),
 59   "C67190708" NUMBER(25, 5),
 60   "C67189912" NUMBER(25, 5),
 61   "C67183490" NUMBER(25, 5)
 62 )
 63 PARTITION BY RANGE ("STARTTIME")
 64 (
 65     PARTITION PRS_PART_19000101 VALUES LESS THAN (to_date('19000101', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 66     PARTITION PRS_PART_20190501 VALUES LESS THAN (to_date('20190501', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 67     PARTITION PRS_PART_20190502 VALUES LESS THAN (to_date('20190502', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 68     PARTITION PRS_PART_20190503 VALUES LESS THAN (to_date('20190503', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 69     PARTITION PRS_PART_20190504 VALUES LESS THAN (to_date('20190504', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 70     PARTITION PRS_PART_20190505 VALUES LESS THAN (to_date('20190505', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8,
 71     PARTITION PRS_PART_20190506 VALUES LESS THAN (to_date('20190506', 'YYYYMMDD'))  INITRANS 2 PCTFREE 8
 72 )
 73 INITRANS 2
 74 MAXTRANS 255
 75 PCTFREE 8;

Succeed.

SQL> 
SQL> CREATE UNIQUE INDEX "I_TNN000061_RNCUNCELL_H" ON "F_TNN000061_RNCUNCELL_H"("STARTTIME", "HOUR", "RNCUNCELLID", "DSTOFFSET")
  2 LOCAL
  3 INITRANS 2
  4 PCTFREE 8;

Succeed.

SQL> 
SQL> CREATE INDEX "II_TNN000061_RNCUNCELL_H" ON "F_TNN000061_RNCUNCELL_H"("STARTTIME", "RNCUNCELLID")
  2 LOCAL
  3 INITRANS 2
  4 PCTFREE 8;

Succeed.

SQL> 
SQL> CREATE INDEX "III_TNN000061_RNCUNCELL_H" ON "F_TNN000061_RNCUNCELL_H"("STARTTIME", "RESULTNO")
  2 LOCAL
  3 INITRANS 2
  4 PCTFREE 8;

Succeed.

SQL> 
SQL> CREATE INDEX "NE_TNN000061_RNCUNCELL_H" ON "F_TNN000061_RNCUNCELL_H"("NEID", "HOUR")
  2 LOCAL
  3 INITRANS 2
  4 PCTFREE 8;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "M_INOBJINDEX_2_01_00002" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "M_INOBJINDEX_2_01_00002"
  2 (
  3   "OBJECTID" NUMBER(19) NOT NULL
  4 )NOLOGGING
  5 TABLESPACE "TEMP2"
  6 INITRANS 2
  7 MAXTRANS 255
  8 PCTFREE 8;

CT-00130, Operation create nologging table is not supported on cluster mode

SQL> 
SQL> CREATE UNIQUE INDEX "I0_INOBJINDEX_2_01_00002" ON "M_INOBJINDEX_2_01_00002"("OBJECTID")
  2 INITRANS 2
  3 PCTFREE 8;

CT-00843, The table or view SYS.M_INOBJINDEX_2_01_00002 does not exist.

SQL> 
SQL> explain delete from f_TNN000061_RNCUNCELL_H where StartTime = to_date('20190504000000', 'yyyymmddhh24miss') and Hour = 17 and exists (select 1 from m_inObjIndex_2_01_00002 where RNCUNCELLId = m_inObjIndex_2_01_00002.ObjectId+0);

CT-00843, [1:149]The table or view SYS.M_INOBJINDEX_2_01_00002 does not exist.
SQL> 
SQL> drop table if exists RBO_BMSQL_CUSTOMER_1;

Succeed.

SQL> drop table if exists RBO_BMSQL_CUSTOMER_2;

Succeed.

SQL> create table RBO_BMSQL_CUSTOMER_1
  2 (
  3 C_W_ID                              BINARY_INTEGER NOT NULL, 
  4 C_D_ID                              BINARY_INTEGER NOT NULL, 
  5 C_ID                                BINARY_INTEGER NOT NULL, 
  6 C_DISCOUNT                          NUMBER(4, 4),
  7 C_CREDIT                            CHAR(2 BYTE),
  8 C_LAST                              VARCHAR(16 BYTE),
  9 C_FIRST                             VARCHAR(16 BYTE),
 10 C_CREDIT_LIM                        NUMBER(12, 2),
 11 C_BALANCE                           NUMBER(12, 2),
 12 C_YTD_PAYMENT                       NUMBER(12, 2),
 13 C_PAYMENT_CNT                       BINARY_INTEGER,
 14 C_DELIVERY_CNT                      BINARY_INTEGER,
 15 C_STREET_1                          VARCHAR(20 BYTE),
 16 C_STREET_2                          VARCHAR(20 BYTE),
 17 C_CITY                              VARCHAR(20 BYTE),
 18 C_STATE                             CHAR(2 BYTE),
 19 C_ZIP                               CHAR(9 BYTE),
 20 C_PHONE                             CHAR(16 BYTE),
 21 C_SINCE                             TIMESTAMP(6),
 22 C_MIDDLE                            CHAR(2 BYTE),
 23 C_DATA                              VARCHAR(500 BYTE)
 24 );

Succeed.

SQL> 
SQL> create index RBO_BMSQL_CUSTOMER_1_idx1 on  RBO_BMSQL_CUSTOMER_1 (c_w_id);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx2 on  RBO_BMSQL_CUSTOMER_1 (c_d_id);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx3 on  RBO_BMSQL_CUSTOMER_1 (c_id);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx4 on  RBO_BMSQL_CUSTOMER_1 (c_last);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx5 on  RBO_BMSQL_CUSTOMER_1 (c_first);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx6 on  RBO_BMSQL_CUSTOMER_1 (c_w_id,c_first);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx7 on  RBO_BMSQL_CUSTOMER_1 (c_w_id,c_d_id,c_first);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx8 on  RBO_BMSQL_CUSTOMER_1 (c_w_id, c_d_id, c_last, c_first);

Succeed.

SQL> create index RBO_BMSQL_CUSTOMER_1_idx9 on  RBO_BMSQL_CUSTOMER_1 (C_SINCE);

Succeed.

SQL> 
SQL> create table RBO_BMSQL_CUSTOMER_2 (
  2   c_w_id         integer        not null,
  3   c_d_id         integer        not null,
  4   c_id           integer        not null,
  5   c_discount     decimal(4,4),
  6   c_credit       char(2),
  7   c_last         varchar(16),
  8   c_first        varchar(16),
  9   c_credit_lim   decimal(12,2),
 10   c_balance      decimal(12,2),
 11   c_ytd_payment  decimal(12,2),
 12   c_payment_cnt  integer,
 13   c_delivery_cnt integer,
 14   c_street_1     varchar(20),
 15   c_street_2     varchar(20),
 16   c_city         varchar(20),
 17   c_state        char(2),
 18   c_zip          char(9),
 19   c_phone        char(16),
 20   c_since        timestamp,
 21   c_middle       char(2),
 22   c_data         varchar(500)
 23 );

Succeed.

SQL> 
SQL> create index rbo_bmsql_customer_2_idx1 on  RBO_BMSQL_CUSTOMER_2 (c_w_id, c_d_id, c_last, c_first);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx2 on  RBO_BMSQL_CUSTOMER_2 (c_w_id);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx3 on  RBO_BMSQL_CUSTOMER_2 (c_d_id);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx4 on  RBO_BMSQL_CUSTOMER_2 (c_id);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx5 on  RBO_BMSQL_CUSTOMER_2 (c_last);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx6 on  RBO_BMSQL_CUSTOMER_2 (c_first);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx7 on  RBO_BMSQL_CUSTOMER_2 (c_w_id,c_first);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx8 on  RBO_BMSQL_CUSTOMER_2 (c_w_id,c_d_id,c_first);

Succeed.

SQL> create index rbo_bmsql_customer_2_idx9 on  RBO_BMSQL_CUSTOMER_2 (C_SINCE);

Succeed.

SQL> 
SQL> explain select a.C_W_ID, a.C_LAST
  2   from RBO_BMSQL_CUSTOMER_1 a
  3   left join (select C_SINCE
  4                from rbo_bmsql_customer_2
  5               where c_first like 'w%'
  6               group by C_SINCE) b
  7     on a.C_SINCE = b.C_SINCE
  8  where a.C_W_ID > 80;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                           |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID      | SYS   | RBO_BMSQL_CUSTOMER_1 A    |      |      |       |        |
| 3   |       INDEX RANGE SCAN               | SYS   | RBO_BMSQL_CUSTOMER_1_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                        |       | B                         |      |      |       |        |
| 5   |       HASH GROUP BY                  |       |                           |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | RBO_BMSQL_CUSTOMER_2      |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | RBO_BMSQL_CUSTOMER_2_IDX6 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.C_SINCE = B.C_SINCE                            
   3 - access: A.C_W_ID > 80                                    
   7 - access: C_FIRST LIKE 'w%'                                

17 rows fetched.

SQL> 
SQL> drop table if exists RBO_BMSQL_CUSTOMER_1;

Succeed.

SQL> drop table if exists RBO_BMSQL_CUSTOMER_2;

Succeed.

SQL> 
SQL> drop table if exists rbo_t_join_base_001;

Succeed.

SQL> drop table if exists rbo_t_join_base_101;

Succeed.

SQL> drop table if exists rbo_t_join_base_102;

Succeed.

SQL> drop table if exists rbo_t_join_base_103;

Succeed.

SQL> drop table if exists rbo_t_join_base_104;

Succeed.

SQL> create table rbo_t_join_base_001(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp)
  5 PARTITION BY RANGE(id)
  6 (
  7 PARTITION id1 VALUES LESS than(10),
  8 PARTITION id2 VALUES LESS than(100),
  9 PARTITION id3 VALUES LESS than(1000),
 10 PARTITION id4 VALUES LESS than(MAXVALUE)
 11 );

Succeed.

SQL> create table rbo_t_join_base_101 as select * from rbo_t_join_base_001;

Succeed.

SQL> create table rbo_t_join_base_102 as select * from rbo_t_join_base_001;

Succeed.

SQL> create table rbo_t_join_base_103 as select * from rbo_t_join_base_001;

Succeed.

SQL> create table rbo_t_join_base_104 as select * from rbo_t_join_base_001;

Succeed.

SQL> explain plan for
  2 select count(*) from rbo_t_join_base_001 t1
  3 where exists (select reverse(t11.c_vchar||t1.c_vchar) from rbo_t_join_base_101 t11
  4 join rbo_t_join_base_102 t12 on t11.c_int=t12.c_int and t11.c_vchar=t12.c_vchar and t11.c_timestamp=t12.c_timestamp and t1.c_real=t12.c_real
  5 where t11.c_int=t1.c_int and t11.c_vchar=t1.c_vchar and t11.c_timestamp=t1.c_timestamp and t11.c_real=t1.c_real
  6 )
  7 and exists (select bitand(rownum,rownum) from rbo_t_join_base_101 t11
  8 join rbo_t_join_base_103 t13 on t11.c_number=t13.c_number and t11.c_clob is not null and t13.c_clob is not null
  9 where t11.c_int=t1.c_int and t11.c_vchar=t1.c_vchar and t11.c_timestamp=t1.c_timestamp and t11.c_real=t1.c_real
 10 )
 11 and exists (select upper(t1.rowid) from rbo_t_join_base_101 t11
 12 join rbo_t_join_base_104 t14 on t11.c_int=t14.c_int and t11.c_vchar=t14.c_vchar and t11.c_timestamp=t14.c_timestamp
 13 where t11.c_int=t1.c_int and t11.c_vchar=t1.c_vchar and t11.c_timestamp=t1.c_timestamp and t11.c_real=t1.c_real
 14 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |                         |      |      |       |        |
| 1   |   AGGR                                   |       |                         |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)                    |       |                         |      |      |       |        |
| 3   |       HASH JOIN SEMI(R)                  |       |                         |      |      |       |        |
| 4   |         HASH JOIN SEMI(L)                |       |                         |      |      |       |        |
| 5   |           SUBSELECT                      |       |                         |      |      |       |        |
| 6   |             HASH JOIN(L)                 |       |                         |      |      |       |        |
| 7   |               TABLE ACCESS FULL          | SYS   | RBO_T_JOIN_BASE_101 T11 |      |      |       |        |
| 8   |               TABLE ACCESS FULL          | SYS   | RBO_T_JOIN_BASE_102 T12 |      |      |       |        |
| 9   |           TABLE ACCESS FULL Filter:[0,4) | SYS   | RBO_T_JOIN_BASE_001 T1  |      |      |       |        |
| 10  |         SUBSELECT                        |       |                         |      |      |       |        |
| 11  |           ROWNUM COUNT                   |       |                         |      |      |       |        |
| 12  |             HASH JOIN(L)                 |       |                         |      |      |       |        |
| 13  |               TABLE ACCESS FULL          | SYS   | RBO_T_JOIN_BASE_101 T11 |      |      |       |        |
| 14  |               TABLE ACCESS FULL          | SYS   | RBO_T_JOIN_BASE_103 T13 |      |      |       |        |
| 15  |       SUBSELECT                          |       |                         |      |      |       |        |
| 16  |         HASH JOIN(L)                     |       |                         |      |      |       |        |
| 17  |           TABLE ACCESS FULL              | SYS   | RBO_T_JOIN_BASE_101 T11 |      |      |       |        |
| 18  |           TABLE ACCESS FULL              | SYS   | RBO_T_JOIN_BASE_104 T14 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.C_TIMESTAMP = T14.C_TIMESTAMP AND T1.C_VCHAR = T14.C_VCHAR AND T1.C_REAL = T11.C_REAL AND 
               T1.C_INT = T11.C_INT AND T1.C_VCHAR = T11.C_VCHAR AND T1.C_TIMESTAMP = T11.C_TIMESTAMP AND 
               T1.C_INT = T14.C_INT                             
   3 - access: T1.C_TIMESTAMP = T11.C_TIMESTAMP AND T1.C_REAL = T11.C_REAL AND T1.C_INT = T11.C_INT AND 
               T1.C_VCHAR = T11.C_VCHAR                         
   4 - access: T12.C_TIMESTAMP = T1.C_TIMESTAMP AND T12.C_VCHAR = T1.C_VCHAR AND T12.C_INT = T1.C_INT AND 
               T12.C_REAL = T1.C_REAL AND T11.C_VCHAR = T1.C_VCHAR AND T11.C_INT = T1.C_INT AND T11.C_REAL = T1.C_REAL AND 
               T11.C_TIMESTAMP = T1.C_TIMESTAMP                 
   6 - access: T11.C_REAL = T12.C_REAL AND T11.C_TIMESTAMP = T12.C_TIMESTAMP AND T11.C_VCHAR = T12.C_VCHAR AND 
               T11.C_INT = T12.C_INT                            
   12 - access: T11.C_NUMBER = T13.C_NUMBER                     
   13 - filter: T11.C_CLOB IS NOT NULL                          
   14 - filter: T13.C_CLOB IS NOT NULL                          
   16 - access: T11.C_TIMESTAMP = T14.C_TIMESTAMP AND T11.C_VCHAR = T14.C_VCHAR AND T11.C_INT = T14.C_INT

39 rows fetched.

SQL> drop table if exists rbo_t_join_base_001;

Succeed.

SQL> drop table if exists rbo_t_join_base_101;

Succeed.

SQL> drop table if exists rbo_t_join_base_102;

Succeed.

SQL> drop table if exists rbo_t_join_base_103;

Succeed.

SQL> drop table if exists rbo_t_join_base_104;

Succeed.

SQL> 
SQL> drop table if exists rbo_test_in;

Succeed.

SQL> create table rbo_test_in(a int, b int, c int);

Succeed.

SQL> create index idx_rbo_test_in on rbo_test_in(a,b);

Succeed.

SQL> explain select * from rbo_test_in where a in (10) order by b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | RBO_TEST_IN     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_RBO_TEST_IN |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A = 10                                           

10 rows fetched.

SQL> drop table if exists rbo_test_in;

Succeed.

SQL> 
SQL> 
SQL> drop table if exists test_or_index;

Succeed.

SQL> create table test_or_index(a int, b int, c int, d int, e int);

Succeed.

SQL> create index idx_test_or_index_1 on test_or_index(b,a);

Succeed.

SQL> create index idx_test_or_index_2 on test_or_index(c,a);

Succeed.

SQL> create index idx_test_or_index_3 on test_or_index(d);

Succeed.

SQL> create index idx_test_or_index_4 on test_or_index(e);

Succeed.

SQL> explain select * from test_or_index where (b=10 or c = 100) and (d = 66 or a = 88);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                     |      |      |       |        |
| 1   |   CONCATENATION                  |       |                     |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = 10 OR C = 100 AND D = 66 OR A = 88           
   3 - access: B = 10                                           
   4 - filter: B = 10 OR C = 100 AND D = 66 OR A = 88           
   5 - access: C = 100                                          

16 rows fetched.

SQL> explain select * from test_or_index where (b=10 or c = 100) and (d = 66 or e = 88);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                     |      |      |       |        |
| 1   |   CONCATENATION                  |       |                     |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_3 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_4 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = 10 OR C = 100 AND D = 66 OR E = 88           
   3 - access: D = 66                                           
   4 - filter: B = 10 OR C = 100 AND D = 66 OR E = 88           
   5 - access: E = 88                                           

16 rows fetched.

SQL> explain select * from test_or_index where a=10 and (b=10 or c = 100) and (d = 66 or e = 88);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                     |      |      |       |        |
| 1   |   CONCATENATION                  |       |                     |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_OR_INDEX       |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_OR_INDEX_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: D = 66 OR E = 88 AND B = 10 OR C = 100           
   3 - access: A = 10 AND B = 10                                
   4 - filter: D = 66 OR E = 88 AND B = 10 OR C = 100           
   5 - access: A = 10 AND C = 100                               

16 rows fetched.

SQL> drop table if exists test_or_index;

Succeed.

SQL> 
SQL> --DTS2019112216305
SQL> drop table if exists CM_SUBS_ORDER;

Succeed.

SQL> create table CM_SUBS_ORDER
  2 (
  3   oid                  NUMBER(20) not null,
  4   ordernumber          VARCHAR2(32),
  5   type                 CHAR(2),
  6   status               CHAR(1),
  7   start_time           VARCHAR2(14),
  8   end_time             VARCHAR2(14),
  9   corp_id              VARCHAR2(20),
 10   device_groupid       NUMBER(10),
 11   creator              VARCHAR2(32),
 12   create_time          DATE default sysdate,
 13   order_type           CHAR(2) default '01',
 14   job_id               VARCHAR2(32),
 15   file_name            VARCHAR2(256),
 16   job_msg              VARCHAR2(256),
 17   job_status           VARCHAR2(10),
 18   result_file_pathname VARCHAR2(256)
 19 )
 20 partition by range (CREATE_TIME) interval (NUMTOYMINTERVAL(1,'MONTH'))
 21 (
 22   partition ORDER_CREATE_TIME_01 values less than (TO_DATE('2019-05-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS'))
 23 );

Succeed.

SQL> create index IDX_CRT_TIME_ORDER on CM_SUBS_ORDER (CREATOR,TYPE,CREATE_TIME) local; 

Succeed.

SQL> explain select o.oid,
  2          o.ORDERNUMBER,
  3          o.corp_id,
  4          o.status,
  5          o.start_time,
  6          o.end_time,
  7          o.type,
  8          o.create_time,
  9          o.creator,
 10          o.order_type,
 11          o.file_name
 12     from cm_subs_order o
 13    WHERE o.create_time >=
 14          to_date('2019-09-21 00:00:00', 'yyyy-MM-dd hh24:mi:ss')
 15      and o.create_time <=
 16          to_date('2019-09-30 00:00:00', 'yyyy-MM-dd hh24:mi:ss')
 17      and o.CREATOR = 'iot189'
 18      and o.TYPE = '27'
 19    order by  o.create_time limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                    |      |      |       |        |
| 1   |   QUERY LIMIT                              |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID Filter:N/A | SYS   | CM_SUBS_ORDER O    |      |      |       |        |
| 3   |       INDEX RANGE SCAN                     | SYS   | IDX_CRT_TIME_ORDER |      |      |       |        |
----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: O.CREATOR = 'iot189' AND O.TYPE = '27' AND O.CREATE_TIME >= to_date('2019-09-21 00:00:00', 'YYYY-MM-DD HH24:MI:SS') AND 
               O.CREATE_TIME <= to_date('2019-09-30 00:00:00', 'YYYY-MM-DD HH24:MI:SS')

12 rows fetched.

SQL> drop table if exists CM_SUBS_ORDER;

Succeed.

SQL> 
SQL> --20210709
SQL> drop table if exists part_test;

Succeed.

SQL> create table part_test (a int, b int, c int, d int)
  2 partition by range (a, b)
  3 (
  4 partition p1 values less than (5, 5),
  5 partition p2 values less than (10, 10),
  6 partition p3 values less than (15, 15),
  7 partition p4 values less than (20, 20),
  8 partition p5 values less than (25, 25),
  9 partition p6 values less than (30, 30),
 10 partition p7 values less than(MAXVALUE, MAXVALUE)
 11 );

Succeed.

SQL> create index part_test_index_abc on part_test(a,b,c);

Succeed.

SQL> explain select * from part_test order by a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                     |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,7) | SYS   | PART_TEST           |      |      |       |        |
| 2   |     INDEX FULL SCAN                        | SYS   | PART_TEST_INDEX_ABC |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> drop table if exists part_test;

Succeed.

SQL> 
SQL> --20200218
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> drop table if exists t_join_base_102;

Succeed.

SQL> drop table if exists t_join_base_201;

Succeed.

SQL> create table t_join_base_001(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);  

Succeed.

SQL> create table t_join_base_101(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);    

Succeed.

SQL> create table t_join_base_102(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);

Succeed.

SQL> create table t_join_base_201(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date);   

Succeed.

SQL> create index idx_join_base_001_1 on t_join_base_001(c_int);

Succeed.

SQL> create index idx_join_base_101_3 on t_join_base_101(c_int,c_vchar,c_date);

Succeed.

SQL> create index idx_join_base_102_1 on t_join_base_102(c_int);

Succeed.

SQL> create index idx_join_base_201_1 on t_join_base_201(c_int);

Succeed.

SQL> insert into t_join_base_001 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_101 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_102 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> commit;

Succeed.

SQL> select count(*) from t_join_base_001 t1, (t_join_base_101 t2 left join (t_join_base_201 t3 left join (t_join_base_201 t4 left join (t_join_base_102 t5 left join t_join_base_102 t6 on t5.c_int>t6.c_int) on t4.c_int>t5.c_int) on t3.c_int>t4.c_int) on t2.c_date>t4.c_date) where abs(t4.id) = -1;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> drop table t_join_base_001;

Succeed.

SQL> drop table t_join_base_101;

Succeed.

SQL> drop table t_join_base_102;

Succeed.

SQL> drop table t_join_base_201;

Succeed.

SQL> 
SQL> -- DTS202009090LORNGP1I00
SQL> drop table if exists hash_anti_eof_t1;

Succeed.

SQL> drop table if exists hash_anti_eof_t2;

Succeed.

SQL> drop table if exists hash_anti_eof_t3;

Succeed.

SQL> drop table if exists hash_anti_eof_t4;

Succeed.

SQL> create table hash_anti_eof_t1
  2 (
  3     id number(8) not null,
  4     c_int number(8),
  5     c_bigint number(15)
  6 );

Succeed.

SQL> insert into hash_anti_eof_t1 values(1, 1, 100);

1 rows affected.

SQL> insert into hash_anti_eof_t1 values(2, 1, 200);

1 rows affected.

SQL> insert into hash_anti_eof_t1 values(3, 1, 300);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table hash_anti_eof_t2
  2 (
  3     id number(8) not null,
  4     c_int number(8)
  5 );

Succeed.

SQL> insert into hash_anti_eof_t2 values(1, 1);

1 rows affected.

SQL> insert into hash_anti_eof_t2 values(2, 1);

1 rows affected.

SQL> insert into hash_anti_eof_t2 values(3, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table hash_anti_eof_t3
  2 (
  3   id varchar(10) not null,
  4   c_str varchar(35)
  5 );

Succeed.

SQL> 
SQL> create table hash_anti_eof_t4
  2 (
  3   emp_no number(8) not null,
  4   salary number(8) not null
  5 );

Succeed.

SQL> 
SQL> explain 
  2 SELECT
  3     ref_1.c_str AS C0,
  4     ref_0.c_bigint AS C1
  5 FROM
  6     (hash_anti_eof_t1 ref_0)
  7         INNER JOIN (((hash_anti_eof_t3 ref_1)
  8             INNER JOIN (((hash_anti_eof_t2 ref_2)
  9                 INNER JOIN (hash_anti_eof_t4 ref_3)
 10                 ON (NOT EXISTS (
 11                         SELECT DISTINCT
 12                             ref_3.emp_no AS C0,
 13                             ref_3.salary AS C3
 14                         FROM
 15                             hash_anti_eof_t1 ref_4
 16                         WHERE ref_4.c_int < ref_4.c_int)))
 17             CROSS JOIN (hash_anti_eof_t1 ref_5))
 18             ON ref_5.id is null))
 19         ON (ref_5.c_bigint IS NOT NULL)
 20 WHERE ref_0.c_int >= ref_5.c_int;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   NESTED LOOPS                 |       |                        |      |      |       |        |
| 2   |     NESTED LOOPS               |       |                        |      |      |       |        |
| 3   |       NESTED LOOPS             |       |                        |      |      |       |        |
| 4   |         HASH JOIN ANTI(R)      |       |                        |      |      |       |        |
| 5   |           MERGE JOIN           |       |                        |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | HASH_ANTI_EOF_T1 REF_0 |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | HASH_ANTI_EOF_T1 REF_5 |      |      |       |        |
| 8   |           SUBSELECT            |       |                        |      |      |       |        |
| 9   |             TABLE ACCESS FULL  | SYS   | HASH_ANTI_EOF_T1 REF_4 |      |      |       |        |
| 10  |         TABLE ACCESS FULL      | SYS   | HASH_ANTI_EOF_T3 REF_1 |      |      |       |        |
| 11  |       TABLE ACCESS FULL        | SYS   | HASH_ANTI_EOF_T2 REF_2 |      |      |       |        |
| 12  |     TABLE ACCESS FULL          | SYS   | HASH_ANTI_EOF_T4 REF_3 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: NA = NA                                          
   5 - access: REF_0.C_INT >= REF_5.C_INT                       
   7 - filter: REF_5.ID IS NULL AND REF_5.C_BIGINT IS NOT NULL  
   9 - filter: REF_4.C_INT < REF_4.C_INT                        

23 rows fetched.

SQL> 
SQL> SELECT
  2     ref_1.c_str AS C0,
  3     ref_0.c_bigint AS C1
  4 FROM
  5     (hash_anti_eof_t1 ref_0)
  6         INNER JOIN (((hash_anti_eof_t3 ref_1)
  7             INNER JOIN (((hash_anti_eof_t2 ref_2)
  8                 INNER JOIN (hash_anti_eof_t4 ref_3)
  9                 ON (NOT EXISTS (
 10                         SELECT DISTINCT
 11                             ref_3.emp_no AS C0,
 12                             ref_3.salary AS C3
 13                         FROM
 14                             hash_anti_eof_t1 ref_4
 15                         WHERE ref_4.c_int < ref_4.c_int)))
 16             CROSS JOIN (hash_anti_eof_t1 ref_5))
 17             ON ref_5.id is null))
 18         ON (ref_5.c_bigint IS NOT NULL)
 19 WHERE ref_0.c_int >= ref_5.c_int;

C0                                  C1                                      
----------------------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> drop table hash_anti_eof_t1;

Succeed.

SQL> drop table hash_anti_eof_t2;

Succeed.

SQL> drop table hash_anti_eof_t3;

Succeed.

SQL> drop table hash_anti_eof_t4;

Succeed.

SQL> 
SQL> -- 
SQL> drop table if exists scan_mode_reset_t0;

Succeed.

SQL> drop table if exists scan_mode_reset_t1;

Succeed.

SQL> drop table if exists scan_mode_reset_t2;

Succeed.

SQL> 
SQL> create table scan_mode_reset_t0(id number(8), c_int number(8), name varchar(30));

Succeed.

SQL> create table scan_mode_reset_t1(name varchar(30), type char(6));

Succeed.

SQL> create table scan_mode_reset_t2(id number(8), type char(5)) partition by range(id) interval(1)(partition p_0 values less than (1));

Succeed.

SQL> 
SQL> insert into scan_mode_reset_t0 values(1, 10, 'test1');

1 rows affected.

SQL> insert into scan_mode_reset_t0 values(2, 20, 'test2');

1 rows affected.

SQL> insert into scan_mode_reset_t0 values(3, 30, 'test3');

1 rows affected.

SQL> insert into scan_mode_reset_t1 values('view1', 'normal');

1 rows affected.

SQL> insert into scan_mode_reset_t1 values('view2', 'normal');

1 rows affected.

SQL> insert into scan_mode_reset_t1 values('view3', 'normal');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select  
  2   ref_5.name as c0, 
  3   ref_2.type as c2
  4 from 
  5   ((scan_mode_reset_t0 as ref_0)
  6       full join ((scan_mode_reset_t1 as ref_1)
  7         inner join (scan_mode_reset_t2 as ref_2)
  8         on (ref_1.type = ref_1.name))
  9       on (true))
 10     cross join (scan_mode_reset_t0 as ref_5)
 11 where ref_0.c_int > ref_5.id;

C0                             C2   
------------------------------ -----
test1                               
test2                               
test3                               
test1                               
test2                               
test3                               
test1                               
test2                               
test3                               

9 rows fetched.

SQL> 
SQL> explain plan for
  2 select  
  3   ref_5.name as c0, 
  4   ref_2.type as c2
  5 from 
  6   ((scan_mode_reset_t0 as ref_0)
  7       full join ((scan_mode_reset_t1 as ref_1)
  8         inner join (scan_mode_reset_t2 as ref_2)
  9         on (ref_1.type = ref_1.name))
 10       on (true))
 11     cross join (scan_mode_reset_t0 as ref_5)
 12 where ref_0.c_int > ref_5.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name                     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                          |      |      |       |        |
| 1   |   MERGE JOIN                           |       |                          |      |      |       |        |
| 2   |     NESTED LOOPS OUTER                 |       |                          |      |      |       |        |
| 3   |       TABLE ACCESS FULL                | SYS   | SCAN_MODE_RESET_T0 REF_0 |      |      |       |        |
| 4   |       NESTED LOOPS                     |       |                          |      |      |       |        |
| 5   |         TABLE ACCESS FULL              | SYS   | SCAN_MODE_RESET_T1 REF_1 |      |      |       |        |
| 6   |         TABLE ACCESS FULL Filter:[0,1) | SYS   | SCAN_MODE_RESET_T2 REF_2 |      |      |       |        |
| 7   |     TABLE ACCESS FULL                  | SYS   | SCAN_MODE_RESET_T0 REF_5 |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: REF_0.C_INT > REF_5.ID                           
   5 - filter: REF_1.TYPE = REF_1.NAME                          

16 rows fetched.

SQL> 
SQL> drop table scan_mode_reset_t0;

Succeed.

SQL> drop table scan_mode_reset_t1;

Succeed.

SQL> drop table scan_mode_reset_t2;

Succeed.

SQL> 
SQL> create table scan_mode_reset_t0(id int, c_int bigint, c_text varchar(30), c_date date, c_timestamp timestamp, c_bool boolean);

Succeed.

SQL> create index idx_scan_mode_int on scan_mode_reset_t0(id);

Succeed.

SQL> create index idx_scan_mode_bigint on scan_mode_reset_t0(c_int);

Succeed.

SQL> create index idx_scan_mode_string on scan_mode_reset_t0(c_text);

Succeed.

SQL> create index idx_scan_mode_date on scan_mode_reset_t0(c_date);

Succeed.

SQL> create index idx_scan_mode_timestmp on scan_mode_reset_t0(c_timestamp);

Succeed.

SQL> create index idx_scan_mode_bool on scan_mode_reset_t0(c_bool);

Succeed.

SQL> 
SQL> create table scan_mode_reset_t1(id int, c_int bigint, c_text varchar(30), c_date date, c_timestamp timestamp, c_clob clob, c_raw raw(10), c_bool boolean);

Succeed.

SQL> --int
SQL> explain select * from scan_mode_reset_t0 where id=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 1                                           

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id=1111111111111111111111111111111;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 1111111111111111111111111111111             

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id=:p1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = ?                                           

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id is null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID IS NULL                                       

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 1                                           

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id=1.1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 1.1                                         

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where id=true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_INT  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = TRUE                                        

10 rows fetched.

SQL> --bigint
SQL> explain select * from scan_mode_reset_t0 where c_int=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = 1                                        

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int=1111111111111111111111111111111;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = 1111111111111111111111111111111          

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int=:p1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = ?                                        

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int is null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT IS NULL                                    

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = 1                                        

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int=1.1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = 1.1                                      

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_int=true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BIGINT |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = TRUE                                     

10 rows fetched.

SQL> --string
SQL> explain select * from scan_mode_reset_t0 where c_text=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = 1                                       

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=1111111111111111111111111111111;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = 1111111111111111111111111111111         

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=:p1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_STRING |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TEXT = ?                                       

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text is null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_STRING |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TEXT IS NULL                                   

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0   |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_STRING |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TEXT = '1'                                     

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=1.1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = 1.1                                     

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text='111'::binary(4);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = '31313100'                              

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text='111'::raw(4);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = '0111'                                  

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=sysdate;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = SYSDATE                                 

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = TRUE                                    

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=interval '21-2' year to month;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = '+21-02'                                

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_text=interval '2 3:04:11.333' day to second(3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_TEXT = '+02 03:04:11.333000'                   

9 rows fetched.

SQL> --date/timestamp
SQL> explain select * from scan_mode_reset_t0 where c_date='2020-11-11 11:22:33';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_DATE |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_DATE = CAST('2020-11-11 11:22:33' AS DATE)     

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_date=sysdate;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_DATE |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_DATE = SYSDATE                                 

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_date=systimestamp;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_DATE |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_DATE = SYSTIMESTAMP                            

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_timestamp='2020-11-11 11:22:33';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TIMESTAMP = CAST('2020-11-11 11:22:33' AS TIMESTAMP(6))

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_timestamp=sysdate;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TIMESTAMP = SYSDATE                            

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_timestamp=systimestamp;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_TIMESTAMP = SYSTIMESTAMP                       

10 rows fetched.

SQL> --bool
SQL> explain select * from scan_mode_reset_t0 where c_bool=0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = FALSE                                   

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = TRUE                                    

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_BOOL = 2                                       

9 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool=1111111111111111111111111111111;

CT-00606, [1:55]Inconsistent datatypes, expected BOOLEAN - got NUMBER
SQL> explain select * from scan_mode_reset_t0 where c_bool=:p1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = ?                                       

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool is null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL IS NULL                                   

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool='1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = TRUE                                    

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool='true';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = TRUE                                    

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool='false';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = FALSE                                   

10 rows fetched.

SQL> explain select * from scan_mode_reset_t0 where c_bool='yes';

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> explain select * from scan_mode_reset_t0 where c_bool='no';

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> explain select * from scan_mode_reset_t0 where c_bool=1.1;

CT-00606, [1:55]Inconsistent datatypes, expected BOOLEAN - got NUMBER
SQL> explain select * from scan_mode_reset_t0 where c_bool=true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SCAN_MODE_RESET_T0 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_SCAN_MODE_BOOL |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_BOOL = TRUE                                    

10 rows fetched.

SQL> 
SQL> --join/exists
SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.id=t1.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.ID = T1.ID                                    

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.id=t1.c_int;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.ID = T1.C_INT                                 

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.id=t1.c_text;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.ID = T1.C_TEXT                                

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.id=t1.c_date;

CT-00606, [1:87]Inconsistent datatypes, expected BINARY_INTEGER - got DATE
SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.ID                                

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_int;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_INT                             

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_text;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_TEXT = T1.C_TEXT                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_date;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_DATE                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_timestamp;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_TIMESTAMP                       

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_clob;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_CLOB                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_raw;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_RAW                             

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_text=t1.c_bool;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.C_TEXT = T1.C_BOOL                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_date=t1.c_date;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_DATE = T1.C_DATE                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_date=t1.c_timestamp;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_DATE = T1.C_TIMESTAMP                       

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_date=t1.c_text;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   AGGR                            |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0 |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_DATE = T1.C_TEXT                            

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_timestamp=t1.c_date;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                   | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                        |      |      |       |        |
| 1   |   AGGR                            |       |                        |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                        |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_TIMESTAMP = T1.C_DATE                       

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_timestamp=t1.c_timestamp;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                   | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                        |      |      |       |        |
| 1   |   AGGR                            |       |                        |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                        |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_TIMESTAMP = T1.C_TIMESTAMP                  

13 rows fetched.

SQL> explain select count(1) from scan_mode_reset_t0 t0, scan_mode_reset_t1 t1 where t0.c_timestamp=t1.c_text;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                   | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                        |      |      |       |        |
| 1   |   AGGR                            |       |                        |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                        |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0 T0  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T0.C_TIMESTAMP = T1.C_TEXT                       

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.id);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.ID                                   

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_int);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.C_INT                                

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_text);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0)         
   4 - access: C_TEXT = T1.C_TEXT                               

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_clob);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.C_CLOB                               

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_date);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.C_DATE                               

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_timestamp);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.C_TIMESTAMP                          

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_text=t1.c_raw);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)               |       |                       |      |      |       |        |
| 2   |     SUBSELECT                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | IDX_SCAN_MODE_STRING  |      |      |       |        |
| 5   |     TABLE ACCESS FULL             | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: C_TEXT = T1.C_RAW                                

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where id = t1.id);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0)         
   4 - access: ID = T1.ID                                       

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where id = t1.c_int);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0 WHERE ID = T1.C_INT)
   4 - access: ID = T1.C_INT                                    

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where id = t1.c_text);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_INT     |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0 WHERE ID = T1.C_TEXT)
   4 - access: ID = T1.C_TEXT                                   

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_date = t1.c_date);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0)         
   4 - access: C_DATE = T1.C_DATE                               

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_date = t1.c_timestamp);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0 WHERE C_DATE = T1.C_TIMESTAMP)
   4 - access: C_DATE = T1.C_TIMESTAMP                          

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_date = t1.c_text);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0    |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_DATE    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0 WHERE C_DATE = T1.C_TEXT)
   4 - access: C_DATE = T1.C_TEXT                               

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_timestamp = t1.c_date);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                   | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                        |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                        |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0)         
   4 - access: C_TIMESTAMP = T1.C_DATE                          

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_timestamp = t1.c_timestamp);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                   | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                        |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                        |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0)         
   4 - access: C_TIMESTAMP = T1.C_TIMESTAMP                     

13 rows fetched.

SQL> explain select * from scan_mode_reset_t1 t1 where exists(select 1 from scan_mode_reset_t0 where c_timestamp = t1.c_text);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                   | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                        |      |      |       |        |
| 1   |   KERNEL FILTER                 |       |                        |      |      |       |        |
| 2   |     TABLE ACCESS FULL           | SYS   | SCAN_MODE_RESET_T1 T1  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SCAN_MODE_RESET_T0     |      |      |       |        |
| 4   |       INDEX RANGE SCAN          | SYS   | IDX_SCAN_MODE_TIMESTMP |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM SCAN_MODE_RESET_T0 WHERE C_TIMESTAMP = T1.C_TEXT)
   4 - access: C_TIMESTAMP = T1.C_TEXT                          

13 rows fetched.

SQL> drop table scan_mode_reset_t0;

Succeed.

SQL> drop table scan_mode_reset_t1;

Succeed.

SQL> 
SQL> --test bool
SQL> drop table if exists t_base_vchar;

Succeed.

SQL> CREATE TABLE t_base_vchar
  2 (c_vchar1 int not null,
  3  c_vchar2 boolean,
  4  c_vchar3 boolean,
  5  c_vchar4 boolean,
  6  c_vchar5 boolean,
  7  c_vchar6 boolean
  8 );

Succeed.

SQL> 
SQL> INSERT INTO t_base_vchar values (13,'0','0','0','0','0');

1 rows affected.

SQL> INSERT INTO t_base_vchar values (14,'1','1','1','1','1');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> create unique index idx_t_base_vchar_001 on t_base_vchar(c_vchar1);

Succeed.

SQL> CREATE INDEX idx_t_base_vchar_002 ON t_base_vchar(c_vchar2);

Succeed.

SQL> CREATE INDEX idx_t_base_vchar_003 ON t_base_vchar(NVL(c_vchar3,0));

Succeed.

SQL> CREATE INDEX idx_t_base_vchar_004 ON t_base_vchar(c_vchar4,c_vchar5);

Succeed.

SQL> 
SQL> select /*+ full(t_base_vchar) */c_vchar2,NVL(c_vchar3,0) from t_base_vchar where NVL(c_vchar3,0) >= -180::INTEGER and NVL(c_vchar3,0) <= 180::INTEGER order by 1,2;

C_VCHAR2 NVL(C_VCHAR3,0)
-------- ---------------
FALSE    FALSE          
TRUE     TRUE           

2 rows fetched.

SQL> explain select /*+ full(t_base_vchar) */c_vchar2,NVL(c_vchar3,0) from t_base_vchar where NVL(c_vchar3,0) >= -180::BIGINT and NVL(c_vchar3,0) <= 180::BIGINT order by 1,2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY  |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_BASE_VCHAR |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: NVL(C_VCHAR3, 0) >= -180 AND NVL(C_VCHAR3, 0) <= 180

10 rows fetched.

SQL> select c_vchar2,NVL(c_vchar3,0) from t_base_vchar where NVL(c_vchar3,0) >= -180::INTEGER and NVL(c_vchar3,0) <= 180::INTEGER order by 1,2;

C_VCHAR2 NVL(C_VCHAR3,0)
-------- ---------------
FALSE    FALSE          
TRUE     TRUE           

2 rows fetched.

SQL> select c_vchar2,NVL(c_vchar3,0) from t_base_vchar where NVL(c_vchar3,0) >= -180::BIGINT and NVL(c_vchar3,0) <= 180::BIGINT order by 1,2;

C_VCHAR2 NVL(C_VCHAR3,0)
-------- ---------------
FALSE    FALSE          
TRUE     TRUE           

2 rows fetched.

SQL> drop table t_base_vchar;

Succeed.

SQL> 


