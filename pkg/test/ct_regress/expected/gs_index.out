

SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> DROP TABLE IF EXISTS RENAME_IND_CON_13;

Succeed.

SQL> CREATE TABLE RENAME_IND_CON_13(c1 int, c2 varchar(32), c3 bigint);

Succeed.

SQL> INSERT INTO RENAME_IND_CON_13 VALUES(50, 'P1', 5000);

1 rows affected.

SQL> INSERT INTO RENAME_IND_CON_13 VALUES(150, 'P2', 15000);

1 rows affected.

SQL> INSERT INTO RENAME_IND_CON_13 VALUES(250, 'P3', 25000);

1 rows affected.

SQL> INSERT INTO RENAME_IND_CON_13 VALUES(350, 'P4', 35000);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE RENAME_IND_CON_13 ADD CONSTRAINT pk_RENAME_IND_CON_13_1 unique(c1);

Succeed.

SQL> ALTER TABLE RENAME_IND_CON_13 ADD CONSTRAINT pk_RENAME_IND_CON_13_2 check(c3>2500);

Succeed.

SQL> ALTER TABLE RENAME_IND_CON_13 rename constraint pk_RENAME_IND_CON_13_4 to pk_RENAME_IND_CON_13_3;

CT-00811, The constraint PK_RENAME_IND_CON_13_4 does not exist.
SQL> DROP TABLE IF EXISTS RENAME_IND_CON_13;

Succeed.

SQL> create table caot3(id1 int ,id2 int);

Succeed.

SQL> create index ittt1 on caot3(id1);

Succeed.

SQL> create index ittt2 on caot3(id2);

Succeed.

SQL> alter index ittt2 on caot3 rename to cao1.ittt1;

CT-00601, Sql syntax error: SYS expected 
SQL> select index_name  from all_indexes where index_name like '%ITTT%';

INDEX_NAME                                                      
----------------------------------------------------------------
ITTT1                                                           
ITTT2                                                           

2 rows fetched.

SQL> alter index ittt2 on caot3 rename to sys.ittt1;

CT-00753, The object index ITTT1 already exists.
SQL> select index_name  from all_indexes where index_name like '%ITTT%';

INDEX_NAME                                                      
----------------------------------------------------------------
ITTT1                                                           
ITTT2                                                           

2 rows fetched.

SQL> alter index ittt2 on caot3 rename to sys.ittt3;

Succeed.

SQL> select index_name  from all_indexes where index_name like '%ITTT%';

INDEX_NAME                                                      
----------------------------------------------------------------
ITTT1                                                           
ITTT3                                                           

2 rows fetched.

SQL> drop table caot3;

Succeed.

SQL> drop table if exists base_008;

Succeed.

SQL> create table base_008 (id int,name char);

Succeed.

SQL> create index oldidx on base_008(name);

Succeed.

SQL> select  t.name TB , i.name IDX  from SYS_TABLES t ,SYS_INDEXES i  where i.table#=t.id and t.name = 'BASE_008';

TB                                                               IDX                                                             
---------------------------------------------------------------- ----------------------------------------------------------------
BASE_008                                                         OLDIDX                                                          

1 rows fetched.

SQL> alter index sys.oldidx on base_008 rename to newidx;

Succeed.

SQL> select  t.name TB , i.name IDX  from SYS_TABLES t ,SYS_INDEXES i  where i.table#=t.id and t.name = 'BASE_008';

TB                                                               IDX                                                             
---------------------------------------------------------------- ----------------------------------------------------------------
BASE_008                                                         NEWIDX                                                          

1 rows fetched.

SQL> alter index sys.newidx on base_008 rename to oldidx;

Succeed.

SQL> select  t.name TB , i.name IDX  from SYS_TABLES t ,SYS_INDEXES i  where i.table#=t.id and t.name = 'BASE_008';

TB                                                               IDX                                                             
---------------------------------------------------------------- ----------------------------------------------------------------
BASE_008                                                         OLDIDX                                                          

1 rows fetched.

SQL> drop table base_008;

Succeed.

SQL> --SELECT * FROM DBA_IND_COLUMNS;
SQL> --SELECT * FROM USER_IND_COLUMNS;
SQL> DROP TABLE IF EXISTS T_INDEX_1;

Succeed.

SQL> CREATE TABLE T_INDEX_1
  2 (
  3 	F_INT1 INT,
  4 	F_INT2 INT,
  5 	F_CHAR1 CHAR(20)
  6 );

Succeed.

SQL> 
SQL> CREATE INDEX INDEX_INT_T_INDEX_1 ON T_INDEX_1(F_INT1);

Succeed.

SQL> CREATE INDEX INDEX_CHAR_INDEX_1 ON T_INDEX_1(F_CHAR1);

Succeed.

SQL> 
SQL> INSERT INTO T_INDEX_1 VALUES(1,2,'0001Z01000ACCOUNT028');

1 rows affected.

SQL> INSERT INTO T_INDEX_1 VALUES(2,3,'0001Z01000ACCOUNT073');

1 rows affected.

SQL> INSERT INTO T_INDEX_1 VALUES(3,4,'10111110000000001ZX5');

1 rows affected.

SQL> INSERT INTO T_INDEX_1 VALUES(4,5,'101511100000000006NZ');

1 rows affected.

SQL> INSERT INTO T_INDEX_1 VALUES(null,6,'101511100000000006NX');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT * FROM T_INDEX_1 WHERE F_CHAR1 = '0001Z01000ACCOUNT028' or F_CHAR1 = '0001Z01000ACCOUNT073';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028
2            3            0001Z01000ACCOUNT073

2 rows fetched.

SQL> SELECT * FROM T_INDEX_1 WHERE F_CHAR1 = '10111110000000001ZX5' or F_CHAR1 = '101511100000000006NZ';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
3            4            10111110000000001ZX5
4            5            101511100000000006NZ

2 rows fetched.

SQL> 
SQL> SELECT * FROM T_INDEX_1 WHERE F_INT1 = 3 AND EXISTS (SELECT 1 FROM DUAL);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
3            4            10111110000000001ZX5

1 rows fetched.

SQL> SELECT * FROM T_INDEX_1 WHERE F_INT1 = 1 AND NOT EXISTS (SELECT 1 FROM DUAL);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------

0 rows fetched.

SQL> SELECT * FROM T_INDEX_1 WHERE F_INT1 = 1 AND NOT EXISTS (SELECT 1 FROM DUAL WHERE 1 = 0);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028

1 rows fetched.

SQL> 
SQL> SELECT * FROM T_INDEX_1 WHERE F_INT1 IS NULL AND F_INT1 IS NULL;

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
             6            101511100000000006NX

1 rows fetched.

SQL> 
SQL> CREATE USER NEBULA IDENTIFIED BY Cantian_234;

Succeed.

SQL> DROP TABLE IF EXISTS NEBULA.STORAGE_LIST_TBL_001;

Succeed.

SQL> CREATE TABLE NEBULA.STORAGE_LIST_TBL_001(C_ID INT,C_D_ID INT NOT NULL,C_W_ID INT NOT NULL,C_FIRST VARCHAR(64) NOT NULL,C_MIDDLE CHAR(2),C_LAST VARCHAR(64) NOT NULL,C_STREET_1 VARCHAR(20) NOT NULL,C_STREET_2 VARCHAR(20),C_CITY VARCHAR(64) NOT NULL,C_STATE CHAR(2) NOT NULL,C_ZIP CHAR(9) NOT NULL,C_PHONE CHAR(16) NOT NULL,C_SINCE TIMESTAMP,C_CREDIT CHAR(2) NOT NULL,C_CREDIT_LIM NUMERIC(12,2),C_DISCOUNT NUMERIC(4,4),C_BALANCE NUMERIC(12,2),C_YTD_PAYMENT REAL NOT NULL,C_PAYMENT_CNT NUMBER NOT NULL,C_DELIVERY_CNT BOOLEAN NOT NULL,C_END DATE NOT NULL,C_VCHAR VARCHAR(1000),C_DATA varchar(2000),C_TEXT varchar(2000)) PARTITION BY LIST(C_D_ID,C_FIRST,C_LAST,C_CITY) (PARTITION PART_1 VALUES ((1,'A','A','A'),(10,'AA','AA','AA'),(10,'AAAA','AAAA','AAAA'),(10,'aaaa','aaaa','aaaa'),(100,'AAAA','AAAA','AAAA'),(1,'a','a','a'),(10,'aa','aa','aa'),(100,'aaaa','aaaa','aaaa')),PARTITION PART_2 VALUES ((2,'B','B','B'),(20,'BB','BB','BB'),(20,'BBBB','BBBB','BBBB'),(20,'bbbb','bbbb','bbbb'),(200,'BBBB','BBBB','BBBB'),(2,'b','b','b'),(20,'bb','bb','bb'),(200,'bbbb','bbbb','bbbb')),PARTITION PART_3 VALUES ((3,'C','C','C'),(30,'CC','CC','CC'),(30,'CCCC','CCCC','CCCC'),(30,'cccc','cccc','cccc'),(300,'CCCC','CCCC','CCCC'),(3,'c','c','c'),(30,'cc','cc','cc'),(300,'cccc','cccc','cccc')),PARTITION PART_4 VALUES ((4,'D','D','D'),(40,'DD','DD','DD'),(40,'DDDD','DDDD','DDDD'),(40,'dddd','dddd','dddd'),(400,'DDDD','DDDD','DDDD'),(4,'d','d','d'),(40,'dd','dd','dd'),(400,'dddd','dddd','dddd')),PARTITION PART_5 VALUES ((5,'E','E','E'),(50,'EE','EE','EE'),(50,'EEEE','EEEE','EEEE'),(50,'eeee','eeee','eeee'),(500,'EEEE','EEEE','EEEE'),(5,'e','e','e'),(50,'ee','ee','ee'),(500,'eeee','eeee','eeee')),PARTITION PART_6 VALUES ((6,'F','F','F'),(60,'FF','FF','FF'),(60,'FFFF','FFFF','FFFF'),(60,'ffff','ffff','ffff'),(600,'FFFF','FFFF','FFFF'),(6,'f','f','f'),(60,'ff','ff','ff'),(600,'ffff','ffff','ffff')),PARTITION PART_7 VALUES ((7,'G','G','G'),(70,'GG','GG','GG'),(70,'GGGG','GGGG','GGGG'),(70,'gggg','gggg','gggg'),(700,'GGGG','GGGG','GGGG'),(7,'g','g','g'),(70,'gg','gg','gg'),(700,'gggg','gggg','gggg')),PARTITION PART_8 VALUES ((8,'H','H','H'),(80,'HH','HH','HH'),(80,'HHHH','HHHH','HHHH'),(80,'hhhh','hhhh','hhhh'),(800,'HHHH','HHHH','HHHH'),(8,'h','h','h'),(80,'hh','hh','hh'),(800,'hhhh','hhhh','hhhh')),PARTITION PART_9 VALUES ((9,'I','I','I'),(90,'II','II','II'),(90,'IIII','IIII','IIII'),(90,'iiii','iiii','iiii'),(900,'IIII','IIII','IIII'),(9,'i','i','i'),(90,'ii','ii','ii'),(900,'iiii','iiii','iiii')),PARTITION PART_10 VALUES (DEFAULT));

Succeed.

SQL> CREATE UNIQUE INDEX  NEBULA.STORAGE_LIST_INDEX_001_1 ON NEBULA.STORAGE_LIST_TBL_001(C_D_ID,C_FIRST,C_LAST,C_CITY,C_ID)  LOCAL ;

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA.STORAGE_LIST_INDEX_001_2 ON NEBULA.STORAGE_LIST_TBL_001(C_ID,C_CITY,C_LAST,C_STREET_2)  ;

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA.STORAGE_LIST_INDEX_001_3 ON NEBULA.STORAGE_LIST_TBL_001(C_STREET_2,C_ID)  ;

Succeed.

SQL> CREATE INDEX NEBULA.STORAGE_LIST_INDEX_001_5 ON NEBULA.STORAGE_LIST_TBL_001(C_STREET_1,C_W_ID)   ;

Succeed.

SQL> INSERT INTO NEBULA.STORAGE_LIST_TBL_001 VALUES(1,90,1,'II'||'9'||'Cabdg','OE','II'||'9'||'Bdbed','bki'||'9'||'fdger','pwo'||'9'||'vedef','II'||'9'||'Yed3f','uq',4801||'9',940||'9',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'9','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'9','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542329');

1 rows affected.

SQL> CREATE INDEX NEBULA.STORAGE_LIST_INDEX_001_4 ON NEBULA.STORAGE_LIST_TBL_001(C_ID,C_CITY,C_FIRST) parallel 5 LOCAL ;

Succeed.

SQL> SELECT C_ID,C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA.STORAGE_LIST_TBL_001 where C_ID<1500 and C_D_ID<1500 and (C_FIRST like 'I%' ) and  (C_LAST like 'I%' )and  (C_CITY like 'I%' );

C_ID         C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1            90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT C_ID,C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA.STORAGE_LIST_TBL_001 where C_ID<1500 and C_D_ID<1500 ;

C_ID         C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1            90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT C_ID,C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA.STORAGE_LIST_TBL_001 where  (C_FIRST like 'I%' ) and  (C_LAST like 'I%' )and  (C_CITY like 'I%' );

C_ID         C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1            90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT C_ID,C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA.STORAGE_LIST_TBL_001 ;

C_ID         C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1            90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> delete from NEBULA.STORAGE_LIST_TBL_001;

1 rows affected.

SQL> DROP TABLE IF EXISTS NEBULA.STORAGE_LIST_TBL_001;

Succeed.

SQL> DROP TABLE IF EXISTS NEBULA.STRG_PARTRANGE_TBL_001;

Succeed.

SQL> CREATE TABLE NEBULA.STRG_PARTRANGE_TBL_001(c_id int,c_d_id int not null,c_w_id int not null,c_first varchar(32) not null,c_middle char(2),c_last varchar(32) not null,c_street_1 varchar(20) not null,c_street_2 varchar(20),c_city varchar(20) not null,c_state char(2) not null,c_zip char(9) not null,c_phone char(16) not null,c_since timestamp,c_credit char(2) not null,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real not null,c_payment_cnt number not null,c_delivery_cnt bool not null,c_end date not null,c_vchar varchar(1000),c_data varchar(2000),c_text varchar(2000)) partition by range(c_id) (partition part_1 values less than (201),partition part_2 values less than (401),partition part_3 values less than (601),partition part_4 values less than (801),partition part_5 values less than (1001),partition part_6 values less than (1201),partition part_7 values less than (1401),partition part_8 values less than (1601),partition part_9 values less than (1801),partition part_10 values less than (2001),partition part_11 values less than (maxvalue));

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA.STRG_RANGE_INDEX_001_1 ON NEBULA.STRG_PARTRANGE_TBL_001(C_ID) LOCAL;

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA.STRG_RANGE_INDEX_001_2 ON NEBULA.STRG_PARTRANGE_TBL_001(C_W_ID) ;

Succeed.

SQL> CREATE INDEX NEBULA.STRG_RANGE_INDEX_001_3 ON NEBULA.STRG_PARTRANGE_TBL_001(C_FIRST) LOCAL;

Succeed.

SQL> INSERT INTO  NEBULA.STRG_PARTRANGE_TBL_001 SELECT 1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4801||'1',940||'1'||215||'1',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSF'||'1','QVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSF'||'1','\x1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323';

1 rows affected.

SQL> SELECT COUNT(*) FROM  nebula.STRG_PARTRANGE_TBL_001;

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> SELECT COUNT(*) FROM nebula.STRG_PARTRANGE_TBL_001 WHERE c_first LIKE 'AA%';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> SELECT c_first FROM nebula.STRG_PARTRANGE_TBL_001 WHERE c_first < 'BB';

C_FIRST                         
--------------------------------
AAis1cmvls                      

1 rows fetched.

SQL> SELECT * FROM nebula.STRG_PARTRANGE_TBL_001 WHERE C_ID like 1234;

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM nebula.STRG_PARTRANGE_TBL_001 WHERE C_ID like '1234';

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM nebula.STRG_PARTRANGE_TBL_001 WHERE C_FIRST like 1234;

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM nebula.STRG_PARTRANGE_TBL_001 WHERE C_FIRST like '1234' OR C_ID like '1234';

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS NEBULA.STRG_PARTRANGE_TBL_001;

Succeed.

SQL> DROP USER NEBULA CASCADE;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_2;

Succeed.

SQL> CREATE TABLE T_INDEX_2(F1 REAL, F2 DATE, F3 TIMESTAMP, F4 NUMBER(6), F5 DECIMAL(20,5), F6 RAW(6), F7 VARBINARY(6));

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_1 ON T_INDEX_2(F1);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_2 ON T_INDEX_2(F2);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_3 ON T_INDEX_2(F3);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_4 ON T_INDEX_2(F4);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_5 ON T_INDEX_2(F5);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_6 ON T_INDEX_2(F6);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_2_7 ON T_INDEX_2(F7);

Succeed.

SQL> INSERT INTO T_INDEX_2 VALUES(12.5, '2018-02-13', '2018-02-13 09:30:00', 1, 123456, '1111', '11111');

1 rows affected.

SQL> SELECT * FROM T_INDEX_2 WHERE F1=12.5;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F2='2018-02-13';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F3='2018-02-13 09:30:00';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F4=1;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F5=123456;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F6='1111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_INDEX_2 WHERE F7='11111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_3;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_4;

Succeed.

SQL> CREATE TABLE T_INDEX_3(CAR_ID NUMBER(6),CAR_CUST NUMBER(3),ADDR_3 NUMBER(5),CAR_CODE VARCHAR2(32),CAR_STATUS CHAR(1),CAR_REGION NUMBER(6),CAR_DOUBLE NUMBER(6,4),PRIMARY KEY(CAR_ID)); 

Succeed.

SQL> CREATE TABLE T_INDEX_4(PHONE_ID NUMBER(6),CUST NUMBER(3),ADDR_2 NUMBER(5),PHONE_CODE VARCHAR2(32),PHONE_STATUS CHAR(1),PHONE_REGION NUMBER(10),PHONE_DOUBLE NUMBER(20,4),PRIMARY KEY (PHONE_ID));

Succeed.

SQL> INSERT INTO T_INDEX_3(CAR_ID,CAR_CODE) VALUES(1000,'XYZ');

1 rows affected.

SQL> INSERT INTO T_INDEX_4(PHONE_ID, PHONE_CODE) VALUES(1000,'ASD');

1 rows affected.

SQL> 
SQL> SELECT CAR_CODE FROM T_INDEX_3 WHERE CAR_ID IN(SELECT PHONE_ID FROM T_INDEX_4 WHERE PHONE_CODE = 'ASD');

CAR_CODE                        
--------------------------------
XYZ                             

1 rows fetched.

SQL> SELECT * FROM T_INDEX_3,T_INDEX_4;

CAR_ID                                   CAR_CUST                                 ADDR_3                                   CAR_CODE                         CAR_STATUS CAR_REGION                               CAR_DOUBLE                               PHONE_ID                                 CUST                                     ADDR_2                                   PHONE_CODE                       PHONE_STATUS PHONE_REGION                             PHONE_DOUBLE                            
---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------------------- ---------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------------------- ------------ ---------------------------------------- ----------------------------------------
1000                                                                                                                       XYZ                                                                                                                           1000                                                                                                                       ASD                                                                                                                            

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS PURCHASES;

Succeed.

SQL> CREATE TABLE PURCHASES (
  2 	CUSTOMER_ID INTEGER  NOT NULL,
  3 	PRODUCT_ID INTEGER  NOT NULL,
  4 	QUANTITY INTEGER ,
  5 	TEST VARCHAR2(10) ,
  6 	PHONE VARCHAR2(12) NOT NULL,
  7 	CONSTRAINT PURCHASES_PK PRIMARY KEY(PRODUCT_ID, CUSTOMER_ID)
  8 );

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS CUSTOMERS;

Succeed.

SQL> CREATE TABLE CUSTOMERS (
  2 	CUSTOMER_ID INTEGER ,
  3 	FIRST_NAME VARCHAR2(10) NOT NULL,
  4 	LAST_NAME VARCHAR2(10) NOT NULL,
  5 	BIRTH DATE NOT NULL,
  6 	PHONE VARCHAR2(12),
  7 	TEST VARCHAR2(10),
  8 	CONSTRAINT CUSTOMERS_PK PRIMARY KEY (CUSTOMER_ID) parallel 4
  9 );

Succeed.

SQL> 
SQL> INSERT INTO CUSTOMERS (CUSTOMER_ID,FIRST_NAME,LAST_NAME,BIRTH,PHONE,TEST) VALUES(1,'JOHN','BROWN','1890-01-01 00:00:00','800-555-1211','123');

1 rows affected.

SQL> INSERT INTO PURCHASES (CUSTOMER_ID,PRODUCT_ID,QUANTITY,TEST,PHONE) VALUES (1,1,1,'TEST1','13776144901');

1 rows affected.

SQL> SELECT PRODUCT_ID,QUANTITY,TEST,PHONE FROM PURCHASES P WHERE P.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM CUSTOMERS WHERE FIRST_NAME LIKE 'JOHN' AND BIRTH < '2014-10-10');

PRODUCT_ID   QUANTITY     TEST       PHONE       
------------ ------------ ---------- ------------
1            1            TEST1      13776144901 

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS TEST_MULTI_KEY;

Succeed.

SQL> CREATE TABLE TEST_MULTI_KEY(F1 INT, F2 INT);

Succeed.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(1,1);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(2,2);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(3,3);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(4,4);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(5,5);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(6,6);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(7,7);

1 rows affected.

SQL> INSERT INTO TEST_MULTI_KEY VALUES(8,8);

1 rows affected.

SQL> CREATE INDEX IDX_TEST_MULTI_KEY_1 ON TEST_MULTI_KEY(F1) parallel 4;

Succeed.

SQL> SELECT * FROM TEST_MULTI_KEY WHERE (F1 >=1 AND F1 <4) OR (F1 >=5 AND F1 <8) ORDER BY F1;

F1           F2          
------------ ------------
1            1           
2            2           
3            3           
5            5           
6            6           
7            7           

6 rows fetched.

SQL> SELECT * FROM TEST_MULTI_KEY WHERE (F1 >=1 AND F1 <4) OR (F1 >=5 AND F1 <8) ORDER BY F1 DESC;  

F1           F2          
------------ ------------
7            7           
6            6           
5            5           
3            3           
2            2           
1            1           

6 rows fetched.

SQL> DROP TABLE IF EXISTS TEST_MULTI_KEY;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_3;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_4;

Succeed.

SQL> DROP TABLE IF EXISTS PURCHASES;

Succeed.

SQL> DROP TABLE IF EXISTS CUSTOMERS;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_5;

Succeed.

SQL> CREATE TABLE T_INDEX_5
  2 (
  3 	F_INT51 INT,
  4 	F_INT52 INT,
  5 	F_CHAR51 CHAR(20)
  6 );

Succeed.

SQL> 
SQL> INSERT INTO T_INDEX_5 VALUES(1,2,'abc');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(2,3,'dec');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(3,4,'hij');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(4,5,'qwe');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(null,6,'asd');

1 rows affected.

SQL> 
SQL> CREATE INDEX INDEX_INT_T_INDEX_5 ON T_INDEX_5(F_INT51) ONLINE;

Succeed.

SQL> CREATE INDEX INDEX_CHAR_INDEX_5 ON T_INDEX_5(F_CHAR51) ONLINE;

Succeed.

SQL> SELECT * FROM T_INDEX_5 WHERE F_CHAR51 = 'abc' or F_CHAR51 = 'qwe';

F_INT51      F_INT52      F_CHAR51            
------------ ------------ --------------------
1            2            abc                 
4            5            qwe                 

2 rows fetched.

SQL> 
SQL> ALTER INDEX INDEX_INT_T_INDEX_5 ON T_INDEX_5 REBUILD;

Succeed.

SQL> ALTER INDEX INDEX_CHAR_INDEX_5 ON T_INDEX_5 REBUILD ONLINE;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_5;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_55;

Succeed.

SQL> CREATE TABLE T_INDEX_55(A INT, B BOOLEAN);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_55_1 ON T_INDEX_55(B);

Succeed.

SQL> INSERT INTO T_INDEX_55 VALUES(1,0);

1 rows affected.

SQL> INSERT INTO T_INDEX_55 VALUES(2,1);

1 rows affected.

SQL> SELECT * FROM T_INDEX_55 WHERE B=0;

A            B     
------------ ------
1            FALSE 

1 rows fetched.

SQL> SELECT * FROM T_INDEX_55 WHERE B IS NULL OR B IS NULL;

A            B     
------------ ------

0 rows fetched.

SQL> DROP TABLE IF EXISTS T_INDEX_55;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_56;

Succeed.

SQL> create table T_INDEX_56(a int, b int);

Succeed.

SQL> create index idx_T_INDEX_56_1 on T_INDEX_56(a);

Succeed.

SQL> SELECT * FROM T_INDEX_56 WHERE (A>20 AND A <30) OR (A >40 AND A <50) OR (A >60 AND A <70) OR (A >25 AND A <35);

A            B           
------------ ------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS T_INDEX_56;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS STRG_RANGE_DML_MUL_TBL_001;

Succeed.

SQL> CREATE TABLE STRG_RANGE_DML_MUL_TBL_001(C_ID INT,C_D_ID INT NOT NULL,C_W_ID INT NOT NULL,C_FIRST VARCHAR(64) NOT NULL,C_MIDDLE CHAR(2),C_LAST VARCHAR(64) NOT NULL,C_STREET_1 VARCHAR(20) NOT NULL,C_STREET_2 VARCHAR(20),C_CITY VARCHAR(20) NOT NULL,C_STATE CHAR(2) NOT NULL,C_ZIP CHAR(9) NOT NULL,C_PHONE CHAR(16) NOT NULL,C_SINCE TIMESTAMP,C_CREDIT CHAR(2) NOT NULL,C_CREDIT_LIM NUMERIC(12,2),C_DISCOUNT NUMERIC(4,4),C_BALANCE NUMERIC(12,2),C_YTD_PAYMENT REAL NOT NULL,C_PAYMENT_CNT NUMBER NOT NULL,C_DELIVERY_CNT BOOL NOT NULL,C_END DATE NOT NULL,C_VCHAR VARCHAR(1000),C_DATA CLOB,C_TEXT BLOB) PARTITION BY RANGE(C_ID,C_FIRST,C_LAST) (PARTITION PART_1 VALUES LESS THAN (201,'B','B'),PARTITION PART_2 VALUES LESS THAN (401,'C','C'),PARTITION PART_3 VALUES LESS THAN (601,'D','D'),PARTITION PART_4 VALUES LESS THAN (801,'E','E'),PARTITION PART_5 VALUES LESS THAN (1001,'F','F'),PARTITION PART_6 VALUES LESS THAN (5001,'G','G'),PARTITION PART_7 VALUES LESS THAN (6001,'H','H'),PARTITION PART_8 VALUES LESS THAN (7001,'I','I'),PARTITION PART_9 VALUES LESS THAN (8001,'J','J'),PARTITION PART_10 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE));

Succeed.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(1,1,1,'A'||'1'||'Cabdg','OE','A'||'1'||'Bdbed','bki'||'1'||'fdger','pwo'||'1'||'vedef','A'||'1'||'Yed3f','uq',4801||'1',940||'1',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'1','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'1','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(201,201,201,'B'||'201'||'Cabdg','OE','B'||'201'||'Bdbed','bki'||'201'||'fdger','pwo'||'201'||'vedef','B'||'201'||'Yed3f','uq',4801||'201',940||'201',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'201','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'201','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(401,401,401,'C'||'401'||'Cabdg','OE','C'||'401'||'Bdbed','bki'||'401'||'fdger','pwo'||'401'||'vedef','C'||'401'||'Yed3f','uq',4801||'401',940||'401',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'401','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'401','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(601,601,601,'D'||'601'||'Cabdg','OE','D'||'601'||'Bdbed','bki'||'601'||'fdger','pwo'||'601'||'vedef','D'||'601'||'Yed3f','uq',4801||'601',940||'601',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'601','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'601','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(801,801,801,'E'||'801'||'Cabdg','OE','E'||'801'||'Bdbed','bki'||'801'||'fdger','pwo'||'801'||'vedef','E'||'801'||'Yed3f','uq',4801||'801',940||'801',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'801','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'801','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(1001,1001,1001,'F'||'1001'||'Cabdg','OE','F'||'1001'||'Bdbed','bki'||'1001'||'fdger','pwo'||'1001'||'vedef','F'||'1001'||'Yed3f','uq',4801||'1001',940||'1001',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'1001','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'1001','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(5001,5001,5001,'G'||'5001'||'Cabdg','OE','G'||'5001'||'Bdbed','bki'||'5001'||'fdger','pwo'||'5001'||'vedef','G'||'5001'||'Yed3f','uq',4801||'5001',940||'5001',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'5001','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'5001','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(6001,6001,6001,'H'||'6001'||'Cabdg','OE','H'||'6001'||'Bdbed','bki'||'6001'||'fdger','pwo'||'6001'||'vedef','H'||'6001'||'Yed3f','uq',4801||'6001',940||'6001',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'6001','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'6001','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(7001,7001,7001,'I'||'7001'||'Cabdg','OE','I'||'7001'||'Bdbed','bki'||'7001'||'fdger','pwo'||'7001'||'vedef','I'||'7001'||'Yed3f','uq',4801||'7001',940||'7001',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'7001','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'7001','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STRG_RANGE_DML_MUL_TBL_001 values(8001,8001,8001,'J'||'8001'||'Cabdg','OE','J'||'8001'||'Bdbed','bki'||'8001'||'fdger','pwo'||'8001'||'vedef','J'||'8001'||'Yed3f','uq',4801||'8001',940||'8001',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'8001','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'8001','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> SELECT c_id,C_STREET_2 FROM STRG_RANGE_DML_MUL_TBL_001  where C_STREET_2 like '%vedef' order by c_id;

C_ID         C_STREET_2          
------------ --------------------
1            pwo1vedef           
201          pwo201vedef         
401          pwo401vedef         
601          pwo601vedef         
801          pwo801vedef         
1001         pwo1001vedef        
5001         pwo5001vedef        
6001         pwo6001vedef        
7001         pwo7001vedef        
8001         pwo8001vedef        

10 rows fetched.

SQL> CREATE UNIQUE INDEX STRG_RANGE_DML_MUL_IDX_001_3 ON STRG_RANGE_DML_MUL_TBL_001(C_STREET_2,C_D_ID);

Succeed.

SQL> SELECT c_id,C_STREET_2 FROM STRG_RANGE_DML_MUL_TBL_001  where C_STREET_2 like '%vedef' order by c_id;

C_ID         C_STREET_2          
------------ --------------------
1            pwo1vedef           
201          pwo201vedef         
401          pwo401vedef         
601          pwo601vedef         
801          pwo801vedef         
1001         pwo1001vedef        
5001         pwo5001vedef        
6001         pwo6001vedef        
7001         pwo7001vedef        
8001         pwo8001vedef        

10 rows fetched.

SQL> DROP TABLE IF EXISTS STRG_RANGE_DML_MUL_TBL_001;

Succeed.

SQL> DROP TABLE IF EXISTS t1;

Succeed.

SQL> DROP TABLE IF EXISTS t2;

Succeed.

SQL> DROP TABLE IF EXISTS t3;

Succeed.

SQL> CREATE TABLE T1 (F_INT1 INTEGER DEFAULT 0 NOT NULL, F_INT2 INTEGER, F_INT3 INTEGER, F_FLOAT FLOAT,F_DOUBLE DOUBLE, F_VARCHAR1 VARCHAR(512), F_VARCHAR2 VARCHAR2(512));

Succeed.

SQL> CREATE TABLE T2 (F_INT1 INTEGER DEFAULT 0 NOT NULL, F_INT2 INTEGER, F_INT3 INTEGER, F_FLOAT FLOAT,F_DOUBLE DOUBLE, F_VARCHAR1 VARCHAR(512), F_VARCHAR2 VARCHAR2(512));

Succeed.

SQL> CREATE TABLE T3 (F_INT1 INTEGER DEFAULT 0 NOT NULL, F_INT2 INTEGER, F_INT3 INTEGER, F_FLOAT FLOAT,F_DOUBLE DOUBLE, F_VARCHAR1 VARCHAR(512), F_VARCHAR2 VARCHAR2(512));

Succeed.

SQL> CREATE INDEX IDX_T2_1 ON T2(F_INT2);

Succeed.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(0,69,63.27,'xdajd',60,95.79,'dhftn');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(1,99,92.15,'csbgd',24,70.0,'naxqw');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(2,67,80.50,'tsxbw',76,30.75,'mvmjx');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(3,58,68.31,'czlxp',30,22.91,'pmufg');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(4,84,11.23,'hnyud',62,10.85,'ylafp');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(5,48,86.25,'pgfdt',70,87.6,'dfcps');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(6,11,4.29,'inpln',40,88.79,'pcmps');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(7,49,27.82,'hrizk',6,99.67,'rtnyc');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(8,19,73.52,'owmje',13,78.32,'oxpmw');

1 rows affected.

SQL> INSERT INTO t1 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(9,20,36.88,'vnbdv',81,58.0,'rwzxr');

1 rows affected.

SQL> INSERT INTO t2 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(0,69,63.27,'xdajd',60,95.79,'dhftn');

1 rows affected.

SQL> INSERT INTO t2 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(1,99,92.15,'csbgd',24,70.0,'naxqw');

1 rows affected.

SQL> INSERT INTO t2 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(2,67,80.50,'tsxbw',76,30.75,'mvmjx');

1 rows affected.

SQL> INSERT INTO t3 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(0,69,63.27,'xdajd',60,95.79,'dhftn');

1 rows affected.

SQL> INSERT INTO t3 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(1,99,92.15,'csbgd',24,70.0,'naxqw');

1 rows affected.

SQL> INSERT INTO t3 (f_int1, f_int2, f_float, f_varchar1, f_int3, f_double, f_varchar2) VALUES(2,67,80.50,'tsxbw',76,30.75,'mvmjx');

1 rows affected.

SQL> SELECT * FROM T1 WHERE F_INT1 IN (SELECT F_INT1 FROM T2 WHERE T1.F_INT2=T2.F_INT2);

F_INT1       F_INT2       F_INT3       F_FLOAT              F_DOUBLE             F_VARCHAR1                                                       F_VARCHAR2                                                      
------------ ------------ ------------ -------------------- -------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
0            69           60           63.27                95.79                xdajd                                                            dhftn                                                           
1            99           24           92.15                70                   csbgd                                                            naxqw                                                           
2            67           76           80.5                 30.75                tsxbw                                                            mvmjx                                                           

3 rows fetched.

SQL> SELECT * FROM T1 WHERE F_INT1 IN (SELECT F_INT1 FROM T2 WHERE T2.F_INT2=T1.F_INT2);

F_INT1       F_INT2       F_INT3       F_FLOAT              F_DOUBLE             F_VARCHAR1                                                       F_VARCHAR2                                                      
------------ ------------ ------------ -------------------- -------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
0            69           60           63.27                95.79                xdajd                                                            dhftn                                                           
1            99           24           92.15                70                   csbgd                                                            naxqw                                                           
2            67           76           80.5                 30.75                tsxbw                                                            mvmjx                                                           

3 rows fetched.

SQL> SELECT * FROM T1 JOIN T3 ON T1.F_INT1=T3.F_INT1 WHERE T1.F_INT2 IN (SELECT T2.F_INT3 FROM T2 WHERE T2.F_INT3 = T3.F_INT3);

F_INT1       F_INT2       F_INT3       F_FLOAT              F_DOUBLE             F_VARCHAR1                                                       F_VARCHAR2                                                       F_INT1       F_INT2       F_INT3       F_FLOAT              F_DOUBLE             F_VARCHAR1                                                       F_VARCHAR2                                                      
------------ ------------ ------------ -------------------- -------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------ ------------ -------------------- -------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS t1;

Succeed.

SQL> DROP TABLE IF EXISTS t2;

Succeed.

SQL> DROP TABLE IF EXISTS t3;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_101;

Succeed.

SQL> CREATE TABLE T_INDEX_101(F_INT INT, F_CHAR CHAR(128), F_REAL REAL);

Succeed.

SQL> CREATE INDEX IDX_T_INDEX_101_1 ON T_INDEX_101(F_INT, F_CHAR);

Succeed.

SQL> INSERT INTO T_INDEX_101 VALUES(1,'AA', 1.1);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(1,'BB', 1.2);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(1,'CC', 1.3);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(2,'HELLO', 2.1);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(2,'WORLD', 2.2);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(3,'XDAJD', 3.1);

1 rows affected.

SQL> INSERT INTO T_INDEX_101 VALUES(3,'HNYUD', 3.2);

1 rows affected.

SQL> SELECT * FROM T_INDEX_101 WHERE F_INT IN (1,2,3);

F_INT        F_CHAR                                                           F_REAL              
------------ ---------------------------------------------------------------- --------------------
1            AA                                                                                                                               1.1                 
1            BB                                                                                                                               1.2                 
1            CC                                                                                                                               1.3                 
2            HELLO                                                                                                                            2.1                 
2            WORLD                                                                                                                            2.2                 
3            HNYUD                                                                                                                            3.2                 
3            XDAJD                                                                                                                            3.1                 

7 rows fetched.

SQL> SELECT * FROM T_INDEX_101 WHERE F_INT = 1 AND F_CHAR IN ('AA','CC');

F_INT        F_CHAR                                                           F_REAL              
------------ ---------------------------------------------------------------- --------------------
1            AA                                                                                                                               1.1                 
1            CC                                                                                                                               1.3                 

2 rows fetched.

SQL> SELECT * FROM T_INDEX_101 WHERE F_INT = 3 AND F_CHAR IN ('XDAJD','HNYUD');

F_INT        F_CHAR                                                           F_REAL              
------------ ---------------------------------------------------------------- --------------------
3            HNYUD                                                                                                                            3.2                 
3            XDAJD                                                                                                                            3.1                 

2 rows fetched.

SQL> DROP TABLE IF EXISTS T_INDEX_101;

Succeed.

SQL> 
SQL> -----index create --》 truncate --》flashback --》rebuild index
SQL> DROP USER IF EXISTS hzy;

Succeed.

SQL> create user hzy identified by Cantian_234;

Succeed.

SQL> GRANT CREATE SESSION TO hzy;

Succeed.

SQL> grant create table to hzy;

Succeed.

SQL> 
SQL> DROP USER IF EXISTS HZY CASCADE;

Succeed.

SQL> CREATE USER HZY IDENTIFIED BY CANTIAN_234;

Succeed.

SQL> 
SQL> CREATE TABLE HZY.STATS_INTERVAL_NEW(
  2 C_ID INT,
  3 C_D_ID INT NOT NULL,
  4 C_W_ID INT NOT NULL,
  5 C_FIRST VARCHAR(50) NOT NULL,
  6 C_MIDDLE CHAR(2),
  7 C_LAST VARCHAR(16) NOT NULL,
  8 C_STREET_1 VARCHAR(20) NOT NULL,
  9 C_STREET_2 VARCHAR(20),
 10 C_CITY VARCHAR(20) NOT NULL,
 11 C_STATE CHAR(2) NOT NULL,
 12 C_ZIP CHAR(9) NOT NULL,
 13 C_PHONE CHAR(16) NOT NULL,
 14 C_SINCE TIMESTAMP,
 15 C_CREDIT CHAR(2) NOT NULL,
 16 C_CREDIT_LIM NUMERIC(12,2),
 17 C_DISCOUNT NUMERIC(4,4),
 18 C_BALANCE NUMERIC(12,2),
 19 C_YTD_PAYMENT REAL NOT NULL,
 20 C_PAYMENT_CNT NUMBER NOT NULL,
 21 C_DELIVERY_CNT BOOL NOT NULL,
 22 C_END DATE NOT NULL,
 23 C_DATA VARCHAR(1000),
 24 C_CLOB CLOB,
 25 C_TEXT BLOB) 
 26 PARTITION BY RANGE(C_ID)
 27 INTERVAL(100) 
 28 (
 29    PARTITION PART_H1 VALUES LESS THAN (10),
 30    PARTITION PART_H2 VALUES LESS THAN (20),
 31    PARTITION PART_H3 VALUES LESS THAN (30)
 32 );

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE HZY.LOB_HZY_PROC_1115(STARTNUM INT,ENDALL INT) IS
  2 I INT :=1;
  3 J VARCHAR(10);
  4 BEGIN
  5   FOR I IN STARTNUM..ENDALL LOOP
  6     SELECT CAST(I AS VARCHAR(10)) INTO J FROM DUAL;
  7     INSERT INTO  HZY.STATS_INTERVAL_NEW SELECT I,I,I,'IS'||J||'CMRDS'||J,'OE','BAR'||J||'BAR'||J,'BKILI'||J||'FCRRGF'||J,'PMBWO'||J||'VHSDGJ'||J,'DYF'||J||'RDA'||J,'UQ',4801||J,940||J||215||J,'2011-12-11 00:00:00','GC',50000.0,0.4361328,-10.0,10.0,1,TRUE,'2011-12-11 00:00:00','DASD'||J,'DASDSD'||J,'\X1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323';
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> 
SQL> CALL HZY.LOB_HZY_PROC_1115(1001,1120);

PL/SQL procedure successfully completed.

SQL> COMMIT; 

Succeed.

SQL> 
SQL> SELECT COUNT(*) FROM HZY.STATS_INTERVAL_NEW;

COUNT(*)            
--------------------
120                 

1 rows fetched.

SQL> 
SQL> CREATE INDEX HZY.HZY_DML_RANGE_INDX_086 ON HZY.STATS_INTERVAL_NEW(C_ID);

Succeed.

SQL> CREATE INDEX HZY.HZY_DML_RANGE_INDX_087 ON HZY.STATS_INTERVAL_NEW(C_ID, C_D_ID) parallel 5 LOCAL;

Succeed.

SQL> ALTER INDEX HZY.HZY_DML_RANGE_INDX_086 ON HZY.STATS_INTERVAL_NEW UNUSABLE;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_DML_RANGE_INDX_086';

FLAGS       
------------
4           

1 rows fetched.

SQL> CALL HZY.LOB_HZY_PROC_1115(1,20);

PL/SQL procedure successfully completed.

SQL> CALL HZY.LOB_HZY_PROC_1115(1,15);

PL/SQL procedure successfully completed.

SQL> COMMIT;

Succeed.

SQL> ALTER INDEX HZY.HZY_DML_RANGE_INDX_086 ON HZY.STATS_INTERVAL_NEW REBUILD;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_DML_RANGE_INDX_086';

FLAGS       
------------
0           

1 rows fetched.

SQL> CALL HZY.LOB_HZY_PROC_1115(25,45);

PL/SQL procedure successfully completed.

SQL> CALL HZY.LOB_HZY_PROC_1115(10,30);

PL/SQL procedure successfully completed.

SQL> COMMIT;

Succeed.

SQL> ALTER INDEX HZY.HZY_DML_RANGE_INDX_087 ON HZY.STATS_INTERVAL_NEW UNUSABLE;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_DML_RANGE_INDX_087';

FLAGS       
------------
0           

1 rows fetched.

SQL> CALL HZY.LOB_HZY_PROC_1115(50,100);

PL/SQL procedure successfully completed.

SQL> DROP INDEX HZY.HZY_DML_RANGE_INDX_087 ON HZY.STATS_INTERVAL_NEW;

Succeed.

SQL> CREATE INDEX HZY.HZY_DML_RANGE_INDX_087 ON HZY.STATS_INTERVAL_NEW(C_ID, C_D_ID) LOCAL;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_DML_RANGE_INDX_087';

FLAGS       
------------
0           

1 rows fetched.

SQL> DROP TABLE HZY.STATS_INTERVAL_NEW;

Succeed.

SQL> drop PROCEDURE HZY.LOB_HZY_PROC_1115;

Succeed.

SQL> DROP TABLE  IF EXISTS HZY_UNUSABLE;

Succeed.

SQL> CREATE TABLE HZY_UNUSABLE(A INT, B INT, C INT);

Succeed.

SQL> INSERT INTO HZY_UNUSABLE VALUES(1,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(2,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(3,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(4,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(5,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(6,1,1);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE UNIQUE INDEX HZY_UNUSABLE_IDX ON HZY_UNUSABLE(A);

Succeed.

SQL> INSERT INTO HZY_UNUSABLE VALUES(1,1,1);

CT-00729, Unique constraint violated, index HZY_UNUSABLE_IDX, duplicate key 1
SQL> ALTER INDEX HZY_UNUSABLE_IDX ON HZY_UNUSABLE UNUSABLE;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_UNUSABLE_IDX';

FLAGS       
------------
4           

1 rows fetched.

SQL> 
SQL> INSERT INTO HZY_UNUSABLE VALUES(9,1,1);

CT-00823, Index HZY_UNUSABLE_IDX is unusable, need to rebuild index first.
SQL> INSERT INTO HZY_UNUSABLE VALUES(10,1,1);

CT-00823, Index HZY_UNUSABLE_IDX is unusable, need to rebuild index first.
SQL> ALTER INDEX HZY_UNUSABLE_IDX ON HZY_UNUSABLE REBUILD;

Succeed.

SQL> SELECT FLAGS FROM SYS.SYS_INDEXES WHERE NAME = 'HZY_UNUSABLE_IDX';

FLAGS       
------------
0           

1 rows fetched.

SQL> INSERT INTO HZY_UNUSABLE VALUES(9,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(10,1,1);

1 rows affected.

SQL> INSERT INTO HZY_UNUSABLE VALUES(11,1,1);

1 rows affected.

SQL> DROP TABLE  IF EXISTS HZY_UNUSABLE;

Succeed.

SQL> 
SQL> create table hzy.active_standby_range_tbl_000(c_id int,
  2 c_d_id int NOT NULL,
  3 c_w_id int NOT NULL,
  4 c_first varchar(32) NOT NULL,
  5 c_middle char(2),
  6 c_last varchar(32) NOT NULL,
  7 c_street_1 varchar(20) NOT NULL,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) NOT NULL,
 10 c_state char(2) NOT NULL,
 11 c_zip char(9) NOT NULL,
 12 c_phone char(16) NOT NULL,
 13 c_since timestamp,
 14 c_credit char(2) NOT NULL,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real NOT NULL,
 19 c_payment_cnt number NOT NULL,
 20 c_delivery_cnt bool NOT NULL,
 21 c_end date NOT NULL,
 22 c_vchar varchar(1000),
 23 c_data clob,
 24 c_text blob,
 25 primary key (c_id,c_d_id,c_w_id));

Succeed.

SQL> 
SQL> insert into  hzy.active_standby_range_tbl_000 select 1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4801||'1',940||'1'||215||'1',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSF'||'1','QVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSF1','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323';

1 rows affected.

SQL> 
SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+1,c_d_id+1,c_w_id+1,'AA'||'is2cmvls',c_middle,'AA'||'BAR2BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+2,c_d_id+2,c_w_id+2,'AA'||'is3cmvls',c_middle,'AA'||'BAR3BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+3,c_d_id+3,c_w_id+3,'AA'||'is4cmvls',c_middle,'AA'||'BAR4BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+4,c_d_id+4,c_w_id+4,'AA'||'is5cmvls',c_middle,'AA'||'BAR5BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+5,c_d_id+5,c_w_id+5,'AA'||'is6cmvls',c_middle,'AA'||'BAR6BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+6,c_d_id+6,c_w_id+6,'AA'||'is7cmvls',c_middle,'AA'||'BAR7BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+7,c_d_id+7,c_w_id+7,'AA'||'is8cmvls',c_middle,'AA'||'BAR8BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+8,c_d_id+8,c_w_id+8,'AA'||'is9cmvls',c_middle,'AA'||'BAR9BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+9,c_d_id+9,c_w_id+9,'AA'||'is10cmvls',c_middle,'AA'||'BAR10BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+10,c_d_id+10,c_w_id+10,'AA'||'is11cmvls',c_middle,'AA'||'BAR11BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+11,c_d_id+11,c_w_id+11,'AA'||'is12cmvls',c_middle,'AA'||'BAR12BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+12,c_d_id+12,c_w_id+12,'AA'||'is13cmvls',c_middle,'AA'||'BAR13BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+13,c_d_id+13,c_w_id+13,'AA'||'is14cmvls',c_middle,'AA'||'BAR14BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+14,c_d_id+14,c_w_id+14,'AA'||'is15cmvls',c_middle,'AA'||'BAR15BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+15,c_d_id+15,c_w_id+15,'AA'||'is16cmvls',c_middle,'AA'||'BAR16BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+16,c_d_id+16,c_w_id+16,'AA'||'is17cmvls',c_middle,'AA'||'BAR17BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+17,c_d_id+17,c_w_id+17,'AA'||'is18cmvls',c_middle,'AA'||'BAR18BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+18,c_d_id+18,c_w_id+18,'AA'||'is19cmvls',c_middle,'AA'||'BAR19BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+19,c_d_id+19,c_w_id+19,'AA'||'is20cmvls',c_middle,'AA'||'BAR20BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+20,c_d_id+20,c_w_id+20,'AA'||'is21cmvls',c_middle,'AA'||'BAR21BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+21,c_d_id+21,c_w_id+21,'AA'||'is22cmvls',c_middle,'AA'||'BAR22BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+22,c_d_id+22,c_w_id+22,'AA'||'is23cmvls',c_middle,'AA'||'BAR23BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+23,c_d_id+23,c_w_id+23,'AA'||'is24cmvls',c_middle,'AA'||'BAR24BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+24,c_d_id+24,c_w_id+24,'AA'||'is25cmvls',c_middle,'AA'||'BAR25BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+25,c_d_id+25,c_w_id+25,'AA'||'is26cmvls',c_middle,'AA'||'BAR26BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+26,c_d_id+26,c_w_id+26,'AA'||'is27cmvls',c_middle,'AA'||'BAR27BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+27,c_d_id+27,c_w_id+27,'AA'||'is28cmvls',c_middle,'AA'||'BAR28BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+28,c_d_id+28,c_w_id+28,'AA'||'is29cmvls',c_middle,'AA'||'BAR29BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+29,c_d_id+29,c_w_id+29,'AA'||'is30cmvls',c_middle,'AA'||'BAR30BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+30,c_d_id+30,c_w_id+30,'AA'||'is31cmvls',c_middle,'AA'||'BAR31BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+31,c_d_id+31,c_w_id+31,'AA'||'is32cmvls',c_middle,'AA'||'BAR32BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+32,c_d_id+32,c_w_id+32,'AA'||'is33cmvls',c_middle,'AA'||'BAR33BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+33,c_d_id+33,c_w_id+33,'AA'||'is34cmvls',c_middle,'AA'||'BAR34BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+34,c_d_id+34,c_w_id+34,'AA'||'is35cmvls',c_middle,'AA'||'BAR35BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+35,c_d_id+35,c_w_id+35,'AA'||'is36cmvls',c_middle,'AA'||'BAR36BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+36,c_d_id+36,c_w_id+36,'AA'||'is37cmvls',c_middle,'AA'||'BAR37BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+37,c_d_id+37,c_w_id+37,'AA'||'is38cmvls',c_middle,'AA'||'BAR38BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+38,c_d_id+38,c_w_id+38,'AA'||'is39cmvls',c_middle,'AA'||'BAR39BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+39,c_d_id+39,c_w_id+39,'AA'||'is40cmvls',c_middle,'AA'||'BAR40BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+40,c_d_id+40,c_w_id+40,'AA'||'is41cmvls',c_middle,'AA'||'BAR41BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+41,c_d_id+41,c_w_id+41,'AA'||'is42cmvls',c_middle,'AA'||'BAR42BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+42,c_d_id+42,c_w_id+42,'AA'||'is43cmvls',c_middle,'AA'||'BAR43BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+43,c_d_id+43,c_w_id+43,'AA'||'is44cmvls',c_middle,'AA'||'BAR44BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+44,c_d_id+44,c_w_id+44,'AA'||'is45cmvls',c_middle,'AA'||'BAR45BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+45,c_d_id+45,c_w_id+45,'AA'||'is46cmvls',c_middle,'AA'||'BAR46BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+46,c_d_id+46,c_w_id+46,'AA'||'is47cmvls',c_middle,'AA'||'BAR47BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+47,c_d_id+47,c_w_id+47,'AA'||'is48cmvls',c_middle,'AA'||'BAR48BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+48,c_d_id+48,c_w_id+48,'AA'||'is49cmvls',c_middle,'AA'||'BAR49BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+49,c_d_id+49,c_w_id+49,'AA'||'is50cmvls',c_middle,'AA'||'BAR50BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+50,c_d_id+50,c_w_id+50,'AA'||'is51cmvls',c_middle,'AA'||'BAR51BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+51,c_d_id+51,c_w_id+51,'AA'||'is52cmvls',c_middle,'AA'||'BAR52BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+52,c_d_id+52,c_w_id+52,'AA'||'is53cmvls',c_middle,'AA'||'BAR53BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+53,c_d_id+53,c_w_id+53,'AA'||'is54cmvls',c_middle,'AA'||'BAR54BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+54,c_d_id+54,c_w_id+54,'AA'||'is55cmvls',c_middle,'AA'||'BAR55BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+55,c_d_id+55,c_w_id+55,'AA'||'is56cmvls',c_middle,'AA'||'BAR56BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+56,c_d_id+56,c_w_id+56,'AA'||'is57cmvls',c_middle,'AA'||'BAR57BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+57,c_d_id+57,c_w_id+57,'AA'||'is58cmvls',c_middle,'AA'||'BAR58BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+58,c_d_id+58,c_w_id+58,'AA'||'is59cmvls',c_middle,'AA'||'BAR59BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+59,c_d_id+59,c_w_id+59,'AA'||'is60cmvls',c_middle,'AA'||'BAR60BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+60,c_d_id+60,c_w_id+60,'AA'||'is61cmvls',c_middle,'AA'||'BAR61BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+61,c_d_id+61,c_w_id+61,'AA'||'is62cmvls',c_middle,'AA'||'BAR62BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+62,c_d_id+62,c_w_id+62,'AA'||'is63cmvls',c_middle,'AA'||'BAR63BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+63,c_d_id+63,c_w_id+63,'AA'||'is64cmvls',c_middle,'AA'||'BAR64BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+64,c_d_id+64,c_w_id+64,'AA'||'is65cmvls',c_middle,'AA'||'BAR65BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+65,c_d_id+65,c_w_id+65,'AA'||'is66cmvls',c_middle,'AA'||'BAR66BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+66,c_d_id+66,c_w_id+66,'AA'||'is67cmvls',c_middle,'AA'||'BAR67BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+67,c_d_id+67,c_w_id+67,'AA'||'is68cmvls',c_middle,'AA'||'BAR68BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+68,c_d_id+68,c_w_id+68,'AA'||'is69cmvls',c_middle,'AA'||'BAR69BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+69,c_d_id+69,c_w_id+69,'AA'||'is70cmvls',c_middle,'AA'||'BAR70BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+70,c_d_id+70,c_w_id+70,'AA'||'is71cmvls',c_middle,'AA'||'BAR71BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+71,c_d_id+71,c_w_id+71,'AA'||'is72cmvls',c_middle,'AA'||'BAR72BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+72,c_d_id+72,c_w_id+72,'AA'||'is73cmvls',c_middle,'AA'||'BAR73BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+73,c_d_id+73,c_w_id+73,'AA'||'is74cmvls',c_middle,'AA'||'BAR74BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+74,c_d_id+74,c_w_id+74,'AA'||'is75cmvls',c_middle,'AA'||'BAR75BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+75,c_d_id+75,c_w_id+75,'AA'||'is76cmvls',c_middle,'AA'||'BAR76BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+76,c_d_id+76,c_w_id+76,'AA'||'is77cmvls',c_middle,'AA'||'BAR77BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+77,c_d_id+77,c_w_id+77,'AA'||'is78cmvls',c_middle,'AA'||'BAR78BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+78,c_d_id+78,c_w_id+78,'AA'||'is79cmvls',c_middle,'AA'||'BAR79BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+79,c_d_id+79,c_w_id+79,'AA'||'is80cmvls',c_middle,'AA'||'BAR80BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+80,c_d_id+80,c_w_id+80,'AA'||'is81cmvls',c_middle,'AA'||'BAR81BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+81,c_d_id+81,c_w_id+81,'AA'||'is82cmvls',c_middle,'AA'||'BAR82BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+82,c_d_id+82,c_w_id+82,'AA'||'is83cmvls',c_middle,'AA'||'BAR83BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+83,c_d_id+83,c_w_id+83,'AA'||'is84cmvls',c_middle,'AA'||'BAR84BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+84,c_d_id+84,c_w_id+84,'AA'||'is85cmvls',c_middle,'AA'||'BAR85BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+85,c_d_id+85,c_w_id+85,'AA'||'is86cmvls',c_middle,'AA'||'BAR86BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+86,c_d_id+86,c_w_id+86,'AA'||'is87cmvls',c_middle,'AA'||'BAR87BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+87,c_d_id+87,c_w_id+87,'AA'||'is88cmvls',c_middle,'AA'||'BAR88BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+88,c_d_id+88,c_w_id+88,'AA'||'is89cmvls',c_middle,'AA'||'BAR89BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+89,c_d_id+89,c_w_id+89,'AA'||'is90cmvls',c_middle,'AA'||'BAR90BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+90,c_d_id+90,c_w_id+90,'AA'||'is91cmvls',c_middle,'AA'||'BAR91BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+91,c_d_id+91,c_w_id+91,'AA'||'is92cmvls',c_middle,'AA'||'BAR92BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+92,c_d_id+92,c_w_id+92,'AA'||'is93cmvls',c_middle,'AA'||'BAR93BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+93,c_d_id+93,c_w_id+93,'AA'||'is94cmvls',c_middle,'AA'||'BAR94BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+94,c_d_id+94,c_w_id+94,'AA'||'is95cmvls',c_middle,'AA'||'BAR95BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+95,c_d_id+95,c_w_id+95,'AA'||'is96cmvls',c_middle,'AA'||'BAR96BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+96,c_d_id+96,c_w_id+96,'AA'||'is97cmvls',c_middle,'AA'||'BAR97BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+97,c_d_id+97,c_w_id+97,'AA'||'is98cmvls',c_middle,'AA'||'BAR98BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+98,c_d_id+98,c_w_id+98,'AA'||'is99cmvls',c_middle,'AA'||'BAR99BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+99,c_d_id+99,c_w_id+99,'AA'||'is100cmvls',c_middle,'AA'||'BAR100BARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+100,	c_d_id+100,	c_w_id+100,	'BB'||'is101cmvls',	c_middle,'BB'||'BAR101BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+101,	c_d_id+101,	c_w_id+101,	'BB'||'is102cmvls',	c_middle,'BB'||'BAR102BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+102,	c_d_id+102,	c_w_id+102,	'BB'||'is103cmvls',	c_middle,'BB'||'BAR103BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+103,	c_d_id+103,	c_w_id+103,	'BB'||'is104cmvls',	c_middle,'BB'||'BAR104BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+104,	c_d_id+104,	c_w_id+104,	'BB'||'is105cmvls',	c_middle,'BB'||'BAR105BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+105,	c_d_id+105,	c_w_id+105,	'BB'||'is106cmvls',	c_middle,'BB'||'BAR106BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+106,	c_d_id+106,	c_w_id+106,	'BB'||'is107cmvls',	c_middle,'BB'||'BAR107BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+107,	c_d_id+107,	c_w_id+107,	'BB'||'is108cmvls',	c_middle,'BB'||'BAR108BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+108,	c_d_id+108,	c_w_id+108,	'BB'||'is109cmvls',	c_middle,'BB'||'BAR109BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+109,	c_d_id+109,	c_w_id+109,	'BB'||'is110cmvls',	c_middle,'BB'||'BAR110BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+110,	c_d_id+110,	c_w_id+110,	'BB'||'is111cmvls',	c_middle,'BB'||'BAR111BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+111,	c_d_id+111,	c_w_id+111,	'BB'||'is112cmvls',	c_middle,'BB'||'BAR112BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+112,	c_d_id+112,	c_w_id+112,	'BB'||'is113cmvls',	c_middle,'BB'||'BAR113BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into hzy.active_standby_range_tbl_000 select	c_id+113,	c_d_id+113,	c_w_id+113,	'BB'||'is114cmvls',	c_middle,'BB'||'BAR114BARBAR',	c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_vchar,c_data,c_text from hzy.active_standby_range_tbl_000 where c_id=1;

1 rows affected.

SQL> 
SQL> create table hzy.flashback_tbl_range_001(c_id int,
  2 c_d_id int NOT NULL,
  3 c_w_id int NOT NULL,
  4 c_first varchar(32) NOT NULL,
  5 c_middle char(2),
  6 c_last varchar(32) NOT NULL,
  7 c_street_1 varchar(20) NOT NULL,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) NOT NULL,
 10 c_state char(2) NOT NULL,
 11 c_zip char(9) NOT NULL,
 12 c_phone char(16) NOT NULL,
 13 c_since timestamp,
 14 c_credit char(2) NOT NULL,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real NOT NULL,
 19 c_payment_cnt number NOT NULL,
 20 c_delivery_cnt bool NOT NULL,
 21 c_end date NOT NULL,
 22 c_vchar varchar(1000),
 23 c_data clob,
 24 c_text blob,
 25 primary key (c_id,c_d_id,c_w_id))partition by range(c_d_id,c_last) (partition PART_1 values less than (101,'BBis101'),partition PART_2 values less than (501,'FFis501'),partition PART_3 values less than (801,'IIis801'),partition PART_4 values less than (maxvalue,maxvalue));

Succeed.

SQL> CREATE UNIQUE INDEX hzy.flashback_tbl_range_001 ON hzy.flashback_tbl_range_001(C_ID);

Succeed.

SQL> CREATE UNIQUE INDEX hzy.flashback_tbl_range_001_1 ON hzy.flashback_tbl_range_001(C_W_ID,c_first);

Succeed.

SQL> --create global index
SQL> CREATE INDEX hzy.flashback_tbl_range_001_2 ON hzy.flashback_tbl_range_001(C_FIRST);

Succeed.

SQL> --I2.插入数据
SQL> insert into hzy.flashback_tbl_range_001 select * from hzy.active_standby_range_tbl_000;

114 rows affected.

SQL> update hzy.flashback_tbl_range_001 set c_id=c_id+1000,c_first='bbbbbbbb',c_data='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',c_text='1111111111111111',c_vchar='bbbbbbbbbbbbbbbbbbbbbbb';

114 rows affected.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> --I3.truncate表
SQL> truncate table hzy.flashback_tbl_range_001;

Succeed.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> --I4.修改索引
SQL> ALTER INDEX hzy.flashback_tbl_range_001_2 ON hzy.flashback_tbl_range_001 REBUILD ONLINE;

Succeed.

SQL> --I5.闪回
SQL> flashback table hzy.flashback_tbl_range_001 to before truncate ;

Succeed.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> select sum(c_id) from hzy.flashback_tbl_range_001;

SUM(C_ID)           
--------------------
120555              

1 rows fetched.

SQL> drop table hzy.flashback_tbl_range_001 purge;

Succeed.

SQL> 
SQL> create table hzy.flashback_tbl_range_001(c_id int,
  2 c_d_id int NOT NULL,
  3 c_w_id int NOT NULL,
  4 c_first varchar(32) NOT NULL,
  5 c_middle char(2),
  6 c_last varchar(32) NOT NULL,
  7 c_street_1 varchar(20) NOT NULL,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) NOT NULL,
 10 c_state char(2) NOT NULL,
 11 c_zip char(9) NOT NULL,
 12 c_phone char(16) NOT NULL,
 13 c_since timestamp,
 14 c_credit char(2) NOT NULL,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real NOT NULL,
 19 c_payment_cnt number NOT NULL,
 20 c_delivery_cnt bool NOT NULL,
 21 c_end date NOT NULL,
 22 c_vchar varchar(1000),
 23 c_data clob,
 24 c_text blob,
 25 primary key (c_id,c_d_id,c_w_id))partition by range(c_d_id,c_last) (partition PART_1 values less than (101,'BBis101'),partition PART_2 values less than (501,'FFis501'),partition PART_3 values less than (801,'IIis801'),partition PART_4 values less than (maxvalue,maxvalue));

Succeed.

SQL> CREATE UNIQUE INDEX hzy.flashback_tbl_range_001 ON hzy.flashback_tbl_range_001(C_ID);

Succeed.

SQL> CREATE UNIQUE INDEX hzy.flashback_tbl_range_001_1 ON hzy.flashback_tbl_range_001(C_W_ID,c_first);

Succeed.

SQL> --create local index
SQL> CREATE INDEX hzy.flashback_tbl_range_001_2 ON hzy.flashback_tbl_range_001(C_FIRST) local;

Succeed.

SQL> --I2.插入数据
SQL> insert into hzy.flashback_tbl_range_001 select * from hzy.active_standby_range_tbl_000;

114 rows affected.

SQL> update hzy.flashback_tbl_range_001 set c_id=c_id+1000,c_first='bbbbbbbb',c_data='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',c_text='1111111111111111',c_vchar='bbbbbbbbbbbbbbbbbbbbbbb';

114 rows affected.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> --I3.truncate表
SQL> truncate table hzy.flashback_tbl_range_001;

Succeed.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> --I4.修改索引
SQL> ALTER INDEX hzy.flashback_tbl_range_001_2 ON hzy.flashback_tbl_range_001 REBUILD ONLINE;

Succeed.

SQL> --I5.闪回
SQL> flashback table hzy.flashback_tbl_range_001 to before truncate ;

Succeed.

SQL> select distinct c_first,sum(c_id) from hzy.flashback_tbl_range_001 group by 1 order by 1,2;

CT-00609, Expression not in group list
SQL> select sum(c_id) from hzy.flashback_tbl_range_001;

SUM(C_ID)           
--------------------
120555              

1 rows fetched.

SQL> drop table hzy.flashback_tbl_range_001 purge;

Succeed.

SQL> 
SQL> drop table hzy.active_standby_range_tbl_000 purge;

Succeed.

SQL> DROP USER IF EXISTS hzy cascade;

Succeed.

SQL> DROP TABLE IF EXISTS META_VIEW_SOURCE;

Succeed.

SQL> DROP TABLE IF EXISTS META_VIEW_SOURCE_1;

Succeed.

SQL> CREATE TABLE META_VIEW_SOURCE
  2 (
  3   LEFT_CLASS_ID BIGINT NOT NULL,
  4   LEFT_CLASS_ALIAS VARCHAR(128) NOT NULL,
  5   IS_LEFT_SOURCE BOOLEAN NOT NULL,
  6   RIGHT_CLASS_ALIAS VARCHAR(128) NOT NULL,
  7   RELATION_ALIAS VARCHAR(128) NOT NULL,
  8   RIGHT_CLASS_ID BIGINT NOT NULL,
  9   RELATION_ID BIGINT NOT NULL,
 10   VIEW_ID BIGINT NOT NULL,
 11   PRIMARY KEY (VIEW_ID, LEFT_CLASS_ALIAS, RELATION_ALIAS, RIGHT_CLASS_ALIAS)
 12 );

Succeed.

SQL> create table META_VIEW_SOURCE_1(a varchar(300), b varchar(300), c varchar(300), d int);

Succeed.

SQL> create index META_VIEW_SOURCE_1 on META_VIEW_SOURCE_1(a,b,c);

Succeed.

SQL> insert into META_VIEW_SOURCE_1 values(
  2 '11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111',
  3 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',
  4 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',
  5 10);

1 rows affected.

SQL> select a from META_VIEW_SOURCE_1 where a like '1111111%';

A                                                               
----------------------------------------------------------------
11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

1 rows fetched.

SQL> update META_VIEW_SOURCE_1 set a='222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222';

1 rows affected.

SQL> select a from META_VIEW_SOURCE_1 where a like '22222222%';

A                                                               
----------------------------------------------------------------
222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222

1 rows fetched.

SQL> delete from META_VIEW_SOURCE_1;

1 rows affected.

SQL> select * from META_VIEW_SOURCE_1;

A                                                                B                                                                C                                                                D           
---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS META_VIEW_SOURCE;

Succeed.

SQL> DROP TABLE IF EXISTS META_VIEW_SOURCE_1;

Succeed.

SQL> 
SQL> --SELECT * FROM DBA_IND_COLUMNS;
SQL> --SELECT * FROM USER_IND_COLUMNS;
SQL> 
SQL> -----rebuild index  
SQL> drop user if exists user11 cascade;

Succeed.

SQL> create user user11 identified by 'cantian_123';

Succeed.

SQL> grant create session to user11;

Succeed.

SQL> grant create table to user11;

Succeed.

SQL> create table user11.all_datatype_table(id int not null,c_intger integer,c_bigint bigint,c_real real, c_decimal decimal,c_number number,c_char char(100),c_varchar varchar(100),c_varchar400 varchar(400),c_datetime datetime,c_timestamp timestamp,c_boolean boolean,c1 int,c2 int,c3 int,c4 bigint,c5 varchar(10),c6 char(10),c7 int,c8 real,c9 real, c10 int,c11 int,c12 bigint,c13 real,c14 decimal,c15 number,c16 datetime,c17 char)
  2 PARTITION BY RANGE (c_datetime,c_intger)
  3 (
  4 partition P_20180121 values less than ('2018-01-21 00:00:00',2018),
  5 partition P_20190122 values less than ('2019-01-22 00:00:00',2019),
  6 partition P_20200123 values less than ('2020-01-23 00:00:00',2020),
  7 partition P_max values less than ('2050-01-24 00:00:00',2050)
  8 );

Succeed.

SQL> 
SQL> create tablespace  ts_dump_sp datafile 'ts_dump_sp' size 40M;

Succeed.

SQL> create tablespace  ts_dump_sp2 datafile 'ts_dump_sp2' size 40M;

Succeed.

SQL> 
SQL> create index user11.idx5 on user11.all_datatype_table(id,c_datetime ASC,c_intger desc) tablespace ts_dump_sp initrans 1
  2 local
  3 (PARTITION Puser_20180121 pctfree 8 initrans 100,
  4 PARTITION Puser_20190122 pctfree 80 tablespace ts_dump_sp2 initrans 255,
  5 PARTITION Puser_20200123 tablespace ts_dump_sp2 initrans 1 pctfree 80,
  6 PARTITION Puser_max);

Succeed.

SQL> 
SQL> select Name, HIBOUNDVAL,INITRANS, (select name from v$tablespace where id = space#)  from SYS_INDEX_PARTS where name like 'PUSER%' order by NAME;

NAME                                                             HIBOUNDVAL                                                       INITRANS     (SELECT NAME FROM V$TABLESPACE WHERE ID = SPACE#)               
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ----------------------------------------------------------------
PUSER_20180121                                                   '2018-01-21 00:00:00',2018                                       100          TS_DUMP_SP                                                      
PUSER_20190122                                                   '2019-01-22 00:00:00',2019                                       255          TS_DUMP_SP2                                                     
PUSER_20200123                                                   '2020-01-23 00:00:00',2020                                       1            TS_DUMP_SP2                                                     
PUSER_MAX                                                        '2050-01-24 00:00:00',2050                                       1            TS_DUMP_SP                                                      

4 rows fetched.

SQL> ALTER INDEX user11.idx5 on user11.all_datatype_table REBUILD;

Succeed.

SQL> select Name, HIBOUNDVAL,INITRANS, (select name from v$tablespace where id = space#)  from SYS_INDEX_PARTS where name like 'PUSER%' order by NAME;

NAME                                                             HIBOUNDVAL                                                       INITRANS     (SELECT NAME FROM V$TABLESPACE WHERE ID = SPACE#)               
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ----------------------------------------------------------------
PUSER_20180121                                                   '2018-01-21 00:00:00',2018                                       100          TS_DUMP_SP                                                      
PUSER_20190122                                                   '2019-01-22 00:00:00',2019                                       255          TS_DUMP_SP2                                                     
PUSER_20200123                                                   '2020-01-23 00:00:00',2020                                       1            TS_DUMP_SP2                                                     
PUSER_MAX                                                        '2050-01-24 00:00:00',2050                                       1            TS_DUMP_SP                                                      

4 rows fetched.

SQL> ALTER INDEX user11.idx5 on user11.all_datatype_table REBUILD tablespace ts_dump_sp2;

Succeed.

SQL> select Name, (select name from v$tablespace where id = space#)  from SYS_INDEX_PARTS where name like 'PUSER%' order by NAME;

NAME                                                             (SELECT NAME FROM V$TABLESPACE WHERE ID = SPACE#)               
---------------------------------------------------------------- ----------------------------------------------------------------
PUSER_20180121                                                   TS_DUMP_SP2                                                     
PUSER_20190122                                                   TS_DUMP_SP2                                                     
PUSER_20200123                                                   TS_DUMP_SP2                                                     
PUSER_MAX                                                        TS_DUMP_SP2                                                     

4 rows fetched.

SQL> ALTER INDEX user11.idx5 on user11.all_datatype_table REBUILD tablespace ts_dump_sp;

Succeed.

SQL> select Name, (select name from v$tablespace where id = space#)  from SYS_INDEX_PARTS where name like 'PUSER%' order by NAME;

NAME                                                             (SELECT NAME FROM V$TABLESPACE WHERE ID = SPACE#)               
---------------------------------------------------------------- ----------------------------------------------------------------
PUSER_20180121                                                   TS_DUMP_SP                                                      
PUSER_20190122                                                   TS_DUMP_SP                                                      
PUSER_20200123                                                   TS_DUMP_SP                                                      
PUSER_MAX                                                        TS_DUMP_SP                                                      

4 rows fetched.

SQL> ALTER INDEX user11.idx5 on user11.all_datatype_table REBUILD PARTITION Puser_20180121 tablespace ts_dump_sp2;

Succeed.

SQL> select Name, (select name from v$tablespace where id = space#)  from SYS_INDEX_PARTS where name like 'PUSER%' order by NAME;

NAME                                                             (SELECT NAME FROM V$TABLESPACE WHERE ID = SPACE#)               
---------------------------------------------------------------- ----------------------------------------------------------------
PUSER_20180121                                                   TS_DUMP_SP2                                                     
PUSER_20190122                                                   TS_DUMP_SP                                                      
PUSER_20200123                                                   TS_DUMP_SP                                                      
PUSER_MAX                                                        TS_DUMP_SP                                                      

4 rows fetched.

SQL> drop table user11.all_datatype_table purge;

Succeed.

SQL> drop user user11;

Succeed.

SQL> drop TABLESPACE ts_dump_sp including contents cascade constraints;

Succeed.

SQL> drop TABLESPACE ts_dump_sp2 including contents cascade constraints;

Succeed.

SQL> drop table if exists test_pcr_dsc;

Succeed.

SQL> create table test_pcr_dsc(id int primary key) crmode page;

Succeed.

SQL> declare
  2   i integer;
  3 begin
  4   for i in 0..600 loop
  5     execute immediate 'insert into test_pcr_dsc values('||i||')';
  6   end loop;
  7   commit;
  8 end;
  9 /

PL/SQL procedure successfully completed.

SQL> select * from test_pcr_dsc where id>440 and id<445 order by id desc;

ID          
------------
444         
443         
442         
441         

4 rows fetched.

SQL> drop table test_pcr_dsc purge;

Succeed.

SQL> drop table if exists test_rcr_dsc;

Succeed.

SQL> create table test_rcr_dsc(id int primary key) crmode row;

Succeed.

SQL> declare
  2   i integer;
  3 begin
  4   for i in 0..400 loop
  5     execute immediate 'insert into test_rcr_dsc values('||i||')';
  6   end loop;
  7   commit;
  8 end;
  9 /

PL/SQL procedure successfully completed.

SQL> select * from test_rcr_dsc where id>245 and id<249 order by id desc;

ID          
------------
248         
247         
246         

3 rows fetched.

SQL> drop table test_rcr_dsc purge;

Succeed.

SQL> --DTS2018061909186 
SQL> DROP TABLE IF EXISTS STORAGE_LIST_TBL_000;

Succeed.

SQL> DROP TABLE IF EXISTS STORAGE_LIST_TBL_001;

Succeed.

SQL> CREATE TABLE STORAGE_LIST_TBL_000(C_ID INT,
  2 C_D_ID INT NOT NULL,
  3 C_W_ID INT NOT NULL,
  4 C_FIRST VARCHAR(16) NOT NULL,
  5 C_MIDDLE CHAR(2),
  6 C_LAST VARCHAR(16) NOT NULL,
  7 C_STREET_1 VARCHAR(20) NOT NULL,
  8 C_STREET_2 VARCHAR(20),
  9 C_CITY VARCHAR(20) NOT NULL,
 10 C_STATE CHAR(2) NOT NULL,
 11 C_ZIP CHAR(9) NOT NULL,
 12 C_PHONE CHAR(16) NOT NULL,
 13 C_SINCE TIMESTAMP,
 14 C_CREDIT CHAR(2) NOT NULL,
 15 C_CREDIT_LIM NUMERIC(12,2),
 16 C_DISCOUNT NUMERIC(4,4),
 17 C_BALANCE NUMERIC(12,2),
 18 C_YTD_PAYMENT REAL NOT NULL,
 19 C_PAYMENT_CNT NUMBER NOT NULL,
 20 C_DELIVERY_CNT BOOL NOT NULL,
 21 C_END DATE NOT NULL,
 22 C_VCHAR VARCHAR(1000),
 23 C_DATA CLOB,
 24 C_TEXT BLOB);

Succeed.

SQL> 
SQL> insert into STORAGE_LIST_TBL_000 values(1,10,1,'AA'||'1'||'Cabdg','OE','AA'||'1'||'Bdbed','bki'||'1'||'fdger','pwo'||'1'||'vedef','AA'||'1'||'Yed3f','uq',4801||'1',940||'1',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'1','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'1','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(11,10,11,'AA'||'11'||'Cabdg','OE','AA'||'11'||'Bdbed','bki'||'11'||'fdger','pwo'||'11'||'vedef','AA'||'11'||'Yed3f','uq',4801||'11',940||'11',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'11','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'11','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(21,10,21,'AA'||'21'||'Cabdg','OE','AA'||'21'||'Bdbed','bki'||'21'||'fdger','pwo'||'21'||'vedef','AA'||'21'||'Yed3f','uq',4801||'21',940||'21',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'21','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'21','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(31,10,31,'AA'||'31'||'Cabdg','OE','AA'||'31'||'Bdbed','bki'||'31'||'fdger','pwo'||'31'||'vedef','AA'||'31'||'Yed3f','uq',4801||'31',940||'31',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'31','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'31','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(41,10,41,'AA'||'41'||'Cabdg','OE','AA'||'41'||'Bdbed','bki'||'41'||'fdger','pwo'||'41'||'vedef','AA'||'41'||'Yed3f','uq',4801||'41',940||'41',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'41','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'41','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(51,10,51,'AA'||'51'||'Cabdg','OE','AA'||'51'||'Bdbed','bki'||'51'||'fdger','pwo'||'51'||'vedef','AA'||'51'||'Yed3f','uq',4801||'51',940||'51',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'51','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'51','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(61,10,61,'AA'||'61'||'Cabdg','OE','AA'||'61'||'Bdbed','bki'||'61'||'fdger','pwo'||'61'||'vedef','AA'||'61'||'Yed3f','uq',4801||'61',940||'61',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'61','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'61','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(71,10,71,'AA'||'71'||'Cabdg','OE','AA'||'71'||'Bdbed','bki'||'71'||'fdger','pwo'||'71'||'vedef','AA'||'71'||'Yed3f','uq',4801||'71',940||'71',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'71','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'71','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(81,10,81,'AA'||'81'||'Cabdg','OE','AA'||'81'||'Bdbed','bki'||'81'||'fdger','pwo'||'81'||'vedef','AA'||'81'||'Yed3f','uq',4801||'81',940||'81',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'81','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'81','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> insert into STORAGE_LIST_TBL_000 values(91,10,91,'AA'||'91'||'Cabdg','OE','AA'||'91'||'Bdbed','bki'||'91'||'fdger','pwo'||'91'||'vedef','AA'||'91'||'Yed3f','uq',4801||'91',940||'91',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'91','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'91','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323');

1 rows affected.

SQL> 
SQL> update  STORAGE_LIST_TBL_000 set C_FIRST=substr(C_FIRST,1,2),C_LAST=substr(C_FIRST,1,2),C_CITY=substr(C_FIRST,1,2);

10 rows affected.

SQL> update  STORAGE_LIST_TBL_000 set C_DATA='QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF',C_TEXT='1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542328';

10 rows affected.

SQL> 
SQL> CREATE TABLE STORAGE_LIST_TBL_001(C_ID INT,C_D_ID INT NOT NULL,C_W_ID INT NOT NULL,C_FIRST VARCHAR(64) NOT NULL,C_MIDDLE CHAR(2),C_LAST VARCHAR(64) NOT NULL,C_STREET_1 VARCHAR(20) NOT NULL,C_STREET_2 VARCHAR(20),C_CITY VARCHAR(64) NOT NULL,C_STATE CHAR(2) NOT NULL,C_ZIP CHAR(9) NOT NULL,C_PHONE CHAR(16) NOT NULL,C_SINCE TIMESTAMP,C_CREDIT CHAR(2) NOT NULL,C_CREDIT_LIM NUMERIC(12,2),C_DISCOUNT NUMERIC(4,4),C_BALANCE NUMERIC(12,2),C_YTD_PAYMENT REAL NOT NULL,C_PAYMENT_CNT NUMBER NOT NULL,C_DELIVERY_CNT BOOLEAN NOT NULL,C_END DATE NOT NULL,C_VCHAR VARCHAR(1000),C_DATA CLOB,C_TEXT BLOB) 
  2 PARTITION BY LIST(C_D_ID,C_FIRST,C_LAST,C_CITY)
  3 (
  4 PARTITION PART_1 VALUES ((1,'A','A','A'),(10,'AA','AA','AA'),(10,'AAAA','AAAA','AAAA'),(10,'aaaa','aaaa','aaaa'),(100,'AAAA','AAAA','AAAA'),(1,'a','a','a'),(10,'aa','aa','aa'),(100,'aaaa','aaaa','aaaa')),
  5 PARTITION PART_2 VALUES ((2,'B','B','B'),(20,'BB','BB','BB'),(20,'BBBB','BBBB','BBBB'),(20,'bbbb','bbbb','bbbb'),(200,'BBBB','BBBB','BBBB'),(2,'b','b','b'),(20,'bb','bb','bb'),(200,'bbbb','bbbb','bbbb')),
  6 PARTITION PART_3 VALUES ((3,'C','C','C'),(30,'CC','CC','CC'),(30,'CCCC','CCCC','CCCC'),(30,'cccc','cccc','cccc'),(300,'CCCC','CCCC','CCCC'),(3,'c','c','c'),(30,'cc','cc','cc'),(300,'cccc','cccc','cccc')),
  7 PARTITION PART_4 VALUES ((4,'D','D','D'),(40,'DD','DD','DD'),(40,'DDDD','DDDD','DDDD'),(40,'dddd','dddd','dddd'),(400,'DDDD','DDDD','DDDD'),(4,'d','d','d'),(40,'dd','dd','dd'),(400,'dddd','dddd','dddd')),
  8 PARTITION PART_5 VALUES ((5,'E','E','E'),(50,'EE','EE','EE'),(50,'EEEE','EEEE','EEEE'),(50,'eeee','eeee','eeee'),(500,'EEEE','EEEE','EEEE'),(5,'e','e','e'),(50,'ee','ee','ee'),(500,'eeee','eeee','eeee')),
  9 PARTITION PART_6 VALUES ((6,'F','F','F'),(60,'FF','FF','FF'),(60,'FFFF','FFFF','FFFF'),(60,'ffff','ffff','ffff'),(600,'FFFF','FFFF','FFFF'),(6,'f','f','f'),(60,'ff','ff','ff'),(600,'ffff','ffff','ffff')),
 10 PARTITION PART_7 VALUES ((7,'G','G','G'),(70,'GG','GG','GG'),(70,'GGGG','GGGG','GGGG'),(70,'gggg','gggg','gggg'),(700,'GGGG','GGGG','GGGG'),(7,'g','g','g'),(70,'gg','gg','gg'),(700,'gggg','gggg','gggg')),
 11 PARTITION PART_8 VALUES ((8,'H','H','H'),(80,'HH','HH','HH'),(80,'HHHH','HHHH','HHHH'),(80,'hhhh','hhhh','hhhh'),(800,'HHHH','HHHH','HHHH'),(8,'h','h','h'),(80,'hh','hh','hh'),(800,'hhhh','hhhh','hhhh')),
 12 PARTITION PART_9 VALUES ((9,'I','I','I'),(90,'II','II','II'),(90,'IIII','IIII','IIII'),(90,'iiii','iiii','iiii'),(900,'IIII','IIII','IIII'),(9,'i','i','i'),(90,'ii','ii','ii'),(900,'iiii','iiii','iiii')),
 13 PARTITION PART_10 VALUES (DEFAULT)
 14 );

Succeed.

SQL> 
SQL> SELECT DISTINCT FLOOR(C_ID/100),C_D_ID,substr(C_FIRST,1,10),substr(C_LAST,1,10),substr(C_CITY,1,10),COUNT(*) FROM STORAGE_LIST_TBL_001 where C_ID<15000 and C_D_ID<15000  and (C_FIRST='A' or C_FIRST='AA' or C_FIRST='AAAA'  ) and (C_LAST='A' or C_LAST='AA' or C_LAST='AAAA'  ) and  (C_CITY='A' or C_CITY='AA' or C_CITY='AAAA') GROUP BY FLOOR(C_ID/100),C_D_ID,substr(C_FIRST,1,10),substr(C_LAST,1,10),substr(C_CITY,1,10) ORDER BY 1,2,3,4,5,6 desc;

FLOOR(C_ID/100)                          C_D_ID       SUBSTR(C_FIRST,1,10)                                             SUBSTR(C_LAST,1,10)                                              SUBSTR(C_CITY,1,10)                                              COUNT(*)            
---------------------------------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> INSERT INTO STORAGE_LIST_TBL_001 SELECT * FROM STORAGE_LIST_TBL_000;

10 rows affected.

SQL> 
SQL> CREATE UNIQUE INDEX  STORAGE_LIST_INDEX_001_1 ON STORAGE_LIST_TBL_001(C_D_ID,C_FIRST,C_LAST,C_CITY,C_ID)  LOCAL ;

Succeed.

SQL> CREATE UNIQUE INDEX STORAGE_LIST_INDEX_001_2 ON STORAGE_LIST_TBL_001(C_ID,C_CITY,C_LAST,C_STREET_2)  ;

Succeed.

SQL> CREATE UNIQUE INDEX STORAGE_LIST_INDEX_001_3 ON STORAGE_LIST_TBL_001(C_STREET_2,C_ID)  ;

Succeed.

SQL> CREATE INDEX STORAGE_LIST_INDEX_001_4 ON STORAGE_LIST_TBL_001(C_ID,C_CITY,C_FIRST)   ;

Succeed.

SQL> CREATE INDEX STORAGE_LIST_INDEX_001_5 ON STORAGE_LIST_TBL_001(C_STREET_1,C_W_ID)   ;

Succeed.

SQL> 
SQL> SELECT DISTINCT FLOOR(C_ID/100),C_D_ID,substr(C_FIRST,1,10),substr(C_LAST,1,10),substr(C_CITY,1,10),COUNT(*) FROM STORAGE_LIST_TBL_001 where C_ID<15000 and C_D_ID<15000  and (C_FIRST='A' or C_FIRST='AA' or C_FIRST='AAAA'  ) and (C_LAST='A' or C_LAST='AA' or C_LAST='AAAA'  ) and  (C_CITY='A' or C_CITY='AA' or C_CITY='AAAA') GROUP BY FLOOR(C_ID/100),C_D_ID,substr(C_FIRST,1,10),substr(C_LAST,1,10),substr(C_CITY,1,10) ORDER BY 1,2,3,4,5,6 desc;

FLOOR(C_ID/100)                          C_D_ID       SUBSTR(C_FIRST,1,10)                                             SUBSTR(C_LAST,1,10)                                              SUBSTR(C_CITY,1,10)                                              COUNT(*)            
---------------------------------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
0                                        10           AA                                                               AA                                                               AA                                                               10                  

1 rows fetched.

SQL> 
SQL> --test index key with length limit 3900
SQL> DROP TABLE IF EXISTS large_key;

Succeed.

SQL> CREATE TABLE large_key(c1 INTEGER, c2 VARCHAR(4000), c3 INTEGER, c4 char(100));

Succeed.

SQL> CREATE INDEX ix_large_key ON large_key(c1, c2, c4) parallel 5 initrans 100;

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> CREATE INDEX ix_large_key_1 ON large_key(c2) parallel 5 initrans 255;

CT-00634, The total size of index columns within an index exceeded the maximum (1996)
SQL> CREATE OR REPLACE PROCEDURE insert_large_key(v_start int, v_end int)
  2 AS
  3      i int;
  4 BEGIN
  5     FOR i IN v_start .. v_end LOOP
  6         EXECUTE IMMEDIATE 'INSERT INTO large_key VALUES(1, ''a123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'','||i||', null)';
  7     END LOOP;
  8 END;
  9 /

Succeed.

SQL> 
SQL> EXEC insert_large_key(1, 17);

PL/SQL procedure successfully completed.

SQL> CREATE UNIQUE INDEX ix_large_key_2 ON large_key(c3, c2) initrans 100 pctfree 20 parallel 5;

Succeed.

SQL> EXEC insert_large_key(18, 33);

PL/SQL procedure successfully completed.

SQL> DROP INDEX ix_large_key_2 ON large_key;

Succeed.

SQL> EXEC insert_large_key(13, 65);

PL/SQL procedure successfully completed.

SQL> CREATE INDEX ix_large_key ON large_key(c1, c2) initrans 100;

Succeed.

SQL> EXEC insert_large_key(65, 100);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:9] PL/SQL(SYS.INSERT_LARGE_KEY) terminated with execute errors
[6:9] CT-00820, Btree level has exceeded limit 7

SQL> 
SQL> DROP TABLE large_key PURGE;

Succeed.

SQL> CREATE TABLE large_key(a INTEGER, b VARCHAR(4000), c VARCHAR(20), d char(100));

Succeed.

SQL> INSERT INTO large_key VALUES(101, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(1, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(11, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(21, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE INDEX ix_large_key ON large_key(a, b, c) initrans 100 parallel 5;

Succeed.

SQL> DELETE FROM large_key WHERE a=11;

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> EXEC SLEEP(1);

PL/SQL procedure successfully completed.

SQL> INSERT INTO large_key VALUES(20, lpad('b', 40, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(18, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(19, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> INSERT INTO large_key VALUES(17, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> TRUNCATE TABLE large_key PURGE;

Succeed.

SQL> INSERT INTO large_key VALUES(1,  lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(11, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(21, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(18, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(19, lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> DROP TABLE large_key PURGE;

Succeed.

SQL> CREATE TABLE large_key(a INTEGER, b VARCHAR(4000), c VARCHAR(20), d char(100));

Succeed.

SQL> CREATE INDEX ix_large_key ON large_key(a, b, c) initrans 100;

Succeed.

SQL> INSERT INTO large_key VALUES(1,  lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(2,  lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(3,  lpad('b', 4000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(11, lpad('b', 2000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(21, lpad('b', 2000, 'b'), lpad('c', 20, 'c'), 'd');

1 rows affected.

SQL> INSERT INTO large_key VALUES(12, lpad('b', 4000, 'b'), lpad('c', 10, 'c'), 'd');

1 rows affected.

SQL> DROP TABLE large_key PURGE;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS IF_NOT_EXIST;

Succeed.

SQL> CREATE TABLE IF_NOT_EXIST(c1 INTEGER, c2 VARCHAR(1000), c3 INTEGER);

Succeed.

SQL> CREATE INDEX ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

Succeed.

SQL> CREATE INDEX ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

CT-00726, The column has been indexed by IX_IF_NOT_EXIST.
SQL> CREATE INDEX IF NOT EXISTS ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

Succeed.

SQL> DROP INDEX ix_if_not_exist ON IF_NOT_EXIST;

Succeed.

SQL> DROP TABLE IF_NOT_EXIST;

Succeed.

SQL> --pctfree
SQL> DROP TABLE IF EXISTS PCT_TB0;

Succeed.

SQL> CREATE TABLE PCT_TB0 (f1 int, f2 int, f3 int);

Succeed.

SQL> INSERT INTO PCT_TB0 VALUES (1,2,3);INSERT INTO PCT_TB0 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB0 VALUES (3,2,29);INSERT INTO PCT_TB0 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

256 rows affected.


512 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS PCT_TB1;

Succeed.

SQL> CREATE TABLE PCT_TB1 (f1 int, f2 int, f3 int);

Succeed.

SQL> INSERT INTO PCT_TB1 VALUES (1,2,3);INSERT INTO PCT_TB1 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB1 VALUES (3,2,29);INSERT INTO PCT_TB1 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

256 rows affected.


512 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE INDEX idx_tb1 ON PCT_TB1 (f1) ONLINE crmode row;

Succeed.

SQL> CREATE INDEX idx_tb2 ON PCT_TB1 (f2) PCTFREE 10 crmode page;

Succeed.

SQL> CREATE INDEX idx_tb3 ON PCT_TB1 (f3) PCTFREE 80 ONLINE crmode row;

Succeed.

SQL> SELECT SEGMENT_NAME, PAGES FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_TB1' OR SEGMENT_NAME = 'IDX_TB2'  OR SEGMENT_NAME = 'IDX_TB3'  ORDER BY SEGMENT_NAME;

SEGMENT_NAME                                                     PAGES               
---------------------------------------------------------------- --------------------
IDX_TB1                                                          16                  
IDX_TB2                                                          8                   
IDX_TB3                                                          40                  

3 rows fetched.

SQL> ALTER INDEX idx_tb1 ON PCT_TB1 REBUILD PCTFREE 80;

Succeed.

SQL> DELETE FROM PCT_TB1;COMMIT;

1024 rows affected.


Succeed.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB0; COMMIT;

1024 rows affected.


Succeed.

SQL> ALTER INDEX idx_tb2 ON PCT_TB1 REBUILD ONLINE;

Succeed.

SQL> ALTER INDEX idx_tb3 ON PCT_TB1 REBUILD PCTFREE 50;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS PCT_P_TB1;

Succeed.

SQL> CREATE TABLE PCT_P_TB1 (f1 int, f2 int, f3 int)
  2 PARTITION BY RANGE(f3)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30),
  7  PARTITION p4 values less than(40)
  8 );

Succeed.

SQL> INSERT INTO PCT_P_TB1 VALUES (1,2,3);INSERT INTO PCT_P_TB1 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_P_TB1 VALUES (3,2,29);INSERT INTO PCT_P_TB1 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

256 rows affected.


512 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

1024 rows affected.


2048 rows affected.

SQL> COMMIT;

Succeed.

SQL> create index idx_p1_3 on PCT_P_TB1(f3) local
  2 (
  3 partition p1 pctfree 10,
  4 partition p2 pctfree 50,
  5 partition p3 pctfree 80,
  6 partition p4
  7 ) crmode row;

Succeed.

SQL> SELECT SEGMENT_NAME, PARTITION_NAME, PAGES FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_P1_3' ORDER BY PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
IDX_P1_3                                                         P1                                                               8                   
IDX_P1_3                                                         P2                                                               16                  
IDX_P1_3                                                         P3                                                               40                  
IDX_P1_3                                                         P4                                                               8                   
IDX_P1_3                                                                                                                          0                   

5 rows fetched.

SQL> DELETE FROM PCT_P_TB1; COMMIT;

4096 rows affected.


Succeed.

SQL> ALTER INDEX idx_p1_3 on PCT_P_TB1 REBUILD PCTFREE 10;

Succeed.

SQL> SELECT  SEGMENT_NAME, PARTITION_NAME, PAGES  FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_P1_3' ORDER BY PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
IDX_P1_3                                                         P1                                                               8                   
IDX_P1_3                                                         P2                                                               8                   
IDX_P1_3                                                         P3                                                               8                   
IDX_P1_3                                                         P4                                                               8                   
IDX_P1_3                                                                                                                          0                   

5 rows fetched.

SQL> DROP TABLE IF EXISTS PCT_TB1;

Succeed.

SQL> DROP TABLE IF EXISTS PCT_P_TB1;

Succeed.

SQL> DROP TABLE IF EXISTS PCT_TB0;

Succeed.

SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP;

Succeed.

SQL> create table I_FIXEDNETWORKLTP
  2 (
  3 id                                  VARBINARY(16),
  4 class_Name                          VARCHAR(60 BYTE),
  5 class_Id                            BINARY_BIGINT,
  6 last_Modified                       BINARY_BIGINT,
  7 collectorId                                  VARCHAR(36 BYTE),
  8 reportSn                                     BINARY_BIGINT,
  9 regionId                                     BINARY(16),
 10 createTime                                   BINARY_BIGINT,
 11 name                                VARCHAR(255 BYTE),
 12 remark                                       VARCHAR(1024 BYTE),
 13 nativeId                                     VARCHAR(255 BYTE),
 14 ownerId                                      BINARY_BIGINT,
 15 bandwidth                                    BINARY_DOUBLE,
 16 frameId                                      VARCHAR(32 BYTE),
 17 portId                                       VARCHAR(32 BYTE),
 18 cardNativeId                                 VARCHAR(255 BYTE),
 19 portIndex                                    VARCHAR(255 BYTE),
 20 ltpTypeName                         VARCHAR(128 BYTE),
 21 adminState                                   VARCHAR(32 BYTE),
 22 layerRate                                    VARCHAR(64 BYTE),
 23 alias                                        VARCHAR(255 BYTE),
 24 slotId                                       VARCHAR(32 BYTE),
 25 daughterSlotId                               VARCHAR(32 BYTE),
 26 neNativeId                                   VARCHAR(255 BYTE),
 27 direction                                    VARCHAR(32 BYTE),
 28 Trunk__trunkId                               VARCHAR(32 BYTE),
 29 userLabel                                    VARCHAR(256 BYTE),
 30 FanVoipAG__mgId                              BINARY_INTEGER,
 31 workMode                                     VARCHAR(64 BYTE),
 32 OTN__flexFreq                                VARCHAR(32 BYTE),
 33 MPLSTE__availableBandwidth                   BINARY_DOUBLE,
 34 Eth__vlanType                                VARCHAR(32 BYTE),
 35 MPLSTE__maxReservedBandwidth                 BINARY_DOUBLE,
 36 OTN__workBand                                VARCHAR(32 BYTE),
 37 Eth__mtu                                     BINARY_INTEGER,
 38 Optical__opticalModule                       VARCHAR(32 BYTE),
 39 ltpRole                                      VARCHAR(32 BYTE),
 40 isSubLTP                                     BOOLEAN,
 41 owner                                        VARCHAR(32 BYTE),
 42 IP__addrv4Mask                               BINARY_INTEGER,
 43 VNI__vniId                                   BINARY_INTEGER,
 44 isPhysical                                   BOOLEAN,
 45 IP__unnumberedNativeId                       VARCHAR(255 BYTE),
 46 NVE__sourceIP                                VARCHAR(64 BYTE),
 47 OTN__workBandParity                          VARCHAR(32 BYTE),
 48 capabilityURI                                VARCHAR(128 BYTE),
 49 OTN__waveNo                                  VARCHAR(32 BYTE),
 50 Physical__mediumType                         VARCHAR(32 BYTE),
 51 Eth__vlan                                    CLOB,
 52 FanVoipUser__telNumber                       VARCHAR(32 BYTE),
 53 Eth__tunnelId                                BINARY_INTEGER,
 54 tags                                         VARCHAR(2048 BYTE),
 55 SDH__highPath                                BINARY_INTEGER,
 56 SDH__lowPath                                 BINARY_INTEGER,
 57 portType                                     BINARY_INTEGER,
 58 C64K__timeslot                               VARCHAR(100 BYTE),
 59 IP__addrv6                                   CLOB,
 60 Eth__mac                                     VARCHAR(64 BYTE),
 61 FanVLAN__vlanId                              BINARY_INTEGER,
 62 OTN__pathId                                  VARCHAR(32 BYTE),
 63 OTN__freqWidth                               VARCHAR(32 BYTE),
 64 IP__addrv4                                   VARCHAR(32 BYTE)
 65 );

Succeed.

SQL> create index CMDBCORESVRDB  on I_FIXEDNETWORKLTP(id);

Succeed.

SQL> select * from I_FIXEDNETWORKLTP where (((id IN (UNHEX('429a7277017c87d69edaffea03e66f75'),UNHEX('44c82f61cb2b89b0857af549290c5909'),UNHEX('488d8167b62790f1b17a2b7778367e51'),UNHEX('4867690b6d30632199214a4fb7328f7a'),UNHEX('41bd48b2a3f1787d9d61f82a85e83cce'),UNHEX('4d488bd5c957e86daa35a6fdc7707dd6'),UNHEX('42ddaffe428d3ab39ac6dd9b43df1777'),UNHEX('424808d9c5ce88bf9bbcbe3a109c372f'),UNHEX('4c04bb8d4c3ed1a78bfca833a9ef6a6e'),UNHEX('437b8e16cde7e2579ed93fa566257a55'),UNHEX('49880c661bfb0e468f8d1c7fde8cd5c7'),UNHEX('4fabab86d71d3f1fbb83d294aaffebc4'),UNHEX('42b228ebc5fe92db8a14920a787ecd48'),UNHEX('4154cf901314479fb55fc697efd6f37c'),UNHEX('450578032141d947bcc6aa5849e101e6'),UNHEX('4984ed0b89c4414b869be8d2203a3704'),UNHEX('41983fc03addf60dbd11402b087821c4'),UNHEX('40d0c297408d369ba6ae1b9f2bec3dd3'),UNHEX('43e74c146ab15dfbaf586f3c78b2c08d'),UNHEX('4c5a9963a5d14c6195c3ad7abb619b20'),UNHEX('410819ca18aa29ecbf8b750808218377'),UNHEX('4b195d2c0730f8228f476a260e7d71cc'),UNHEX('4d17774828ab54a6a5b92e06146b031b'),UNHEX('4e191c2fd2391a4eaac6875938010136'),UNHEX('4187824b89f513e888831c9204871cbc'),UNHEX('400bd58c3362f2d2b2594b5818018214'),UNHEX('4115ba2c6c021dd3b96c144ed6aa74d8'),UNHEX('44330866b068fbbfaf521c15221f9c41'),UNHEX('4d67e7c4f6974dd2bb83484decbd8325'),UNHEX('4f33e89ec9a2c31f9a08cd4e65b82260'),UNHEX('4fd956c7ecb42dae81cc68acf64ac294'),UNHEX('430782b1cd30fd298c916203382e52b4'),UNHEX('454d87166e075238bba0fd3247a39921'),UNHEX('4e4b14e17c1a1b7da67f7ae893cf15b4'),UNHEX('44d2341e3b12865b9a7b97cf0994d721'),UNHEX('404482fd3d5b81c28839edf797fabced'),UNHEX('468e63d1dcdb035792b68cfff2bd660c'),UNHEX('451825fc616777be8507d7e89d803774'),UNHEX('42bb5727d5db44f185e0844ad37715d7'),UNHEX('4ba4b0b79f867e459a5c1956641f8185'),UNHEX('481959483c811557bf83531d769f11a4'),UNHEX('46a125ef4bb92b8eae7c48f4aab14442'),UNHEX('4e3f1990b0552c22a876f2651709a142'),UNHEX('436a3821b3be2bbea0c6fd7127f94354'),UNHEX('451d7b755f9f659a9909c5fe8139be90'),UNHEX('4f11e1cd0b00cc449d3ae2fc5c8aafd1'),UNHEX('4b13e73a21f5fa2390e56599768dfc89'),UNHEX('40f6e862be7fd0f49b9b68d8842430f1'),UNHEX('4e60de304af3fbf48820c3b27dcb7c82'),UNHEX('46f3dbc86321cbab81eefc7b0b666ba8'),UNHEX('45e4e822ba02322fbf772f0f79772c47'),UNHEX('46ab68ad318f74b48ce01711b8737911'),UNHEX('48ddf790b15d1f0abc70139fce949bea'),UNHEX('4b8c7303f804f87386dea8fb4e47a578'),UNHEX('4357b27070e02d6ebda14c89898c6b05'),UNHEX('4c05dbcd07d88606a91fe2707655b6da'),UNHEX('4e6673e9f8a898978a0cdab9eccbb81a'),UNHEX('4ae888e7051fdb92bc39a1715a4a80a3'),UNHEX('466e9c1df6656d6cb5b57b7d5b9a871d'),UNHEX('489c3d20e5e1e16bacb25f2e6c6fc8a6'),
  2 UNHEX('44159e8fc1098328811fec8a2185b875'),UNHEX('4868a28ca9542c6694ade875bd02041a'),UNHEX('4c42ec4bb101065281b925ac0354641d'),UNHEX('4379e1df0fe3178e9871aa013f92df48'),UNHEX('4d3b8940d221f9a48d196e1688914d80'),UNHEX('48547ec4ee501037968dec4944cd12d1'),UNHEX('47573a453e32bf09b1f85f3d58f3fe12'),UNHEX('4dccde5424153d4bab53a8f3b4a336b3'),UNHEX('4e781ac2546f2c32b16cc767f6b3b643'),UNHEX('41bb09b94fcfbe8fb577326222463268'),UNHEX('442de081cbccc66d8eb7a00069200222'),UNHEX('4c1ff819c43d4c99b9c50e39aecbedf6'),UNHEX('4e2fd85f6792190b9fc75940101fb67b'),UNHEX('43fb17aef5396eb7905eac6286112b40'),UNHEX('41e6aa84230cd252a01b588a194fb75f'),UNHEX('449c36d9e9cfcc97984bd9c088e81394'),UNHEX('4464f3e0a99ef21eacc65425103e5fc0'),UNHEX('4fd105da93978b39a8f877f847069c23'),UNHEX('45e13fe656ab916db10558d939be8e09'),UNHEX('448cd90a4b421276be6451557ac9b3bd'),UNHEX('47f33a094a51af87862c313b1664b80d'),UNHEX('4a0f6d04a449114eae7e8a311e5819de'),UNHEX('4acc639d342e25c98c906e158a93a1d6'),UNHEX('43560ed7f6c5742bad106f5d99ba651e'),UNHEX('45e74538d46aec24b5c0413a0901fb9d'),UNHEX('4af1485a9a84b3f7beefdaf2ed609bea'),UNHEX('4c59c8872efd3d3d8487b1edd9b615d8'),UNHEX('4003fd1d1dfd9be6ad283176d9e2b4ef'),UNHEX('4344aa10432d765a95ad499b1a36f00c'),UNHEX('4bf686e5db71f18a8fca22098bb77296'),UNHEX('4d13ac53766ca16da46f23cdc297375a'),UNHEX('4c9f8890625206f3a3e3db9cececfafd'),UNHEX('41090298d80006ff99b2761848d58cf2'),UNHEX('42ed8d64c4b4a2d9bd0d0bcaac9e42d2'),UNHEX('4fc962dcc7cd28c7ac096e8ca77c058f'),UNHEX('497a424942b60da48bb79479d41423d5'),UNHEX('43da9fbab2d130a5b6b0ca373f5c2cd8'),UNHEX('48b32bd8da1285beafe987a4729ea081'),UNHEX('42c363ab0dbc907f917dd1e85728f6cf'),UNHEX('48e0dd71f0c9805f84d37524b48628d7')) ))) LIMIT 20 OFFSET 0;

ID                                                               CLASS_NAME                                                   CLASS_ID             LAST_MODIFIED        COLLECTORID                          REPORTSN             REGIONID                                                         CREATETIME           NAME                                                             REMARK                                                           NATIVEID                                                         OWNERID              BANDWIDTH            FRAMEID                          PORTID                           CARDNATIVEID                                                     PORTINDEX                                                        LTPTYPENAME                                                      ADMINSTATE                       LAYERRATE                                                        ALIAS                                                            SLOTID                           DAUGHTERSLOTID                   NENATIVEID                                                       DIRECTION                        TRUNK__TRUNKID                   USERLABEL                                                        FANVOIPAG__MGID WORKMODE                                                         OTN__FLEXFREQ                    MPLSTE__AVAILABLEBANDWIDTH ETH__VLANTYPE                    MPLSTE__MAXRESERVEDBANDWIDTH OTN__WORKBAND                    ETH__MTU     OPTICAL__OPTICALMODULE           LTPROLE                          ISSUBLTP OWNER                            IP__ADDRV4MASK VNI__VNIID   ISPHYSICAL IP__UNNUMBEREDNATIVEID                                           NVE__SOURCEIP                                                    OTN__WORKBANDPARITY              CAPABILITYURI                                                    OTN__WAVENO                      PHYSICAL__MEDIUMTYPE             ETH__VLAN                                                        FANVOIPUSER__TELNUMBER           ETH__TUNNELID TAGS                                                             SDH__HIGHPATH SDH__LOWPATH PORTTYPE     C64K__TIMESLOT                                                   IP__ADDRV6                                                       ETH__MAC                                                         FANVLAN__VLANID OTN__PATHID                      OTN__FREQWIDTH                   IP__ADDRV4                      
---------------------------------------------------------------- ------------------------------------------------------------ -------------------- -------------------- ------------------------------------ -------------------- ---------------------------------------------------------------- -------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- -------------------- -------------------------------- -------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- -------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- -------------------------------- -------------------------------- ---------------------------------------------------------------- -------------------------------- -------------------------------- ---------------------------------------------------------------- --------------- ---------------------------------------------------------------- -------------------------------- -------------------------- -------------------------------- ---------------------------- -------------------------------- ------------ -------------------------------- -------------------------------- -------- -------------------------------- -------------- ------------ ---------- ---------------------------------------------------------------- ---------------------------------------------------------------- -------------------------------- ---------------------------------------------------------------- -------------------------------- -------------------------------- ---------------------------------------------------------------- -------------------------------- ------------- ---------------------------------------------------------------- ------------- ------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------- -------------------------------- -------------------------------- --------------------------------

0 rows fetched.

SQL> 
SQL> drop user if exists userv cascade;

Succeed.

SQL> create user userv identified by GS_12345677;

Succeed.

SQL> drop table if exists userv.nebula_ddl_com_012;                                                      

Succeed.

SQL> create table userv.nebula_ddl_com_012(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(50) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data varchar(1000),c_clob clob,c_text blob) appendonly on;  

Succeed.

SQL> 
SQL> create sequence userv.oracle_wide_table_list_seq_012 start with 1 increment by 1 order;

Succeed.

SQL> create sequence userv.oracle_wide_table_list_seq_012_1 start with 1 increment by 1 order;

Succeed.

SQL> create sequence userv.oracle_wide_table_list_seq_012_2 start with 1 increment by 1 order;

Succeed.

SQL> 
SQL> CREATE or replace procedure userv.oracle_ddl_com_tbl_012_proc(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(mod(i,10) as varchar(10)) into j from dual;
  7     insert into userv.nebula_ddl_com_012(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_clob,c_text) select userv.oracle_wide_table_list_seq_012.nextval,userv.oracle_wide_table_list_seq_012_1.nextval,userv.oracle_wide_table_list_seq_012_2.nextval,'is'||j||'cmRDs','OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate,lpad('aaa',800,'bbb'),lpad('aaa',3000,'bbb'),lpad('111',3000,'222') from dual;
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> 
SQL> CREATE INDEX userv.nebula_ddl_com_indx_012_2 ON userv.nebula_ddl_com_012(c_first);                            

Succeed.

SQL> alter index userv.nebula_ddl_com_indx_012_2 ON userv.nebula_ddl_com_012 unusable;                                                                                                                                                                        

Succeed.

SQL> call userv.oracle_ddl_com_tbl_012_proc(1,100);

PL/SQL procedure successfully completed.

SQL> commit;                                        

Succeed.

SQL> truncate table userv.nebula_ddl_com_012;                                                       

Succeed.

SQL> alter index userv.nebula_ddl_com_indx_012_2 ON userv.nebula_ddl_com_012 rebuild;                                                                                                                                                                     

Succeed.

SQL> flashback table userv.nebula_ddl_com_012 to before truncate force;                                                                                                                                   

Succeed.

SQL> update userv.nebula_ddl_com_012 set c_first=substr(c_first,1,16),c_city='bbbbbb',c_data=substr(c_data,1,100),c_text='1111122222222333334445555',c_last=substr(c_last,1,16);

100 rows affected.

SQL> 
SQL> drop table if exists userv.oracle_wide_table_list_tbl_012;

Succeed.

SQL> create table userv.oracle_wide_table_list_tbl_012(c_id int,c_d_id bigint NOT NULL,c_w_id tinyint unsigned NOT NULL,c_first varchar(16) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 varchar(8000),c_data2 varchar(8000),c_data3 varchar(8000),c_data4 varchar(8000),c_data5 varchar(8000),c_data6 varchar(8000),c_data7 varchar(8000),c_data8 varchar(8000),c_clob clob,c_blob blob) partition by list(c_id,c_first) (partition PART_1 values ((0,'is0cmRDs'),(1,'is1cmRDs'),(0,'is0cmRDsaa'),(1,'is1cmRDsaa'),(0,'is0cmRDsbb'),(1,'is1cmRDsbb'),(0,'is0cmRDsaabb'),(1,'is1cmRDsaabb'),(0,'is0cmRDsbbaa'),(1,'is1cmRDsbbaa')),partition PART_2 values((2,'is2cmRDs'),(3,'is3cmRDs'),(2,'is2cmRDsaa'),(3,'is3cmRDsaa'),(2,'is2cmRDsbb'),(3,'is3cmRDsbb'),(2,'is2cmRDsaabb'),(3,'is3cmRDsaabb'),(2,'is2cmRDsbbaa'),(3,'is3cmRDsbbaa')),partition PART_3 values((4,'is4cmRDs'),(5,'is5cmRDs'),(4,'is4cmRDsaa'),(5,'is5cmRDsaa'),(4,'is4cmRDsbb'),(5,'is5cmRDsbb'),(4,'is4cmRDsaabb'),(5,'is5cmRDsaabb'),(4,'is4cmRDsbbaa'),(5,'is5cmRDsbbaa')),partition PART_4 values((6,'is6cmRDs'),(7,'is7cmRDs'),(6,'is6cmRDsaa'),(7,'is7cmRDsaa'),(6,'is6cmRDsbb'),(7,'is7cmRDsbb'),(6,'is6cmRDsaabb'),(7,'is7cmRDsaabb'),(6,'is6cmRDsbbaa'),(7,'is7cmRDsbbaa')),partition PART_5 values(default));

Succeed.

SQL> CREATE INDEX userv.oracle_wide_table_list_tbl_012_indx_5 ON userv.oracle_wide_table_list_tbl_012(c_id,c_d_id,c_since) local;

Succeed.

SQL> 
SQL> CREATE or replace procedure userv.oracle_wide_table_list_tbl_012_proc(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(mod(i,10) as varchar(10)) into j from dual;
  7     insert into userv.oracle_wide_table_list_tbl_012(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) select userv.oracle_wide_table_list_seq_012.nextval,userv.oracle_wide_table_list_seq_012_1.nextval,userv.oracle_wide_table_list_seq_012_2.nextval,'is'||j||'cmRDs','OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate,lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('aaa',3000,'bbb'),lpad('111',3000,'222') from dual;
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> call userv.oracle_wide_table_list_tbl_012_proc(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> call userv.oracle_wide_table_list_tbl_012_proc(1,100);commit;

PL/SQL procedure successfully completed.


Succeed.

SQL> alter index userv.oracle_wide_table_list_tbl_012_indx_5 ON userv.oracle_wide_table_list_tbl_012 unusable;

Succeed.

SQL> alter table userv.oracle_wide_table_list_tbl_012 truncate partition PART_5;

Succeed.

SQL> alter index userv.oracle_wide_table_list_tbl_012_indx_5 ON userv.oracle_wide_table_list_tbl_012 rebuild;

Succeed.

SQL> flashback table userv.oracle_wide_table_list_tbl_012 partition PART_5 to before truncate;

Succeed.

SQL> update userv.oracle_wide_table_list_tbl_012 set c_d_id=c_d_id+300,c_since=sysdate,c_first=c_first||'aa',c_delivery_cnt=false,c_data1=lpad('2390ajklKG',200,'ftiun95'),c_data2=lpad('2390ajklKG',200,'ftiun95'),c_data3=lpad('2390ajklKG',200,'ftiun95'),c_data4=lpad('2390ajklKG',200,'ftiun95'),c_data5=lpad('2390ajklKG',200,'ftiun95'),c_data6=lpad('2390ajklKG',200,'ftiun95'),c_data7=lpad('2390ajklKG',200,'ftiun95'),c_data8=lpad('2390ajklKG',200,'ftiun95'),c_clob=lpad('2390ajklKG',2000,'ftiun95'),c_blob=lpad('1112222',4000,'333');commit;

200 rows affected.


Succeed.

SQL> drop user userv cascade;

Succeed.

SQL> 
SQL> --DTS2018091501597
SQL> CREATE USER idxtester IDENTIFIED BY asdf_1234;

Succeed.

SQL> GRANT CREATE ANY TABLE TO idxtester;

Succeed.

SQL> GRANT CREATE ANY INDEX TO idxtester;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS idx_tab001;

Succeed.

SQL> DROP TABLE IF EXISTS idxtester.idx_tab001;

Succeed.

SQL> CREATE TABLE idxtester.idx_tab001 (col1 INTEGER NOT NULL, col2 VARCHAR(64));

Succeed.

SQL> CREATE TABLE idx_tab001 (col1 INTEGER NOT NULL, col2 REAL);

Succeed.

SQL> CREATE INDEX sys.ix_idx_tab001 ON idxtester.idx_tab001(col1);    -- error. schema name not same

CT-00601, [1:35]Sql syntax error: index user(SYS) is not consistent with table user(IDXTESTER)
SQL> CREATE INDEX ix_idx_tab001 ON idxtester.idx_tab001(col1);        -- OK. index's schema equals with "idxtester"

Succeed.

SQL> CREATE INDEX idxtester.ix_idx_tab002 ON idx_tab001(col2);        -- error. schema name not same

CT-00601, [1:41]Sql syntax error: index user(IDXTESTER) is not consistent with table user(SYS)
SQL> CREATE INDEX ix_idx_tab002 ON idx_tab001(col2);                  -- OK. index's schema equals with "sys"

Succeed.

SQL> 
SQL> SELECT U.NAME AS OWNER, T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME FROM SYS_USERS U JOIN SYS_INDEXES I ON U.ID=I.USER# AND U.NAME='IDXTESTER' JOIN SYS_TABLES T ON I.USER#=T.USER# AND I.TABLE#=T.ID WHERE T.NAME='IDX_TAB001';  --1 row expected

OWNER                                                            TABLE_NAME                                                       INDEX_NAME                                                      
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
IDXTESTER                                                        IDX_TAB001                                                       IX_IDX_TAB001                                                   

1 rows fetched.

SQL> SELECT M.USER_NAME AS OWNER, T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME FROM V$ME M JOIN SYS_INDEXES I ON M.USER_ID=I.USER# JOIN SYS_TABLES T ON I.USER#=T.USER# AND I.TABLE#=T.ID WHERE T.NAME='IDX_TAB001';  --1 row expected

OWNER                                                            TABLE_NAME                                                       INDEX_NAME                                                      
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
SYS                                                              IDX_TAB001                                                       IX_IDX_TAB002                                                   

1 rows fetched.

SQL> 
SQL> DROP INDEX ix_idx_tab002 ON idx_tab001;

Succeed.

SQL> DROP TABLE idx_tab001;

Succeed.

SQL> DROP INDEX idxtester.ix_idx_tab001 ON idxtester.idx_tab001;

Succeed.

SQL> DROP TABLE idxtester.idx_tab001;

Succeed.

SQL> DROP USER idxtester CASCADE;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS TEST_IN_INDEX;

Succeed.

SQL> CREATE TABLE TEST_IN_INDEX (ID VARBINARY(36) UNIQUE);

Succeed.

SQL> SELECT * FROM TEST_IN_INDEX I WHERE (((((((I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  2 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  3 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  4 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  5 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) )));

ID                                                              
----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS TEST_IN_INDEX;

Succeed.

SQL> 
SQL> CREATE TABLE TEST_IN_INDEX (ID INT, PID INT, NAME VARCHAR(8));

Succeed.

SQL> CREATE INDEX IDX_IDS ON TEST_IN_INDEX(ID,PID);

Succeed.

SQL> INSERT INTO TEST_IN_INDEX VALUES (1,1,'zzz');

1 rows affected.

SQL> SELECT DISTINCT ID,PID FROM TEST_IN_INDEX;

ID           PID         
------------ ------------
1            1           

1 rows fetched.

SQL> DROP TABLE TEST_IN_INDEX;

Succeed.

SQL> 
SQL> --test truncate btree reuse storage
SQL> DROP TABLE IF EXISTS bt_truncate;

Succeed.

SQL> CREATE TABLE bt_truncate(c1 int, c2 varchar(1000), c3 int);

Succeed.

SQL> CREATE INDEX ix_bt_truncate ON bt_truncate(c1, c2);

Succeed.

SQL> CREATE OR REPLACE PROCEDURE proc_bt_truncate(v_count integer) AS
  2   v_c1 INTEGER;
  3 BEGIN
  4   FOR v_c1 IN 1 .. v_count LOOP
  5       EXECUTE IMMEDIATE 'INSERT INTO bt_truncate VALUES(100000-'||v_c1||', LPAD(''ABCDEFGHIJ'', 100, ''ABCDEFGHIJ''), 1)';
  6   END LOOP;
  7   COMMIT;
  8 END;
  9 /

Succeed.

SQL> EXEC proc_bt_truncate(2000);

PL/SQL procedure successfully completed.

SQL> DROP TABLE IF EXISTS bt_truncate2;

Succeed.

SQL> CREATE TABLE bt_truncate2(c1 int, c2 varchar(1000), c3 int);

Succeed.

SQL> CREATE INDEX ix_bt_truncate2 ON bt_truncate2(c1, c2);

Succeed.

SQL> CREATE OR REPLACE PROCEDURE proc_bt_truncate2(v_count integer) AS
  2   v_c1 INTEGER;
  3 BEGIN
  4   FOR v_c1 IN 1 .. v_count LOOP
  5       EXECUTE IMMEDIATE 'INSERT INTO bt_truncate2 VALUES(100000-'||v_c1||', LPAD(''ABCDEFGHIJ'', 100, ''ABCDEFGHIJ''), 1)';
  6   END LOOP;
  7   COMMIT;
  8 END;
  9 /

Succeed.

SQL> EXEC proc_bt_truncate2(2000);

PL/SQL procedure successfully completed.

SQL> 
SQL> TRUNCATE TABLE bt_truncate REUSE STORAGE;

Succeed.

SQL> TRUNCATE TABLE bt_truncate2 REUSE STORAGE;

Succeed.

SQL> EXEC proc_bt_truncate2(3000);

PL/SQL procedure successfully completed.

SQL> EXEC proc_bt_truncate(3000);

PL/SQL procedure successfully completed.

SQL> DROP TABLE bt_truncate PURGE;

Succeed.

SQL> DROP TABLE bt_truncate2 PURGE;

Succeed.

SQL> --alter system index
SQL> ALTER INDEX IX_TABLE$001 ON SYS_TABLES REBUILD;

CT-00130, Operation alter index is not supported on system table
SQL> CREATE INDEX IDX_SYS_1 ON SYS_TABLES(ID);

CT-00130, Operation create index is not supported on system table
SQL> CREATE INDEX IDX_SYS_2 ON SYS_TABLES(UPPER(ID));

CT-00130, Operation create index is not supported on system table
SQL> 
SQL> --test batch update of primary key 
SQL> drop table if exists test_pk;

Succeed.

SQL> create table test_pk(id int primary key, val varchar(10));

Succeed.

SQL> insert into test_pk values(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e');

5 rows affected.

SQL> commit;

Succeed.

SQL> update test_pk set id = id+1 where id<3;

CT-00729, Unique constraint violated
SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> update test_pk set id = id+1 where id<10;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
2            a         
3            b         
4            c         
5            d         
6            e         

5 rows fetched.

SQL> update test_pk set id = id - 1 where id > 3;

CT-00729, Unique constraint violated
SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
2            a         
3            b         
4            c         
5            d         
6            e         

5 rows fetched.

SQL> update test_pk set id = id - 1;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> update test_pk set id = id - 1;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
0            a         
1            b         
2            c         
3            d         
4            e         

5 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> drop table test_pk;

Succeed.

SQL> 
SQL> drop table if exists test_pk;

Succeed.

SQL> create table test_pk(id int, val varchar(10)) crmode row;

Succeed.

SQL> create unique index idx_test_pk on test_pk(id) crmode row;

Succeed.

SQL> insert into test_pk values(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e');

5 rows affected.

SQL> commit;

Succeed.

SQL> update test_pk set id = id+1 where id<3;

CT-00729, Unique constraint violated
SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> update test_pk set id = id+1 where id<10;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
2            a         
3            b         
4            c         
5            d         
6            e         

5 rows fetched.

SQL> update test_pk set id = id - 1 where id > 3;

CT-00729, Unique constraint violated
SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
2            a         
3            b         
4            c         
5            d         
6            e         

5 rows fetched.

SQL> update test_pk set id = id - 1;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> update test_pk set id = id - 1;

5 rows affected.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
0            a         
1            b         
2            c         
3            d         
4            e         

5 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from test_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
3            c         
4            d         
5            e         

5 rows fetched.

SQL> drop table test_pk;

Succeed.

SQL> 
SQL> drop table if exists  trigger_tbl_032_1;

Succeed.

SQL> drop table if exists trigger_tbl_032;

Succeed.

SQL> create table trigger_tbl_032(c_id int,c_d_id int,c_w_id int,c_credit_lim numeric(12,2),c_first varchar(32),c_since timestamp);

Succeed.

SQL> alter table trigger_tbl_032 add constraint pk_trigger_032_001 primary key(c_id);

Succeed.

SQL> insert into trigger_tbl_032 values(1000,1,1,10,'c_firstaaaaaaaa',to_timestamp('2018-01-01 00:00:00.00','yyyy-mm-dd hh24:mi:ss.ff3'));

1 rows affected.

SQL> insert into trigger_tbl_032 values(2000,2,2,10,'c_firstbbbbbbbb',to_timestamp('2018-12-01 00:00:00.00','yyyy-mm-dd hh24:mi:ss.ff3'));

1 rows affected.

SQL> insert into trigger_tbl_032 values(3000,3,3,10,'c_firstcccccccc',to_timestamp('2018-12-30 00:00:00.00','yyyy-mm-dd hh24:mi:ss.ff3'));

1 rows affected.

SQL> 
SQL> create table trigger_tbl_032_1(c_id int,c_d_id int,c_w_id int);

Succeed.

SQL> alter table trigger_tbl_032_1 add constraint fk_trigger_032_001 foreign key(c_id) references trigger_tbl_032(c_id);

Succeed.

SQL> insert into trigger_tbl_032_1 values(1000,10,10);

1 rows affected.

SQL> insert into trigger_tbl_032_1 values(2000,20,20);

1 rows affected.

SQL> insert into trigger_tbl_032_1 values(3000,30,20);

1 rows affected.

SQL> 
SQL> commit;

Succeed.

SQL> 
SQL> --I2.创建表级before delete or update 行级触发器
SQL> create or replace trigger trg_aft_dml_032
  2 after delete or update of c_id on trigger_tbl_032 for each row
  3 begin
  4 if :old.c_id != :new.c_id then
  5 update trigger_tbl_032_1 set trigger_tbl_032_1.c_id=null
  6 where trigger_tbl_032_1.c_id=:old.c_id;
  7 end if;
  8 end;
  9 /

Succeed.

SQL> 
SQL> --I3.执行update和delete语句触发触发器()
SQL> update trigger_tbl_032 set c_id=c_id+1;

3 rows affected.

SQL> update trigger_tbl_032 set c_id=c_id-1;

3 rows affected.

SQL> update trigger_tbl_032 set c_id=1;

CT-00729, Unique constraint violated
SQL> update trigger_tbl_032 set c_id=1 where c_first like 'c_firsta%';

1 rows affected.

SQL> delete from trigger_tbl_032;

3 rows affected.

SQL> select c_id from trigger_tbl_032 order by 1;

C_ID        
------------

0 rows fetched.

SQL> select c_id from trigger_tbl_032_1 order by 1;

C_ID        
------------
            
            
            

3 rows fetched.

SQL> drop table trigger_tbl_032_1 purge;

Succeed.

SQL> drop table trigger_tbl_032 purge;

Succeed.

SQL> 
SQL> --test insert on duplicate key
SQL> drop table if exists test_duplicate_026;

Succeed.

SQL> create table test_duplicate_026(id int primary key); 

Succeed.

SQL> insert into test_duplicate_026 values(1) on duplicate key update id =16+10;

1 rows affected.

SQL> insert into test_duplicate_026 values(2) on duplicate key update id =16-10;

1 rows affected.

SQL> insert into test_duplicate_026 values(3) on duplicate key update id =16+10; 

1 rows affected.

SQL> insert into test_duplicate_026 values(4) on duplicate key update id =16-10; 

1 rows affected.

SQL> insert into test_duplicate_026 values(1) on duplicate key update id =2;

CT-00729, Unique constraint violated
SQL> select * from test_duplicate_026;

ID          
------------
1           
2           
3           
4           

4 rows fetched.

SQL> drop table test_duplicate_026 purge;

Succeed.

SQL> 
SQL> --test merge into
SQL> drop table if exists merge_org;

Succeed.

SQL> drop table if exists merge_dst;

Succeed.

SQL> create table merge_org(id int primary key, val int);

Succeed.

SQL> insert into merge_org values(1, 1), (2, 2), (3, 3);

3 rows affected.

SQL> commit;

Succeed.

SQL> create table merge_dst(id int, val int);

Succeed.

SQL> alter table merge_dst add constraint pk_merge_dst primary key(id);

Succeed.

SQL> insert into merge_dst values(1, 1),(2, 2);

2 rows affected.

SQL> commit;

Succeed.

SQL> merge into merge_dst d using merge_org o on (o.id = d.id) when matched then update set id = d.id+1 when not matched then insert (id, val) values(3, 3);

CT-00729, Unique constraint violated, index PK_MERGE_DST, duplicate key 3
SQL> select * from merge_dst order by id;

ID           VAL         
------------ ------------
1            1           
2            2           

2 rows fetched.

SQL> insert into merge_dst values(3,3);

1 rows affected.

SQL> merge into merge_dst d using merge_org o on (o.id = d.id) when matched then update set id = d.id+1 when not matched then insert (id, val) values(3, 3);

3 rows affected.

SQL> select * from merge_dst order by id;

ID           VAL         
------------ ------------
2            1           
3            2           
4            3           

3 rows fetched.

SQL> drop table merge_dst purge;

Succeed.

SQL> drop table merge_org purge;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_TRIG_1;

Succeed.

SQL> DROP TABLE IF EXISTS T_TRIG_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_TRIG_3;

Succeed.

SQL> CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE, primary key(F_INT1));

Succeed.

SQL> CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> CREATE TABLE T_TRIG_3 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> 
SQL> insert into  T_TRIG_1 values(1,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_1 values(2,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_1 values(3,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_1 values(4,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_1 values(5,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> 
SQL> insert into  T_TRIG_2 values(3,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_2 values(4,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_2 values(5,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_2 values(6,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> insert into  T_TRIG_2 values(7,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> 
SQL> CREATE OR REPLACE TRIGGER TRIG_BEFORE_STMT BEFORE UPDATE ON T_TRIG_1
  2 FOR EACH ROW
  3 BEGIN
  4   INSERT INTO T_TRIG_3 VALUES(null,null,null,null);
  5 END;
  6 /

Succeed.

SQL> 
SQL> merge into T_TRIG_1 hzy1 using (select * from T_TRIG_2)hzy2 on (hzy1.F_INT1 = hzy2.F_INT1)
  2 WHEN MATCHED THEN update set hzy1.F_INT1 = hzy1.F_INT1 + 1;

3 rows affected.

SQL> select * from T_TRIG_1 order by F_INT1;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
2            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
5            2            A                2017-12-11 14:08:00   
6            2            A                2017-12-11 14:08:00   

5 rows fetched.

SQL> select * from T_TRIG_1 where F_INT1 = 1;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   

1 rows fetched.

SQL> select * from T_TRIG_1 where F_INT1 = 2;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
2            2            A                2017-12-11 14:08:00   

1 rows fetched.

SQL> select * from T_TRIG_1 where F_INT1 = 4;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
4            2            A                2017-12-11 14:08:00   

1 rows fetched.

SQL> select * from T_TRIG_1 where F_INT1 = 5;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
5            2            A                2017-12-11 14:08:00   

1 rows fetched.

SQL> select * from T_TRIG_1 where F_INT1 = 6;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
6            2            A                2017-12-11 14:08:00   

1 rows fetched.

SQL> DROP TABLE IF EXISTS T_TRIG_1;

Succeed.

SQL> DROP TABLE IF EXISTS T_TRIG_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_TRIG_3;

Succeed.

SQL> 
SQL> --test split
SQL> drop table if exists test_split;

Succeed.

SQL> create table test_split(id int, name varchar(3890), score int);

Succeed.

SQL> create index ix_test_split on test_split(id, name);

Succeed.

SQL> create or replace procedure pro_init_split() as
  2     i integer;
  3 begin
  4     for i in 1..10 loop
  5         execute immediate 'insert into test_split values(20 - 2 * '||i||', lpad(''a'', 1000, ''a''), 1)';
  6     end loop;
  7     insert into test_split values(13, lpad('a', 3890, 'a'), 1);
  8     commit;
  9 end;
 10 /

Succeed.

SQL> 
SQL> declare
  2     i integer;
  3 begin
  4     for i in 1..10 loop
  5         delete from test_split;
  6         execute immediate 'truncate table test_split purge';
  7         execute immediate ' call pro_init_split()';
  8         execute immediate 'insert into test_split values(1 + 2 * '||i||', lpad(''a'', 3890, ''a''), 1)';
  9     end loop;
 10     commit;
 11 end;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table test_split purge;

Succeed.

SQL> 
SQL> drop table if exists tablename1;

Succeed.

SQL> create table tablename1(id int auto_increment primary key,  b NVARCHAR(3900), text NVARCHAR(4080), c VARCHAR(660 char), d VARCHAR(260 char), e integer);

Succeed.

SQL> CREATE INDEX index_nv1 ON tablename1(text);

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> CREATE INDEX index_nv4 ON tablename1(id, e, b);

Succeed.

SQL> CREATE INDEX index_nv3 ON tablename1(d);

Succeed.

SQL> CREATE INDEX index_nv2 ON tablename1(c);

Succeed.

SQL> CREATE INDEX index_nv0 ON tablename1(upper(d));

Succeed.

SQL> insert into tablename1 values(1,  lpad('a', 3871, 'a'), lpad('a', 3900, 'a'),  lpad('a', 650, 'a'),  lpad('a', 30, 'a'), 1);

1 rows affected.

SQL> insert into tablename1(id, b, e) values(2, '测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符', 1);

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> insert into tablename1(id, b, e) values(2, '测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测试宽字符测', 1);

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> commit;

Succeed.

SQL> CREATE INDEX index_nv5 ON tablename1(upper(d), b);

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> drop table if exists tablename1;

Succeed.

SQL> 
SQL> drop table if exists initrans_a;

Succeed.

SQL> create table initrans_a (i char(10));

Succeed.

SQL> create index idx_trans_1 on initrans_a(i) initrans 167;

Succeed.

SQL> create or replace procedure pro_init_trans() as
  2 i integer;
  3 begin
  4    for i in 1..156 loop
  5        insert into initrans_a values('zzzzz');
  6   end loop;
  7 end;
  8 /

Succeed.

SQL> call pro_init_trans();

PL/SQL procedure successfully completed.

SQL> insert into initrans_a values('zaaaa');

1 rows affected.

SQL> commit;

Succeed.

SQL> drop table initrans_a;

Succeed.

SQL> 
SQL> drop table if exists initrans_row;

Succeed.

SQL> create table initrans_row (i char(10)) crmode row;

Succeed.

SQL> create index idx_trans_2 on initrans_row(i) initrans 165 crmode row;

Succeed.

SQL> create or replace procedure pro_init_trans_row() as
  2 i integer;
  3 begin
  4    for i in 1..119 loop
  5        insert into initrans_row values('zzzzz');
  6   end loop;
  7 end;
  8 /

Succeed.

SQL> call pro_init_trans_row();

PL/SQL procedure successfully completed.

SQL> insert into initrans_row values('zaaaa');

1 rows affected.

SQL> commit;

Succeed.

SQL> drop table initrans_row;

Succeed.

SQL> drop table if exists sys.tbl_duplicate;

Succeed.

SQL> create table sys.tbl_duplicate(col_int int,col_binary1 binary(100));

Succeed.

SQL> alter table sys.tbl_duplicate add constraint cons_pk_int1 primary key(col_binary1);   

Succeed.

SQL> insert into sys.tbl_duplicate values  (1, 'c0427c0dd8474651a29230d3fc898bc9');

1 rows affected.

SQL> insert into sys.tbl_duplicate values  (1, 'c0427c0dd8474651a29230d3fc898bc9');

CT-00729, Unique constraint violated, index CONS_PK_INT1, duplicate key 633034323763306464383437343635316132393233306433666338393862633900000000000000000000000000000000000000000000000000000000000000
SQL> drop table if exists sys.tbl_duplicate;

Succeed.

SQL> create table sys.tbl_duplicate(col_char varchar(10),col_varchar1 varchar(100));

Succeed.

SQL> create unique index idx_duplicate on sys.tbl_duplicate(col_char, col_varchar1);

Succeed.

SQL> insert into sys.tbl_duplicate values  (NULL, 'c0427c0dd8474651a29230d3fc898bc9');

1 rows affected.

SQL> insert into sys.tbl_duplicate values  (NULL, 'c0427c0dd8474651a29230d3fc898bc9');

CT-00729, Unique constraint violated, index IDX_DUPLICATE, duplicate key null-c0427c0dd8474651a29230d3fc898bc9
SQL> drop table if exists sys.tbl_duplicate;

Succeed.

SQL> drop table if exists table_errno;

Succeed.

SQL> create table table_errno (i int);

Succeed.

SQL> create index index_errno on table_errno(i);

Succeed.

SQL> create index index_errno on table_errno(i) online;

CT-00726, The column has been indexed by INDEX_ERRNO.
SQL> create index index_errno on table_errno(i);

CT-00726, The column has been indexed by INDEX_ERRNO.
SQL> drop table if exists table_errno;

Succeed.

SQL> --duplicate primary key
SQL> drop table if exists hsf;

Succeed.

SQL> create table hsf(col1 int, col2 int,col3 int,col4 int);

Succeed.

SQL> create unique index test_hsf on hsf(col1,col2);

Succeed.

SQL> ALTER TABLE hsf ADD PRIMARY KEY(col1,col2);

Succeed.

SQL> ALTER TABLE hsf ADD PRIMARY KEY(col1,col3,col2);

CT-00640, The table had more than one primary key
SQL> drop table if exists hsf;

Succeed.

SQL> 
SQL> --loss extent when rebuild index
SQL> CREATE TABLESPACE IDX_SEG_TEST_SPC DATAFILE 'IDX_SEG_TEST_FILE' SIZE 16M;

Succeed.

SQL> CREATE TABLE IDX_SEG_TEST_TB (A INT, B INT) TABLESPACE IDX_SEG_TEST_SPC;

Succeed.

SQL> CREATE INDEX IDX_SEG_TEST_IDX ON IDX_SEG_TEST_TB(A, B);

Succeed.

SQL> INSERT INTO IDX_SEG_TEST_TB VALUES(1,2);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE IDX_SEG_TEST_TB MODIFY (A BINARY_INTEGER NOT NULL, B BINARY_INTEGER NOT NULL);

Succeed.

SQL> 
SQL> SET SERVEROUT ON;

ON
SQL> DECLARE
  2     SIZE1 BIGINT;
  3     SIZE2 BIGINT;
  4 BEGIN
  5 	SELECT USED_SIZE INTO SIZE1 FROM DBA_TABLESPACES WHERE TABLESPACE_NAME='IDX_SEG_TEST_SPC';
  6 	SELECT SUM(BYTES) INTO SIZE2 FROM DBA_SEGMENTS WHERE TABLESPACE_NAME = 'IDX_SEG_TEST_SPC';
  7 	dbe_output.print_line(SIZE1-SIZE2);
  8 END;
  9 /

16384

PL/SQL procedure successfully completed.

SQL> drop TABLESPACE IDX_SEG_TEST_SPC including contents cascade constraints;

Succeed.

SQL> 
SQL> --SR.TMP.0000000365  Index selection optimization
SQL> drop table if exists index_t1;

Succeed.

SQL> create table index_t1 (a int, b int, c int, d int);

Succeed.

SQL> create index index1 on index_t1(a,b);

Succeed.

SQL> create index index2 on index_t1(a,c,d);

Succeed.

SQL> explain select * from index_t1 where a > 10 and c > 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> 
SQL> drop index index1 on index_t1;

Succeed.

SQL> drop index index2 on index_t1;

Succeed.

SQL> create index index1 on index_t1(a,b,d);

Succeed.

SQL> create index index2 on index_t1(a,b,c);  

Succeed.

SQL> explain select * from index_t1 where a > 10 and c > 10 and b < 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10 AND B < 10                     

10 rows fetched.

SQL> 
SQL> drop index index1 on index_t1;

Succeed.

SQL> drop index index2 on index_t1;

Succeed.

SQL> create index index1 on index_t1(a,b,c,d);

Succeed.

SQL> create index index2 on index_t1(a,c);  

Succeed.

SQL> explain select * from index_t1 where a > 10 and c > 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> 
SQL> drop index index1 on index_t1;

Succeed.

SQL> drop index index2 on index_t1;

Succeed.

SQL> create index index1 on index_t1(b,a);

Succeed.

SQL> create index index2 on index_t1(a,b);  

Succeed.

SQL> explain select * from index_t1 where a > 10 and b < 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX1   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND B < 10                                

10 rows fetched.

SQL> 
SQL> drop index index1 on index_t1;

Succeed.

SQL> drop index index2 on index_t1;

Succeed.

SQL> create index index1 on index_t1(a,c);

Succeed.

SQL> create index index2 on index_t1(a,c,d);  

Succeed.

SQL> explain select * from index_t1 where a > 10 and c > 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX1   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> explain select * from index_t1 where a > 10 and c > 10 order by a, c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX1   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> explain select d from index_t1 where a > 10 and c > 10 order by a, c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name     | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | INDEX2   |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> explain select * from index_t1 where a > 10 and c > 10 order by a, c, d;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> 
SQL> drop index index1 on index_t1;

Succeed.

SQL> drop index index2 on index_t1;   

Succeed.

SQL> create index index1 on index_t1(a,c,d);

Succeed.

SQL> create index index2 on index_t1(a,c,b);

Succeed.

SQL> explain select d from index_t1 where a > 10 and c > 10 order by a, c, b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 10 AND C > 10                                

10 rows fetched.

SQL> 
SQL> drop table if exists index_t1;

Succeed.

SQL> drop table if exists index_t2;

Succeed.

SQL> create table index_t1 (a int, b int, c int, d int);

Succeed.

SQL> create table index_t2 (a int, b int, c int, d int);

Succeed.

SQL> create index index1 on index_t1(a,b);

Succeed.

SQL> create index index2 on index_t1(a,c,d);

Succeed.

SQL> create index index3 on index_t2(a,b);

Succeed.

SQL> create index index4 on index_t2(a,c,d);

Succeed.

SQL> explain select * from index_t1,index_t2 where index_t1.a > 10 and index_t1.c > 10 and index_t2.a > 10 and index_t2.c < 10; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T2 |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | INDEX4   |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: INDEX_T1.A > 10 AND INDEX_T1.C > 10              
   5 - access: INDEX_T2.A > 10 AND INDEX_T2.C < 10              

14 rows fetched.

SQL> drop table if exists index_t1;

Succeed.

SQL> drop table if exists index_t2;

Succeed.

SQL> 
SQL> --DTS2019061707095
SQL> Drop table if exists t_test_index1;

Succeed.

SQL> Drop index if exists index11 on t_test_index1;

Succeed.

SQL> Drop index if exists index22 on t_test_index1;

Succeed.

SQL> create table t_test_index1(a int, b number, c bool, d varchar(10), e varchar(1000), f date);

Succeed.

SQL> Create index index11 on t_test_index1(a,f,b);

Succeed.

SQL> Create index index22 on t_test_index1(c,f,d,b);

Succeed.

SQL> Explain plan for Select * from t_test_index1 where a in (1,2) and c in (true,false) and d = 'abcergk' and b > 0  and f = '2011-10-10' order by a,f,b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |               |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |               |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_TEST_INDEX1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | INDEX22       |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: A IN(1, 2)                                       
   3 - access: C IN(TRUE, FALSE) AND D = 'abcergk' AND B > 0 AND F = CAST('2011-10-10' AS DATE)

12 rows fetched.

SQL> Drop table t_test_index1;

Succeed.

SQL> 
SQL> ----DTS2019061208763
SQL> Drop table if exists index_t1;

Succeed.

SQL> create table index_t1(a int, b int, c int, d int, e int, f int);

Succeed.

SQL> ALTER TABLE index_t1 ADD CONSTRAINT PK_I_FIXEDNETWORKLTP PRIMARY KEY (a);

Succeed.

SQL> Create index index2 on index_t1(b,a);

Succeed.

SQL> Explain Select * from index_t1 where a >0 and b in (3,1,2) order by a limit 4;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |          |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | INDEX2   |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: A > 0 AND B IN(3, 1, 2)                          

12 rows fetched.

SQL> 
SQL> Drop table if exists index_t1;

Succeed.

SQL> create table index_t1(a int, b int, c int, d int, e int, f int);

Succeed.

SQL> Create index index3 on index_t1( c );

Succeed.

SQL> Create index index4 on index_t1( b, a, c );

Succeed.

SQL> Explain Select * from index_t1 where a in (1,2) and b = 3 and c > 0  order by c limit 1 offset 0; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |          |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | INDEX4   |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: B = 3 AND A IN(1, 2) AND C > 0                   

12 rows fetched.

SQL> 
SQL> Drop table if exists index_t1;

Succeed.

SQL> create table index_t1(a int, b int, c int, d int, e int, f int);

Succeed.

SQL> Create index index5 on index_t1(a,b);

Succeed.

SQL> Create index index6 on index_t1(c,d,b);

Succeed.

SQL> Explain Select * from index_t1 where a in (1,2) and c in (1,3,2) and d = 3 and b > 0  order by a,b limit 3 offset 0; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |          |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | INDEX6   |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: A IN(1, 2)                                       
   4 - access: D = 3 AND B > 0 AND C IN(1, 3, 2)                

13 rows fetched.

SQL> 
SQL> Drop table if exists index_t1;

Succeed.

SQL> create table index_t1(a int, b int, c int, d int, e int, f int);

Succeed.

SQL> Create index index7 on index_t1(a,f,b);

Succeed.

SQL> Create index index8 on index_t1(c,f,d,b);

Succeed.

SQL> Explain Select * from index_t1 where a in (1,2) and c in (1,3,2) and d = 3 and b > 0  and f = 0 order by a,f,b ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | INDEX_T1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | INDEX8   |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: A IN(1, 2)                                       
   3 - access: F = 0 AND C IN(1, 3, 2) AND B > 0 AND D = 3      

12 rows fetched.

SQL> Drop table index_t1;

Succeed.

SQL> 
SQL> drop table if exists index_t2;

Succeed.

SQL> create table index_t2 (id int, name varchar(1024));

Succeed.

SQL> create unique index i1 on index_t2 (id);

Succeed.

SQL> create index i2 on index_t2 (name, id);

Succeed.

SQL> explain select * from index_t2 where (id > 1 or id is null) and name in ('a', 'b') order by id asc limit 1001 offset 0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name     | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |          |      |      |       |        |
| 1   |   QUERY LIMIT                     |       |          |      |      |       |        |
| 2   |     QUERY SORT ORDER BY           |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | INDEX_T2 |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | I2       |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: NAME IN('a', 'b') AND ID > 1 OR ID IS NULL       

12 rows fetched.

SQL> explain select * from index_t2 where (id > 1 or id is null) and name in ('a', 'b') order by id asc offset 0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name     | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |          |      |      |       |        |
| 1   |   QUERY LIMIT                     |       |          |      |      |       |        |
| 2   |     QUERY SORT ORDER BY           |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | INDEX_T2 |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | I2       |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: NAME IN('a', 'b') AND ID > 1 OR ID IS NULL       

12 rows fetched.

SQL> drop table index_t2;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP;

Succeed.

SQL> CREATE TABLE `I_FIXEDNETWORKLTP`
  2 (
  3   `id` VARBINARY(16) NOT NULL,
  4   `class_Id` BINARY_BIGINT NOT NULL,
  5   `collectorId` VARCHAR(36 BYTE),
  6   `tenantId` VARCHAR(64 BYTE),
  7   `regionId` VARBINARY(16),
  8   `name` VARCHAR(765 BYTE) NOT NULL,
  9   `nativeId` VARCHAR(765 BYTE),
 10   `ownerId` BINARY_BIGINT,
 11   `FanVoipUser__telNumber` VARCHAR(384 BYTE),
 12   `alias` VARCHAR(765 BYTE),
 13   `IP__addrv4` VARCHAR(96 BYTE),
 14   `Plan__usageState` VARCHAR(96 BYTE)
 15 );

Succeed.

SQL> ALTER TABLE I_FIXEDNETWORKLTP ADD CONSTRAINT PK_I_FIXEDNETWORKLTP PRIMARY KEY (`id`);

Succeed.

SQL> CREATE INDEX `IDXFIXEDNETWORKLTP_FANVOIPUSER_TELNUMBER_2130` ON `I_FIXEDNETWORKLTP`(`FanVoipUser__telNumber`, `id`);

Succeed.

SQL> CREATE INDEX `IDXFIXEDNETWORKLTP_IP_ADDRV4_2130` ON `I_FIXEDNETWORKLTP`(`IP__addrv4`, `id`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_ALIAS_ID` ON `I_FIXEDNETWORKLTP`(`alias`, `id`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_CLASS_ID` ON `I_FIXEDNETWORKLTP`(`class_Id`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_COLLECTORID` ON `I_FIXEDNETWORKLTP`(`collectorId`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_NAME_ID` ON `I_FIXEDNETWORKLTP`(`name`, `id`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_NATIVEID_OWNERID_REGIONID` ON `I_FIXEDNETWORKLTP`(`nativeId`, `ownerId`, `regionId`);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_TENANTID_COLLECTORID` ON `I_FIXEDNETWORKLTP`(`tenantId`, `collectorId`);

Succeed.

SQL> explain
  2 SELECT `id`,ROWNUM FROM I_FIXEDNETWORKLTP I WHERE ((
  3 (((I.`id`  > UNHEX('11E84A9640970A1A82CC005056810409')) )) AND 
  4 ((I.`name` IN (
  5 unhex('11E840A1517340FD9167005056810409'),
  6 unhex('11E840A151867ADE9167005056810409'),
  7 unhex('11E840A1573C6BE89167005056810409')
  8 )))))   order by `id` limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                 | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                      |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                      |      |      |       |        |
| 2   |     ROWNUM COUNT                   |       |                      |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I  |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | PK_I_FIXEDNETWORKLTP |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.name IN('11E840A1517340FD9167005056810409', '11E840A151867ADE9167005056810409', '11E840A1573C6BE89167005056810409')
   4 - access: I.id > '11E84A9640970A1A82CC005056810409'        

13 rows fetched.

SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP_PARTITION_LOCAL;

Succeed.

SQL> CREATE TABLE `I_FIXEDNETWORKLTP_PARTITION_LOCAL`
  2 (
  3   `id` varchar(32) NOT NULL,
  4   `name` VARCHAR(765 BYTE) NOT NULL,
  5   `remark` VARCHAR(3072 BYTE),
  6   `nativeId` VARCHAR(765 BYTE),
  7   `ownerId` BINARY_BIGINT
  8 )
  9 partition by hash (`id`)
 10 (
 11 partition part_00 ,
 12 partition part_01
 13 );

Succeed.

SQL> ALTER TABLE I_FIXEDNETWORKLTP_PARTITION_LOCAL ADD CONSTRAINT PK_I_FIXEDNETWORKLTP_PARTITION_LOCAL PRIMARY KEY(`id`)  
  2 USING INDEX (CREATE INDEX PK_I_FIXEDNETWORKLTP_PARTITION_LOCAL ON I_FIXEDNETWORKLTP_PARTITION_LOCAL(`id`) local);

Succeed.

SQL> CREATE INDEX `IDX_I_FIXEDNETWORKLTP_LOCALNAME_ID` ON `I_FIXEDNETWORKLTP_PARTITION_LOCAL`(`name`, `id`) local;

Succeed.

SQL> explain SELECT  `name`,`remark` FROM I_FIXEDNETWORKLTP_Partition_local I WHERE I.`name` like 'TestLTP2%' ORDER BY I.`name` ASC , I.`id` ASC LIMIT 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                    | Owner | Name                                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                               |       |                                     |      |      |       |        |
| 1   |   QUERY LIMIT                                  |       |                                     |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM                 |       |                                     |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | I_FIXEDNETWORKLTP_PARTITION_LOCAL I |      |      |       |        |
| 4   |         INDEX RANGE SCAN                       | SYS   | IDX_I_FIXEDNETWORKLTP_LOCALNAME_ID  |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: I.name LIKE 'TestLTP2%'                          

12 rows fetched.

SQL> explain SELECT  `name`,`remark`  FROM I_FIXEDNETWORKLTP_Partition_local I WHERE I.`name` like 'TestLTP2%'  and I.`id` > 'abc' ORDER BY I.`id` ASC LIMIT 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                    | Owner | Name                                 | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                               |       |                                      |      |      |       |        |
| 1   |   QUERY LIMIT                                  |       |                                      |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM                 |       |                                      |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | I_FIXEDNETWORKLTP_PARTITION_LOCAL I  |      |      |       |        |
| 4   |         INDEX RANGE SCAN                       | SYS   | PK_I_FIXEDNETWORKLTP_PARTITION_LOCAL |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.name LIKE 'TestLTP2%'                          
   4 - access: I.id > 'abc'                                     

13 rows fetched.

SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP_PARTITION_LOCAL;

Succeed.

SQL> 
SQL> --DTS2019071012563
SQL> drop table if exists rbo_table1;

Succeed.

SQL> drop table if exists rbo_table2;

Succeed.

SQL> drop table if exists rbo_table3;

Succeed.

SQL> create table rbo_table1(a int, b int, c int, d int, e int);

Succeed.

SQL> create table rbo_table2(a int, b int, c int, d int, e int);

Succeed.

SQL> create table rbo_table3(a int, b int, c int, d int, e int);

Succeed.

SQL> create index rbo_index_2 on rbo_table3(a,b,c);

Succeed.

SQL> create index rbo_index_1 on rbo_table3(a);

Succeed.

SQL> 
SQL> explain select * from rbo_table3 where a > 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | RBO_TABLE3  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | RBO_INDEX_1 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: A > 1                                            

10 rows fetched.

SQL> explain select * from rbo_table1, rbo_table2 where exists(select b from rbo_table3  where rbo_table3.a = rbo_table1.a );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name        | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |             |      |      |       |        |
| 1   |   NESTED LOOPS                    |       |             |      |      |       |        |
| 2   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
| 6   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 7   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE2  |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 9   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM RBO_TABLE3)                 
   5 - access: RBO_TABLE3.A = RBO_TABLE1.A                      
   9 - access: RBO_TABLE3.A = RBO_TABLE1.A                      

19 rows fetched.

SQL> explain select * from rbo_table1, rbo_table2 where exists(select b from rbo_table3  where rbo_table3.a = rbo_table1.a and rbo_table3.c > 0);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name        | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |             |      |      |       |        |
| 1   |   NESTED LOOPS                    |       |             |      |      |       |        |
| 2   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
| 6   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 7   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE2  |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 9   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM RBO_TABLE3 WHERE RBO_TABLE3.C > 0)
   5 - access: RBO_TABLE3.A = RBO_TABLE1.A AND RBO_TABLE3.C > 0 
   9 - access: RBO_TABLE3.A = RBO_TABLE1.A AND RBO_TABLE3.C > 0 

19 rows fetched.

SQL> explain select * from rbo_table1, rbo_table2 where exists(select 1 from rbo_table3  where rbo_table3.c > 0 and rbo_table3.a = rbo_table1.a  order by a, b);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name        | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |             |      |      |       |        |
| 1   |   NESTED LOOPS                    |       |             |      |      |       |        |
| 2   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE1  |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
| 6   |     KERNEL FILTER                 |       |             |      |      |       |        |
| 7   |       TABLE ACCESS FULL           | SYS   | RBO_TABLE2  |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ONLY  | SYS   | RBO_TABLE3  |      |      |       |        |
| 9   |         INDEX RANGE SCAN          | SYS   | RBO_INDEX_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM RBO_TABLE3 WHERE RBO_TABLE3.C > 0)
   5 - access: RBO_TABLE3.A = RBO_TABLE1.A AND RBO_TABLE3.C > 0 
   9 - access: RBO_TABLE3.A = RBO_TABLE1.A AND RBO_TABLE3.C > 0 

19 rows fetched.

SQL> drop table rbo_table1;

Succeed.

SQL> drop table rbo_table2;

Succeed.

SQL> drop table rbo_table3;

Succeed.

SQL> 
SQL> --test index print duplicate key
SQL> DROP TABLE IF EXISTS test_dupkey_print;

Succeed.

SQL> CREATE TABLE test_dupkey_print(c1 varchar(1000), c2 int);

Succeed.

SQL> CREATE UNIQUE INDEX ix_test_dupkey_print ON test_dupkey_print(c1, c2);

Succeed.

SQL> INSERT INTO test_dupkey_print VALUES(LPAD('A',1000,'A'), 1);

1 rows affected.

SQL> INSERT INTO test_dupkey_print VALUES(LPAD('A',1000,'A'), 1);

CT-00729, Unique constraint violated, index IX_TEST_DUPKEY_PRINT, duplicate key AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-1
SQL> DROP TABLE test_dupkey_print PURGE;

Succeed.

SQL> 
SQL> conn / as sysdba

connected.

SQL> drop user if exists liu_rename_index cascade;

Succeed.

SQL> create user liu_rename_index identified by Lh00420062;

Succeed.

SQL> grant dba to liu_rename_index;

Succeed.

SQL> conn liu_rename_index/Lh00420062@127.0.0.1:1611

connected.

SQL> 
SQL> drop table if exists rename_index_t1;

Succeed.

SQL> create table rename_index_t1(a int, c varchar(100));

Succeed.

SQL> insert into rename_index_t1 values(10,'liu');

1 rows affected.

SQL> create index idx1 on rename_index_t1(a);

Succeed.

SQL> select INDEX_NAME from sys.db_indexes where owner=upper('liu_rename_index');

INDEX_NAME                                                      
----------------------------------------------------------------
IDX1                                                            

1 rows fetched.

SQL> 
SQL> drop table if exists tt1;

Succeed.

SQL> drop table if exists tt2;

Succeed.

SQL> create table tt1(a int,b int);

Succeed.

SQL> create index liu_idx1 on tt1(a);

Succeed.

SQL> drop index liu_idx1 on tt2;

CT-00843, The table or view LIU_RENAME_INDEX.TT2 does not exist.
SQL> drop index liu_idx2 on tt1;

CT-00830, Index LIU_RENAME_INDEX.LIU_IDX2 does not exist
SQL> drop index liu_idx1 on tt1;

Succeed.

SQL> drop table if exists tt1;

Succeed.

SQL> drop table if exists tt2;

Succeed.

SQL> 
SQL> conn / as sysdba

connected.

SQL> alter index liu_rename_index.idx1 on rename_index_t1 rename to idx_other1;

Succeed.

SQL> select INDEX_NAME  from sys.db_indexes where owner=upper('liu_rename_index');

INDEX_NAME                                                      
----------------------------------------------------------------
IDX_OTHER1                                                      

1 rows fetched.

SQL> drop user if exists liu_rename_index cascade;

Succeed.

SQL> 
SQL> drop user if exists test_index;

Succeed.

SQL> create user test_index identified by 'Cantian_234';

Succeed.

SQL> grant dba to test_index;

Succeed.

SQL> conn test_index/Cantian_234@127.0.0.1:1611

connected.

SQL> drop table if exists a;

Succeed.

SQL> create table a(id int);

Succeed.

SQL> create index ix_a on a(id);

Succeed.

SQL> insert into a values(10);

1 rows affected.

SQL> create tablespace new_space datafile 'new_space' size 128M;

Succeed.

SQL> truncate table a;

Succeed.

SQL> select index_name, tablespace_name from user_indexes where index_name='IX_A';

INDEX_NAME                                                       TABLESPACE_NAME                                                 
---------------------------------------------------------------- ----------------------------------------------------------------
IX_A                                                             USERS                                                           

1 rows fetched.

SQL> alter index ix_a on a rebuild tablespace new_space;

Succeed.

SQL> flashback table a to before truncate;

Succeed.

SQL> select index_name, tablespace_name from user_indexes where index_name='IX_A';

INDEX_NAME                                                       TABLESPACE_NAME                                                 
---------------------------------------------------------------- ----------------------------------------------------------------
IX_A                                                             USERS                                                           

1 rows fetched.

SQL> drop table a;

Succeed.

SQL> drop tablespace new_space INCLUDING CONTENTS AND DATAFILES;

Succeed.

SQL> conn / as sysdba

connected.

SQL> drop user test_index cascade;

Succeed.

SQL> drop user test_index;

CT-00781, The user TEST_INDEX does not exist.
SQL> 
SQL> drop table if exists match_cond;

Succeed.

SQL> create table match_cond(c1 int, c2 int, c3 int, c4 int, c5 int);

Succeed.

SQL> create index ix_match_cond on match_cond(c1, c2, c3, c4) crmode page;

Succeed.

SQL> create or replace procedure load_data() as
  2     a int;
  3     b int;
  4     c int;
  5     d int;
  6 begin
  7     for a in 1..10 loop
  8         for b in 1..10 loop
  9             for c in 1..10 loop
 10                 for d in 1..10 loop
 11                     execute immediate 'insert into match_cond values('||a||', '||b||', '||c||', '||d||', 1)';
 12                 end loop;
 13             end loop;
 14         end loop;
 15     end loop;
 16     commit;
 17 end;
 18 /

Succeed.

SQL> 
SQL> call load_data();

PL/SQL procedure successfully completed.

SQL> 
SQL> drop index ix_match_cond on match_cond;

Succeed.

SQL> create index ix_match_cond on match_cond(c1, c2, c3, c4) crmode row;

Succeed.

SQL> select * from match_cond where c1>3 and c1<5 and c2>3 and c2<5 and c4>5 order by c1, c2, c3, c4;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
4            4            1            6            1           
4            4            1            7            1           
4            4            1            8            1           
4            4            1            9            1           
4            4            1            10           1           
4            4            2            6            1           
4            4            2            7            1           
4            4            2            8            1           
4            4            2            9            1           
4            4            2            10           1           
4            4            3            6            1           
4            4            3            7            1           
4            4            3            8            1           
4            4            3            9            1           
4            4            3            10           1           
4            4            4            6            1           
4            4            4            7            1           
4            4            4            8            1           
4            4            4            9            1           
4            4            4            10           1           
4            4            5            6            1           
4            4            5            7            1           
4            4            5            8            1           
4            4            5            9            1           
4            4            5            10           1           
4            4            6            6            1           
4            4            6            7            1           
4            4            6            8            1           
4            4            6            9            1           
4            4            6            10           1           
4            4            7            6            1           
4            4            7            7            1           
4            4            7            8            1           
4            4            7            9            1           
4            4            7            10           1           
4            4            8            6            1           
4            4            8            7            1           
4            4            8            8            1           
4            4            8            9            1           
4            4            8            10           1           
4            4            9            6            1           
4            4            9            7            1           
4            4            9            8            1           
4            4            9            9            1           
4            4            9            10           1           
4            4            10           6            1           
4            4            10           7            1           
4            4            10           8            1           
4            4            10           9            1           
4            4            10           10           1           

50 rows fetched.

SQL> select * from match_cond where c1=3 and c2=3 and c4>5 order by c1, c2, c3, c4;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
3            3            1            6            1           
3            3            1            7            1           
3            3            1            8            1           
3            3            1            9            1           
3            3            1            10           1           
3            3            2            6            1           
3            3            2            7            1           
3            3            2            8            1           
3            3            2            9            1           
3            3            2            10           1           
3            3            3            6            1           
3            3            3            7            1           
3            3            3            8            1           
3            3            3            9            1           
3            3            3            10           1           
3            3            4            6            1           
3            3            4            7            1           
3            3            4            8            1           
3            3            4            9            1           
3            3            4            10           1           
3            3            5            6            1           
3            3            5            7            1           
3            3            5            8            1           
3            3            5            9            1           
3            3            5            10           1           
3            3            6            6            1           
3            3            6            7            1           
3            3            6            8            1           
3            3            6            9            1           
3            3            6            10           1           
3            3            7            6            1           
3            3            7            7            1           
3            3            7            8            1           
3            3            7            9            1           
3            3            7            10           1           
3            3            8            6            1           
3            3            8            7            1           
3            3            8            8            1           
3            3            8            9            1           
3            3            8            10           1           
3            3            9            6            1           
3            3            9            7            1           
3            3            9            8            1           
3            3            9            9            1           
3            3            9            10           1           
3            3            10           6            1           
3            3            10           7            1           
3            3            10           8            1           
3            3            10           9            1           
3            3            10           10           1           

50 rows fetched.

SQL> select * from match_cond where c1>9 and c2 > 9 and c3>5 and c4 > 5;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
10           10           6            6            1           
10           10           6            7            1           
10           10           6            8            1           
10           10           6            9            1           
10           10           6            10           1           
10           10           7            6            1           
10           10           7            7            1           
10           10           7            8            1           
10           10           7            9            1           
10           10           7            10           1           
10           10           8            6            1           
10           10           8            7            1           
10           10           8            8            1           
10           10           8            9            1           
10           10           8            10           1           
10           10           9            6            1           
10           10           9            7            1           
10           10           9            8            1           
10           10           9            9            1           
10           10           9            10           1           
10           10           10           6            1           
10           10           10           7            1           
10           10           10           8            1           
10           10           10           9            1           
10           10           10           10           1           

25 rows fetched.

SQL> select * from match_cond where c1<2 and c2 < 2 and c3<5 and c4 < 5;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
1            1            1            1            1           
1            1            1            2            1           
1            1            1            3            1           
1            1            1            4            1           
1            1            2            1            1           
1            1            2            2            1           
1            1            2            3            1           
1            1            2            4            1           
1            1            3            1            1           
1            1            3            2            1           
1            1            3            3            1           
1            1            3            4            1           
1            1            4            1            1           
1            1            4            2            1           
1            1            4            3            1           
1            1            4            4            1           

16 rows fetched.

SQL> 
SQL> select * from match_cond where c1>3 and c1<5 and c2>3 and c2<5 and c4>5 order by c1, c2, c3, c4 desc;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
4            4            1            10           1           
4            4            1            9            1           
4            4            1            8            1           
4            4            1            7            1           
4            4            1            6            1           
4            4            2            10           1           
4            4            2            9            1           
4            4            2            8            1           
4            4            2            7            1           
4            4            2            6            1           
4            4            3            10           1           
4            4            3            9            1           
4            4            3            8            1           
4            4            3            7            1           
4            4            3            6            1           
4            4            4            10           1           
4            4            4            9            1           
4            4            4            8            1           
4            4            4            7            1           
4            4            4            6            1           
4            4            5            10           1           
4            4            5            9            1           
4            4            5            8            1           
4            4            5            7            1           
4            4            5            6            1           
4            4            6            10           1           
4            4            6            9            1           
4            4            6            8            1           
4            4            6            7            1           
4            4            6            6            1           
4            4            7            10           1           
4            4            7            9            1           
4            4            7            8            1           
4            4            7            7            1           
4            4            7            6            1           
4            4            8            10           1           
4            4            8            9            1           
4            4            8            8            1           
4            4            8            7            1           
4            4            8            6            1           
4            4            9            10           1           
4            4            9            9            1           
4            4            9            8            1           
4            4            9            7            1           
4            4            9            6            1           
4            4            10           10           1           
4            4            10           9            1           
4            4            10           8            1           
4            4            10           7            1           
4            4            10           6            1           

50 rows fetched.

SQL> select * from match_cond where c1=3 and c2=3 and c4>5 order by c1, c2, c3, c4 desc;

C1           C2           C3           C4           C5          
------------ ------------ ------------ ------------ ------------
3            3            1            10           1           
3            3            1            9            1           
3            3            1            8            1           
3            3            1            7            1           
3            3            1            6            1           
3            3            2            10           1           
3            3            2            9            1           
3            3            2            8            1           
3            3            2            7            1           
3            3            2            6            1           
3            3            3            10           1           
3            3            3            9            1           
3            3            3            8            1           
3            3            3            7            1           
3            3            3            6            1           
3            3            4            10           1           
3            3            4            9            1           
3            3            4            8            1           
3            3            4            7            1           
3            3            4            6            1           
3            3            5            10           1           
3            3            5            9            1           
3            3            5            8            1           
3            3            5            7            1           
3            3            5            6            1           
3            3            6            10           1           
3            3            6            9            1           
3            3            6            8            1           
3            3            6            7            1           
3            3            6            6            1           
3            3            7            10           1           
3            3            7            9            1           
3            3            7            8            1           
3            3            7            7            1           
3            3            7            6            1           
3            3            8            10           1           
3            3            8            9            1           
3            3            8            8            1           
3            3            8            7            1           
3            3            8            6            1           
3            3            9            10           1           
3            3            9            9            1           
3            3            9            8            1           
3            3            9            7            1           
3            3            9            6            1           
3            3            10           10           1           
3            3            10           9            1           
3            3            10           8            1           
3            3            10           7            1           
3            3            10           6            1           

50 rows fetched.

SQL> drop table match_cond purge;

Succeed.

SQL> 
SQL> create user test_index identified by 'Cantian_234';

Succeed.

SQL> grant dba to test_index;

Succeed.

SQL> conn test_index/Cantian_234@127.0.0.1:1611

connected.

SQL> drop table if exists a;

Succeed.

SQL> create table a(id int);

Succeed.

SQL> create index ix_a on a(id);

Succeed.

SQL> insert into a values(10);

1 rows affected.

SQL> create tablespace new_space datafile 'new_space' size 128M;

Succeed.

SQL> truncate table a;

Succeed.

SQL> select index_name, tablespace_name from user_indexes where index_name='IX_A';

INDEX_NAME                                                       TABLESPACE_NAME                                                 
---------------------------------------------------------------- ----------------------------------------------------------------
IX_A                                                             USERS                                                           

1 rows fetched.

SQL> alter index ix_a on a rebuild tablespace new_space;

Succeed.

SQL> flashback table a to before truncate;

Succeed.

SQL> select index_name, tablespace_name from user_indexes where index_name='IX_A';

INDEX_NAME                                                       TABLESPACE_NAME                                                 
---------------------------------------------------------------- ----------------------------------------------------------------
IX_A                                                             USERS                                                           

1 rows fetched.

SQL> drop table a;

Succeed.

SQL> drop tablespace new_space INCLUDING CONTENTS AND DATAFILES;

Succeed.

SQL> conn / as sysdba

connected.

SQL> drop user if exists test_index cascade;

Succeed.

SQL> 
SQL> drop table if exists test_batch;

Succeed.

SQL> drop table if exists test_data;

Succeed.

SQL> 
SQL> create table test_data(id1 varchar(3000), id2 varchar(3000), val varchar(10));

Succeed.

SQL> declare
  2   i int;
  3 begin
  4   for i in 1..1000 loop
  5     execute immediate 'insert into test_data values('||i||', '||i||', ''aaaaaaaaa'')';
  6   end loop;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --test batch insert
SQL> create table test_batch(id1 varchar(3000), id2 varchar(3000), val varchar(10));

Succeed.

SQL> insert into test_batch select * from test_data;

1000 rows affected.

SQL> create unique index ix_test_batch on test_batch(id2) crmode page;

Succeed.

SQL> --test unique index overwrite
SQL> savepoint svpt1;

Succeed.

SQL> delete from test_batch;

1000 rows affected.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
                                        

1 rows fetched.

SQL> savepoint svpt2;

Succeed.

SQL> insert into test_batch select * from test_data;

1000 rows affected.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> savepoint svpt3;

Succeed.

SQL> delete from test_batch where id2 %2 = 0;

500 rows affected.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
250000                                  

1 rows fetched.

SQL> insert into test_batch select * from test_data;

CT-00729, Unique constraint violated, index IX_TEST_BATCH, duplicate key 1
SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
250000                                  

1 rows fetched.

SQL> rollback to savepoint svpt3;

Succeed.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> rollback to savepoint svpt2;

Succeed.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
                                        

1 rows fetched.

SQL> rollback to savepoint svpt1;

Succeed.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> truncate table test_batch purge;

Succeed.

SQL> 
SQL> --test non-unique index batch insert
SQL> drop index ix_test_batch on test_batch;

Succeed.

SQL> create index ix_test_batch on test_batch(id1) crmode page;

Succeed.

SQL> create index ix_test_batch2 on test_batch(id2) crmode row;

Succeed.

SQL> insert into test_batch select * from test_data;

1000 rows affected.

SQL> savepoint svpt1;

Succeed.

SQL> delete from test_batch;

1000 rows affected.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
                                        

1 rows fetched.

SQL> savepoint svpt2;

Succeed.

SQL> insert into test_batch select * from test_data;

1000 rows affected.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> savepoint svpt3;

Succeed.

SQL> delete from test_batch where id2 %2 = 0;

500 rows affected.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
250000                                  

1 rows fetched.

SQL> insert into test_batch select * from test_data;

1000 rows affected.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
750500                                  

1 rows fetched.

SQL> rollback to savepoint svpt3;

Succeed.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> rollback to savepoint svpt2;

Succeed.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
                                        

1 rows fetched.

SQL> rollback to savepoint svpt1;

Succeed.

SQL> select sum(id1) from test_batch;

SUM(ID1)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> select sum(id2) from test_batch;

SUM(ID2)                                
----------------------------------------
500500                                  

1 rows fetched.

SQL> drop index ix_test_batch2 on test_batch;

Succeed.

SQL> truncate table test_batch purge;

Succeed.

SQL> 
SQL> --DTS2020031601743
SQL> truncate table test_data purge;

Succeed.

SQL> insert into test_data values(lpad('a', 3000, 'a'), 'aaaaa', 'aaaaa');

1 rows affected.

SQL> insert into test_data values(lpad('a', 3000, 'a'), 'aaaaa', 'aaaaa');

1 rows affected.

SQL> insert into test_data values(lpad('a', 1000, 'a'), 'aaaaa', 'aaaaa');

1 rows affected.

SQL> 
SQL> declare
  2   i int;
  3 begin
  4   for i in 1..128 loop
  5     execute immediate 'insert into test_data values(''a'', null, null)';
  6   end loop;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2   i int;
  3   j int;
  4 begin
  5     for j in 1..16 loop
  6         for i in 1..16 loop
  7             execute immediate 'insert into test_data values(lpad(''a'', 128 * '||i||' , ''a''), null, null)';
  8         end loop;
  9     end loop;
 10 end;
 11 /

PL/SQL procedure successfully completed.

SQL> 
SQL> insert into test_batch select * from test_data;

387 rows affected.

SQL> 
SQL> truncate table test_batch purge;

Succeed.

SQL> --test foreign key for batch insert
SQL> drop table if exists test_batch_parent;

Succeed.

SQL> drop index ix_test_batch on test_batch;

Succeed.

SQL> create table test_batch_parent(id varchar(3000), constraint pk_batch_parent primary key(id));

Succeed.

SQL> alter table test_batch add constraint fk_batch foreign key(id1) references test_batch_parent(id);

Succeed.

SQL> insert into test_batch select * from test_data;

CT-01223, Integrity constraint violated - parent key not found
SQL> alter table test_batch drop constraint fk_batch;

Succeed.

SQL> drop table test_batch_parent purge;

Succeed.

SQL> drop table test_data purge;

Succeed.

SQL> drop table test_batch purge;

Succeed.

SQL> 
SQL> drop table if exists test_key_len_check;

Succeed.

SQL> create table test_key_len_check(a int, b varchar(6500));

Succeed.

SQL> alter system set ENABLE_IDX_KEY_LEN_CHECK = true;

Succeed.

SQL> create index idx_test_key_len_check on test_key_len_check(json_value(b, '$.aa'), json_value(b, '$.cc')) parallel 5;

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> alter system set ENABLE_IDX_KEY_LEN_CHECK = false;

Succeed.

SQL> create index idx_test_key_len_check on test_key_len_check(json_value(b, '$.aa'), json_value(b, '$.cc'));

Succeed.

SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 3000, 'bvfdf'), 'cc' is lpad('bvfdf', 1094, 'bvfdf') returning clob));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 3900, 'bvfdf'), 'cc' is lpad('bvfdf', 157, 'bvfdf') returning clob));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 3900, 'bvfdf'), 'cc' is lpad('bvfdf', 139, 'bvfdf') returning clob));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 3900, 'bvfdf'), 'cc' is lpad('bvfdf', 138, 'bvfdf') returning clob));

1 rows affected.

SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 3900, 'bvfdf'), 'cc' is lpad('bvfdf', 137, 'bvfdf') returning clob));

1 rows affected.

SQL> insert into test_key_len_check values(1, json_object('aa' is lpad('bvfdf', 100, 'bvfdf'), 'cc' is lpad('bvfdf', 100, 'bvfdf') returning clob));

1 rows affected.

SQL> select length(b) len from test_key_len_check order by len desc;

LEN                 
--------------------
4055                
4054                
217                 

3 rows fetched.

SQL> alter table test_key_len_check modify b varchar(7000);

CT-00130, Operation modify column is not supported on functional index
SQL> explain select * from test_key_len_check where json_value(b, '$.aa') = 'dsd';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_KEY_LEN_CHECK     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_TEST_KEY_LEN_CHECK |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: JSON_VALUE(B, '$.aa') = 'dsd'                    

10 rows fetched.

SQL> explain select * from test_key_len_check where json_value(b, '$.aa') = 'dsd' and json_value(b, '$.cc') ='dsds';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_KEY_LEN_CHECK     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_TEST_KEY_LEN_CHECK |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: JSON_VALUE(B, '$.aa') = 'dsd' AND JSON_VALUE(B, '$.cc') = 'dsds'

10 rows fetched.

SQL> drop table test_key_len_check;

Succeed.

SQL> alter system set ENABLE_IDX_KEY_LEN_CHECK = true;

Succeed.

SQL> --test alter index rebuild keep storage;
SQL> drop table if exists test_delay_rebuild;

Succeed.

SQL> create table test_delay_rebuild (id int, num int) partition by range (id) 
  2 (
  3 partition p1 values less than (10),
  4 partition p2 values less than (20),
  5 partition p3 values less than (MAXVALUE)
  6 );

Succeed.

SQL> create index idx_delay_rebuild on test_delay_rebuild (num) parallel 5;

Succeed.

SQL> create index idx_delay_local on test_delay_rebuild (id) local;

Succeed.

SQL> alter index idx_delay_rebuild on test_delay_rebuild rebuild keep storage;

CT-00601, Sql syntax error: expected word online not found
SQL> alter index idx_delay_local on test_delay_rebuild rebuild partition p1 keep storage;

CT-00601, Sql syntax error: expected word online not found
SQL> insert into test_delay_rebuild values (5, 10);

1 rows affected.

SQL> insert into test_delay_rebuild values (15, 10);

1 rows affected.

SQL> insert into test_delay_rebuild values (25, 10);

1 rows affected.

SQL> commit;

Succeed.

SQL> alter index idx_delay_rebuild on test_delay_rebuild rebuild keep storage;

CT-00601, Sql syntax error: expected word online not found
SQL> alter index idx_delay_local on test_delay_rebuild rebuild partition p1 keep storage;

CT-00601, Sql syntax error: expected word online not found
SQL> insert into test_delay_rebuild values (5, 10);

1 rows affected.

SQL> insert into test_delay_rebuild values (15, 10);

1 rows affected.

SQL> insert into test_delay_rebuild values (25, 10);

1 rows affected.

SQL> commit;

Succeed.

SQL> alter index idx_delay_rebuild on test_delay_rebuild rebuild keep storage online;

Succeed.

SQL> alter index idx_delay_local on test_delay_rebuild rebuild partition p1 keep storage online;

Succeed.

SQL> drop table if exists test_delay_rebuild;

Succeed.

SQL> 
SQL> --support parameter CBO_INDEX_CACHING CBO_INDEX_COST_ADJ
SQL> drop table if exists tbl_cbo_param;

Succeed.

SQL> create table tbl_cbo_param
  2 (
  3 	empno int,
  4 	ename varchar(100),
  5 	sal int
  6 );

Succeed.

SQL> alter table tbl_cbo_param add constraint pk_tbl_cbo_param primary key(empno);

Succeed.

SQL> create index employees_index_001 on  tbl_cbo_param (ename); 

Succeed.

SQL> create index employees_index_002 on  tbl_cbo_param (sal); 

Succeed.

SQL> declare
  2 	v_sql VARCHAR2(2000);
  3 	v_i int;
  4 	v_name VARCHAR2(100);
  5 BEGIN
  6 	for i in 1..1000 loop
  7 	v_i:=i;
  8 	v_name:=to_char(i);
  9 	v_sql := 'insert into tbl_cbo_param values (:v1,:v2,:v3)';
 10 	EXECUTE IMMEDIATE v_sql USING v_i,'name_'||v_name,1500;
 11 	end loop;
 12 commit;
 13 END;
 14 /

PL/SQL procedure successfully completed.

SQL> exec dbe_stats.collect_table_stats('sys','tbl_cbo_param',null,100);

PL/SQL procedure successfully completed.

SQL> --set cbo on to show COST
SQL> alter system set cbo = on;

Succeed.

SQL> explain select * from tbl_cbo_param where empno =10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_caching = 50;

Succeed.

SQL> explain select * from tbl_cbo_param where empno =10 ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_caching = 100;

Succeed.

SQL> explain select * from tbl_cbo_param where empno =10  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_caching = 0;

Succeed.

SQL> explain select * from tbl_cbo_param where ename = 'name_50';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     | 1    | 8    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM       | 1    | 8    |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | EMPLOYEES_INDEX_001 | 1    | 8    |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ENAME = 'name_50'                                

10 rows fetched.

SQL> alter system set cbo_index_caching = 50;

Succeed.

SQL> explain select * from tbl_cbo_param where ename = 'name_50' ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     | 1    | 4    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM       | 1    | 4    |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | EMPLOYEES_INDEX_001 | 1    | 4    |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ENAME = 'name_50'                                

10 rows fetched.

SQL> alter system set cbo_index_caching = 100;

Succeed.

SQL> explain select * from tbl_cbo_param where ename = 'name_50'  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     | 1    | 0    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM       | 1    | 0    |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | EMPLOYEES_INDEX_001 | 1    | 0    |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ENAME = 'name_50'                                

10 rows fetched.

SQL> alter system set cbo_index_caching = 0;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500 order by empno;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 32   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 32   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 32   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_caching = 50;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500 order by empno ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 22   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 22   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 22   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_caching = 100;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500 order by empno  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 12   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 12   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 12   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_caching = 0;

Succeed.

SQL> 
SQL> explain select * from tbl_cbo_param where  empno =10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 50;

Succeed.

SQL> explain select * from tbl_cbo_param where  empno =10 ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 200;

Succeed.

SQL> explain select * from tbl_cbo_param where  empno =10  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 1    | 1    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 1    | 1    |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | PK_TBL_CBO_PARAM | 1    | 1    |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: EMPNO = 10                                       

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 100;

Succeed.

SQL> explain select * from tbl_cbo_param where  ename = 'name_50';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     | 1    | 8    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM       | 1    | 8    |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | EMPLOYEES_INDEX_001 | 1    | 8    |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ENAME = 'name_50'                                

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 50;

Succeed.

SQL> explain select * from tbl_cbo_param where  ename = 'name_50' ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     | 1    | 4    |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM       | 1    | 4    |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | EMPLOYEES_INDEX_001 | 1    | 4    |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ENAME = 'name_50'                                

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 200;

Succeed.

SQL> explain select * from tbl_cbo_param where  ename = 'name_50'  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               | 1    | 8    |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TBL_CBO_PARAM | 1    | 8    |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: ENAME = 'name_50'                                

9 rows fetched.

SQL> alter system set cbo_index_cost_adj = 100;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500  order by empno;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 32   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 32   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 32   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 50;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500  order by empno ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 16   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 16   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 16   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 200;

Succeed.

SQL> explain select distinct empno from tbl_cbo_param where sal=1000 or empno >500  order by empno  ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  | 500  | 65   |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TBL_CBO_PARAM    | 500  | 65   |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | PK_TBL_CBO_PARAM | 500  | 65   |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SAL = 1000 OR EMPNO > 500                        

10 rows fetched.

SQL> alter system set cbo_index_cost_adj = 100;

Succeed.

SQL> alter system set cbo = off;

Succeed.

SQL> 
SQL> --base table
SQL> drop table if exists aa;

Succeed.

SQL> create table aa(C_ID INT, C_PAYMENT_CNT_3 NUMBER(12,8), PRIMARY KEY (C_ID)) format csf;

Succeed.

SQL> create OR REPLACE PROCEDURE STORAGE_UPDATE_PARTITION_KEY_SIN_IND_PROC_000_1_1(STARTNUM INT,ENDALL INT) IS
  2 I int :=1;
  3 begin
  4   for I in STARTNUM..ENDALL loop
  5     INSERT INTO aa SELECT I, (I+0.12345678) FROM SYS_DUMMY;
  6   end loop;
  7 end;
  8 /

Succeed.

SQL> call STORAGE_UPDATE_PARTITION_KEY_SIN_IND_PROC_000_1_1(1,1);

PL/SQL procedure successfully completed.

SQL> 
SQL> --csf table
SQL> DROP TABLE IF EXISTS aa_csf;

Succeed.

SQL> CREATE TABLE aa_csf(C_ID INT, C_PAYMENT_CNT_3 NUMBER(12,8)) 
  2 PARTITION BY LIST(C_PAYMENT_CNT_3)(PARTITION PART_1 VALUES (0,1),PARTITION PART_2 VALUES (2,3),PARTITION PART_3 VALUES (4,5),PARTITION PART_4 VALUES (6,7),PARTITION PART_5 VALUES (DEFAULT)) FORMAT CSF;

Succeed.

SQL> CREATE INDEX aa_csf_index ON aa_csf(C_PAYMENT_CNT_3) parallel 5;

Succeed.

SQL> insert into aa_csf values(0,0);

1 rows affected.

SQL> rollback;

Succeed.

SQL> INSERT INTO aa_csf SELECT * FROM aa;

1 rows affected.

SQL> UPDATE aa_csf SET C_PAYMENT_CNT_3=MOD(C_ID,1);

1 rows affected.

SQL> commit;

Succeed.

SQL> SELECT C_PAYMENT_CNT_3 from aa_csf;

C_PAYMENT_CNT_3                         
----------------------------------------
0                                       

1 rows fetched.

SQL> DROP TABLE IF EXISTS aa_csf;

Succeed.

SQL> drop table if exists aa;

Succeed.

SQL> 
SQL> drop table if exists tb1;

Succeed.

SQL> create table tb1 ( i int, name varchar(4000));

Succeed.

SQL> insert into tb1 values (1, LPAD('A',976,'A'));

1 rows affected.

SQL> insert into tb1 values (1, 'C');

1 rows affected.

SQL> insert into tb1 values (1, 'D');

1 rows affected.

SQL> insert into tb1 values (1, 'E');

1 rows affected.

SQL> insert into tb1 values (1, 'F');

1 rows affected.

SQL> insert into tb1 values (1, 'G');

1 rows affected.

SQL> insert into tb1 values (1, 'H');

1 rows affected.

SQL> insert into tb1 values (1, 'I');

1 rows affected.

SQL> insert into tb1 values (1, 'J');

1 rows affected.

SQL> insert into tb1 values (1, 'K');

1 rows affected.

SQL> insert into tb1 values (1, 'L');

1 rows affected.

SQL> insert into tb1 values (1, 'M');

1 rows affected.

SQL> insert into tb1 values (1, 'N');

1 rows affected.

SQL> insert into tb1 values (1, 'O');

1 rows affected.

SQL> insert into tb1 values (1, 'P');

1 rows affected.

SQL> insert into tb1 values (1, 'Q');

1 rows affected.

SQL> insert into tb1 values (1, 'R');

1 rows affected.

SQL> insert into tb1 values (1, 'S');

1 rows affected.

SQL> insert into tb1 values (1, LPAD('T',974,'T'));

1 rows affected.

SQL> insert into tb1 values (1, LPAD('U',974,'U'));

1 rows affected.

SQL> insert into tb1 values (1, 'V');

1 rows affected.

SQL> insert into tb1 values (1, LPAD('W',3874,'W'));

1 rows affected.

SQL> commit;

Succeed.

SQL> drop index if exists idx_1 on tb1;

Succeed.

SQL> create index idx_1 on tb1(name) initrans 10;

Succeed.

SQL> alter index idx_1 on tb1 rebuild online ; 

Succeed.

SQL> drop table if exists tb1;

Succeed.

SQL> 
SQL> --index_part_space
SQL> create tablespace index_part_space datafile 'part_space_file' size 100M ;

Succeed.

SQL> create tablespace test_nologging datafile 'nologging_file' size 100M nologging;

Succeed.

SQL> create tablespace index_part_encrypt_space datafile 'part_encrypt_space' size 100M encryption;

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_space)
  7    tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging);

CT-00130, Operation create nologging object is not supported on logging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace temp, partition p2 tablespace temp);

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace test_nologging);

CT-00130, Operation create nologging object is not supported on logging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace temp);

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace undo);

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace test_nologging;

CT-00130, Operation create nologging object is not supported on logging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace temp;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace undo;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging) tablespace index_part_space;

CT-00130, Operation create nologging object is not supported on logging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace temp, partition p2 tablespace temp) tablespace index_part_space;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace undo, partition p2 tablespace undo) tablespace index_part_space;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace test_nologging) tablespace index_part_space;

CT-00130, Operation create nologging object is not supported on logging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace temp) tablespace index_part_space;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace undo) tablespace index_part_space;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_space)
  7    tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id);

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_space)
  7    tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space);

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_space)
  7    tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_space;

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace test_nologging,
  6    partition p2 values less than(MAXVALUE) tablespace test_nologging)
  7    tablespace test_nologging;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space);

CT-00130, Operation create logging object is not supported on nologging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace temp, partition p2 tablespace temp);

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace index_part_space);

CT-00130, Operation create logging object is not supported on nologging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace temp);

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace undo);

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging) tablespace index_part_space;

CT-00130, Operation create logging object is not supported on nologging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging) tablespace temp;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging) tablespace undo;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace test_nologging;

CT-00130, Operation create logging object is not supported on nologging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace temp, partition p2 tablespace temp) tablespace test_nologging;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace undo, partition p2 tablespace undo) tablespace test_nologging;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace index_part_space) tablespace test_nologging;

CT-00130, Operation create logging object is not supported on nologging parent object
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace temp) tablespace test_nologging;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace undo) tablespace test_nologging;

CT-00871, UNDO tablespace cannot be used to create user object
SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace test_nologging,
  6    partition p2 values less than(MAXVALUE) tablespace test_nologging)
  7    tablespace test_nologging;

Succeed.

SQL> create index part_table_index on index_part_table(id);

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace test_nologging,
  6    partition p2 values less than(MAXVALUE) tablespace test_nologging)
  7    tablespace test_nologging;  

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging);

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace test_nologging,
  6    partition p2 values less than(MAXVALUE) tablespace test_nologging)
  7    tablespace test_nologging;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace test_nologging, partition p2 tablespace test_nologging) tablespace test_nologging;

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id) tablespace index_part_encrypt_space;

CT-00130, Operation create encrypt object is not supported on non-encrypt parent object or create non-encrypt object on encrypt parent object.
SQL> create index part_table_index on index_part_table(id) tablespace index_part_space;

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_space)
  7    tablespace index_part_space;

Succeed.

SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_encrypt_space;

CT-00130, Operation create encrypt object is not supported on non-encrypt parent object or create non-encrypt object on encrypt parent object.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_encrypt_space) tablespace index_part_space;

CT-00130, Operation create encrypt object is not supported on non-encrypt parent object or create non-encrypt object on encrypt parent object.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_space;

Succeed.

SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_encrypt_space)
  7    tablespace index_part_space;

CT-00130, Operation create partition is not supported on cases: create encrypt partition on non-encrypt part table or create non-encrypt partition on encrypt part table.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_encrypt_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_encrypt_space) tablespace index_part_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> create table index_part_table (
  2     id int not null,
  3     name varchar(8000) not null)
  4 partition by range (id)
  5  ( partition p1 values less than(1000) tablespace index_part_encrypt_space,
  6    partition p2 values less than(MAXVALUE) tablespace index_part_encrypt_space)
  7    tablespace index_part_encrypt_space;

CT-00137, encryption not support: column size should less than 7744
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_encrypt_space) tablespace index_part_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_space, partition p2 tablespace index_part_space) tablespace index_part_encrypt_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> create index part_table_index on index_part_table(id) local (partition p1 tablespace index_part_encrypt_space, partition p2 tablespace index_part_encrypt_space) tablespace index_part_space;

CT-00843, The table or view SYS.INDEX_PART_TABLE does not exist.
SQL> 
SQL> drop table if exists index_part_table;

Succeed.

SQL> drop tablespace test_nologging including contents and datafiles;

Succeed.

SQL> drop tablespace index_part_space including contents and datafiles;

Succeed.

SQL> drop tablespace index_part_encrypt_space including contents and datafiles;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS RQG_TABLE;

Succeed.

SQL> CREATE TABLE  RQG_TABLE
  2 (
  3     UNIQUE BINARY_INTEGER DEFAULT -1000 NULL, 
  4     COMMENT NCHAR(4000), 
  5     C1 VARCHAR(2000),
  6     C2 VARCHAR(2000)
  7 );

Succeed.

SQL> CREATE UNIQUE INDEX IDX_RQG_TABLE ON RQG_TABLE(COMMENT);

Succeed.

SQL> INSERT INTO RQG_TABLE VALUES(-1054212096,'kgytukmbxouhxgqg','kgytukmbxouhxgqgk','ymkgytukmbxouhx');

1 rows affected.

SQL> INSERT INTO RQG_TABLE(C1,C2) VALUES('dymkgytukmbxouhxgqgkbfipljifwtab','dymkgytukmbxouhx');

1 rows affected.

SQL> INSERT INTO RQG_TABLE SELECT * FROM RQG_TABLE;

CT-00729, Unique constraint violated, index IDX_RQG_TABLE, duplicate key kgytukmbxouhxgqg                                                                                                                
SQL> DROP TABLE IF EXISTS RQG_TABLE;

Succeed.

SQL> 
SQL> ---- SINGLE PARTTITON UNSABLE
SQL> drop user if exists hzy_unuasble cascade;

Succeed.

SQL> create user hzy_unuasble identified by Cantian_234;

Succeed.

SQL> drop table hzy_unuasble.test_usindx1;

CT-00843, The table or view HZY_UNUASBLE.TEST_USINDX1 does not exist.
SQL> create table hzy_unuasble.test_usindx1(
  2 c_id int,
  3 c_d_id int NOT NULL,
  4 c_w_id int NOT NULL,
  5 c_first varchar(50) NOT NULL,
  6 c_middle char(2),
  7 c_last varchar(16) NOT NULL,
  8 c_street_1 varchar(20) NOT NULL,
  9 c_street_2 varchar(20),
 10 c_city varchar(20) NOT NULL,
 11 c_state char(2) NOT NULL,
 12 c_zip char(9) NOT NULL,
 13 c_phone char(16) NOT NULL,
 14 c_since timestamp,
 15 c_credit char(2) NOT NULL,
 16 c_credit_lim numeric(12,2),
 17 c_discount numeric(4,4),
 18 c_balance numeric(12,2),
 19 c_ytd_payment real NOT NULL,
 20 c_payment_cnt number NOT NULL,
 21 c_delivery_cnt bool NOT NULL,
 22 c_end date NOT NULL,
 23 c_data varchar(1000),
 24 c_clob clob,
 25 c_text blob) 
 26 partition by range(c_id) 
 27 (
 28    partition PART_1 values less than (10),
 29    partition PART_2 values less than (20),
 30    partition PART_3 values less than (30),
 31    partition PART_4 values less than (40),
 32    partition PART_5 values less than (50),
 33    partition PART_6 values less than (60),
 34    partition PART_7 values less than (70),
 35    partition PART_8 values less than (80),
 36    partition PART_9 values less than (maxvalue)
 37 );

Succeed.

SQL> 
SQL> CREATE INDEX hzy_unuasble.usidx1 ON hzy_unuasble.test_usindx1(c_id);

Succeed.

SQL> CREATE INDEX hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1(c_d_id) local;

Succeed.

SQL> CREATE INDEX hzy_unuasble.usidx3 ON hzy_unuasble.test_usindx1(c_w_id, c_last) local;

Succeed.

SQL> 
SQL> alter index hzy_unuasble.usidx1 ON hzy_unuasble.test_usindx1 modify partition PART_1 unusable;

CT-01112, The common index was treated as a (sub)partitioned index
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_1,PART_2 unusable;

CT-00601, [1:56]Sql syntax error: unexpected word , found.
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_111 unusable;

CT-00800, A table (sub)partition PART_111 does not exist.
SQL> 
SQL> CREATE or replace procedure hzy_unuasble.lob_hzy_proc_1115(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     insert into  hzy_unuasble.test_usindx1 select i,i,i,'is'||j||'cmRDs'||j,'OE','BAR'||j||'Bar'||j,'bkili'||j||'fcrRGF'||j,'pmbwo'||j||'vhSDGj'||j,'dyf'||j||'rDa'||j,'uq',4801||j,940||j||215||j,'2011-12-11 00:00:00','GC',50000.0,0.4361328,-10.0,10.0,1,true,'2011-12-11 00:00:00','dasd'||j,'dasdsd'||j,'\x1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323';
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> 
SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

100 rows affected.

SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

200 rows affected.

SQL> commit;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           PART_1                                                           65536                8                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           PART_1                                                           65536                8                   
USIDX3                                                           PART_2                                                           65536                8                   
USIDX3                                                           PART_3                                                           65536                8                   
USIDX3                                                           PART_4                                                           65536                8                   
USIDX3                                                           PART_5                                                           65536                8                   
USIDX3                                                           PART_6                                                           65536                8                   
USIDX3                                                           PART_7                                                           65536                8                   
USIDX3                                                           PART_8                                                           65536                8                   
USIDX3                                                           PART_9                                                           65536                8                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           0           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_1 unusable;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           PART_1                                                           65536                8                   
USIDX3                                                           PART_2                                                           65536                8                   
USIDX3                                                           PART_3                                                           65536                8                   
USIDX3                                                           PART_4                                                           65536                8                   
USIDX3                                                           PART_5                                                           65536                8                   
USIDX3                                                           PART_6                                                           65536                8                   
USIDX3                                                           PART_7                                                           65536                8                   
USIDX3                                                           PART_8                                                           65536                8                   
USIDX3                                                           PART_9                                                           65536                8                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           4           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           PART_1                                                           65536                8                   
USIDX3                                                           PART_2                                                           65536                8                   
USIDX3                                                           PART_3                                                           65536                8                   
USIDX3                                                           PART_4                                                           65536                8                   
USIDX3                                                           PART_5                                                           65536                8                   
USIDX3                                                           PART_6                                                           65536                8                   
USIDX3                                                           PART_7                                                           65536                8                   
USIDX3                                                           PART_8                                                           65536                8                   
USIDX3                                                           PART_9                                                           65536                8                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           4           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> update hzy_unuasble.test_usindx1 set c_d_id = 10;

500 rows affected.

SQL> delete from hzy_unuasble.test_usindx1;

500 rows affected.

SQL> 
SQL> --- UNIQUE INDEX UNUSABLE
SQL> purge recyclebin;

Succeed.

SQL> drop table hzy_unuasble.test_usindx1;

Succeed.

SQL> create table hzy_unuasble.test_usindx1(
  2 c_id int,
  3 c_d_id int NOT NULL,
  4 c_w_id int NOT NULL,
  5 c_first varchar(50) NOT NULL,
  6 c_middle char(2),
  7 c_last varchar(16) NOT NULL,
  8 c_street_1 varchar(20) NOT NULL,
  9 c_street_2 varchar(20),
 10 c_city varchar(20) NOT NULL,
 11 c_state char(2) NOT NULL,
 12 c_zip char(9) NOT NULL,
 13 c_phone char(16) NOT NULL,
 14 c_since timestamp,
 15 c_credit char(2) NOT NULL,
 16 c_credit_lim numeric(12,2),
 17 c_discount numeric(4,4),
 18 c_balance numeric(12,2),
 19 c_ytd_payment real NOT NULL,
 20 c_payment_cnt number NOT NULL,
 21 c_delivery_cnt bool NOT NULL,
 22 c_end date NOT NULL,
 23 c_data varchar(1000),
 24 c_clob clob,
 25 c_text blob) 
 26 partition by range(c_id) 
 27 (
 28    partition PART_1 values less than (10),
 29    partition PART_2 values less than (20),
 30    partition PART_3 values less than (30),
 31    partition PART_4 values less than (40),
 32    partition PART_5 values less than (50),
 33    partition PART_6 values less than (60),
 34    partition PART_7 values less than (70),
 35    partition PART_8 values less than (80),
 36    partition PART_9 values less than (maxvalue)
 37 );

Succeed.

SQL> 
SQL> CREATE unique INDEX hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1(c_id) local;

Succeed.

SQL> 
SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           PART_1                                                           65536                8                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           0           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> 
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_1 unusable;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           4           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> 
SQL> truncate table hzy_unuasble.test_usindx1;

Succeed.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           PART_1                                                           65536                8                   
USIDX2                                                           PART_2                                                           65536                8                   
USIDX2                                                           PART_3                                                           65536                8                   
USIDX2                                                           PART_4                                                           65536                8                   
USIDX2                                                           PART_5                                                           65536                8                   
USIDX2                                                           PART_6                                                           65536                8                   
USIDX2                                                           PART_7                                                           65536                8                   
USIDX2                                                           PART_8                                                           65536                8                   
USIDX2                                                           PART_9                                                           65536                8                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           0           
20           0           
30           0           
40           0           
50           0           
60           0           
70           0           
80           0           
90           0           

9 rows fetched.

SQL> 
SQL> --- PARENT PART INDEX UNUSABLE ERROR
SQL> purge recyclebin;

Succeed.

SQL> drop table hzy_unuasble.test_usindx1;

Succeed.

SQL> create table hzy_unuasble.test_usindx1(
  2 c_id int,
  3 c_d_id int NOT NULL,
  4 c_w_id int NOT NULL,
  5 c_first varchar(50) NOT NULL,
  6 c_middle char(2),
  7 c_last varchar(16) NOT NULL,
  8 c_street_1 varchar(20) NOT NULL,
  9 c_street_2 varchar(20),
 10 c_city varchar(20) NOT NULL,
 11 c_state char(2) NOT NULL,
 12 c_zip char(9) NOT NULL,
 13 c_phone char(16) NOT NULL,
 14 c_since timestamp,
 15 c_credit char(2) NOT NULL,
 16 c_credit_lim numeric(12,2),
 17 c_discount numeric(4,4),
 18 c_balance numeric(12,2),
 19 c_ytd_payment real NOT NULL,
 20 c_payment_cnt number NOT NULL,
 21 c_delivery_cnt bool NOT NULL,
 22 c_end date NOT NULL,
 23 c_data varchar(1000),
 24 c_clob clob,
 25 c_text blob) 
 26 partition by range(c_id) subpartition by range(c_w_id)
 27 (
 28    partition PART_1 values less than (10)
 29    (
 30      subpartition p11 values less than(20),
 31      subpartition p12 values less than(maxvalue)
 32    ),
 33    partition PART_2 values less than (50)
 34    (
 35      subpartition p21 values less than(20),
 36      subpartition p22 values less than(maxvalue)
 37    ),
 38    partition PART_3 values less than (maxvalue)
 39    (
 40      subpartition p31 values less than(50),
 41      subpartition p32 values less than(maxvalue)
 42    )
 43 );

Succeed.

SQL> 
SQL> CREATE INDEX hzy_unuasble.usidx1 ON hzy_unuasble.test_usindx1(c_id);

Succeed.

SQL> CREATE INDEX hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1(c_d_id) local;

Succeed.

SQL> CREATE INDEX hzy_unuasble.usidx3 ON hzy_unuasble.test_usindx1(c_w_id, c_last) local;

Succeed.

SQL> 
SQL> alter index hzy_unuasble.usidx1 ON hzy_unuasble.test_usindx1 modify partition PART_11 unusable;

CT-01112, The common index was treated as a (sub)partitioned index
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_11,PART_21 unusable;

CT-00601, [1:57]Sql syntax error: unexpected word , found.
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_311 unusable;

CT-00800, A table (sub)partition PART_311 does not exist.
SQL> 
SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

100 rows affected.

SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

200 rows affected.

SQL> commit;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' and SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           P11                                                              65536                8                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           P11                                                              65536                8                   
USIDX3                                                           P12                                                              0                    0                   
USIDX3                                                           P21                                                              65536                8                   
USIDX3                                                           P22                                                              65536                8                   
USIDX3                                                           P31                                                              0                    0                   
USIDX3                                                           P32                                                              65536                8                   
USIDX3                                                           PART_1                                                           0                    0                   
USIDX3                                                           PART_2                                                           0                    0                   
USIDX3                                                           PART_3                                                           0                    0                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> 
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_1 unusable;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           P11                                                              65536                8                   
USIDX3                                                           P12                                                              0                    0                   
USIDX3                                                           P21                                                              65536                8                   
USIDX3                                                           P22                                                              65536                8                   
USIDX3                                                           P31                                                              0                    0                   
USIDX3                                                           P32                                                              65536                8                   
USIDX3                                                           PART_1                                                           0                    0                   
USIDX3                                                           PART_2                                                           0                    0                   
USIDX3                                                           PART_3                                                           0                    0                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index# 
  2 order by a.SUBpart#,a.flags;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           4           
20           0           
20           0           
20           4           

6 rows fetched.

SQL> 
SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX1                                                                                                                            65536                8                   
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   
USIDX3                                                           P11                                                              65536                8                   
USIDX3                                                           P12                                                              0                    0                   
USIDX3                                                           P21                                                              65536                8                   
USIDX3                                                           P22                                                              65536                8                   
USIDX3                                                           P31                                                              0                    0                   
USIDX3                                                           P32                                                              65536                8                   
USIDX3                                                           PART_1                                                           0                    0                   
USIDX3                                                           PART_2                                                           0                    0                   
USIDX3                                                           PART_3                                                           0                    0                   
USIDX3                                                                                                                            0                    0                   

21 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index# 
  2 order by a.SUBpart#,a.flags;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           4           
20           0           
20           0           
20           4           

6 rows fetched.

SQL> 
SQL> --- PARENT PART INDEX UNUSABLE
SQL> purge recyclebin;

Succeed.

SQL> drop table hzy_unuasble.test_usindx1;

Succeed.

SQL> create table hzy_unuasble.test_usindx1(
  2 c_id int,
  3 c_d_id int NOT NULL,
  4 c_w_id int NOT NULL,
  5 c_first varchar(50) NOT NULL,
  6 c_middle char(2),
  7 c_last varchar(16) NOT NULL,
  8 c_street_1 varchar(20) NOT NULL,
  9 c_street_2 varchar(20),
 10 c_city varchar(20) NOT NULL,
 11 c_state char(2) NOT NULL,
 12 c_zip char(9) NOT NULL,
 13 c_phone char(16) NOT NULL,
 14 c_since timestamp,
 15 c_credit char(2) NOT NULL,
 16 c_credit_lim numeric(12,2),
 17 c_discount numeric(4,4),
 18 c_balance numeric(12,2),
 19 c_ytd_payment real NOT NULL,
 20 c_payment_cnt number NOT NULL,
 21 c_delivery_cnt bool NOT NULL,
 22 c_end date NOT NULL,
 23 c_data varchar(1000),
 24 c_clob clob,
 25 c_text blob) 
 26 partition by range(c_id) subpartition by range(c_w_id)
 27 (
 28    partition PART_1 values less than (10)
 29    (
 30      subpartition p11 values less than(20),
 31      subpartition p12 values less than(maxvalue)
 32    ),
 33    partition PART_2 values less than (50)
 34    (
 35      subpartition p21 values less than(20),
 36      subpartition p22 values less than(maxvalue)
 37    ),
 38    partition PART_3 values less than (maxvalue)
 39    (
 40      subpartition p31 values less than(50),
 41      subpartition p32 values less than(maxvalue)
 42    )
 43 );

Succeed.

SQL> CREATE INDEX hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1(c_d_id) local;

Succeed.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

100 rows affected.

SQL> insert into hzy_unuasble.test_usindx1 select * from hzy_unuasble.test_usindx1;

200 rows affected.

SQL> commit;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' and SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              65536                8                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> 
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition p11 unusable;

CT-00800, A table (sub)partition P11 does not exist.
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify subpartition p11 unusable;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           4           
20           0           
20           0           
20           0           

6 rows fetched.

SQL> 
SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           4           
20           0           
20           0           
20           0           

6 rows fetched.

SQL> update hzy_unuasble.test_usindx1 set c_d_id = 10;

500 rows affected.

SQL> delete from hzy_unuasble.test_usindx1;

500 rows affected.

SQL> commit;

Succeed.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild;

Succeed.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 unusable;

Succeed.

SQL> select PARTITION_NAME, status from adm_ind_partitions where INDEX_OWNER = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2' order by PARTITION_NAME;

PARTITION_NAME                                                   STATUS 
---------------------------------------------------------------- -------
PART_1                                                           VALID  
PART_2                                                           VALID  
PART_3                                                           VALID  

3 rows fetched.

SQL> select PARTITION_NAME, status from adm_ind_subpartitions where INDEX_OWNER = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2' order by PARTITION_NAME;

PARTITION_NAME                                                   STATUS 
---------------------------------------------------------------- -------
P11                                                              INVALID
P12                                                              INVALID
P21                                                              INVALID
P22                                                              INVALID
P31                                                              INVALID
P32                                                              INVALID

6 rows fetched.

SQL> select INDEX_NAME, status from adm_indexes where owner = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2';

INDEX_NAME                                                       STATUS 
---------------------------------------------------------------- -------
USIDX2                                                           VALID  

1 rows fetched.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild partition PART_1;

Succeed.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild partition PART_2;

Succeed.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild subpartition p31;

Succeed.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild subpartition p32;

Succeed.

SQL> select PARTITION_NAME, status from adm_ind_partitions where INDEX_OWNER = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2' order by PARTITION_NAME;

PARTITION_NAME                                                   STATUS 
---------------------------------------------------------------- -------
PART_1                                                           VALID  
PART_2                                                           VALID  
PART_3                                                           VALID  

3 rows fetched.

SQL> select PARTITION_NAME, status from adm_ind_subpartitions where INDEX_OWNER = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2' order by PARTITION_NAME;

PARTITION_NAME                                                   STATUS 
---------------------------------------------------------------- -------
P11                                                              VALID  
P12                                                              VALID  
P21                                                              VALID  
P22                                                              VALID  
P31                                                              VALID  
P32                                                              VALID  

6 rows fetched.

SQL> select INDEX_NAME, status from adm_indexes where owner = 'HZY_UNUASBLE' and INDEX_NAME = 'USIDX2';

INDEX_NAME                                                       STATUS 
---------------------------------------------------------------- -------
USIDX2                                                           VALID  

1 rows fetched.

SQL> 
SQL> --- SUB PART UNIQUE INDEX UNUSABLE 
SQL> purge recyclebin;

Succeed.

SQL> drop table hzy_unuasble.test_usindx1;

Succeed.

SQL> create table hzy_unuasble.test_usindx1(
  2 c_id int,
  3 c_d_id int NOT NULL,
  4 c_w_id int NOT NULL,
  5 c_first varchar(50) NOT NULL,
  6 c_middle char(2),
  7 c_last varchar(16) NOT NULL,
  8 c_street_1 varchar(20) NOT NULL,
  9 c_street_2 varchar(20),
 10 c_city varchar(20) NOT NULL,
 11 c_state char(2) NOT NULL,
 12 c_zip char(9) NOT NULL,
 13 c_phone char(16) NOT NULL,
 14 c_since timestamp,
 15 c_credit char(2) NOT NULL,
 16 c_credit_lim numeric(12,2),
 17 c_discount numeric(4,4),
 18 c_balance numeric(12,2),
 19 c_ytd_payment real NOT NULL,
 20 c_payment_cnt number NOT NULL,
 21 c_delivery_cnt bool NOT NULL,
 22 c_end date NOT NULL,
 23 c_data varchar(1000),
 24 c_clob clob,
 25 c_text blob) 
 26 partition by range(c_id) subpartition by range(c_w_id)
 27 (
 28    partition PART_1 values less than (10)
 29    (
 30      subpartition p11 values less than(20),
 31      subpartition p12 values less than(maxvalue)
 32    ),
 33    partition PART_2 values less than (50)
 34    (
 35      subpartition p21 values less than(20),
 36      subpartition p22 values less than(maxvalue)
 37    ),
 38    partition PART_3 values less than (maxvalue)
 39    (
 40      subpartition p31 values less than(50),
 41      subpartition p32 values less than(maxvalue)
 42    )
 43 );

Succeed.

SQL> 
SQL> CREATE unique INDEX hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1(c_id,c_w_id) local;

Succeed.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              65536                8                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by part#;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 modify partition PART_1 unusable;

Succeed.

SQL> 
SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           4           
20           0           
20           0           
20           4           

6 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,10);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[7:5] PL/SQL(HZY_UNUASBLE.LOB_HZY_PROC_1115) terminated with execute errors
[7:5] CT-01120, Partition P11 of index USIDX2 is unusable, need to rebuild index first.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild partition PART_1;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              65536                8                   
USIDX2                                                           P12                                                              65536                8                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           0           
20           0           
20           0           
20           0           

6 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 unusable;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              0                    0                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              0                    0                   
USIDX2                                                           P22                                                              0                    0                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              0                    0                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           4           
10           4           
10           4           
20           4           
20           4           
20           4           

6 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> update hzy_unuasble.test_usindx1 set c_id = 10;

CT-01120, Partition P11 of index USIDX2 is unusable, need to rebuild index first.
SQL> delete from hzy_unuasble.test_usindx1;

CT-01120, Partition P11 of index USIDX2 is unusable, need to rebuild index first.
SQL> commit;

Succeed.

SQL> 
SQL> alter index hzy_unuasble.usidx2 ON hzy_unuasble.test_usindx1 rebuild;

Succeed.

SQL> select segment_name,PARTITION_NAME,bytes,pages from adm_segments where owner = 'HZY_UNUASBLE' and SEGMENT_TYPE = 'INDEX' AND SEGMENT_NAME like '%USIDX%' order by segment_name,PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   BYTES                PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- -------------------- --------------------
USIDX2                                                           P11                                                              65536                8                   
USIDX2                                                           P12                                                              0                    0                   
USIDX2                                                           P21                                                              65536                8                   
USIDX2                                                           P22                                                              65536                8                   
USIDX2                                                           P31                                                              0                    0                   
USIDX2                                                           P32                                                              65536                8                   
USIDX2                                                           PART_1                                                           0                    0                   
USIDX2                                                           PART_2                                                           0                    0                   
USIDX2                                                           PART_3                                                           0                    0                   
USIDX2                                                                                                                            0                    0                   

10 rows fetched.

SQL> select a.SUBpart#,a.FLAGS from sys.sys_sub_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

SUBPART#     FLAGS       
------------ ------------
10           0           
10           0           
10           0           
20           0           
20           0           
20           0           

6 rows fetched.

SQL> select a.part#,a.FLAGS from sys.sys_index_parts a , sys.sys_indexes b ,sys.sys_tables c where c.name = 'TEST_USINDX1' and c.id = b.table# and c.user# = b.user# and b.name = 'USIDX2' and a.table# = c.id and b.id = a.index#  order by 1,2;

PART#        FLAGS       
------------ ------------
10           64          
20           64          
30           64          

3 rows fetched.

SQL> call hzy_unuasble.lob_hzy_proc_1115(1,10);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[7:5] PL/SQL(HZY_UNUASBLE.LOB_HZY_PROC_1115) terminated with execute errors
[7:5] CT-00729, Unique constraint violated, index USIDX2, duplicate key 1-1

SQL> update hzy_unuasble.test_usindx1 set c_id = 10;

100 rows affected.

SQL> delete from hzy_unuasble.test_usindx1;

100 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> drop table if exists test1;

Succeed.

SQL> create table test1(f1 varchar2(4000 char));

Succeed.

SQL> create index idx_test1 on test1(f1);

Succeed.

SQL> insert into test1 values(lpad('中国',2000,'中国'));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> select * from test1 where f1 = lpad('中国',2000,'中国');

F1                                                              
----------------------------------------------------------------

0 rows fetched.

SQL> drop table if exists test2;

Succeed.

SQL> create table test2(f1 varchar2(2000 char), f2 varchar2(2000 char));

Succeed.

SQL> create index idx_test2 on test2(f1, f2);

Succeed.

SQL> insert into test2 values(lpad('中国',1000,'中国'), lpad('中国',1000,'中国'));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> select * from test2 where f1 = lpad('中国',1000,'中国') and f2 = lpad('中国',1000,'中国');

F1                                                               F2                                                              
---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> drop table test1;

Succeed.

SQL> drop table test2;

Succeed.

SQL> drop PROCEDURE hzy_unuasble.LOB_HZY_PROC_1115;

Succeed.

SQL> drop user hzy_unuasble cascade;

Succeed.

SQL> drop table if exists test_time;

Succeed.

SQL> CREATE TABLE test_time (time  TIMESTAMP(6) WITH TIME ZONE);

Succeed.

SQL> create index idx_time on test_time(time);

Succeed.

SQL> insert into test_time values ('2020-01-01 08:00:00.00000 +01:00');

1 rows affected.

SQL> commit;

Succeed.

SQL> update test_time set time = '2020-01-01 09:00:00.00000 +02:00';

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 09:00:00.000000 +02:00       

1 rows fetched.

SQL> update test_time set time = '2020-01-01 08:00:00.00000 +01:00'; 

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 08:00:00.000000 +01:00       

1 rows fetched.

SQL> truncate table test_time;

Succeed.

SQL> drop index idx_time on test_time;

Succeed.

SQL> create index idx_time on test_time(time) crmode row;

Succeed.

SQL> insert into test_time values ('2020-01-01 08:00:00.00000 +01:00');

1 rows affected.

SQL> commit;

Succeed.

SQL> update test_time set time = '2020-01-01 09:00:00.00000 +02:00';

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 09:00:00.000000 +02:00       

1 rows fetched.

SQL> update test_time set time = '2020-01-01 08:00:00.00000 +01:00'; 

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 08:00:00.000000 +01:00       

1 rows fetched.

SQL> drop table test_time;

Succeed.

SQL> create global temporary table test_time (time  TIMESTAMP(6) WITH TIME ZONE) on commit PRESERVE rows;

Succeed.

SQL> create index idx_time on test_time(time);

Succeed.

SQL> insert into test_time values ('2020-01-01 08:00:00.00000 +01:00');

1 rows affected.

SQL> commit;

Succeed.

SQL> update test_time set time = '2020-01-01 09:00:00.00000 +02:00';

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 09:00:00.000000 +02:00       

1 rows fetched.

SQL> update test_time set time = '2020-01-01 08:00:00.00000 +01:00'; 

1 rows affected.

SQL> select * from test_time;

TIME                                    
----------------------------------------
2020-01-01 08:00:00.000000 +01:00       

1 rows fetched.

SQL> drop table test_time;

Succeed.

SQL> 
SQL> --DTS202104260DGXB4P1I00
SQL> drop table IF EXISTS TEST_DUPLICATE_127;

Succeed.

SQL> 
SQL> CREATE TABLE "TEST_DUPLICATE_127"
  2 (
  3  "ID" BINARY_DOUBLE NOT NULL,
  4  "GRADE" BINARY_DOUBLE
  5 );

Succeed.

SQL> 
SQL> create unique index idx_DUPLICATE_127 on "TEST_DUPLICATE_127"(id);

Succeed.

SQL> INSERT INTO "TEST_DUPLICATE_127" ("ID","GRADE") values (0.1234567891,null);

1 rows affected.

SQL> INSERT INTO "TEST_DUPLICATE_127" ("ID","GRADE") values (0.12345678912,null);

CT-00729, Unique constraint violated, index IDX_DUPLICATE_127, duplicate key 0.1234567891
SQL> INSERT INTO "TEST_DUPLICATE_127" ("ID","GRADE") values (0.1234567891236,null);

CT-00729, Unique constraint violated, index IDX_DUPLICATE_127, duplicate key 0.1234567891
SQL> COMMIT;

Succeed.

SQL> truncate table "TEST_DUPLICATE_127";

Succeed.

SQL> drop index idx_DUPLICATE_127 on "TEST_DUPLICATE_127";

Succeed.

SQL> create index idx_DUPLICATE_127 on "TEST_DUPLICATE_127"(id);

Succeed.

SQL> INSERT INTO "TEST_DUPLICATE_127" ("ID","GRADE") values (1000000000000005994, 1);

1 rows affected.

SQL> update "TEST_DUPLICATE_127" set id = 1000000000000006903 where id = 1000000000000005994;

1 rows affected.

SQL> update "TEST_DUPLICATE_127" set id = 1000000000000006740 where id = 1000000000000006903;

1 rows affected.

SQL> update "TEST_DUPLICATE_127" set id = 1000000000000005617 where id = 1000000000000006740;

1 rows affected.

SQL> rollback;

Succeed.

SQL> drop table TEST_DUPLICATE_127;

Succeed.

SQL> --20210525
SQL> drop table if exists temp001;

Succeed.

SQL> create table temp001(f1 int, f2 int, f3 varchar(1000));

Succeed.

SQL> insert into temp001 values(1,1,'sdsdsf'),(2,2,'sdsafdg');

2 rows affected.

SQL> commit;

Succeed.

SQL> create index temp001_idx on temp001(f1);

Succeed.

SQL> create index temp001_idx2 on temp001(f2);

Succeed.

SQL> explain select /*+rule*/ * from (select null a, f2 b from temp001 union all select f1 a, null b from temp001) where a = 1 or b = 2;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name         | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |              |      |      |       |        |
| 1   |   SUBSELECT                       |       |              |      |      |       |        |
| 2   |     UNION ALL                     |       |              |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | TEMP001      |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | TEMP001_IDX2 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ONLY  | SYS   | TEMP001      |      |      |       |        |
| 6   |         INDEX RANGE SCAN          | SYS   | TEMP001_IDX  |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: A = 1 OR B = 2
   4 - access: F2 = 2
   6 - access: F1 = 1

16 rows fetched.

SQL> explain select /*+rule*/ * from (select null a, f2 b, f3 c from temp001 union all select f1 a, null b, f3 c from temp001) where (a = 1 or b = 2 ) and c is not null;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   SUBSELECT                        |       |              |      |      |       |        |
| 2   |     UNION ALL                      |       |              |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP001      |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | TEMP001_IDX2 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP001      |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | TEMP001_IDX  |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: C IS NOT NULL AND A = 1 OR B = 2
   3 - filter: F3 IS NOT NULL
   4 - access: F2 = 2
   5 - filter: F3 IS NOT NULL
   6 - access: F1 = 1

18 rows fetched.

SQL> explain select /*+rule*/ * from (select null a, f2 b, f3 c from temp001) where (a = 1 or b = 2 ) and c is not null;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP001      |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP001_IDX2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: F3 IS NOT NULL
   2 - access: F2 = 2

11 rows fetched.

SQL> explain select * from (select /*+rule*/ null a, f2 b, f3 c from temp001 ,sys_dummy) where (a = 1 or b = 2 ) and c is not null;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |              |      |      |       |        |
| 1   |   SUBSELECT                        |       |              |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |              |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP001      |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | TEMP001_IDX2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL            | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - filter: F3 IS NOT NULL
   4 - access: F2 = 2

14 rows fetched.

SQL> explain select * from (select null a, f2 b, f3 c from temp001 ,sys_dummy) where (a = 1 or b = 2 ) and c is not null;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP001      |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP001_IDX2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | SYS_DUMMY    |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F3 IS NOT NULL                                   
   3 - access: F2 = 2                                           

13 rows fetched.

SQL> drop table temp001;

Succeed.

SQL> alter system set ENABLE_IDX_KEY_LEN_CHECK = FALSE;

Succeed.

SQL> drop table if exists large_key;

Succeed.

SQL> CREATE TABLE large_key(c1 INTEGER, c2 VARCHAR(4100), c3 INTEGER, c4 char(100)) partition by range (c1) (partition p1 values less than (10), partition p2 values less than (20), partition p3 values less than  (maxvalue)) ;

Succeed.

SQL> insert into large_key values (1, LPAD('1', 4058, '1'), 2, '1');

1 rows affected.

SQL> insert into large_key values (1, LPAD('1', 4058, '1'), 2, '1');

1 rows affected.

SQL> insert into large_key values (1, LPAD('1', 4058, '1'), 2, '1');

1 rows affected.

SQL> insert into large_key values (1, LPAD('1', 4058, '1'), 2, '1');

1 rows affected.

SQL> CREATE INDEXcluster (INDEX ix_large_key ON large_key( c2, c3) parallel 5 local, INDEX ix_large_key_1 ON large_key(c2) parallel 5 local, INDEX ix_large_key_2 ON large_key(c1, c2, c3) parallel 5  local);

CT-00779, Index build failed: The total size of index columns within an index exceeded the maximum (4058)
SQL> drop table if exists large_key;

Succeed.

SQL> alter system set ENABLE_IDX_KEY_LEN_CHECK = TRUE;
Succeed.




