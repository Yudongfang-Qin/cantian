

SQL> conn / as sysdba

connected.

SQL> drop table if exists t_par_tab_idx_0001;

Succeed.

SQL> CREATE TABLE t_par_tab_idx_0001
  2 (c_vchar varchar(2000))
  3 PARTITION BY LIST (c_vchar)
  4 (
  5 partition t_par_tab_idx_0001_P_50 values ('1+2+1.1' ||max(2) over(partition by 1)),
  6 partition t_par_tab_idx_0001_P_100 values (upper('abc'))
  7 );

CT-01316, [5:62]Unexpected windows sort analytic function
SQL> drop table if exists t_par_tab_idx_0001;

Succeed.

SQL> drop table if exists t_par_tab_idx_0002;

Succeed.

SQL> CREATE TABLE t_par_tab_idx_0002
  2 (c_vchar varchar(2000))
  3 PARTITION BY LIST (c_vchar)
  4 (
  5 partition t_par_tab_idx_0002_P_50 values ('1+2+1.1'),
  6 partition t_par_tab_idx_0002_P_100 values (upper('abc'))
  7 );

Succeed.

SQL> insert into t_par_tab_idx_0002 values('1+2+1.1'||max(2) over(partition by 1));

CT-01316, [1:57]Unexpected windows sort analytic function
SQL> update t_par_tab_idx_0002 set c_vchar = max(2) over(partition by 1);

CT-01316, [1:48]Unexpected windows sort analytic function
SQL> REPLACE INTO t_par_tab_idx_0002(c_vchar) VALUES(max(2) over(partition by 1));

CT-01316, [1:56]Unexpected windows sort analytic function
SQL> drop table if exists TEST;

Succeed.

SQL> create table TEST (ID INTEGER,VALUE VARCHAR2(255) );

Succeed.

SQL> MERGE INTO  TEST T1
  2 USING (SELECT '2' as ID, 'newtest2' as VALUE FROM dual) T2 on (T1.ID=T2.ID)
  3 WHEN MATCHED THEN UPDATE SET T1.VALUE=max(2) over(partition by 1)
  4 WHEN NOT MATCHED THEN  INSERT (T1.VALUE) VALUES (max(2) over(partition by 1));

CT-01316, [3:46]Unexpected windows sort analytic function
SQL> insert into TEST values (2, 'test2');

1 rows affected.

SQL> MERGE INTO  TEST T1
  2 USING (SELECT '2' as ID, 'newtest2' as VALUE FROM dual) T2 on (T1.ID=T2.ID)
  3 WHEN MATCHED THEN UPDATE SET T1.VALUE=max(2) over(partition by 1)
  4 WHEN NOT MATCHED THEN  INSERT (T1.VALUE) VALUES (max(2) over(partition by 1));

CT-01316, [3:46]Unexpected windows sort analytic function
SQL> drop table TEST;

Succeed.

SQL> create table TEST_INTREVAL_ALL_PART_STORE
  2 (HIREDATE DATE)
  3 PARTITION BY RANGE (HIREDATE)
  4 INTERVAL (NUMTODSINTERVAL(max(2) over(partition by 1),'DAY'))
  5 STORE IN(tablespace users, tablespace system)
  6 (PARTITION ALL_PART_STORE_PART01
  7 VALUES LESS THAN (TO_DATE ('02/02/1981', 'MM/DD/YYYY')),
  8 PARTITION ALL_PART_STORE_PART02
  9 VALUES LESS THAN (TO_DATE ('03/02/1981', 'MM/DD/YYYY'))
 10 );

CT-01316, [4:34]Unexpected windows sort analytic function
SQL> create table TEST_INTREVAL_ALL_PART_STORE
  2 ( HIREDATE DATE)
  3 PARTITION BY RANGE (HIREDATE)
  4 INTERVAL (NUMTODSINTERVAL(1,'DAY'))
  5 STORE IN(tablespace users, tablespace system)
  6 (PARTITION ALL_PART_STORE_PART01
  7 VALUES LESS THAN (max(2) over(partition by 1)),
  8 PARTITION ALL_PART_STORE_PART02
  9 VALUES LESS THAN (TO_DATE ('03/02/1981', 'MM/DD/YYYY'))
 10 );

CT-01316, [7:26]Unexpected windows sort analytic function
SQL> create table TEST_INTREVAL_ALL_PART_STORE
  2 ( HIREDATE DATE)
  3 PARTITION BY RANGE (HIREDATE)
  4 (PARTITION ALL_PART_STORE_PART01
  5 VALUES LESS THAN (TO_DATE ('03/02/1980', 'MM/DD/YYYY')),
  6 PARTITION ALL_PART_STORE_PART02
  7 VALUES LESS THAN (TO_DATE ('03/02/1981', 'MM/DD/YYYY'))
  8 );

Succeed.

SQL> alter table TEST_INTREVAL_ALL_PART_STORE set INTERVAL (NUMTODSINTERVAL(max(2) over(partition by 1),'DAY'));

CT-01316, [1:79]Unexpected windows sort analytic function
SQL> drop table if exists cao_tt2;

Succeed.

SQL> create table cao_tt2(id int check (id > max(2) over(partition by 1)));

CT-01316, [1:48]Unexpected windows sort analytic function
SQL> create table cao_tt2(id int );

Succeed.

SQL> alter table cao_tt2 add constraint ck_error check (id > max(2) over(partition by 1));

CT-01316, [1:64]Unexpected windows sort analytic function
SQL> drop table if exists cao_tt2;

Succeed.

SQL> CREATE TABLE bonus_2018(staff_id INT NOT NULL, staff_name CHAR(50), job VARCHAR(30), bonus NUMBER);

Succeed.

SQL> FLASHBACK TABLE bonus_2018 TO TIMESTAMP max(2) over(partition by 1);

CT-01316, [1:48]Unexpected windows sort analytic function
SQL> drop table if exists bonus_2018;

Succeed.

SQL> select * from dual limit 1+max(2) over(partition by 1);

CT-01316, [1:35]Unexpected windows sort analytic function
SQL> create or replace procedure testProcWithAllTypeInputOut(datetime_type IN datetime,timestamp_type IN TIMESTAMP)
  2 as
  3 SWC_Current_1 SYS_REFCURSOR;
  4 begin
  5     if (datetime_type > 1+max(2) over(partition by 1))
  6     then
  7     open SWC_Current_1 for select datetime_type as datetime1,timestamp_type as timestamp_type1 from dual;
  8     dbe_sql.return_cursor(SWC_Current_1);
  9     end if;
 10 end;
 11 /

Succeed.
Warning:
PL/SQL(SYS.TESTPROCWITHALLTYPEINPUTOUT) terminated with compiling errors
[5:34] PLC-01316 Unexpected windows sort analytic function
[9:9] PLC-00920 Undefined symbol IF


SQL> drop table if exists t_aggr_1;

Succeed.

SQL> create table t_aggr_1(f0 int, f1 bigint, f2 double, f3 number(20,10), f4 date, f5 timestamp, f6 char(100), f7 varchar(100), f8 binary(100), f9 clob, f10 blob);

Succeed.

SQL> 
SQL> -- int/bigint/real/decimal/date/timestamp
SQL> insert into t_aggr_1(f0) values(10);

1 rows affected.

SQL> insert into t_aggr_1(f0) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f0) values(5);

1 rows affected.

SQL> insert into t_aggr_1(f0) values(15);

1 rows affected.

SQL> insert into t_aggr_1(f1) values(2147483648);

1 rows affected.

SQL> insert into t_aggr_1(f1) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f1) values(2147483650);

1 rows affected.

SQL> insert into t_aggr_1(f1) values(2147483649);

1 rows affected.

SQL> insert into t_aggr_1(f2) values(12334.997);

1 rows affected.

SQL> insert into t_aggr_1(f2) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f2) values(12334.999);

1 rows affected.

SQL> insert into t_aggr_1(f2) values(12334.998);

1 rows affected.

SQL> insert into t_aggr_1(f3) values(9912334.997);

1 rows affected.

SQL> insert into t_aggr_1(f3) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f3) values(9912334.999);

1 rows affected.

SQL> insert into t_aggr_1(f3) values(9912334.998);

1 rows affected.

SQL> insert into t_aggr_1(f4) values('2018-02-23 13:18:23');

1 rows affected.

SQL> insert into t_aggr_1(f4) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f4) values('2018-02-23 13:18:25');

1 rows affected.

SQL> insert into t_aggr_1(f4) values('2018-02-23 13:18:24');

1 rows affected.

SQL> insert into t_aggr_1(f5) values('2018-02-23 13:18:23.345');

1 rows affected.

SQL> insert into t_aggr_1(f5) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f5) values('2018-02-23 13:18:23.347');

1 rows affected.

SQL> insert into t_aggr_1(f5) values('2018-02-23 13:18:23.346');

1 rows affected.

SQL> insert into t_aggr_1(f6) values('2018-02-23 13:18:23.345');

1 rows affected.

SQL> insert into t_aggr_1(f6) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f6) values('2018-02-23 13:18:23.347');

1 rows affected.

SQL> insert into t_aggr_1(f6) values('2018-02-23 13:18:23.346');

1 rows affected.

SQL> insert into t_aggr_1(f7) values('2018-02-23 13:18:23.345');

1 rows affected.

SQL> insert into t_aggr_1(f7) values(null);

1 rows affected.

SQL> insert into t_aggr_1(f7) values('2018-02-23 13:18:23.347');

1 rows affected.

SQL> insert into t_aggr_1(f7) values('2018-02-23 13:18:23.346');

1 rows affected.

SQL> insert into t_aggr_1(f8, f9, f10) values('1D', '222', '3133');

1 rows affected.

SQL> insert into t_aggr_1(f8, f9, f10) values('1F', '222', '3323');

1 rows affected.

SQL> insert into t_aggr_1(f8, f9, f10) values('1E', '222', '3333');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select max(f0 + 1) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(F0 + 1) OVER (PARTITION BY F0 ORDER BY F0)
----------------------------------------------
6                                             
11                                            
16                                            

3 rows fetched.

SQL> select max(-f0) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(-F0) OVER (PARTITION BY F0 ORDER BY F0)
-------------------------------------------
-5                                         
-10                                        
-15                                        

3 rows fetched.

SQL> select max(if(f0 is not null, f0, 1)) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(IF(F0 IS NOT NULL, F0, 1)) OVER (PARTITION BY F0 ORDER BY F0
----------------------------------------------------------------
5                                                               
10                                                              
15                                                              

3 rows fetched.

SQL> select max(if(f0 > 0, f0, 1)) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(IF(F0 > 0, F0, 1)) OVER (PARTITION BY F0 ORDER BY F0)
---------------------------------------------------------
5                                                        
10                                                       
15                                                       

3 rows fetched.

SQL> select max(if(not f0 > 0, f0, 1)) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(IF(NOT F0 > 0, F0, 1)) OVER (PARTITION BY F0 ORDER BY F0)
-------------------------------------------------------------
1                                                            
1                                                            
1                                                            

3 rows fetched.

SQL> select max(if(f0 is not null and f1 is null, f0, 1)) over (partition by f0 order by f0) from t_aggr_1 where f0 is not null;

MAX(IF(F0 IS NOT NULL AND F1 IS NULL, F0, 1)) OVER (PARTITION BY
----------------------------------------------------------------
5                                                               
10                                                              
15                                                              

3 rows fetched.

SQL> 
SQL> select count(f0), sum(f0), max(f0), min(f0), avg(f0), row_number() over (partition by f0 order by f0) from t_aggr_1;

CT-00609, Expression not in group list
SQL> select count(f0), sum(f0), max(f0), min(f0), avg(f0), row_number() over (partition by f0 order by f0) from t_aggr_1;

CT-00609, Expression not in group list
SQL> select distinct sum(f0), row_number() over (partition by f0 order by f0) from t_aggr_1;

CT-00609, Expression not in group list
SQL> select row_number() over (partition by f0 order by f0) from t_aggr_1 group by f0;

ROW_NUMBER() OVER (PARTITION BY F0 ORDER BY F0)
-----------------------------------------------
1                                              
1                                              
1                                              
1                                              

4 rows fetched.

SQL> explain plan for select row_number() over (partition by f0 order by f0) from t_aggr_1 group by f0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   WINDOW SORT            |       |          |      |      |       |        |
| 2   |     HASH GROUP BY        |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_AGGR_1 |      |      |       |        |
------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain plan for select row_number() over (partition by f0 order by f0), row_number() over (partition by f1 order by f1) from t_aggr_1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   WINDOW SORT            |       |          |      |      |       |        |
| 2   |     WINDOW SORT          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_AGGR_1 |      |      |       |        |
------------------------------------------------------------------------------------

8 rows fetched.

SQL> 
SQL> select row_number() over from t_aggr_1;

CT-00828, [1:8]function SYS.ROW_NUMBER does not exist
SQL> select row_number() over () from t_aggr_1;

CT-00253, [1:21]Order-by clause should be specified for the function "ROW_NUMBER"
SQL> select row_number() over (partition by f0) from t_aggr_1;

CT-00253, [1:21]Order-by clause should be specified for the function "ROW_NUMBER"
SQL> select row_number() over (aa) from t_aggr_1;

CT-00601, [1:27]Sql syntax error: partition or order expected
SQL> 
SQL> select * from t_aggr_1 where row_number() over (partition by f0 order by f0) = 1;

CT-01316, [1:43]Unexpected windows sort analytic function
SQL> 
SQL> select count(f1) over (partition by f0) from t_aggr_1;

COUNT(F1) OVER (PARTITION BY F0)
--------------------------------
0                               
0                               
0                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               
3                               

35 rows fetched.

SQL> select count(*) over (partition by f0) from t_aggr_1;

COUNT(*) OVER (PARTITION BY F0)
-------------------------------
1                              
1                              
1                              
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             
32                             

35 rows fetched.

SQL> drop table if exists tbl_range;

Succeed.

SQL> create table tbl_range(
  2 col_int int AUTO_INCREMENT primary key,
  3 col_bigint bigint not null default '3',
  4 col_integer integer,
  5 col_varchar_200 varchar(200),
  6 col_varchar2_1000 varchar2(1000)
  7 );

Succeed.

SQL> 
SQL> explain SELECT col_int,
  2        (case
  3          when col_varchar_200 is not null then
  4           col_varchar_200
  5          else
  6           'NO'
  7        end) as c1,
  8        Row_Number() OVER(partition by(case
  9          when col_varchar_200 is not null then
 10           col_varchar_200
 11          else
 12           'NO'
 13        end),(case
 14          when col_varchar2_1000 >= col_varchar_200 then
 15           col_varchar2_1000
 16          else
 17           col_varchar_200
 18        end) ORDER BY col_int desc) as c3
 19   FROM tbl_range;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |           |      |      |       |        |
| 1   |   WINDOW SORT          |       |           |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TBL_RANGE |      |      |       |        |
-----------------------------------------------------------------------------------

7 rows fetched.

SQL> 
SQL> --DTS2019011706076 
SQL> drop table if exists t_winsort_001;

Succeed.

SQL> drop table if exists t_winsort_101;

Succeed.

SQL> 
SQL> create table t_winsort_001(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp)
  5 PARTITION BY RANGE(id)
  6 (
  7 PARTITION id1 VALUES LESS than(10),
  8 PARTITION id2 VALUES LESS than(100),
  9 PARTITION id3 VALUES LESS than(1000),
 10 PARTITION id4 VALUES LESS than(MAXVALUE)
 11 );

Succeed.

SQL> insert into t_winsort_001 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-01-01 10:51:47.123456'),'yyyy-mm-dd hh24:mi:ss.FF6'));

1 rows affected.

SQL> insert into t_winsort_001 values(0,null,null,null,null,null,null,null,null,null,null,null,null,null,null);

1 rows affected.

SQL> 
SQL> create table t_winsort_101 as select * from t_winsort_001;    

Succeed.

SQL> 
SQL> select count(*) from t_winsort_001 t1 where exists (select max(t11.c_int) over(partition by max(t11.c_int) over(partition by 100000)) from t_winsort_101 t11 where t11.c_number=t1.c_number);

CT-01316, [1:108]Unexpected windows sort analytic function
SQL> 
SQL> drop table t_winsort_001;

Succeed.

SQL> drop table t_winsort_101;

Succeed.

SQL> 
SQL> 
SQL> drop table if exists t_winsort_002;

Succeed.

SQL> create table t_winsort_002(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp)
  5 PARTITION BY RANGE(id)
  6 (
  7 PARTITION id1 VALUES LESS than(10),
  8 PARTITION id2 VALUES LESS than(100),
  9 PARTITION id3 VALUES LESS than(1000),
 10 PARTITION id4 VALUES LESS than(MAXVALUE)
 11 );

Succeed.

SQL> insert into t_winsort_002 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-01-01 10:51:47.123456'),'yyyy-mm-dd hh24:mi:ss.FF6'));

1 rows affected.

SQL> 
SQL> select case when max(id) over( partition by (c_int+c_real)) then id end from t_winsort_002;

CASE WHEN MAX(ID) OVER( PARTITION BY (C_INT+C_REAL)) THEN ID END
----------------------------------------------------------------
1                                                               

1 rows fetched.

SQL> drop table t_winsort_002;

Succeed.

SQL> 
SQL> drop table if exists cume_dist_t1;

Succeed.

SQL> create table cume_dist_t1(c1 int , c2 int, c3 varchar(10));

Succeed.

SQL> insert into cume_dist_t1 values(1,3,'a1'),(1,2,'a2'),(1,1,'a3'),(1,3,'a4'),(1,2,'a5');

5 rows affected.

SQL> insert into cume_dist_t1 values(2,1,'a6'),(2,3,'a7'),(2,2,'a8'),(2,1,'a9');

4 rows affected.

SQL> insert into cume_dist_t1 values(3,1,'a10'),(3,3,'a11'),(3,2,'a12'),(3,1,'a13'),(3,5,'a14'),(3,5,'a15'),(3,7,'a16');

7 rows affected.

SQL> insert into cume_dist_t1 values(4,1,'a17');

1 rows affected.

SQL> commit;

Succeed.

SQL>
SQL> --ok
SQL> select c1, c2, c3, CUME_DIST() OVER (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.0588235294117647
1            2            a2         0.176470588235294
1            2            a5         0.176470588235294
1            3            a1         0.294117647058824
1            3            a4         0.294117647058824
2            1            a6         0.411764705882353
2            1            a9         0.411764705882353
2            2            a8         0.470588235294118
2            3            a7         0.529411764705882
3            1            a10        0.647058823529412
3            1            a13        0.647058823529412
3            2            a12        0.705882352941177
3            3            a11        0.764705882352941
3            5            a14        0.882352941176471
3            5            a15        0.882352941176471
3            7            a16        0.941176470588235
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (ORDER BY c1 desc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.764705882352941
1            2            a2         0.882352941176471
1            2            a5         0.882352941176471
1            3            a1         1
1            3            a4         1
2            1            a6         0.588235294117647
2            1            a9         0.588235294117647
2            2            a8         0.647058823529412
2            3            a7         0.705882352941177
3            1            a10        0.176470588235294
3            1            a13        0.176470588235294
3            2            a12        0.235294117647059
3            3            a11        0.294117647058824
3            5            a14        0.411764705882353
3            5            a15        0.411764705882353
3            7            a16        0.470588235294118
4            1            a17        0.0588235294117647

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (ORDER BY c1 asc, c2 desc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.294117647058824
1            2            a2         0.235294117647059
1            2            a5         0.235294117647059
1            3            a1         0.117647058823529
1            3            a4         0.117647058823529
2            1            a6         0.529411764705882
2            1            a9         0.529411764705882
2            2            a8         0.411764705882353
2            3            a7         0.352941176470588
3            1            a10        0.941176470588235
3            1            a13        0.941176470588235
3            2            a12        0.823529411764706
3            3            a11        0.764705882352941
3            5            a14        0.705882352941177
3            5            a15        0.705882352941177
3            7            a16        0.588235294117647
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (ORDER BY c1 desc, c2 desc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         1
1            2            a2         0.941176470588235
1            2            a5         0.941176470588235
1            3            a1         0.823529411764706
1            3            a4         0.823529411764706
2            1            a6         0.705882352941177
2            1            a9         0.705882352941177
2            2            a8         0.588235294117647
2            3            a7         0.529411764705882
3            1            a10        0.470588235294118
3            1            a13        0.470588235294118
3            2            a12        0.352941176470588
3            3            a11        0.294117647058824
3            5            a14        0.235294117647059
3            5            a15        0.235294117647059
3            7            a16        0.117647058823529
4            1            a17        0.0588235294117647

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (partition by c1 ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.2
1            2            a2         0.6
1            2            a5         0.6
1            3            a1         1
1            3            a4         1
2            1            a6         0.5
2            1            a9         0.5
2            2            a8         0.75
2            3            a7         1
3            1            a10        0.285714285714286
3            1            a13        0.285714285714286
3            2            a12        0.428571428571429
3            3            a11        0.571428571428571
3            5            a14        0.857142857142857
3            5            a15        0.857142857142857
3            7            a16        1
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (partition by c1 ORDER BY c1 desc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.2
1            2            a2         0.6
1            2            a5         0.6
1            3            a1         1
1            3            a4         1
2            1            a6         0.5
2            1            a9         0.5
2            2            a8         0.75
2            3            a7         1
3            1            a10        0.285714285714286
3            1            a13        0.285714285714286
3            2            a12        0.428571428571429
3            3            a11        0.571428571428571
3            5            a14        0.857142857142857
3            5            a15        0.857142857142857
3            7            a16        1
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (partition by c1 ORDER BY c1 asc, c2 desc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         1
1            2            a2         0.8
1            2            a5         0.8
1            3            a1         0.4
1            3            a4         0.4
2            1            a6         1
2            1            a9         1
2            2            a8         0.5
2            3            a7         0.25
3            1            a10        1
3            1            a13        1
3            2            a12        0.714285714285714
3            3            a11        0.571428571428571
3            5            a14        0.428571428571429
3            5            a15        0.428571428571429
3            7            a16        0.142857142857143
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, CUME_DIST() OVER (partition by c1 ORDER BY c1 desc, c2 desc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         1
1            2            a2         0.8
1            2            a5         0.8
1            3            a1         0.4
1            3            a4         0.4
2            1            a6         1
2            1            a9         1
2            2            a8         0.5
2            3            a7         0.25
3            1            a10        1
3            1            a13        1
3            2            a12        0.714285714285714
3            3            a11        0.571428571428571
3            5            a14        0.428571428571429
3            5            a15        0.428571428571429
3            7            a16        0.142857142857143
4            1            a17        1

17 rows fetched.

SQL> select c1, c2, c3, cast(CUME_DIST() OVER (partition by c1 ORDER BY c1 asc, c2 asc) as double) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

C1           C2           C3         cume_dist_col
------------ ------------ ---------- --------------------
1            1            a3         0.2
1            2            a2         0.6
1            2            a5         0.6
1            3            a1         1
1            3            a4         1
2            1            a6         0.5
2            1            a9         0.5
2            2            a8         0.75
2            3            a7         1
3            1            a10        0.285714285714286
3            1            a13        0.285714285714286
3            2            a12        0.428571428571429
3            3            a11        0.571428571428571
3            5            a14        0.857142857142857
3            5            a15        0.857142857142857
3            7            a16        1
4            1            a17        1

17 rows fetched.

SQL>
SQL> --error
SQL> select c1, c2, c3, CUME_DIST(23) OVER (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00601, [1:34]Sql syntax error: within expected
SQL> drop table if exists cume_dist_t1;

Succeed.

SQL> 
SQL> -- CUME_DIST as aggr func
SQL> drop table if exists cume_dist_t1;

Succeed.

SQL> create table cume_dist_t1(c1 int , c2 int, c3 varchar(10));

Succeed.

SQL> insert into cume_dist_t1 values(6,3,'a1');

1 rows affected.

SQL> insert into cume_dist_t1 values(6,2,'a2');

1 rows affected.

SQL> insert into cume_dist_t1 values(6,1,'a3');

1 rows affected.

SQL> insert into cume_dist_t1 values(7,1,'a3');

1 rows affected.

SQL> commit;

Succeed.

SQL>
SQL> select CUME_DIST(6, '3.365') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.8

1 rows fetched.

SQL> select CUME_DIST(6, 3) WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.2

1 rows fetched.

SQL> select CUME_DIST(6, '3') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.2

1 rows fetched.

SQL> select CUME_DIST(6, 'a1') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.4

1 rows fetched.

SQL> select CUME_DIST(6, 'a2') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.6

1 rows fetched.

SQL> select CUME_DIST(6, 'a3') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.8

1 rows fetched.

SQL> select CUME_DIST(6, 'a5') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.8

1 rows fetched.

SQL> select CUME_DIST(8, 'a5') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
1

1 rows fetched.

SQL>
SQL> select CUME_DIST(2, 2) WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.2

1 rows fetched.

SQL> select CUME_DIST(2, '2') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.2

1 rows fetched.

SQL> select CUME_DIST(6, '2') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.6

1 rows fetched.

SQL> select CUME_DIST(6, ' 1 ') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.4

1 rows fetched.

SQL> select CUME_DIST(2, 'ew') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL> select CUME_DIST(2, ' 34rfd') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL> select CUME_DIST(2, '00gfdtr') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL> select CUME_DIST(2) WITHIN GROUP (ORDER BY c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc;

cume_dist_col
--------------------
0.8

1 rows fetched.

SQL> select c1, CUME_DIST(2) WITHIN GROUP (ORDER BY c2 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

C1           cume_dist_col
------------ --------------------
6            0.75
7            1

2 rows fetched.

SQL>
SQL> select CUME_DIST('2', '2') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

cume_dist_col
--------------------
0.2

1 rows fetched.

SQL> select CUME_DIST('2aaa', '2') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL>
SQL> select CUME_DIST(6) WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00601, [1:18]Sql syntax error: invalid number of arguments
SQL> select CUME_DIST(6, 'a1') WITHIN GROUP (ORDER BY c1 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00601, [1:18]Sql syntax error: invalid number of arguments
SQL> select CUME_DIST(c1) WITHIN GROUP (ORDER BY c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc;

CT-00601, [1:18]Sql syntax error: Argument should be a constant
SQL> select CUME_DIST(c1, c2) WITHIN GROUP (ORDER BY c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc;

CT-00601, [1:18]Sql syntax error: invalid number of arguments
SQL> select CUME_DIST('cdsfdsvfd', 2) WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL> select CUME_DIST(5, 'dscvdscvsd') WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00636, [1:8]Invalid number -- unexpected character
SQL> select CUME_DIST(current_timestamp(), 2) WITHIN GROUP (ORDER BY c1 asc, c2 asc) as "cume_dist_col"  FROM cume_dist_t1 order by c1 asc, c2 asc, c3 asc;

CT-00601, [1:18]Sql syntax error: Argument should be a constant
SQL>
SQL> select CUME_DIST(3, 3) WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
0.25
0.5

2 rows fetched.

SQL> select CUME_DIST(3, '3') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
0.25
0.5

2 rows fetched.

SQL> select CUME_DIST(3, 'a1') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
0.25
0.5

2 rows fetched.

SQL>
SQL> select CUME_DIST(8, 3) WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
1
1

2 rows fetched.

SQL> select CUME_DIST(8, '3d') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
1
1

2 rows fetched.

SQL> select CUME_DIST(8, 'bb') WITHIN GROUP (ORDER BY c1 asc, c3 asc) as "cume_dist_col"  FROM cume_dist_t1 group by c1 order by c1 asc;

cume_dist_col
--------------------
1
1

2 rows fetched.

SQL> drop table if exists cume_dist_t1;

Succeed.

SQL> select dummy from dual order by row_number() over(partition by dummy);

CT-01316, [1:46]Unexpected windows sort analytic function
SQL> select dummy from dual order by row_number() over(order by dummy);

CT-01316, [1:46]Unexpected windows sort analytic function
SQL> 
SQL> --DENSE_RANK()
SQL> drop table if exists tb_win_emp;

Succeed.

SQL> create table tb_win_emp(ename char(10), Hiredate date, sal int);

Succeed.

SQL> insert into tb_win_emp values('smith', to_date('1980-12-17', 'yyyy-mm-dd'), 800);

1 rows affected.

SQL> insert into tb_win_emp values('allen', to_date('1981-2-20', 'yyyy-mm-dd'), 1600);

1 rows affected.

SQL> insert into tb_win_emp values('ward', to_date('1981-2-22', 'yyyy-mm-dd'), 1250);

1 rows affected.

SQL> insert into tb_win_emp values('turner', to_date('1980-12-17', 'yyyy-mm-dd'), 1500);

1 rows affected.

SQL> insert into tb_win_emp values('king', to_date('1981-2-20', 'yyyy-mm-dd'), 5000);

1 rows affected.

SQL> insert into tb_win_emp values('ford', to_date('1980-12-17', 'yyyy-mm-dd'), 950);

1 rows affected.

SQL> insert into tb_win_emp values('rum', to_date('1980-12-17', 'yyyy-mm-dd'), 1500);

1 rows affected.

SQL> insert into tb_win_emp values('tom', to_date('1981-2-20', 'yyyy-mm-dd'), 2975);

1 rows affected.

SQL> insert into tb_win_emp values('zoe', to_date('1981-2-22', 'yyyy-mm-dd'), 1250);

1 rows affected.

SQL> insert into tb_win_emp values('abd', to_date('1980-12-17', 'yyyy-mm-dd'), null);

1 rows affected.

SQL> insert into tb_win_emp values('eae', to_date('1981-2-20', 'yyyy-mm-dd'), null);

1 rows affected.

SQL> insert into tb_win_emp values('wer', to_date('1981-2-22', 'yyyy-mm-dd'), null);

1 rows affected.

SQL> insert into tb_win_emp values('ward', to_date('1981-2-22', 'yyyy-mm-dd'), 1250);

1 rows affected.

SQL> insert into tb_win_emp values('ward', to_date('1981-2-22', 'yyyy-mm-dd'), 900);

1 rows affected.

SQL> insert into tb_win_emp values('turner', to_date('1980-12-17', 'yyyy-mm-dd'), 1550);

1 rows affected.

SQL> commit;

Succeed.

SQL> select sal, dense_rank() over (order by sal) as dense_rank from tb_win_emp;

SAL          DENSE_RANK  
------------ ------------
800          1           
900          2           
950          3           
1250         4           
1250         4           
1250         4           
1500         5           
1500         5           
1550         6           
1600         7           
2975         8           
5000         9           
             10          
             10          
             10          

15 rows fetched.

SQL> select hiredate, sal, dense_rank() over (partition by hiredate order by sal) as dense_rank from tb_win_emp;

HIREDATE               SAL          DENSE_RANK  
---------------------- ------------ ------------
1980-12-17 00:00:00    800          1           
1980-12-17 00:00:00    950          2           
1980-12-17 00:00:00    1500         3           
1980-12-17 00:00:00    1500         3           
1980-12-17 00:00:00    1550         4           
1980-12-17 00:00:00                 5           
1981-02-20 00:00:00    1600         1           
1981-02-20 00:00:00    2975         2           
1981-02-20 00:00:00    5000         3           
1981-02-20 00:00:00                 4           
1981-02-22 00:00:00    900          1           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00                 3           

15 rows fetched.

SQL> select hiredate, sal, ename, dense_rank() over (partition by hiredate order by sal desc nulls last, ename asc nulls first) as dense_rank from tb_win_emp;

HIREDATE               SAL          ENAME      DENSE_RANK  
---------------------- ------------ ---------- ------------
1980-12-17 00:00:00    1550         turner     1           
1980-12-17 00:00:00    1500         rum        2           
1980-12-17 00:00:00    1500         turner     3           
1980-12-17 00:00:00    950          ford       4           
1980-12-17 00:00:00    800          smith      5           
1980-12-17 00:00:00                 abd        6           
1981-02-20 00:00:00    5000         king       1           
1981-02-20 00:00:00    2975         tom        2           
1981-02-20 00:00:00    1600         allen      3           
1981-02-20 00:00:00                 eae        4           
1981-02-22 00:00:00    1250         ward       1           
1981-02-22 00:00:00    1250         ward       1           
1981-02-22 00:00:00    1250         zoe        2           
1981-02-22 00:00:00    900          ward       3           
1981-02-22 00:00:00                 wer        4           

15 rows fetched.

SQL> select hiredate, sal, dense_rank() over (partition by hiredate) as dense_rank from tb_win_emp;

CT-00253, [1:36]Order-by clause should be specified for the function "DENSE_RANK"
SQL> select hiredate, sal, dense_rank(sal) over (partition by hiredate order by sal) as dense_rank from tb_win_emp;

CT-00601, [1:39]Sql syntax error: within expected
SQL> select dense_rank() over (order by sal) as dense_rank from tb_win_emp group by hiredate;

CT-00609, [1:36]Expression not in group list
SQL> --rank
SQL> select sal, rank() over (order by sal) as rank from tb_win_emp;

SAL          RANK        
------------ ------------
800          1           
900          2           
950          3           
1250         4           
1250         4           
1250         4           
1500         7           
1500         7           
1550         9           
1600         10          
2975         11          
5000         12          
             13          
             13          
             13          

15 rows fetched.

SQL> select hiredate, sal, rank() over (partition by hiredate order by sal) as rank from tb_win_emp;

HIREDATE               SAL          RANK        
---------------------- ------------ ------------
1980-12-17 00:00:00    800          1           
1980-12-17 00:00:00    950          2           
1980-12-17 00:00:00    1500         3           
1980-12-17 00:00:00    1500         3           
1980-12-17 00:00:00    1550         5           
1980-12-17 00:00:00                 6           
1981-02-20 00:00:00    1600         1           
1981-02-20 00:00:00    2975         2           
1981-02-20 00:00:00    5000         3           
1981-02-20 00:00:00                 4           
1981-02-22 00:00:00    900          1           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00    1250         2           
1981-02-22 00:00:00                 5           

15 rows fetched.

SQL> select hiredate, sal, ename, rank() over (partition by hiredate order by sal desc nulls last, ename asc nulls first) as rank from tb_win_emp;

HIREDATE               SAL          ENAME      RANK        
---------------------- ------------ ---------- ------------
1980-12-17 00:00:00    1550         turner     1           
1980-12-17 00:00:00    1500         rum        2           
1980-12-17 00:00:00    1500         turner     3           
1980-12-17 00:00:00    950          ford       4           
1980-12-17 00:00:00    800          smith      5           
1980-12-17 00:00:00                 abd        6           
1981-02-20 00:00:00    5000         king       1           
1981-02-20 00:00:00    2975         tom        2           
1981-02-20 00:00:00    1600         allen      3           
1981-02-20 00:00:00                 eae        4           
1981-02-22 00:00:00    1250         ward       1           
1981-02-22 00:00:00    1250         ward       1           
1981-02-22 00:00:00    1250         zoe        3           
1981-02-22 00:00:00    900          ward       4           
1981-02-22 00:00:00                 wer        5           

15 rows fetched.

SQL> select hiredate, sal, rank() over (partition by hiredate) as rank from tb_win_emp;

CT-00253, [1:30]Order-by clause should be specified for the function "RANK"
SQL> select hiredate, sal, rank(sal) over (partition by hiredate order by sal) as rank from tb_win_emp;

CT-00601, [1:33]Sql syntax error: within expected
SQL> select rank() over (order by sal) as rank from tb_win_emp group by hiredate;

CT-00609, [1:30]Expression not in group list
SQL> drop table tb_win_emp;

Succeed.

SQL> 
SQL> drop table if exists t_winsort_push;

Succeed.

SQL> create table t_winsort_push(f_varchar1 varchar(32), f_int1 int, f_int2 int);

Succeed.

SQL> create index idx_t_winsort_push_1 on t_winsort_push(f_int1);

Succeed.

SQL> create index idx_t_winsort_push_2 on t_winsort_push(f_int2);

Succeed.

SQL> explain select * from (select f_int1,f_int2,sum(f_int2)over(partition by f_int1 order by f_int2) mm from t_winsort_push) where mm = 95;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                |      |      |       |        |
| 1   |   SUBSELECT              |       |                |      |      |       |        |
| 2   |     WINDOW SORT          |       |                |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_WINSORT_PUSH |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: MM = 95                                          

11 rows fetched.

SQL> explain select * from (select f_int1,f_int2,sum(f_int2)over(partition by f_int1 order by f_int2) mm from t_winsort_push) where f_int2 = 95;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                |      |      |       |        |
| 1   |   SUBSELECT              |       |                |      |      |       |        |
| 2   |     WINDOW SORT          |       |                |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_WINSORT_PUSH |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: T_WINSORT_PUSH.F_INT2 = 95                       

11 rows fetched.

SQL> explain select * from (select f_int1,f_int2,sum(f_int2)over(partition by f_int1 order by f_int2) mm from t_winsort_push) where f_int1 = 3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                 | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                      |      |      |       |        |
| 1   |   SUBSELECT                        |       |                      |      |      |       |        |
| 2   |     WINDOW SORT                    |       |                      |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_WINSORT_PUSH       |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_T_WINSORT_PUSH_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T_WINSORT_PUSH.F_INT1 = 3                        

12 rows fetched.

SQL> explain SELECT TABLE_NAME  FROM USER_TAB_PARTITIONS WHERE TABLE_NAME ='TBL_RESULT_1526726743_1' AND ROWNUM <= 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name                | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |                     |      |      |       |        |
| 1   |   ROWNUM FILTER                          |       |                     |      |      |       |        |
| 2   |     VIEW                                 | SYS   | USER_TAB_PARTITIONS |      |      |       |        |
| 3   |       HASH JOIN(L)                       |       |                     |      |      |       |        |
| 4   |         NESTED LOOPS                     |       |                     |      |      |       |        |
| 5   |           NESTED LOOPS                   |       |                     |      |      |       |        |
| 6   |             TABLE ACCESS FULL            | SYS   | DV_ME M             |      |      |       |        |
| 7   |             TABLE ACCESS BY INDEX ROWID  | SYS   | SYS_TABLES T        |      |      |       |        |
| 8   |               INDEX UNIQUE SCAN          | SYS   | IX_TABLE$001        |      |      |       |        |
| 9   |           TABLE ACCESS BY INDEX ROWID    | SYS   | SYS_TABLE_PARTS TP  |      |      |       |        |
| 10  |             INDEX RANGE SCAN             | SYS   | IX_TABLEPART$001    |      |      |       |        |
| 11  |         TABLE ACCESS FULL                | SYS   | DV_TABLESPACES TS   |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: ROWNUM <= 1                                      
   3 - access: TP.SPACE# = TS.ID                                
   8 - access: T.NAME = 'TBL_RESULT_1526726743_1' AND M.USER_ID = T.USER#
   10 - access: TP.USER# = T.USER# AND TP.TABLE# = T.ID AND TP.USER# = M.USER_ID

22 rows fetched.

SQL> drop table if exists t_winsort_push;
Succeed.

SQL>
SQL>--array
SQL> drop table if exists t_rank_over_datatype;

Succeed.

SQL> create table t_rank_over_datatype(id int,deptno int,name varchar(20),sal int,col_16 int[],b_boolean boolean,f_floor decimal(10,2));

Succeed.

SQL> insert into t_rank_over_datatype values(1,1,'1aa',120,'{1,2,3}',true,10.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(2,1,'2aa',300,'{1,3,3}',false,100.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(3,1,'3aa',100,'{1,2,3}',true,99.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(4,1,'4aa',99,'{1,2,3}',true,67.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(5,1,'5aa',90,'{1,3,3}',false,67.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(6,2,'6aa',87,'{1,2,3}',true,10.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(7,2,'7aa',500,'{1,2,3}',false,99.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(8,2,'8aa',200,'{2,3,3}',true,10.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(9,2,'9aa',20,'{1,3,3}',false,99.5);

1 rows affected.

SQL> insert into t_rank_over_datatype values(10,2,'10aa',30,'{2,3,3}',true,99.5);

1 rows affected.

SQL> insert into t_rank_over_datatype values(null,2,'10aa',30,'{2,3,3}',false,10.2);

1 rows affected.

SQL> insert into t_rank_over_datatype values(12,2,'10aa',null,'{2,3,3}',true,10.2);

1 rows affected.

SQL> commit;

Succeed.

SQL> select col_16,nvl(id,sal),rank() over(partition by col_16[2] order by nvl(id,sal)) from t_rank_over_datatype order by 2,3;

COL_16                                                           NVL(ID,SAL)  RANK() OVER(PARTITION BY COL_16[2] ORDER BY NVL(ID,SAL))
---------------------------------------------------------------- ------------ --------------------------------------------------------
{1,2,3}                                                          1            1
{1,3,3}                                                          2            1
{1,2,3}                                                          3            2
{1,2,3}                                                          4            3
{1,3,3}                                                          5            2
{1,2,3}                                                          6            4
{1,2,3}                                                          7            5
{2,3,3}                                                          8            3
{1,3,3}                                                          9            4
{2,3,3}                                                          10           5
{2,3,3}                                                          12           6
{2,3,3}                                                          30           7

12 rows fetched.

SQL> select col_16[2],col_16,nvl(id,sal),rank() over(partition by col_16[2] order by nvl(id,sal)) from t_rank_over_datatype order by 3,4;

COL_16       COL_16                                                           NVL(ID,SAL)  RANK() OVER(PARTITION BY COL_16[2] ORDER BY NVL(ID,SAL))
------------ ---------------------------------------------------------------- ------------ --------------------------------------------------------
2            {1,2,3}                                                          1            1
3            {1,3,3}                                                          2            1
2            {1,2,3}                                                          3            2
2            {1,2,3}                                                          4            3
3            {1,3,3}                                                          5            2
2            {1,2,3}                                                          6            4
2            {1,2,3}                                                          7            5
3            {2,3,3}                                                          8            3
3            {1,3,3}                                                          9            4
3            {2,3,3}                                                          10           5
3            {2,3,3}                                                          12           6
3            {2,3,3}                                                          30           7

12 rows fetched.

SQL> select col_16[2],col_16[1],col_16[1:2],col_16,nvl(id,sal),rank() over(partition by col_16[2] order by nvl(id,sal)) from t_rank_over_datatype order by 5,6;

COL_16       COL_16       COL_16                                                           COL_16                                                           NVL(ID,SAL)  RANK() OVER(PARTITION BY COL_16[2] ORDER BY NVL(ID,SAL))
------------ ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ --------------------------------------------------------
2            1            {1,2}                                                            {1,2,3}                                                          1            1
3            1            {1,3}                                                            {1,3,3}                                                          2            1
2            1            {1,2}                                                            {1,2,3}                                                          3            2
2            1            {1,2}                                                            {1,2,3}                                                          4            3
3            1            {1,3}                                                            {1,3,3}                                                          5            2
2            1            {1,2}                                                            {1,2,3}                                                          6            4
2            1            {1,2}                                                            {1,2,3}                                                          7            5
3            2            {2,3}                                                            {2,3,3}                                                          8            3
3            1            {1,3}                                                            {1,3,3}                                                          9            4
3            2            {2,3}                                                            {2,3,3}                                                          10           5
3            2            {2,3}                                                            {2,3,3}                                                          12           6
3            2            {2,3}                                                            {2,3,3}                                                          30           7

12 rows fetched.

SQL> drop table t_rank_over_datatype;

Succeed.

SQL> 
SQL> drop table if exists for_ntile;

Succeed.

SQL> create table for_ntile(f1 int, f2 int ,f3 int);

Succeed.

SQL> insert into for_ntile values(1,1,10);

1 rows affected.

SQL> insert into for_ntile values(2,1,15);

1 rows affected.

SQL> insert into for_ntile values(3,2,10);

1 rows affected.

SQL> insert into for_ntile values(4,2,15);

1 rows affected.

SQL> insert into for_ntile values(5,1,20);

1 rows affected.

SQL> insert into for_ntile values(6,1,12);

1 rows affected.

SQL> insert into for_ntile values(7,1,22);

1 rows affected.

SQL> insert into for_ntile values(8,1,12);

1 rows affected.

SQL> insert into for_ntile values(9,1,22);

1 rows affected.

SQL> insert into for_ntile values(10,1,15);

1 rows affected.

SQL> commit;

Succeed.

SQL> SELECT NTILE(1+1) OVER(PARTITION BY F2 ORDER BY F3) FROM FOR_NTILE;

NTILE(1+1) OVER(PARTITION BY F2 ORDER BY F3)
--------------------------------------------
1                                           
1                                           
1                                           
1                                           
2                                           
2                                           
2                                           
2                                           
1                                           
2                                           

10 rows fetched.

SQL> select f1,f2,f3,f4 from (select f1,f2,f3,ntile(2) over(partition by f2 order by f3) f4 from for_ntile);

F1           F2           F3           F4                  
------------ ------------ ------------ --------------------
1            1            10           1                   
6            1            12           1                   
8            1            12           1                   
2            1            15           1                   
10           1            15           2                   
5            1            20           2                   
7            1            22           2                   
9            1            22           2                   
3            2            10           1                   
4            2            15           2                   

10 rows fetched.

SQL> select case when ntile(4) over (partition by f2 order by f1,f2) in (1,2) then f2 end a from for_ntile;

A           
------------
1           
1           
1           
1           
            
            
            
            
2           
2           

10 rows fetched.

SQL> drop table for_ntile;

Succeed.

SQL> drop table if exists salary;

Succeed.

SQL> create table salary(stuff_id INT, month INT, salary INT);

Succeed.

SQL> insert into salary values(1, 1, 800);

1 rows affected.

SQL> insert into salary values(1, 2, 900);

1 rows affected.

SQL> insert into salary values(2, 2, 900);

1 rows affected.

SQL> insert into salary values(2, 3, 950);

1 rows affected.

SQL> insert into salary values(3, 4, 880);

1 rows affected.

SQL> insert into salary values(3, 5, 930);

1 rows affected.

SQL> commit;

Succeed.

SQL> select stuff_id, month, salary, FIRST_VALUE(salary) over (PARTITION BY stuff_id) first_month_salary from salary;

STUFF_ID     MONTH        SALARY       FIRST_MONTH_SALARY
------------ ------------ ------------ ------------------
1            1            800          800               
1            2            900          800               
2            2            900          900               
2            3            950          900               
3            4            880          880               
3            5            930          880               

6 rows fetched.

SQL> drop table salary;

Succeed.

SQL> 
SQL> --DTS2020021006768
SQL> drop table if exists t_DTS2020021006768;

Succeed.

SQL> create table t_DTS2020021006768(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10) not null,c_vchar2 varchar2(100),c_clob clob,
  4 c_long varchar(200),c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> insert into t_DTS2020021006768 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-03-05 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_DTS2020021006768 values(-1,null,null,null,null,null,null,'M',null,null,null,null,null,null,null);

1 rows affected.

SQL> CREATE or replace procedure proc_insert(tname varchar,startall int,endall int) as
  2 sqlst varchar(500);
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5                 sqlst := 'insert into ' || tname ||' select id+'||i||',c_int+'||i||',c_real+'||i||',c_float+'||i||',c_decimal+'||i||',c_number+'||i||',c_char'||',c_vchar||'||i||',c_vchar2||'||i||',c_clob||'||i||',c_long||'||i||',c_blob'||',c_raw,ADD_MONTHS(c_date,'||i||'),ADD_MONTHS(c_timestamp,'||i||') from '||tname|| ' where id=1';
  6         execute immediate sqlst;
  7   END LOOP;
  8 END;
  9 /

Succeed.

SQL> exec proc_insert('t_DTS2020021006768',1,6);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> select prior count(id) over(order by t1.id) c from t_DTS2020021006768 t1 connect by nocycle prior t1.id=t1.id+1;

CT-01316, [1:24]Unexpected windows sort analytic function
SQL> drop table t_DTS2020021006768;

Succeed.

SQL> --20200514
SQL> DROP TABLE if exists "FVT_OBJ_DEFINE_TABLE_FRE1";

Succeed.

SQL> DROP TABLE if exists "STUDENT";

Succeed.

SQL> DROP TABLE if exists "SCORE";

Succeed.

SQL> DROP TABLE if exists "EMPLOYEES";

Succeed.

SQL> DROP TABLE if exists "DEPARTMENTS";

Succeed.

SQL> DROP TABLE if exists "DEPT_MANAGER";

Succeed.

SQL> DROP TABLE if exists "DEPT_EMP";

Succeed.

SQL> DROP TABLE if exists "SALARIES";

Succeed.

SQL> DROP TABLE if exists "TEST";

Succeed.

SQL> DROP TABLE if exists "MY_EMPLOYEES";

Succeed.

SQL> CREATE TABLE "FVT_OBJ_DEFINE_TABLE_FRE1"
  2 (
  3   "COL_1" BINARY_BIGINT,
  4   "COL_2" TIMESTAMP(6),
  5   "COL_3" BOOLEAN,
  6   "COL_4" NUMBER,
  7   "COL_5" CLOB,
  8   "COL_6" BINARY_INTEGER,
  9   "COL_7" CHAR(30 BYTE),
 10   "COL_8" BINARY_DOUBLE,
 11   "COL_9" CLOB,
 12   "COL_10" CLOB,
 13   "COL_11" VARCHAR(30 BYTE),
 14   "COL_12" BINARY_DOUBLE,
 15   "COL_13" BOOLEAN,
 16   "COL_14" BOOLEAN,
 17   "COL_15" BLOB,
 18   "COL_16" BINARY_DOUBLE,
 19   "COL_17" VARCHAR(30 BYTE),
 20   "COL_18" VARCHAR(30 BYTE),
 21   "COL_19" TIMESTAMP(6) WITH TIME ZONE,
 22   "COL_20" CHAR(30 BYTE),
 23   "COL_21" BLOB,
 24   "COL_22" NUMBER,
 25   "COL_23" BLOB,
 26   "COL_24" CHAR(30 BYTE),
 27   "COL_25" BINARY_INTEGER,
 28   "COL_26" BINARY_DOUBLE,
 29   "COL_27" NUMBER,
 30   "COL_28" NUMBER,
 31   "COL_29" BINARY_INTEGER,
 32   "COL_30" BLOB,
 33   "COL_31" BINARY_DOUBLE,
 34   "COL_32" BLOB,
 35   "COL_33" NUMBER,
 36   "COL_34" CHAR(30 BYTE),
 37   "COL_35" BINARY_DOUBLE,
 38   "COL_36" CHAR(30 BYTE),
 39   "COL_37" NUMBER,
 40   "COL_38" TIMESTAMP(6),
 41   "COL_39" BINARY_BIGINT,
 42   "COL_40" BINARY_DOUBLE,
 43   "COL_41" BLOB,
 44   "COL_42" BINARY_INTEGER,
 45   "COL_43" BINARY_DOUBLE,
 46   "COL_44" BINARY_INTEGER,
 47   "COL_45" TIMESTAMP(6),
 48   "COL_46" CLOB,
 49   "COL_47" CHAR(30 BYTE),
 50   "COL_48" NUMBER,
 51   "COL_49" BOOLEAN,
 52   "COL_50" BINARY_INTEGER,
 53   "COL_51" TIMESTAMP(6) WITH TIME ZONE,
 54   "COL_52" BLOB,
 55   "COL_53" BINARY_INTEGER,
 56   "COL_54" BINARY_INTEGER,
 57   "COL_55" NUMBER,
 58   "COL_56" BINARY_INTEGER,
 59   "COL_57" BLOB,
 60   "COL_58" TIMESTAMP(6) WITH TIME ZONE,
 61   "COL_59" NUMBER,
 62   "COL_60" BINARY_DOUBLE,
 63   "COL_61" INTERVAL DAY(2) TO SECOND(6),
 64   "COL_62" BINARY_DOUBLE,
 65   "COL_63" CLOB,
 66   "COL_64" TIMESTAMP(6) WITH TIME ZONE,
 67   "COL_65" TIMESTAMP(6) WITH TIME ZONE,
 68   "COL_66" VARCHAR(30 BYTE),
 69   "COL_67" BOOLEAN,
 70   "COL_68" CHAR(30 CHAR),
 71   "COL_69" BINARY_DOUBLE,
 72   "COL_70" BINARY_DOUBLE,
 73   "COL_71" CHAR(30 BYTE),
 74   "COL_72" VARCHAR(30 BYTE),
 75   "COL_73" BINARY_INTEGER,
 76   "COL_74" BINARY_BIGINT,
 77   "COL_75" BINARY_INTEGER,
 78   "COL_76" CHAR(100 CHAR),
 79   "COL_77" TIMESTAMP(6) WITH TIME ZONE,
 80   "COL_78" NUMBER,
 81   "COL_79" VARCHAR(30 BYTE),
 82   "COL_80" CHAR(30 BYTE),
 83   "COL_81" BLOB,
 84   "COL_82" CLOB,
 85   "COL_83" NUMBER,
 86   "COL_84" BINARY_DOUBLE,
 87   "COL_85" BINARY_INTEGER,
 88   "COL_86" CHAR(30 BYTE),
 89   "COL_87" TIMESTAMP(6) WITH TIME ZONE,
 90   "COL_88" NUMBER,
 91   "COL_89" BINARY_BIGINT,
 92   "COL_90" BLOB,
 93   "COL_91" BLOB,
 94   "COL_92" BINARY_DOUBLE,
 95   "COL_93" BINARY_DOUBLE,
 96   "COL_94" BINARY_INTEGER,
 97   "COL_95" CHAR(30 BYTE),
 98   "COL_96" BINARY_BIGINT,
 99   "COL_97" BINARY_DOUBLE,
100   "COL_98" BINARY_INTEGER,
101   "COL_99" CHAR(30 BYTE),
102   "COL_100" VARCHAR(30 BYTE),
103   "COL_101" BINARY_BIGINT,
104   "COL_102" CLOB,
105   "COL_103" TIMESTAMP(6) WITH LOCAL TIME ZONE,
106   "COL_104" TIMESTAMP(6),
107   "COL_105" NUMBER,
108   "COL_106" NUMBER,
109   "COL_107" NUMBER,
110   "COL_108" IMAGE,
111   "COL_109" BOOLEAN,
112   "COL_110" BINARY_DOUBLE,
113   "COL_111" CHAR(30 BYTE),
114   "COL_112" VARCHAR(30 BYTE),
115   "COL_113" NUMBER,
116   "COL_114" BINARY_INTEGER,
117   "COL_115" VARCHAR(30 BYTE),
118   "COL_116" NUMBER,
119   "COL_117" BINARY_BIGINT,
120   "COL_118" INTERVAL YEAR(2) TO MONTH,
121   "COL_119" BOOLEAN,
122   "COL_120" NUMBER,
123   "COL_121" BLOB,
124   "COL_122" BINARY_DOUBLE,
125   "COL_123" BINARY_DOUBLE,
126   "COL_124" BINARY_INTEGER,
127   "COL_125" BINARY_INTEGER,
128   "COL_126" BINARY_INTEGER,
129   "COL_127" TIMESTAMP(6),
130   "COL_128" BINARY_INTEGER,
131   "COL_129" TIMESTAMP(6) WITH TIME ZONE,
132   "COL_130" CHAR(30 BYTE),
133   "COL_131" BLOB,
134   "COL_132" CHAR(30 BYTE),
135   "COL_133" BINARY_BIGINT,
136   "COL_134" TIMESTAMP(6) WITH TIME ZONE,
137   "COL_135" BINARY_INTEGER,
138   "COL_136" NUMBER,
139   "COL_137" NUMBER,
140   "COL_138" INTERVAL YEAR(2) TO MONTH,
141   "COL_139" BLOB,
142   "COL_140" CHAR(30 BYTE),
143   "COL_141" NUMBER,
144   "COL_142" BINARY_DOUBLE,
145   "COL_143" BINARY_DOUBLE,
146   "COL_144" CLOB,
147   "COL_145" BOOLEAN,
148   "COL_146" BINARY_INTEGER,
149   "COL_147" BINARY_BIGINT,
150   "COL_148" CHAR(30 BYTE),
151   "COL_149" VARCHAR(30 BYTE),
152   "COL_150" BLOB,
153   "COL_151" BINARY_DOUBLE,
154   "COL_152" CHAR(30 BYTE),
155   "COL_153" BINARY_DOUBLE,
156   "COL_154" CLOB,
157   "COL_155" BINARY_BIGINT,
158   "COL_156" BINARY_INTEGER,
159   "COL_157" NUMBER,
160   "COL_158" INTERVAL YEAR(2) TO MONTH,
161   "COL_159" TIMESTAMP(6) WITH TIME ZONE,
162   "COL_160" BLOB,
163   "COL_161" NUMBER,
164   "COL_162" BINARY_INTEGER,
165   "COL_163" RAW(100),
166   "COL_164" NUMBER(6, 2),
167   "COL_165" BINARY_INTEGER,
168   "COL_166" CLOB,
169   "COL_167" BINARY_DOUBLE,
170   "COL_168" NUMBER(6, 2),
171   "COL_169" NUMBER(6, 2),
172   "COL_170" NUMBER(6, 2),
173   "COL_171" RAW(100),
174   "COL_172" BINARY_INTEGER,
175   "COL_173" CLOB,
176   "COL_174" VARCHAR(50 BYTE),
177   "COL_175" VARCHAR(30 BYTE),
178   "COL_176" BINARY_DOUBLE,
179   "COL_177" TIMESTAMP(6) WITH TIME ZONE,
180   "COL_178" NUMBER(6, 2),
181   "COL_179" NUMBER(6, 2),
182   "COL_180" VARCHAR(100 CHAR),
183   "COL_181" NUMBER(6, 2),
184   "COL_182" DATE,
185   "COL_183" NUMBER(12, 6),
186   "COL_184" NUMBER(6, 2),
187   "COL_185" VARCHAR(30 CHAR),
188   "COL_186" BINARY_INTEGER,
189   "COL_187" NUMBER(6, 2),
190   "COL_188" DATE,
191   "COL_189" DATE,
192   "COL_190" NUMBER(6, 2),
193   "COL_191" NUMBER(6, 2),
194   "COL_192" VARCHAR(30 BYTE),
195   "COL_193" TIMESTAMP(6),
196   "COL_194" BINARY_DOUBLE,
197   "COL_195" IMAGE,
198   "COL_196" NUMBER(6, 2),
199   "COL_197" NUMBER(6, 2),
200   "COL_198" NUMBER(6, 2),
201   "COL_199" CLOB,
202   "COL_200" VARCHAR(55 CHAR),
203   "COL_201" BINARY_DOUBLE,
204   "COL_202" INTERVAL DAY(2) TO SECOND(6),
205   "COL_203" NUMBER(6, 2),
206   "COL_204" VARCHAR(30 BYTE),
207   "COL_205" NUMBER(6, 2),
208   "COL_206" NUMBER(6, 2),
209   "COL_207" VARCHAR(30 BYTE),
210   "COL_208" RAW(200),
211   "COL_209" NUMBER(6, 2),
212   "COL_210" NUMBER(6, 2),
213   "COL_211" BINARY_DOUBLE,
214   "COL_212" BINARY_DOUBLE,
215   "COL_213" NUMBER(6, 2),
216   "COL_214" VARCHAR(30 BYTE),
217   "COL_215" CLOB,
218   "COL_216" BINARY_INTEGER,
219   "COL_217" NUMBER(6, 2),
220   "COL_218" NUMBER(6, 2),
221   "COL_219" CLOB,
222   "COL_220" VARCHAR(30 BYTE),
223   "COL_221" BINARY_INTEGER,
224   "COL_222" NUMBER(6, 2),
225   "COL_223" TIMESTAMP(6),
226   "COL_224" VARCHAR(30 BYTE),
227   "COL_225" DATE,
228   "COL_226" NUMBER(16, 2),
229   "COL_227" VARCHAR(100 BYTE),
230   "COL_228" DATE,
231   "COL_229" CLOB,
232   "COL_230" NUMBER(12, 6),
233   "COL_231" DATE,
234   "COL_232" NUMBER(6, 2),
235   "COL_233" BINARY_INTEGER,
236   "COL_234" DATE,
237   "COL_235" VARCHAR(200 CHAR),
238   "COL_236" NUMBER(6, 2),
239   "COL_237" CLOB,
240   "COL_238" VARCHAR(300 BYTE),
241   "COL_239" NUMBER(6, 2),
242   "COL_240" CLOB,
243   "COL_241" VARCHAR(30 BYTE),
244   "COL_242" NUMBER(6, 2),
245   "COL_243" NUMBER(6, 2),
246   "COL_244" BINARY_DOUBLE,
247   "COL_245" VARCHAR(60 BYTE),
248   "COL_246" BINARY_INTEGER,
249   "COL_247" VARBINARY(200),
250   "COL_248" VARCHAR(30 BYTE),
251   "COL_249" BINARY(200),
252   "COL_250" NUMBER(6, 2),
253   "COL_251" RAW(100),
254   "COL_252" BINARY_DOUBLE,
255   "COL_253" NUMBER(6, 2),
256   "COL_254" BINARY_DOUBLE,
257   "COL_255" DATE,
258   "COL_256" NUMBER(6, 2),
259   "COL_257" BINARY_INTEGER,
260   "COL_258" NUMBER(6, 2),
261   "COL_259" BINARY(100),
262   "COL_260" RAW(100),
263   "COL_261" VARCHAR(60 BYTE),
264   "COL_262" VARCHAR(30 BYTE),
265   "COL_263" NUMBER(6, 2),
266   "COL_264" CLOB,
267   "COL_265" NUMBER(6, 2),
268   "COL_266" CLOB,
269   "COL_267" VARCHAR(30 BYTE),
270   "COL_268" NUMBER(6, 2),
271   "COL_269" NUMBER(6, 2),
272   "COL_270" INTERVAL YEAR(2) TO MONTH,
273   "COL_271" VARCHAR(60 BYTE),
274   "COL_272" NUMBER(6, 2),
275   "COL_273" NUMBER(6, 2),
276   "COL_274" DATE,
277   "COL_275" BINARY_DOUBLE
278 );

Succeed.

SQL>
SQL> CREATE TABLE "STUDENT"
  2 (
  3   "ID" BINARY_INTEGER NOT NULL,
  4   "NAME" VARCHAR(50 BYTE) NOT NULL,
  5   "SEX" VARCHAR(50 BYTE),
  6   "BIRTH" DATE,
  7   "DEPARTMENT" VARCHAR(50 BYTE),
  8   "ADDRESS" VARCHAR(50 BYTE)
  9 );

Succeed.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (901,'张老大','男','1985-01-01 00:00:00','计算机系','北京市海淀区');

1 rows affected.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (902,'张老二','男','1986-01-01 00:00:00','中文系','北京市昌平区');

1 rows affected.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (903,'张三','女','1990-01-01 00:00:00','中文系','湖南省永州市');

1 rows affected.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (904,'李四','男','1990-01-01 00:00:00','英语系','辽宁省阜新市');

1 rows affected.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (905,'王五','女','1991-01-01 00:00:00','英语系','福建省厦门市');

1 rows affected.

SQL> INSERT INTO "STUDENT" ("ID","NAME","SEX","BIRTH","DEPARTMENT","ADDRESS") values (906,'王六','男','1988-01-01 00:00:00','计算机系','湖南省衡阳市');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "STUDENT" ADD PRIMARY KEY("ID");

Succeed.

SQL>
SQL> CREATE TABLE "SCORE"
  2 (
  3   "ID" BINARY_INTEGER NOT NULL,
  4   "STU_ID" BINARY_INTEGER NOT NULL,
  5   "C_NAME" VARCHAR(50 BYTE),
  6   "GRADE" BINARY_INTEGER
  7 );

Succeed.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (1,901,'计算机',98);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (2,901,'英语',80);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (3,902,'计算机',65);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (4,902,'中文',88);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (5,903,'中文',95);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (6,904,'计算机',70);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (7,904,'英语',92);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (8,905,'英语',94);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (9,906,'计算机',90);

1 rows affected.

SQL> INSERT INTO "SCORE" ("ID","STU_ID","C_NAME","GRADE") values (10,906,'英语',85);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "SCORE" ADD PRIMARY KEY("ID");

Succeed.

SQL> ALTER TABLE "SCORE" MODIFY "ID" AUTO_INCREMENT;

Succeed.

SQL> ALTER TABLE "SCORE" AUTO_INCREMENT = 101;

Succeed.

SQL>
SQL> CREATE TABLE "EMPLOYEES"
  2 (
  3   "EMP_NO" BINARY_INTEGER NOT NULL,
  4   "BIRTH_DATE" DATE NOT NULL,
  5   "FIRST_NAME" VARCHAR(50 BYTE) NOT NULL,
  6   "LAST_NAME" VARCHAR(50 BYTE) NOT NULL,
  7   "GENDER" CHAR(1 BYTE) NOT NULL,
  8   "HIRE_DATE" DATE NOT NULL
  9 );

Succeed.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10001,'1953-09-02 00:00:00','Georgi','Facello','M','1986-06-26 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10002,'1964-06-02 00:00:00','Bezalel','Simmel','F','1985-11-21 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10003,'1959-12-03 00:00:00','Parto','Bamford','M','1986-08-28 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10004,'1954-05-01 00:00:00','Chirstian','Koblick','M','1986-12-01 00:00:00');


1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10005,'1955-01-21 00:00:00','Kyoichi','Maliniak','M','1989-09-12 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10006,'1953-04-20 00:00:00','Anneke','Preusig','F','1989-06-02 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10007,'1957-05-23 00:00:00','Tzvetan','Zielinski','F','1989-02-10 00:00:00');


1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10008,'1958-02-19 00:00:00','Saniya','Kalloufi','M','1994-09-15 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10009,'1952-04-19 00:00:00','Sumant','Peac','F','1985-02-18 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10010,'1963-06-01 00:00:00','Duangkaew','Piveteau','F','1989-08-24 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10011,'1953-11-07 00:00:00','Mary','Sluis','F','1990-01-22 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10012,'1960-10-04 00:00:00','Patricio','Bridgland','M','1992-12-18 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10013,'1963-06-07 00:00:00','Eberhardt','Terkki','M','1985-10-20 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10014,'1956-02-12 00:00:00','Berni','Genin','M','1987-03-11 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10015,'1959-08-19 00:00:00','Guoxiang','Nooteboom','M','1987-07-02 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10016,'1961-05-02 00:00:00','Kazuhito','Cappelletti','M','1995-01-27 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10017,'1958-07-06 00:00:00','Cristinel','Bouloucos','F','1993-08-03 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10018,'1954-06-19 00:00:00','Kazuhide','Peha','F','1987-04-03 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10019,'1953-01-23 00:00:00','Lillian','Haddadi','M','1999-04-30 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10020,'1952-12-24 00:00:00','Mayuko','Warwick','M','1991-01-26 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10021,'1960-02-20 00:00:00','Ramzi','Erde','M','1988-02-10 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10022,'1952-07-08 00:00:00','Shahaf','Famili','M','1995-08-22 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10023,'1953-09-29 00:00:00','Bojan','Montemayor','F','1989-12-17 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10024,'1958-09-05 00:00:00','Suzette','Pettey','F','1997-05-19 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10025,'1958-10-31 00:00:00','Prasadram','Heyers','M','1987-08-17 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10026,'1953-04-03 00:00:00','Yongqiao','Berztiss','M','1995-03-20 00:00:00');


1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10027,'1962-07-10 00:00:00','Divier','Reistad','F','1989-07-07 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10028,'1963-11-26 00:00:00','Domenick','Tempesti','M','1991-10-22 00:00:00');


1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10029,'1956-12-13 00:00:00','Otmar','Herbst','M','1985-11-20 00:00:00');

1 rows affected.

SQL> INSERT INTO "EMPLOYEES" ("EMP_NO","BIRTH_DATE","FIRST_NAME","LAST_NAME","GENDER","HIRE_DATE") values (10030,'1958-07-14 00:00:00','Elvis','Demeyer','M','1994-02-17 00:00:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "EMPLOYEES" ADD PRIMARY KEY("EMP_NO");

Succeed.

SQL>
SQL> CREATE TABLE "DEPARTMENTS"
  2 (
  3   "DEPT_NO" CHAR(30 BYTE) NOT NULL,
  4   "DEPT_NAME" VARCHAR(50 BYTE) NOT NULL
  5 );

Succeed.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d001                          ','市场部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d002                          ','财务部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d003                          ','人事部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d004                          ','生产部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d005                          ','研发部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d006                          ','质量部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d007                          ','销售部');

1 rows affected.

SQL> INSERT INTO "DEPARTMENTS" ("DEPT_NO","DEPT_NAME") values ('d008                          ','销售服务部');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "DEPARTMENTS" ADD PRIMARY KEY("DEPT_NO");

Succeed.

SQL> ALTER TABLE "DEPARTMENTS" ADD UNIQUE("DEPT_NAME");

Succeed.

SQL>
SQL> CREATE TABLE "DEPT_MANAGER"
  2 (
  3   "EMP_NO" BINARY_INTEGER NOT NULL,
  4   "DEPT_NO" CHAR(30 BYTE) NOT NULL,
  5   "FROM_DATE" DATE NOT NULL,
  6   "TO_DATE" DATE NOT NULL
  7 );

Succeed.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10017,'d001                          ','1985-01-01 00:00:00','1991-10-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10020,'d002                          ','1991-10-01 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10013,'d003                          ','1985-01-01 00:00:00','1989-12-17 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10018,'d004                          ','1989-12-17 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10018,'d005                          ','1985-01-01 00:00:00','1992-03-21 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10029,'d006                          ','1992-03-21 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10016,'d007                          ','1985-01-01 00:00:00','1988-09-09 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10007,'d008                          ','1988-09-09 00:00:00','1992-08-02 00:00:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "DEPT_MANAGER" ADD PRIMARY KEY("EMP_NO", "DEPT_NO");

Succeed.

SQL>
SQL> CREATE TABLE "DEPT_EMP"
  2 (
  3   "EMP_NO" BINARY_INTEGER NOT NULL,
  4   "DEPT_NO" CHAR(30 BYTE) NOT NULL,
  5   "FROM_DATE" DATE NOT NULL,
  6   "TO_DATE" DATE NOT NULL
  7 );

Succeed.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10001,'d005                          ','1986-06-26 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10002,'d007                          ','1996-08-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10003,'d004                          ','1995-12-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10004,'d004                          ','1986-12-01 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10005,'d003                          ','1989-09-12 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10006,'d005                          ','1990-08-05 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10007,'d008                          ','1989-02-10 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10008,'d005                          ','1998-03-11 00:00:00','2000-07-31 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10009,'d006                          ','1985-02-18 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10010,'d004                          ','1996-11-24 00:00:00','2000-06-26 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10010,'d006                          ','2000-06-26 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10011,'d007                          ','1990-01-22 00:00:00','1996-11-09 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10012,'d005                          ','1992-12-18 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10013,'d003                          ','1985-10-20 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10014,'d005                          ','1993-12-29 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10015,'d008                          ','1992-09-19 00:00:00','1993-08-22 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10016,'d007                          ','1998-02-11 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10017,'d001                          ','1993-08-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10018,'d004                          ','1992-07-29 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10018,'d005                          ','1987-04-03 00:00:00','1992-07-29 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10019,'d008                          ','1999-04-30 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10020,'d002                          ','1997-12-30 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10021,'d005                          ','1988-02-10 00:00:00','2002-07-15 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10022,'d005                          ','1999-09-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10023,'d005                          ','1999-09-27 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10024,'d004                          ','1998-06-14 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10025,'d005                          ','1987-08-17 00:00:00','1997-10-15 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10026,'d004                          ','1995-03-20 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10027,'d005                          ','1995-04-02 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10028,'d005                          ','1991-10-22 00:00:00','1998-04-06 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10029,'d004                          ','1991-09-18 00:00:00','1999-07-08 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10029,'d006                          ','1999-07-08 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "DEPT_EMP" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10030,'d004                          ','1994-02-17 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "DEPT_EMP" ADD PRIMARY KEY("EMP_NO", "DEPT_NO");

Succeed.

SQL>
SQL> CREATE TABLE "SALARIES"
  2 (
  3   "EMP_NO" BINARY_INTEGER NOT NULL,
  4   "SALARY" BINARY_INTEGER NOT NULL,
  5   "FROM_DATE" DATE NOT NULL,
  6   "TO_DATE" DATE NOT NULL
  7 );

Succeed.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10001,5000,'1986-06-26 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10002,5100,'1996-08-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10003,5200,'1995-12-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10004,5300,'1986-12-01 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10005,5400,'1989-09-12 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10006,5500,'1990-08-05 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10007,5600,'1989-02-10 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10008,5700,'1998-03-11 00:00:00','2000-07-31 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10009,5800,'1985-02-18 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10010,5900,'1996-11-24 00:00:00','2000-06-26 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10010,6000,'2000-06-26 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10011,6100,'1990-01-22 00:00:00','1996-11-09 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10012,5000,'1992-12-18 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10013,5100,'1985-10-20 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10014,5200,'1993-12-29 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10015,5300,'1992-09-19 00:00:00','1993-08-22 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10016,5400,'1998-02-11 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10017,5500,'1993-08-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10018,5600,'1992-07-29 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10018,5700,'1987-04-03 00:00:00','1992-07-29 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10019,5800,'1999-04-30 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10020,5900,'1997-12-30 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10021,6000,'1988-02-10 00:00:00','2002-07-15 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10022,6100,'1999-09-03 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10023,5000,'1999-09-27 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10024,5100,'1998-06-14 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10025,5200,'1987-08-17 00:00:00','1997-10-15 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10026,5300,'1995-03-20 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10027,5400,'1995-04-02 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10028,5500,'1991-10-22 00:00:00','1998-04-06 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10029,5600,'1991-09-18 00:00:00','1999-07-08 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10029,5700,'1999-07-08 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SALARIES" ("EMP_NO","SALARY","FROM_DATE","TO_DATE") values (10030,5800,'1994-02-17 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "SALARIES" ADD PRIMARY KEY("EMP_NO", "FROM_DATE");

Succeed.

SQL>
SQL> CREATE TABLE "TEST"
  2 (
  3   "ID" BINARY_INTEGER,
  4   "NAME" VARCHAR(30 BYTE)
  5 );

Succeed.

SQL> INSERT INTO "TEST" ("ID","NAME") values (1,'dgd');

1 rows affected.

SQL> INSERT INTO "TEST" ("ID","NAME") values (2,'ssn');

1 rows affected.

SQL> INSERT INTO "TEST" ("ID","NAME") values (3,'ddd');

1 rows affected.

SQL> INSERT INTO "TEST" ("ID","NAME") values (11,'aaaa');

1 rows affected.

SQL> INSERT INTO "TEST" ("ID","NAME") values (4,'dgd');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE TABLE "MY_EMPLOYEES"
  2 (
  3   "ID" BINARY_INTEGER,
  4   "DD" CLOB,
  5   "FLAG" CHAR(1 BYTE),
  6   "BB" BOOLEAN,
  7   "DBL" BINARY_DOUBLE
  8 );

Succeed.

SQL> INSERT INTO "MY_EMPLOYEES" ("ID","DD","FLAG","BB","DBL") values (0,'dddddddddddddddddddddddd','m',TRUE,301415902);

1 rows affected.

SQL> INSERT INTO "MY_EMPLOYEES" ("ID","DD","FLAG","BB","DBL") values (111,'ssssssssssssssssssssss','f',FALSE,0.1415902);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "DEPT_MANAGER" ADD FOREIGN KEY("EMP_NO") REFERENCES "EMPLOYEES"("EMP_NO");

Succeed.

SQL> ALTER TABLE "DEPT_MANAGER" ADD FOREIGN KEY("DEPT_NO") REFERENCES "DEPARTMENTS"("DEPT_NO");

Succeed.

SQL> ALTER TABLE "DEPT_EMP" ADD FOREIGN KEY("DEPT_NO") REFERENCES "DEPARTMENTS"("DEPT_NO");

Succeed.

SQL> ALTER TABLE "DEPT_EMP" ADD FOREIGN KEY("EMP_NO") REFERENCES "EMPLOYEES"("EMP_NO");

Succeed.

SQL> ALTER TABLE "SALARIES" ADD FOREIGN KEY("EMP_NO") REFERENCES "EMPLOYEES"("EMP_NO");

Succeed.

SQL> select distinct
  2   subq_0.c16 as c0,
  3     STDDEV_SAMP(
  4       cast(EXP(
  5         cast((select max(COL_8) from FVT_OBJ_DEFINE_TABLE_FRE1)
  6            as BINARY_DOUBLE)) as BINARY_DOUBLE)) over (partition by subq_0.c1,subq_0.c7 order by subq_0.c0) as c1,
  7     sum(
  8       cast(subq_0.c4 as BINARY_INTEGER)) over (partition by subq_0.c14 order by subq_0.c3) as c2
  9 from
 10   (select distinct
 11           STDDEV(
 12             cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.BIRTH_DATE order by ref_0.GENDER,ref_0.BIRTH_DATE,ref_0.LAST_NAME,ref_0.EMP_NO) as c0,
 13         ref_0.LAST_NAME as c1,
 14         ref_0.GENDER as c2,
 15         ref_0.HIRE_DATE as c3,
 16         ref_0.EMP_NO as c4,
 17           STDDEV_POP(
 18             cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.GENDER order by ref_0.HIRE_DATE,ref_0.EMP_NO) as c5,
 19           sum(
 20             cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.LAST_NAME order by ref_0.LAST_NAME,ref_0.BIRTH_DATE,ref_0.HIRE_DATE) as c6,
 21         ref_0.EMP_NO as c7,
 22         ref_0.HIRE_DATE as c8,
 23         (select FIRST_NAME from EMPLOYEES limit 1 offset 3)
 24            as c9,
 25         ref_0.EMP_NO as c10,
 26         ref_0.FIRST_NAME as c11,
 27         ref_0.HIRE_DATE as c12,
 28         ref_0.FIRST_NAME as c13,
 29         (select ID from TEST limit 1 offset 1)
 30            as c14,
 31         34 as c15,
 32         ref_0.BIRTH_DATE as c16,
 33         MIN(cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.GENDER,ref_0.HIRE_DATE,ref_0.LAST_NAME order by ref_0.EMP_NO,ref_0.FIRST_NAME,ref_0.BIRTH_DATE,ref_0.HIRE_DATE) as c17,
 34             case when (EXISTS (select distinct
 35                   ref_1.COL_85 as c0,
 36                   ref_0.BIRTH_DATE as c1,
 37                   ref_1.COL_226 as c2,
 38                   50 as c3,
 39                   ref_1.COL_22 as c4
 40                 from
 41                   FVT_OBJ_DEFINE_TABLE_FRE1 as ref_1
 42                 where EXISTS (
 43                   select distinct
 44                       ref_0.HIRE_DATE as c0,
 45                       ref_2.EMP_NO as c1,
 46                       ref_0.EMP_NO as c2,
 47                       ref_0.EMP_NO as c3,
 48                       ref_0.BIRTH_DATE as c4,
 49                       ref_0.BIRTH_DATE as c5,
 50                       ref_0.HIRE_DATE as c6,
 51                       ref_0.EMP_NO as c7,
 52                       ref_0.HIRE_DATE as c8,
 53                       ref_0.EMP_NO as c9,
 54                       ref_0.EMP_NO as c10,
 55                       ref_0.LAST_NAME as c11,
 56                       ref_0.FIRST_NAME as c12,
 57                       ref_2.EMP_NO as c13
 58                     from
 59                       SALARIES as ref_2
 60                     where (ref_2.TO_DATE is NULL)
 61                       and (((ref_2.SALARY is NULL)
 62                           or ((ref_2.EMP_NO is not NULL)
 63                             or (true)))
 64                         and (true))
 65                     limit 105)
 66                 limit 124))
 67             and (ref_0.HIRE_DATE is not NULL) then ref_0.FIRST_NAME else ref_0.FIRST_NAME end
 68            as c18,
 69         ref_0.HIRE_DATE as c19
 70       from
 71         EMPLOYEES as ref_0
 72       where ref_0.EMP_NO is not NULL) as subq_0
 73 where subq_0.c11 is NULL
 74 limit 106;

C0                     C1                                       C2
---------------------- ---------------------------------------- --------------------

0 rows fetched.

SQL> select distinct
  2   ref_0.DEPT_NO as c0,
  3
  4     count(
  5       cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_1.HIRE_DATE,ref_0.EMP_NO order by ref_1.BIRTH_DATE) as c1,
  6
  7     STDDEV(
  8       cast(cast(nullif((select DBL from MY_EMPLOYEES limit 1 offset 1)
  9           ,
 10         (select COL_8 from FVT_OBJ_DEFINE_TABLE_FRE1 limit 1 offset 3)
 11           ) as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by ref_0.EMP_NO,ref_1.LAST_NAME order by ref_0.DEPT_NO,ref_1.GENDER) as c2,
 12
 13     STDDEV_SAMP(
 14       cast((select COL_8 from FVT_OBJ_DEFINE_TABLE_FRE1 limit 1 offset 6)
 15          as BINARY_DOUBLE)) over (partition by ref_1.BIRTH_DATE order by ref_0.TO_DATE) as c3,
 16
 17     STDDEV(
 18       cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.DEPT_NO order by ref_1.GENDER,ref_0.FROM_DATE) as c4
 19 from
 20   DEPT_MANAGER as ref_0
 21     left join EMPLOYEES as ref_1
 22     on (ref_1.FIRST_NAME is not NULL)
 23 where ((ref_0.EMP_NO is not NULL)
 24     or (cast(nullif(case when ((false)
 25               or (true))
 26             or (ref_0.TO_DATE is NULL) then case when ref_0.EMP_NO is NULL then ref_1.EMP_NO else ref_1.EMP_NO end
 27              else case when ref_0.EMP_NO is NULL then ref_1.EMP_NO else ref_1.EMP_NO end
 28              end
 29           ,
 30         ref_0.EMP_NO) as BINARY_INTEGER) is NULL))
 31   or ((ref_0.EMP_NO is not NULL)
 32     or (EXISTS (
 33       select distinct
 34           ref_0.FROM_DATE as c0,
 35           ref_1.BIRTH_DATE as c1,
 36           ref_0.EMP_NO as c2,
 37           ref_1.BIRTH_DATE as c3,
 38           ref_0.TO_DATE as c4
 39         from
 40           DEPT_EMP as ref_2
 41         where ref_1.HIRE_DATE is NULL)));

C0                             C1                   C2                                       C3                                       C4
------------------------------ -------------------- ---------------------------------------- ---------------------------------------- ----------------------------------------
d008                           1                    0                                                                                 0
d003                           1                    0                                                                                 0
d007                           1                    0                                                                                 0
d001                           1                    0                                                                                 0
d005                           2                    0                                                                                 0                                       
d004                           2                    0                                                                                 0
d002                           1                    0                                                                                 0
d006                           1                    0                                                                                 0

8 rows fetched.

SQL> select distinct
  2
  3     count(
  4       cast(subq_1.c0 as BINARY_DOUBLE)) over (partition by subq_1.c0 order by subq_1.c2) as c0,
  5   subq_1.c2 as c1,
  6
  7     STDDEV_POP(
  8       cast(subq_1.c0 as BINARY_DOUBLE)) over (partition by subq_1.c0 order by subq_1.c0,subq_1.c2) as c2,
  9
 10     sum(
 11       cast((select STDDEV_POP(COL_8) from FVT_OBJ_DEFINE_TABLE_FRE1)
 12          as BINARY_DOUBLE)) over (partition by subq_1.c2 order by subq_1.c2) as c3
 13 from
 14   (select distinct
 15
 16           avg(
 17             cast(ref_0.COL_12 as BINARY_DOUBLE)) over (partition by ref_0.COL_107 order by ref_1.BIRTH_DATE) as c0,
 18         ref_0.COL_159 as c1,
 19         cast(coalesce(case when EXISTS (
 20               select distinct
 21                   41 as c0
 22                 from
 23                   EMPLOYEES as ref_2,
 24                   (select distinct
 25                         (select FROM_DATE from DEPT_EMP limit 1 offset 3)
 26                            as c0,
 27                         (select sum(EMP_NO) from DEPT_EMP)
 28                            as c1,
 29                         ref_0.COL_145 as c2,
 30                         ref_1.BIRTH_DATE as c3,
 31                         ref_3.HIRE_DATE as c4,
 32                         (select ID from TEST limit 1 offset 2)
 33                            as c5,
 34                         ref_3.HIRE_DATE as c6,
 35                         ref_1.FIRST_NAME as c7,
 36                         ref_1.BIRTH_DATE as c8,
 37                         ref_1.BIRTH_DATE as c9,
 38                         ref_3.LAST_NAME as c10,
 39                         ref_3.EMP_NO as c11,
 40                         (select FROM_DATE from DEPT_MANAGER limit 1 offset 4)
 41                            as c12,
 42                         ref_0.COL_136 as c13
 43                       from
 44                         EMPLOYEES as ref_3
 45                       where true
 46                       limit 99) as subq_0
 47                 where (true)
 48                   and (false)) then ref_0.COL_148 else ref_0.COL_148 end
 49             ,
 50           ref_0.COL_111) as CHAR) as c2
 51       from
 52         FVT_OBJ_DEFINE_TABLE_FRE1 as ref_0
 53           right join EMPLOYEES as ref_1
 54           on (22 is not NULL)
 55       where (ref_1.LAST_NAME is NULL)
 56         or ((((true)
 57               and (ref_0.COL_142 is NULL))
 58             or ((ref_0.COL_204 is NULL)
 59               and ((ref_1.GENDER is not NULL)
 60                 and ((ref_1.GENDER is NULL)
 61                   or (true)))))
 62           or ((false)
 63             or ((true)
 64               and (false))))
 65       limit 43) as subq_1
 66 where subq_1.c0 is NULL
 67 limit 58;

C0                   C1 C2                                       C3
-------------------- -- ---------------------------------------- --------------------
0

1 rows fetched.

SQL> select distinct
  2
  3     STDDEV_SAMP(
  4       cast((select avg(ID) from STUDENT)
  5          as BINARY_INTEGER)) over (partition by ref_0.DEPT_NO,ref_0.EMP_NO order by ref_0.TO_DATE) as c0,
  6
  7     STDDEV_POP(
  8       cast((select ID from SCORE limit 1 offset 6)
  9          as BINARY_INTEGER)) over (partition by ref_0.TO_DATE order by ref_0.DEPT_NO) as c1,
 10
 11     STDDEV(
 12       cast(ref_0.EMP_NO as BINARY_INTEGER)) over (partition by ref_0.TO_DATE,ref_0.FROM_DATE order by ref_0.TO_DATE,ref_0.EMP_NO) as c2,
 13
 14     avg(
 15       cast(case when true then (select DBL from MY_EMPLOYEES limit 1 offset 2)
 16            else (select DBL from MY_EMPLOYEES limit 1 offset 2)
 17            end
 18          as BINARY_DOUBLE)) over (partition by ref_0.TO_DATE order by ref_0.DEPT_NO,ref_0.DEPT_NO) as c3
 19 from
 20   DEPT_EMP as ref_0
 21 where ref_0.TO_DATE is not NULL
 22 limit 181;

C0                                       C1                                       C2                                       C3
---------------------------------------- ---------------------------------------- ---------------------------------------- --------------------
                                         0                                        0

1 rows fetched.

SQL> select
  2     MIN(
  3       cast((select max(DBL) from MY_EMPLOYEES)
  4          as BINARY_DOUBLE)) over (partition by subq_0.c4 order by subq_0.c1) as c0,
  5     max(
  6       cast(subq_0.c1 as BINARY_INTEGER)) over (partition by ref_4.NAME,ref_4.ID order by subq_0.c6) as c1,
  7     sum(
  8       cast(ref_4.ID as BINARY_INTEGER)) over (partition by subq_0.c6,ref_4.ID,ref_4.ID order by ref_4.ID) as c2,
  9   subq_0.c2 as c3,
 10     max(
 11       cast((select sum(DBL) from MY_EMPLOYEES)
 12          as BINARY_DOUBLE)) over (partition by subq_0.c6 order by ref_4.NAME) as c4,
 13     STDDEV(
 14       cast(SIN(
 15         cast((select DBL from MY_EMPLOYEES limit 1 offset 4)
 16            as BINARY_DOUBLE)) as BINARY_DOUBLE)) over (partition by ref_4.NAME order by ref_4.ID) as c5
 17 from
 18   (select
 19           ref_0.SEX as c0,
 20           ref_1.SALARY as c1,
 21           (select SALARY from SALARIES limit 1 offset 5)
 22              as c2,
 23           ref_0.BIRTH as c3,
 24             sum(
 25               cast(ref_1.SALARY as BINARY_INTEGER)) over (partition by ref_1.EMP_NO order by ref_1.TO_DATE) as c4,
 26           ref_1.SALARY as c5,
 27           ref_1.TO_DATE as c6,
 28           ref_1.SALARY as c7
 29         from
 30           STUDENT as ref_0
 31             inner join SALARIES as ref_1
 32             on (EXISTS (
 33                 select
 34                     8 as c0,
 35                     ref_0.ADDRESS as c1,
 36                     ref_1.FROM_DATE as c2,
 37                     ref_0.SEX as c3
 38                   from
 39                     SCORE as ref_2
 40                   where EXISTS (
 41                     select
 42                         ref_3.DEPT_NAME as c0,
 43                         ref_0.ADDRESS as c1,
 44                         ref_3.DEPT_NAME as c2,
 45                         ref_1.FROM_DATE as c3,
 46                         ref_1.FROM_DATE as c4,
 47                         ref_3.DEPT_NO as c5,
 48                         ref_0.SEX as c6,
 49                         ref_3.DEPT_NO as c7,
 50                         (select avg(COL_8) from FVT_OBJ_DEFINE_TABLE_FRE1)
 51                            as c8,
 52                         ref_1.TO_DATE as c9
 53                       from
 54                         DEPARTMENTS as ref_3
 55                       where ref_3.DEPT_NAME is not NULL)
 56                   limit 39))
 57         where (ref_0.BIRTH is not NULL)
 58           and ((false)
 59             or (true))) as subq_0
 60     inner join TEST as ref_4
 61     on (trim(
 62           cast(version() as VARCHAR(50)),
 63           cast(case when (73 is NULL)
 64               and ((ref_4.NAME is NULL)
 65                 or (((ref_4.NAME is NULL)
 66                     and ((((select SALARY from SALARIES limit 1 offset 2)
 67                              is not NULL)
 68                         or ((((true)
 69                               and ((EXISTS (
 70                                   select
 71                                       ref_4.NAME as c0,
 72                                       ref_4.ID as c1,
 73                                       ref_4.NAME as c2,
 74                                       ref_4.ID as c3,
 75                                       ref_5.GENDER as c4,
 76                                       63 as c5,
 77                                       subq_0.c7 as c6
 78                                     from
 79                                       EMPLOYEES as ref_5
 80                                     where ((subq_0.c6 is NULL)
 81                                         or ((subq_0.c6 is not NULL)
 82                                           or (false)))
 83                                       or (ref_4.ID is NULL)
 84                                     limit 83))
 85                                 or (EXISTS (
 86                                   select
 87                                       (select C_NAME from SCORE limit 1 offset 2)
 88                                          as c0
 89                                     from
 90                                       DEPT_MANAGER as ref_6
 91                                     where EXISTS (
 92                                       select
 93                                           ref_4.ID as c0,
 94                                           ref_4.NAME as c1,
 95                                           (select ADDRESS from STUDENT limit 1 offset 98)
 96                                              as c2,
 97                                           (select DEPT_NO from DEPARTMENTS limit 1 offset 2)
 98                                              as c3
 99                                         from
100                                           EMPLOYEES as ref_7
101                                         where true
102                                         limit 126)
103                                     limit 26))))
104                             and (subq_0.c5 is not NULL))
105                           or (EXISTS (
106                             select
107                                 ref_4.NAME as c0,
108                                 ref_4.ID as c1,
109                                 ref_8.NAME as c2,
110                                 ref_4.NAME as c3,
111                                 ref_8.NAME as c4
112                               from
113                                 TEST as ref_8
114                               where (true)
115                                 or (EXISTS (
116                                   select
117                                       ref_8.ID as c0,
118                                       ref_4.NAME as c1,
119                                       24 as c2,
120                                       subq_0.c5 as c3,
121                                       ref_4.ID as c4,
122                                       ref_9.EMP_NO as c5
123                                     from
124                                       EMPLOYEES as ref_9
125                                     where true
126                                     limit 68))))))
127                       and (subq_0.c4 is NULL)))
128                   and ((false)
129                     or (ref_4.NAME is not NULL)))) then ref_4.NAME else ref_4.NAME end
130              as VARCHAR(50))) is NULL)
131 where EXISTS (
132   select
133
134         sum(
135           cast(subq_0.c1 as BINARY_INTEGER)) over (partition by ref_10.NAME,ref_4.ID order by subq_0.c6) as c0,
136       case when false then ref_10.ID else ref_10.ID end
137          as c1
138     from
139       TEST as ref_10
140     where false);

C0                   C1           C2                   C3           C4                   C5
-------------------- ------------ -------------------- ------------ -------------------- ----------------------------------------

0 rows fetched.

SQL> 
SQL> drop table if exists winsort_parent_ref;

Succeed.

SQL> create table winsort_parent_ref
  2 (
  3   col_1 int primary key,
  4   col_2 int,
  5   col_3 varchar(20)
  6 );

Succeed.

SQL> 
SQL> insert into winsort_parent_ref values(1, 20, 'text1');

1 rows affected.

SQL> insert into winsort_parent_ref values(2, 30, 'text2');

1 rows affected.

SQL> insert into winsort_parent_ref values(3, 40, 'text3');

1 rows affected.

SQL> insert into winsort_parent_ref values(4, 50, 'text4');

1 rows affected.

SQL> 
SQL> select
  2   subq_1.c3 as c0
  3 from 
  4 (
  5  select  
  6     subq_0.c1 as c1, 
  7     case when 
  8         EXISTS (
  9             select 
 10                 ref_0.col_3 as c1, 
 11                 subq_0.c0 as c2
 12             from 
 13                 winsort_parent_ref as ref_3
 14             where EXISTS (select subq_0.c1 as c2 from winsort_parent_ref as ref_4)
 15         ) 
 16     then ref_0.col_2 else ref_0.col_2 end as c2, 
 17     min(cast(ref_0.col_2 as BINARY_INTEGER)) over (partition by subq_0.c0 order by ref_0.col_3) as c3
 18  from
 19       (winsort_parent_ref as ref_0) 
 20       inner join 
 21       (winsort_parent_ref as ref_1)
 22       inner join 
 23       (
 24        (select  
 25             ref_2.col_3 as c0,
 26             ref_2.col_3 as c1
 27         from 
 28             winsort_parent_ref as ref_2
 29         ) as subq_0
 30       )
 31 ) as subq_1
 32 where EXISTS (
 33         select subq_1.c1 as c6
 34         from winsort_parent_ref as ref_5
 35         where subq_1.c2 is NULL
 36         );

C0          
------------

0 rows fetched.

SQL> 
SQL> select
  2   subq_1.c3 as c0
  3 from 
  4 (
  5  select  
  6     subq_0.c1 as c1, 
  7     case when 
  8         EXISTS (
  9             select 
 10                 ref_0.col_3 as c1, 
 11                 subq_0.rowid as c2
 12             from 
 13                 winsort_parent_ref as ref_3
 14             where EXISTS (select subq_0.rowid as c2, ref_0.rowid from winsort_parent_ref as ref_4)
 15         ) 
 16     then ref_0.col_2 else ref_0.col_2 end as c2, 
 17     min(cast(ref_0.col_2 as BINARY_INTEGER)) over (partition by subq_0.c0 order by ref_0.col_3) as c3
 18  from
 19       (winsort_parent_ref as ref_0) 
 20       inner join 
 21       (winsort_parent_ref as ref_1)
 22       inner join 
 23       (
 24        (select  
 25             ref_2.col_3 as c0,
 26             ref_2.col_3 as c1
 27         from 
 28             winsort_parent_ref as ref_2
 29         ) as subq_0
 30       )
 31 ) as subq_1
 32 where (EXISTS (
 33         select subq_1.c1 as c6
 34         from winsort_parent_ref as ref_5
 35         where subq_1.c2 is NULL
 36         )
 37       );

C0          
------------

0 rows fetched.

SQL> 
SQL> drop table winsort_parent_ref;

Succeed.

SQL> --20200723
SQL> DROP TABLE IF EXISTS "STATES" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "STATES"
  2 (
  3   "STATE_ID" CHAR(2 BYTE) NOT NULL,
  4   "STATE_NAME" VARCHAR(40 BYTE),
  5   "AREA_ID" NUMBER
  6 )
  7 TABLESPACE "USERS"
  8 INITRANS 2
  9 MAXTRANS 255
 10 PCTFREE 8;

Succeed.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('AR','Argentina',2);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('AU','Australia',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('BE','Belgium',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('BR','Brazil',2);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('CA','Canada',2);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('CH','Switzerland',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('CN','China',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('DE','Germany',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('DK','Denmark',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('EG','Egypt',4);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('FR','France',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('HK','HongKong',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('IL','Israel',4);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('IN','India',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('IT','Italy',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('JP','Japan',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('KW','Kuwait',4);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('MX','Mexico',2);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('NG','Nigeria',4);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('NL','Netherlands',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('SG','Singapore',3);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('UK','United Kingdom',1);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('US','United States of America',2);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('ZM','Zambia',4);

1 rows affected.

SQL> INSERT INTO "STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('ZW','Zimbabwe',4);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "STATES" ADD CONSTRAINT "STATE_C_ID_PK" PRIMARY KEY("STATE_ID");

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "SECTIONS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "SECTIONS"
  2 (
  3   "SECTION_ID" NUMBER(4) NOT NULL,
  4   "SECTION_NAME" VARCHAR(30 BYTE),
  5   "MANAGER_ID" NUMBER(6),
  6   "PLACE_ID" NUMBER(4)
  7 )
  8 TABLESPACE "USERS"
  9 INITRANS 2
 10 MAXTRANS 255
 11 PCTFREE 8;

Succeed.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (10,'Administration',200,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (20,'Marketing',201,1800);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (30,'Purchasing',114,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (40,'Human Resources',203,2400);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (50,'Shipping',121,1500);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (60,'IT',103,1400);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (70,'Public Relations',204,2700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (80,'Sales',145,2500);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (90,'Executive',100,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (100,'Finance',108,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (110,'Accounting',205,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (120,'Treasury',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (130,'Corporate Tax',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (140,'Control And Credit',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (150,'Shareholder Services',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (160,'Benefits',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (170,'Manufacturing',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (180,'Construction',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (190,'Contracting',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (200,'Operations',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (210,'IT Support',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (220,'NOC',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (230,'IT Helpdesk',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (240,'Government Sales',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (250,'Retail Sales',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (260,'Recruiting',null,1700);

1 rows affected.

SQL> INSERT INTO "SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values
  2   (270,'Payroll',null,1700);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "PLACES" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "PLACES"
  2 (
  3   "PLACE_ID" NUMBER(4) NOT NULL,
  4   "STREET_ADDRESS" VARCHAR(40 BYTE),
  5   "POSTAL_CODE" VARCHAR(12 BYTE),
  6   "CITY" VARCHAR(30 BYTE),
  7   "STATE_PROVINCE" VARCHAR(25 BYTE),
  8   "STATE_ID" CHAR(2 BYTE)
  9 )
 10 TABLESPACE "USERS"
 11 INITRANS 2
 12 MAXTRANS 255
 13 PCTFREE 8;

Succeed.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1000,'1297 Via Cola di Rie','00989','Roma',null,'IT');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1100,'93091 Calle della Testa','10934','Venice',null,'IT');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1200,'2017 Shinjuku-ku','1689','Tokyo','Tokyo Prefecture','JP');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1300,'9450 Kamiya-cho','6823','Hiroshima',null,'JP');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1400,'2014 Jabberwocky Rd','26192','Southlake','Texas','US');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1500,'2011 Interiors Blvd','99236','South San Francisco','California','US');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1600,'2007 Zagora St','50090','South Brunswick','New Jersey','US');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1700,'2004 Charade Rd','98199','Seattle','Washington','US');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1800,'147 Spadina Ave','M5V 2L7','Toronto','Ontario','CA');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (1900,'6092 Boxwood St','YSW 9T2','Whitehorse','Yukon','CA');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2000,'40-5-12 Laogianggen','190518','Beijing',null,'CN');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2100,'1298 Vileparle (E)','490231','Bombay','Maharashtra','IN');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2200,'12-98 Victoria Street','2901','Sydney','New South Wales','AU');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2300,'198 Clementi North','540198','Singapore',null,'SG');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2400,'8204 Arthur St',null,'London',null,'UK');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2500,'Magdalen Centre, The Oxford Science Park','OX9 9ZB','Oxford','Oxford','UK');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2600,'9702 Chester Road','09629850293','Stretford','Manchester','UK');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2700,'Schwanthalerstr. 7031','80925','Munich','Bavaria','DE');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2800,'Rua Frei Caneca 1360 ','01307-002','Sao Paulo','Sao Paulo','BR');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (2900,'20 Rue des Corps-Saints','1730','Geneva','Geneve','CH');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (3000,'Murtenstrasse 921','3095','Bern','BE','CH');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (3100,'Pieter Breughelstraat 837','3029SK','Utrecht','Utrecht','NL');

1 rows affected.

SQL> INSERT INTO "PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values
  2   (3200,'Mariano Escobedo 9991','11932','Mexico City','Distrito Federal,','MX');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "EMPLOYMENT_HISTORY" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "EMPLOYMENT_HISTORY"
  2 (
  3   "STAFF_ID" NUMBER(6),
  4   "START_DATE" DATE,
  5   "END_DATE" DATE,
  6   "EMPLOYMENT_ID" VARCHAR(10 BYTE),
  7   "SECTION_ID" NUMBER(4)
  8 )
  9 TABLESPACE "USERS"
 10 INITRANS 2
 11 MAXTRANS 255
 12 PCTFREE 8;

Succeed.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (102,'1993-01-13 00:00:00','1998-07-24 00:00:00','IT_PROG',60);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (101,'1989-09-21 00:00:00','1993-10-27 00:00:00','AC_ACCOUNT',110);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (101,'1993-10-28 00:00:00','1997-03-15 00:00:00','AC_MGR',110);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (201,'1996-02-17 00:00:00','1999-12-19 00:00:00','MK_REP',20);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (114,'1998-03-24 00:00:00','1999-12-31 00:00:00','ST_CLERK',50);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (122,'1999-01-01 00:00:00','1999-12-31 00:00:00','ST_CLERK',50);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (200,'1987-09-17 00:00:00','1993-06-17 00:00:00','AD_ASST',90);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (176,'1998-03-24 00:00:00','1998-12-31 00:00:00','SA_REP',80);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (176,'1999-01-01 00:00:00','1999-12-31 00:00:00','SA_MAN',80);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENT_HISTORY" ("STAFF_ID","START_DATE","END_DATE","EMPLOYMENT_ID","SECTION_ID") values
  2   (200,'1994-07-01 00:00:00','1998-12-31 00:00:00','AC_ACCOUNT',90);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "EMPLOYMENTS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "EMPLOYMENTS"
  2 (
  3   "EMPLOYMENT_ID" VARCHAR(10 BYTE) NOT NULL,
  4   "EMPLOYMENT_TITLE" VARCHAR(35 BYTE),
  5   "MIN_SALARY" NUMBER(6),
  6   "MAX_SALARY" NUMBER(6)
  7 )
  8 TABLESPACE "USERS"
  9 INITRANS 2
 10 MAXTRANS 255
 11 PCTFREE 8;

Succeed.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('AD_PRES','President',20000,40000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('AD_VP','Administration Vice President',15000,30000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('AD_ASST','Administration Assistant',3000,6000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('FI_MGR','Finance Manager',8200,16000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('FI_ACCOUNT','Accountant',4200,9000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('AC_MGR','Accounting Manager',8200,16000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('AC_ACCOUNT','Public Accountant',4200,9000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('SA_MAN','Sales Manager',10000,20000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('SA_REP','Sales Representative',6000,12000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('PU_MAN','Purchasing Manager',8000,15000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('PU_CLERK','Purchasing Clerk',2500,5500);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('ST_MAN','Stock Manager',5500,8500);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('ST_CLERK','Stock Clerk',2000,5000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('SH_CLERK','Shipping Clerk',2500,5500);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('IT_PROG','Programmer',4000,10000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('MK_MAN','Marketing Manager',9000,15000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('MK_REP','Marketing Representative',4000,9000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('HR_REP','Human Resources Representative',4000,9000);

1 rows affected.

SQL> INSERT INTO "EMPLOYMENTS" ("EMPLOYMENT_ID","EMPLOYMENT_TITLE","MIN_SALARY","MAX_SALARY") values
  2   ('PR_REP','Public Relations Representative',4500,10500);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "COLLEGE" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "COLLEGE"
  2 (
  3   "COLLEGE_ID" NUMBER,
  4   "COLLEGE_NAME" VARCHAR(40 BYTE)
  5 )
  6 TABLESPACE "USERS"
  7 INITRANS 2
  8 MAXTRANS 255
  9 PCTFREE 8;

Succeed.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1001,'The University of Melbourne');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1002,'Duke University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1003,'New York University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1004,'Kings College London');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1005,'Tsinghua University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1006,'University of Zurich');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1007,'Rice University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1008,'Boston University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1009,'Peking University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1010,'Monash University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1011,'KU Leuven');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1012,'University of Basel');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1013,'Leiden University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1014,'Erasmus University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1015,'Ghent University');

1 rows affected.

SQL> INSERT INTO "COLLEGE" ("COLLEGE_ID","COLLEGE_NAME") values
  2   (1016,'Aarhus University');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "AREAS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "AREAS"
  2 (
  3   "AREA_ID" NUMBER,
  4   "AREA_NAME" VARCHAR(25 BYTE)
  5 )
  6 TABLESPACE "USERS"
  7 INITRANS 2
  8 MAXTRANS 255
  9 PCTFREE 8;

Succeed.

SQL> INSERT INTO "AREAS" ("AREA_ID","AREA_NAME") values
  2   (1,'Europe');

1 rows affected.

SQL> INSERT INTO "AREAS" ("AREA_ID","AREA_NAME") values
  2   (2,'Americas');

1 rows affected.

SQL> INSERT INTO "AREAS" ("AREA_ID","AREA_NAME") values
  2   (3,'Asia');

1 rows affected.

SQL> INSERT INTO "AREAS" ("AREA_ID","AREA_NAME") values
  2   (4,'Middle East and Africa');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS "STAFFS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "STAFFS"
  2 (
  3   "STAFF_ID" NUMBER(6) NOT NULL,
  4   "FIRST_NAME" VARCHAR(20 BYTE),
  5   "LAST_NAME" VARCHAR(25 BYTE),
  6   "EMAIL" VARCHAR(25 BYTE),
  7   "PHONE_NUMBER" VARCHAR(20 BYTE),
  8   "HIRE_DATE" DATE,
  9   "EMPLOYMENT_ID" VARCHAR(10 BYTE),
 10   "SALARY" NUMBER(8, 2),
 11   "COMMISSION_PCT" NUMBER(2, 2),
 12   "MANAGER_ID" NUMBER(6),
 13   "SECTION_ID" NUMBER(4),
 14   "GRADUATED_NAME" VARCHAR(60 BYTE)
 15 )
 16 TABLESPACE "USERS"
 17 INITRANS 2
 18 MAXTRANS 255
 19 PCTFREE 8;

Succeed.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (198,'Donald','OConnell','DOCONNEL','650.507.9833','1999-06-21 00:00:00','SH_CLERK',2600,null,124,50,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (199,'Douglas','Grant','DGRANT','650.507.9844','2000-01-13 00:00:00','SH_CLERK',2600,null,124,50,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (200,'Jennifer','Whalen','JWHALEN','515.123.4444','1987-09-17 00:00:00','AD_ASST',4400,null,101,10,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (201,'Michael','Hartstein','MHARTSTE','515.123.5555','1996-02-17 00:00:00','MK_MAN',13000,null,100,20,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (202,'Pat','Fay','PFAY','603.123.6666','1997-08-17 00:00:00','MK_REP',6000,null,201,20,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (203,'Susan','Mavris','SMAVRIS','515.123.7777','1994-06-07 00:00:00','HR_REP',6500,null,101,40,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (204,'Hermann','Baer','HBAER','515.123.8888','1994-06-07 00:00:00','PR_REP',10000,null,101,70,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (205,'Shelley','Higgins','SHIGGINS','515.123.8080','1994-06-07 00:00:00','AC_MGR',12000,null,101,110,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (206,'William','Gietz','WGIETZ','515.123.8181','1994-06-07 00:00:00','AC_ACCOUNT',8300,null,205,110,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (100,'Steven','King','SKING','515.123.4567','1987-06-17 00:00:00','AD_PRES',24000,null,null,90,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (101,'Neena','Kochhar','NKOCHHAR','515.123.4568','1989-09-21 00:00:00','AD_VP',17000,null,100,90,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (102,'Lex','De Haan','LDEHAAN','515.123.4569','1993-01-13 00:00:00','AD_VP',17000,null,100,90,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (103,'Alexander','Hunold','AHUNOLD','590.423.4567','1990-01-03 00:00:00','IT_PROG',9000,null,102,60,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (104,'Bruce','Ernst','BERNST','590.423.4568','1991-05-21 00:00:00','IT_PROG',6000,null,103,60,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (105,'David','Austin','DAUSTIN','590.423.4569','1997-06-25 00:00:00','IT_PROG',4800,null,103,60,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (106,'Valli','Pataballa','VPATABAL','590.423.4560','1998-02-05 00:00:00','IT_PROG',4800,null,103,60,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (107,'Diana','Lorentz','DLORENTZ','590.423.5567','1999-02-07 00:00:00','IT_PROG',4200,null,103,60,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (108,'Nancy','Greenberg','NGREENBE','515.124.4569','1994-08-17 00:00:00','FI_MGR',12000,null,101,100,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (109,'Daniel','Faviet','DFAVIET','515.124.4169','1994-08-16 00:00:00','FI_ACCOUNT',9000,null,108,100,null);

1 rows affected.

SQL> INSERT INTO "STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values
  2   (110,'John','Chen','JCHEN','515.124.4269','1997-09-28 00:00:00','FI_ACCOUNT',8200,null,108,100,null);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> select
  2   subq_0.c3 as c0,
  3
  4     sum(
  5       cast(cast(nullif(TANH(
  6           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)),
  7         case when false then case when false then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
  8              else case when false then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
  9              end
 10           ) as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by subq_0.c0 order by subq_0.c0) as c3,
 11
 12     STDDEV(
 13       cast(case when EXISTS (
 14           select
 15               subq_0.c1 as c0,
 16
 17               subq_1.c0 as c1,
 18
 19               subq_0.c0 as c2,
 20
 21               subq_1.c2 as c3,
 22
 23               subq_1.c5 as c4,
 24
 25               subq_1.c4 as c5
 26             from
 27
 28               STATES as ref_1,
 29               (select
 30
 31                     2 as c0,
 32
 33                     ref_2.EMPLOYMENT_TITLE as c1,
 34
 35                     (select PLACE_ID from SECTIONS limit 1 offset 4)
 36                        as c2,
 37
 38                     ref_2.MAX_SALARY as c3,
 39
 40                     (select AREA_ID from AREAS limit 1 offset 2)
 41                        as c4,
 42
 43                     subq_0.c1 as c5
 44                   from
 45                     EMPLOYMENTS as ref_2
 46
 47                   where true and subq_0.c1 is not null) as subq_1
 48             where (subq_1.c5 is not NULL)
 49
 50               and ((true)
 51
 52                 and (true))
 53             limit 105) then COS(
 54           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) else COS(
 55           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) end
 56          as BINARY_DOUBLE)) over (partition by subq_0.c2 order by subq_0.c4) as c6,
 57
 58     avg(
 59       cast(subq_0.c0 as BINARY_INTEGER)) over (partition by subq_0.c0 order by subq_0.c4) as c7,
 60
 61     STDDEV_SAMP(
 62       cast(subq_0.c0 as BINARY_INTEGER)) over (partition by subq_0.c3,subq_0.c3 order by subq_0.c0,subq_0.c3) as c8
 63 from
 64
 65   (select
 66
 67         85 as c0,
 68
 69         case when (true)
 70
 71             or (89 is NULL) then (select AREA_ID from AREAS limit 1 offset 87)
 72              else (select AREA_ID from AREAS limit 1 offset 87)
 73              end
 74            as c1,
 75
 76         (select PLACE_ID from SECTIONS limit 1 offset 2)
 77            as c2,
 78
 79         last_insert_id() as c3,
 80
 81         (select AREA_ID from AREAS limit 1 offset 1)
 82            as c4
 83       from
 84         STAFFS as ref_0
 85       where 84 is not NULL
 86       limit 97) as subq_0
 87 where true;

C0                   C3                   C6                                       C7                                       C8
-------------------- -------------------- ---------------------------------------- ---------------------------------------- ----------------------------------------
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0
0                                                                                  85                                       0

20 rows fetched.

SQL> select
  2     STDDEV_SAMP(
  3       cast(subq_0.c4 as BINARY_INTEGER)) over (partition by subq_0.c4,subq_0.c3,subq_0.c2 order by subq_0.c3) as c0,
  4     sum(
  5       cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by subq_0.c3 order by subq_0.c1) as c1,
  6     STDDEV_POP(
  7       cast(20 as BINARY_INTEGER)) over (partition by subq_0.c0,subq_0.c1 order by subq_0.c0,subq_0.c2,subq_0.c1,subq_0.c0,subq_0.c1) as c2,
  8     avg(
  9       cast(subq_0.c4 as BINARY_INTEGER)) over (partition by subq_0.c4,subq_0.c2 order by subq_0.c0,subq_0.c4) as c3,
 10     sum(
 11       cast(subq_0.c4 as BINARY_INTEGER)) over (partition by subq_0.c2 order by subq_0.c0) as c4,
 12
 13   trim(
 14     cast(subq_0.c1 as VARCHAR(50)),
 15     cast((select AREA_NAME from AREAS limit 1 offset 6)
 16        as VARCHAR(50))) as c5,
 17     count(
 18       cast(case when EXISTS (
 19           select
 20
 21               subq_1.c0 as c0
 22             from
 23
 24               EMPLOYMENT_HISTORY as ref_1,
 25               (select
 26
 27                     subq_0.c4 as c0,
 28
 29                     subq_0.c2 as c1,
 30
 31                     subq_0.c1 as c2
 32                   from
 33                     EMPLOYMENT_HISTORY as ref_2
 34                   where subq_0.c1 is NULL) as subq_1
 35             where subq_1.c1 is not NULL) then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
 36          as BINARY_DOUBLE)) over (partition by subq_0.c1 order by subq_0.c3) as c6,
 37     STDDEV_POP(
 38       cast(subq_0.c4 as BINARY_INTEGER)) over (partition by subq_0.c0 order by subq_0.c2) as c7,
 39
 40   subq_0.c4 as c8,
 41
 42   subq_0.c4 as c9,
 43
 44   EMPTY_CLOB() as c10,
 45
 46   subq_0.c0 as c11
 47 from
 48
 49   (select
 50         cast(nullif(ref_0.SECTION_NAME,
 51           ref_0.SECTION_NAME) as VARCHAR(50)) as c0,
 52
 53         ref_0.SECTION_NAME as c1,
 54
 55         ref_0.MANAGER_ID as c2,
 56
 57         ref_0.SECTION_ID as c3,
 58           avg(
 59             cast(69 as BINARY_INTEGER)) over (partition by ref_0.SECTION_NAME order by ref_0.SECTION_ID,ref_0.PLACE_ID,ref_0.PLACE_ID) as c4
 60       from
 61
 62         SECTIONS as ref_0
 63       where ref_0.MANAGER_ID is NULL
 64       limit 67) as subq_0
 65 where ((true)
 66
 67     or (subq_0.c2 is NULL))
 68
 69   or ((((subq_0.c1 is NULL)
 70
 71         or (subq_0.c2 is NULL))
 72
 73       or (true))
 74
 75     and (case when EXISTS (
 76           select
 77
 78               ref_5.MIN_SALARY as c0,
 79
 80               ref_3.MAX_SALARY as c1,
 81
 82               ref_3.MIN_SALARY as c2,
 83
 84               ref_4.MAX_SALARY as c3
 85             from
 86
 87               EMPLOYMENTS as ref_3
 88                   inner join EMPLOYMENTS as ref_4
 89                   on (ref_4.EMPLOYMENT_TITLE is NULL)
 90                 right join EMPLOYMENTS as ref_5
 91                 on (ref_3.MIN_SALARY = ref_5.MIN_SALARY )
 92             where (ref_4.EMPLOYMENT_ID is NULL)
 93
 94               or (subq_0.c1 is not NULL)
 95             limit 51) then subq_0.c4 else subq_0.c4 end
 96          is not NULL))
 97 limit 49;

C0                                       C1                   C2                                       C3                                       C4                   C5                                                 C6                   C7                                       C8                                       C9                                       C10                                                              C11
---------------------------------------- -------------------- ---------------------------------------- ---------------------------------------- -------------------- -------------------------------------------------- -------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- --------------------------------------------------
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69
                                                              0                                        69                                       1104                                                                    0                    0                                       69                                       69

16 rows fetched.

SQL> select
  2   case when true then
  3
  4       STDDEV(
  5         cast(LOG(
  6           cast(96 as BINARY_INTEGER),
  7           cast(case when ((EXISTS (
  8                   select
  9
 10                       ref_0.COLLEGE_ID as c0,
 11
 12                       ref_0.COLLEGE_NAME as c1,
 13
 14                       ref_0.COLLEGE_NAME as c2,
 15
 16                       ref_0.COLLEGE_ID as c3,
 17
 18                       ref_0.COLLEGE_NAME as c4
 19                     from
 20
 21                       STATES as ref_1,
 22                       (select
 23
 24                             ref_0.COLLEGE_ID as c0,
 25
 26                             ref_0.COLLEGE_ID as c1,
 27
 28                             ref_0.COLLEGE_ID as c2,
 29
 30                             ref_0.COLLEGE_ID as c3,
 31
 32                             (select SECTION_NAME from SECTIONS limit 1 offset 4)
 33                                as c4,
 34
 35                             ref_0.COLLEGE_NAME as c5,
 36
 37                             ref_0.COLLEGE_NAME as c6
 38                           from
 39
 40                             PLACES as ref_2
 41                           where true) as subq_0
 42                     where subq_0.c6 is not NULL
 43                     limit 33))
 44
 45                 and ((ref_0.COLLEGE_ID is NULL)
 46
 47                   and (ref_0.COLLEGE_NAME is NULL)))
 48
 49               and (ref_0.COLLEGE_NAME is not NULL) then 52 else 52 end
 50              as BINARY_INTEGER)) as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_ID order by ref_0.COLLEGE_NAME) else
 51
 52       STDDEV(
 53         cast(LOG(
 54           cast(96 as BINARY_INTEGER),
 55           cast(case when ((EXISTS (
 56                   select
 57
 58                       ref_0.COLLEGE_ID as c0,
 59
 60                       ref_0.COLLEGE_NAME as c1,
 61
 62                       ref_0.COLLEGE_NAME as c2,
 63
 64                       ref_0.COLLEGE_ID as c3,
 65                       ref_0.COLLEGE_NAME as c4
 66                     from
 67                       STATES as ref_1,
 68                       (select
 69                             ref_0.COLLEGE_ID as c0,
 70                             ref_0.COLLEGE_ID as c1,
 71                             ref_0.COLLEGE_ID as c2,
 72                             ref_0.COLLEGE_ID as c3,
 73                             (select SECTION_NAME from SECTIONS limit 1 offset 4)
 74                                as c4,
 75                             ref_0.COLLEGE_NAME as c5,
 76                             ref_0.COLLEGE_NAME as c6
 77                           from
 78                             PLACES as ref_2
 79                           where true) as subq_0
 80                     where subq_0.c6 is not NULL
 81                     limit 33))
 82                 and ((ref_0.COLLEGE_ID is NULL)
 83                   and (ref_0.COLLEGE_NAME is NULL)))
 84               and (ref_0.COLLEGE_NAME is not NULL) then 52 else 52 end
 85              as BINARY_INTEGER)) as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_ID order by ref_0.COLLEGE_NAME) end
 86      as c0,
 87     MIN(
 88       cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by ref_0.COLLEGE_NAME order by ref_0.COLLEGE_NAME) as c1,
 89     STDDEV(
 90       cast(27 as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_ID order by ref_0.COLLEGE_ID) as c2,
 91     max(
 92       cast(case when (ref_0.COLLEGE_ID is NULL)
 93           or (EXISTS (
 94             select
 95                 ref_3.MANAGER_ID as c0,
 96                 ref_0.COLLEGE_ID as c1
 97               from
 98                 SECTIONS as ref_3
 99               where EXISTS (
100                 select
101                     ref_0.COLLEGE_ID as c0
102                   from
103                     EMPLOYMENT_HISTORY as ref_4
104                   where false
105                   limit 63)
106               limit 48)) then case when (((true)
107                 or (ref_0.COLLEGE_ID is not NULL))
108               and (EXISTS (
109                 select
110                     ref_5.EMPLOYMENT_ID as c0,
111                     ref_0.COLLEGE_ID as c1,
112                     ref_0.COLLEGE_ID as c2,
113                     ref_0.COLLEGE_ID as c3
114                   from
115                     EMPLOYMENTS as ref_5
116                   where ref_0.COLLEGE_NAME is not NULL)))
117             and ((false)
118               and (true)) then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
119            else case when (((true)
120                 or (ref_0.COLLEGE_ID is not NULL))
121               and (EXISTS (
122                 select
123                     ref_5.EMPLOYMENT_ID as c0,
124                     ref_0.COLLEGE_ID as c1,
125                     ref_0.COLLEGE_ID as c2,
126                     ref_0.COLLEGE_ID as c3
127                   from
128                     EMPLOYMENTS as ref_5
129                   where ref_0.COLLEGE_NAME is not NULL)))
130
131             and ((false)
132
133               and (true)) then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
134            end
135          as BINARY_DOUBLE)) over (partition by ref_0.COLLEGE_NAME order by ref_0.COLLEGE_NAME) as c4,
136     STDDEV_SAMP(
137       cast(last_insert_id() as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_ID,ref_0.COLLEGE_NAME order by ref_0.COLLEGE_ID) as c5,
138     max(
139       cast(case when false then case when ref_0.COLLEGE_NAME is NULL then 16 else 16 end
140            else case when ref_0.COLLEGE_NAME is NULL then 16 else 16 end
141            end
142          as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_ID,ref_0.COLLEGE_NAME,ref_0.COLLEGE_ID,ref_0.COLLEGE_ID,ref_0.COLLEGE_NAME order by ref_0.COLLEGE_ID) as c6
143 from
144
145   COLLEGE as ref_0
146 where ref_0.COLLEGE_ID is not NULL
147 limit 77;

C0                                       C1                   C2                                       C4                   C5                                       C6
---------------------------------------- -------------------- ---------------------------------------- -------------------- ---------------------------------------- ------------
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16
0                                                             0                                                                                                      16

16 rows fetched.

SQL> select
  2   subq_0.c3 as c0,
  3     STDDEV(
  4       cast(subq_0.c3 as BINARY_INTEGER)) over (partition by subq_0.c2 order by subq_0.c3) as c1,
  5     STDDEV_POP(
  6       cast(subq_0.c3 as BINARY_INTEGER)) over (partition by subq_0.c1 order by subq_0.c2,subq_0.c0) as c2,
  7     sum(
  8       cast(cast(nullif(TANH(
  9           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)),
 10         case when false then case when false then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
 11              else case when false then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
 12              end
 13           ) as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by subq_0.c0 order by subq_0.c0) as c3,
 14     avg(
 15       cast(subq_0.c3 as BINARY_INTEGER)) over (partition by subq_0.c0,subq_0.c0,subq_0.c0 order by subq_0.c1,subq_0.c4) as c4,
 16     STDDEV_POP(
 17       cast(subq_0.c0 as BINARY_INTEGER)) over (partition by subq_0.c0 order by subq_0.c0) as c5,
 18     STDDEV(
 19       cast(case when EXISTS (
 20           select
 21               subq_0.c1 as c0,
 22               subq_1.c0 as c1,
 23               subq_0.c0 as c2,
 24               subq_1.c2 as c3,
 25               subq_1.c5 as c4,
 26               subq_1.c4 as c5
 27             from
 28               STATES as ref_1,
 29               (select
 30                     2 as c0,
 31                     ref_2.EMPLOYMENT_TITLE as c1,
 32                     (select PLACE_ID from SECTIONS limit 1 offset 4)
 33                        as c2,
 34                     ref_2.MAX_SALARY as c3,
 35                     (select AREA_ID from AREAS limit 1 offset 2)
 36                        as c4,
 37                     subq_0.c1 as c5
 38                   from
 39                     EMPLOYMENTS as ref_2
 40                   where true) as subq_1
 41             where (subq_1.c5 is not NULL)
 42               and ((true)
 43                 and (true))
 44             limit 105) then COS(
 45           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) else COS(
 46           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) end
 47          as BINARY_DOUBLE)) over (partition by subq_0.c2 order by subq_0.c4) as c6,
 48     avg(
 49       cast(subq_0.c0 as BINARY_INTEGER)) over (partition by subq_0.c0 order by subq_0.c4) as c7,
 50     STDDEV_SAMP(
 51       cast(subq_0.c0 as BINARY_INTEGER)) over (partition by subq_0.c3,subq_0.c3 order by subq_0.c0,subq_0.c3) as c8
 52 from
 53   (select
 54         85 as c0,
 55         case when (true)
 56
 57             or (89 is NULL) then (select AREA_ID from AREAS limit 1 offset 87)
 58              else (select AREA_ID from AREAS limit 1 offset 87)
 59              end
 60            as c1,
 61         (select PLACE_ID from SECTIONS limit 1 offset 2)
 62            as c2,
 63         last_insert_id() as c3,
 64         (select AREA_ID from AREAS limit 1 offset 1)
 65            as c4
 66       from
 67         STAFFS as ref_0
 68       where 84 is not NULL
 69       limit 97) as subq_0
 70 where true
 71 limit 122;

C0                   C1                                       C2                                       C3                   C4                                       C5                                       C6        C7                                       C8
-------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ----------------------------------------
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0
0                    0                                        0                                                             0                                        0        85                                       0

20 rows fetched.

SQL> MERGE INTO EMPLOYMENTS target_0
  2 USING (select
  3       ref_0.COLLEGE_NAME as c0,
  4         count(
  5           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by ref_0.COLLEGE_ID order by ref_0.COLLEGE_ID) as c1,
  6         avg(
  7           cast(cast(null as BINARY_DOUBLE) as BINARY_DOUBLE)) over (partition by ref_0.COLLEGE_ID order by ref_0.COLLEGE_NAME,ref_0.COLLEGE_NAME) as c2,
  8       ref_0.COLLEGE_NAME as c3,
  9         sum(
 10           cast(BITAND(
 11             cast(13 as BINARY_INTEGER),
 12             cast(68 as BINARY_INTEGER)) as BINARY_INTEGER)) over (partition by ref_0.COLLEGE_NAME,ref_0.COLLEGE_ID order by ref_0.COLLEGE_NAME) as c4,
 13       ref_0.COLLEGE_ID as c5,
 14
 15         count(
 16           cast(case when EXISTS (
 17               select
 18                   ref_0.COLLEGE_ID as c0,
 19                   subq_0.c2 as c1,
 20                   ref_0.COLLEGE_ID as c2,
 21                   subq_0.c1 as c3,
 22                   ref_0.COLLEGE_ID as c4,
 23                   ref_0.COLLEGE_ID as c5,
 24                   97 as c6,
 25                   subq_0.c0 as c7,
 26                   subq_0.c2 as c8,
 27                   (select EMPLOYMENT_TITLE from EMPLOYMENTS limit 1 offset 1)
 28                      as c9,
 29                   ref_0.COLLEGE_NAME as c10,
 30                   ref_0.COLLEGE_ID as c11
 31                 from
 32                   PLACES as ref_1,
 33                   (select
 34                         ref_0.COLLEGE_NAME as c0,
 35                         ref_0.COLLEGE_NAME as c1,
 36                         ref_0.COLLEGE_NAME as c2
 37                       from
 38                         STATES as ref_2
 39                       where false) as subq_0
 40                 where (EXISTS (
 41                     select
 42                         subq_0.c2 as c0
 43                       from
 44                         EMPLOYMENTS as ref_3
 45                       where (ref_3.MIN_SALARY is NULL)
 46                         or (false)))
 47                   and (subq_0.c2 is NULL)
 48                 limit 61) then cast(null as BINARY_DOUBLE) else cast(null as BINARY_DOUBLE) end
 49              as BINARY_DOUBLE)) over (partition by ref_0.COLLEGE_ID,ref_0.COLLEGE_NAME order by ref_0.COLLEGE_NAME) as c6,
 50       ref_0.COLLEGE_ID as c7,
 51       last_insert_id() as c8
 52     from
 53       COLLEGE as ref_0
 54     where case when (false)
 55           or (false) then ref_0.COLLEGE_ID else ref_0.COLLEGE_ID end
 56          is not NULL) as subq_1
 57 ON (target_0.MIN_SALARY = subq_1.c5 )
 58 WHEN NOT MATCHED
 59    THEN INSERT VALUES ( cast(null as VARCHAR(50)), cast(null as VARCHAR(50)), cast(null as NUMBER), cast(null as NUMBER))
 60 WHEN MATCHED
 61    THEN UPDATE  set
 62     EMPLOYMENT_ID = target_0.EMPLOYMENT_ID,
 63 MAX_SALARY = target_0.MIN_SALARY;

CT-00620, Can't set NULL value for column 'EMPLOYMENT_ID'

SQL> --20210907
SQL> SELECT
  2   SUBQ_0.C0 AS C1
  3 FROM
  4   ((((SELECT
  5             REF_1.PEXPR_1_AGGR_0 AS C0,
  6             REF_1.PEXPR_0_AGGR_0 AS C1
  7           FROM
  8             SALARIES PIVOT(COVAR_SAMP(
  9                 CAST(SALARIES.SALARY AS BINARY_INTEGER),
 10                 CAST(SALARIES.SALARY AS BINARY_INTEGER)) AS AGGR_0
 11                FOR (EMP_NO, TO_DATE, SALARY, FROM_DATE)
 12               IN ((10007, '1993-08-22 00:00:00', 5400, '1996-08-03 00:00:00') AS PEXPR_0, (10008, '1992-07-29 00:00:00', 5500, '1995-12-03 00:00:00') AS PEXPR_1, (10009, '2002-07-15 00:00:00', 5600, '1986-12-01 00:00:00') AS PEXPR_2)) AS REF_1
 13           WHERE 1 = 1)
 14           EXCEPT  (
 15           SELECT
 16             REF_2.SECTION_ID AS C2,
 17             REF_2.MANAGER_ID AS C3
 18           FROM
 19             SECTIONS AS REF_2
 20           WHERE REF_2.SECTION_NAME REGEXP '.*'
 21           LIMIT 94, 40)
 22         ) AS SUBQ_0)
 23       RIGHT OUTER JOIN (EMPLOYMENTS UNPIVOT EXCLUDE NULLS ((NEWCOL_0)
 24          FOR (FORCOL_0, FORCOL_1)
 25         IN ((EMPLOYMENT_TITLE), (EMPLOYMENT_TITLE) AS ('UNPIVOT_VALUE_0', 'UNPIVOT_VALUE_1'), (EMPLOYMENT_TITLE) AS ('UNPIVOT_VALUE_0', 'UNPIVOT_VALUE_1'), (EMPLOYMENT_TITLE) AS ('UNPIVOT_VALUE_0', 'UNPIVOT_VALUE_1'), (EMPLOYMENT_TITLE), (EMPLOYMENT_TITLE) AS ('UNPIVOT_VALUE_0', 'UNPIVOT_VALUE_1'))) AS REF_3)
 26       ON (SUBQ_0.C1 = REF_3.MIN_SALARY ))
 27     full OUTER JOIN (DEPT_EMP AS REF_4)
 28     ON (REGEXP_LIKE(REF_3.FORCOL_1,'.*'))
 29 WHERE '2021-09-07 12:44:03' >= CAST('2021-09-07 12:44:03' AS TIMESTAMP(6)) limit 1;

C1
----------------------------------------


1 rows fetched.

SQL> --20201201
SQL> SELECT
  2     CORR(
  3       CAST((SELECT 1 FROM sys_dummy) AS NUMBER(6,0)),
  4       CAST(0.0 AS NUMBER)) OVER (PARTITION BY SUBQ_0.C9,SUBQ_0.C6 ORDER BY SUBQ_0.C10 DESC NULLS LAST) AS C0
  5 FROM
  6   (SELECT
  7         REF_0.STU_ID AS C0,
  8         REF_0.ID AS C1,
  9         CAST('2020-11-24 00:44:37' AS TIMESTAMP(6) WITH TIME ZONE) AS C5,
 10         REF_0.GRADE AS C6,
 11         NULL AS C9,
 12         CAST('201066 11:13:26' AS INTERVAL DAY TO SECOND) AS C10,
 13         '0' AS C11,
 14         FALSE AS C12
 15       FROM
 16         SCORE  REF_0
 17       WHERE NULL < ALL(
 18         SELECT
 19             NULL AS C1
 20           FROM
 21             PLACES  REF_1
 22           WHERE (REF_0.STU_ID IN (
 23               SELECT
 24                   NULL AS C1
 25                 FROM
 26                   COLLEGE PIVOT(COVAR_POP(
 27                       CAST(77 AS BINARY_INTEGER),
 28                       CAST(NULL AS BINARY_DOUBLE)) AS AGGR_0, STDDEV(
 29                       CAST(13 AS BINARY_UINT32)) AS AGGR_1
 30                      FOR (COLLEGE_ID, COLLEGE_NAME)
 31                     IN ((1005, 'Tsinghua University') AS PEXPR_0, (1006, 'University of Zurich') AS PEXPR_1)) REF_2
 32                 WHERE REF_1.STREET_ADDRESS REGEXP '.*'))
 33           OFFSET 83 LIMIT 80)
 34     ) AS SUBQ_0
 35 LIMIT 63;

C0
----------------------------------------











10 rows fetched.

SQL> --20201016
SQL> SELECT
  2   SUBQ_0.C35 AS C4,
  3   SUBQ_0.C1 AS C5
  4 FROM
  5   (SELECT DISTINCT
  6         REF_0.ID AS C1,
  7         REF_0.ID AS C18,
  8         MIN(CAST(REF_0.PASSWORD AS VARCHAR(256))) over (partition by REF_0.ID,REF_0.ID,REF_0.PASSWORD ORDER BY REF_0.NAME,REF_0.NAME) AS C35,
  9         REF_0.PASSWORD AS C36,
 10         REF_0.NAME AS C37
 11     FROM
 12         SYS.SYS_ROLES AS REF_0
 13     WHERE CAST('7A894DBD2F669064' AS RAW(4096)) != CASE WHEN NULL >= CAST('EB3FA299E34C78A7' AS BINARY(100)) THEN CAST('73DA76081F985663' AS RAW(4096)) ELSE CAST('73DA76081F985663' AS RAW(4096)) END
 14   ) AS SUBQ_0;

C4                                                               C5
---------------------------------------------------------------- ------------
                                                                 0
                                                                 1
                                                                 2
                                                                 3

4 rows fetched.

SQL> --20201226
SQL> SELECT
  2   1
  3 FROM
  4   EMPLOYMENT_HISTORY PIVOT(COVAR_SAMP(
  5       CAST(EMPLOYMENT_HISTORY.STAFF_ID AS NUMBER(6,0)),
  6       CAST(EMPLOYMENT_HISTORY.SECTION_ID AS NUMBER(4,0))) AS AGGR_0
  7      FOR (STAFF_ID, SECTION_ID, EMPLOYMENT_ID, END_DATE)
  8     IN ((176, 90, 'AD_ASST', '1999-12-31 00:00:00') AS PEXPR_0)) AS REF_0
  9 WHERE NVL2(
 10   CAST(REF_0.PEXPR_0_AGGR_0 AS NUMBER),
 11   CAST(CURRENT_TIMESTAMP() AS DATE),
 12   CAST(CAST('2020-12-17 17:06:44' AS DATE) AS DATE)) <> ALL(
 13   (SELECT
 14       NULL AS C1
 15     FROM
 16       EMPLOYMENT_HISTORY PIVOT(CORR(
 17           CAST(EMPLOYMENT_HISTORY.SECTION_ID AS NUMBER(4,0)),
 18           CAST(EMPLOYMENT_HISTORY.STAFF_ID AS NUMBER(6,0))) AS AGGR_0
 19          FOR (START_DATE, EMPLOYMENT_ID, END_DATE)
 20         IN (('1998-03-24 00:00:00', 'AD_ASST', '1999-12-31 00:00:00') AS PEXPR_0)) AS REF_3
 21     WHERE REF_0.PEXPR_0_AGGR_0 <> ANY(
 22       SELECT
 23           REF_3.PEXPR_0_AGGR_0 AS C1
 24         FROM
 25           EMPLOYEES  AS REF_4))
 26     INTERSECT (
 27     (SELECT
 28       1 AS C1
 29     FROM
 30       FVT_OBJ_DEFINE_TABLE_FRE1 AS REF_5)));

1
------------
1
1
1
1
1
1
1
1

8 rows fetched.

SQL> --20200924
SQL> drop table if exists temp_0924;

Succeed.

SQL> CREATE TABLE temp_0924(ID INT, NAME VARCHAR(20)) PARTITION BY RANGE(ID) INTERVAL(50) SUBPARTITION BY HASH(NAME) (
  2 PARTITION P1 VALUES LESS THAN(50) (SUBPARTITION P11,SUBPARTITION P12),PARTITION P2 VALUES LESS THAN(100) (SUBPARTITION P21,SUBPARTITION P22));

Succeed.

SQL> create index temp_0924_index_003 on temp_0924(id) local;

Succeed.

SQL> create index temp_0924_index_004 on temp_0924(name) local;

Succeed.

SQL> create index temp_0924_index_002 on temp_0924(id,name) local;

Succeed.

SQL> declare
  2 v_name varchar(20);
  3 v_id int;
  4 begin
  5 for i in 1..1000 loop
  6 v_id :=i;
  7 v_name := 'OSS3:NE=forver' || to_char(i);
  8 insert into temp_0924 values (v_id,v_name);
  9 end loop;
 10 commit;
 11 end;
 12 /

PL/SQL procedure successfully completed.

SQL> SELECT
  2   CASE WHEN (
  3           MIN(
  4             CAST(false as BOOLEAN)) over (partition by ref_0.ID ORDER BY ref_0.NAME,ref_0.NAME) <> false)
  5       AND (false <> false) THEN ref_0.ID ELSE ref_0.ID END
  6      AS C0,
  7   ref_0.NAME AS C1,
  8   CASE WHEN false THEN 82 ELSE 82 END
  9      AS C2
 10 FROM
 11   temp_0924 as ref_0
 12 WHERE true > CASE WHEN CASE WHEN CAST(coalesce(true,
 13             true) AS BOOLEAN) < true THEN false ELSE false END
 14          >= true THEN CAST(nullif(false,
 15       true) AS BOOLEAN) ELSE CAST(nullif(false,
 16       true) AS BOOLEAN) END limit 10;

C0           C1                   C2
------------ -------------------- ------------
1            OSS3:NE=forver1      82
2            OSS3:NE=forver2      82
6            OSS3:NE=forver6      82
8            OSS3:NE=forver8      82
15           OSS3:NE=forver15     82
19           OSS3:NE=forver19     82
20           OSS3:NE=forver20     82
21           OSS3:NE=forver21     82
23           OSS3:NE=forver23     82
31           OSS3:NE=forver31     82

10 rows fetched.

SQL> explain SELECT
  2   CASE WHEN (
  3           MIN(
  4             CAST(false as BOOLEAN)) over (partition by ref_0.ID ORDER BY ref_0.NAME,ref_0.NAME) <> false)
  5       AND (false <> false) THEN ref_0.ID ELSE ref_0.ID END
  6      AS C0,
  7   ref_0.NAME AS C1,
  8   CASE WHEN false THEN 82 ELSE 82 END
  9      AS C2
 10 FROM
 11   temp_0924 as ref_0
 12 WHERE true > CASE WHEN CASE WHEN CAST(coalesce(true,
 13             true) AS BOOLEAN) < true THEN false ELSE false END
 14          >= true THEN CAST(nullif(false,
 15       true) AS BOOLEAN) ELSE CAST(nullif(false,
 16       true) AS BOOLEAN) END limit 10;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                             |       |                     |      |      |       |        |
| 1   |   QUERY LIMIT                                |       |                     |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,21) | SYS   | TEMP_0924 REF_0     |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN                   | SYS   | TEMP_0924_INDEX_002 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: TRUE > CASE  WHEN CASE  WHEN CAST(COALESCE(TRUE, TRUE) AS BOOLEAN) < TRUE THEN FALSE ELSE 
               FALSE END >= TRUE THEN CAST(NULLIF(FALSE, TRUE) AS BOOLEAN) ELSE CAST(NULLIF(FALSE, TRUE) AS 
               BOOLEAN) END                                     
  
13 rows fetched.

SQL> drop table temp_0924;

Succeed.

SQL> --20201022
SQL> DROP TABLE IF EXISTS "INF_PROD_PROP" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "INF_PROD_PROP"
  2 (
  3   "PROP_INST_ID" NUMBER(20) NOT NULL,
  4   "PROD_INST_ID" NUMBER(20) NOT NULL,
  5   "PROP_ID" NUMBER(20) NOT NULL,
  6   "PROP_CODE" VARCHAR(32 BYTE) NOT NULL,
  7   "COMPLEX_FLAG" VARCHAR(1 BYTE) NOT NULL,
  8   "PROP_VALUE" VARCHAR(4000 BYTE),
  9   "P_PROP_INST_ID" NUMBER(20),
 10   "OFFERING_INST_ID" NUMBER(20),
 11   "OWNER_ENTITY_TYPE" VARCHAR(4 BYTE),
 12   "OWNER_ENTITY_ID" NUMBER(20),
 13   "MODIFY_CHANNEL_TYPE" VARCHAR(4 BYTE),
 14   "ENTITY_ROUTE" VARCHAR(1024 BYTE),
 15   "EFF_DATE" DATE NOT NULL,
 16   "EXP_DATE" DATE NOT NULL,
 17   "CREATE_ORDER_ID" NUMBER(20),
 18   "LAST_MOD_ORDER_ID" NUMBER(20),
 19   "CREATE_PROLE_TYPE" VARCHAR(4 BYTE),
 20   "CREATE_PROLE_ID" NUMBER(20),
 21   "CREATE_DEPT_ID" NUMBER(20),
 22   "CREATE_TIME" DATE,
 23   "MODIFY_PROLE_TYPE" VARCHAR(4 BYTE),
 24   "MODIFY_PROLE_ID" NUMBER(20),
 25   "MODIFY_DEPT_ID" NUMBER(20),
 26   "MODIFY_TIME" DATE,
 27   "PARTITION_ID" NUMBER(8),
 28   "EX_FIELD1" VARCHAR(32 BYTE),
 29   "EX_FIELD2" VARCHAR(32 BYTE),
 30   "EX_FIELD3" VARCHAR(32 BYTE),
 31   "EX_FIELD4" VARCHAR(32 BYTE),
 32   "EX_FIELD5" VARCHAR(32 BYTE),
 33   "EX_FIELD6" VARCHAR(32 BYTE),
 34   "EX_FIELD7" VARCHAR(32 BYTE),
 35   "EX_FIELD8" VARCHAR(32 BYTE),
 36   "EX_FIELD9" VARCHAR(32 BYTE),
 37   "EX_FIELD10" VARCHAR(32 BYTE),
 38   "BE_ID" NUMBER(10),
 39   "PREVIOUS_DATA_VERSION" DATE,
 40   "DATA_VERSION" DATE,
 41   "TENANT_ID" NUMBER(20) NOT NULL
 42 );

Succeed.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (8511000000000426,8511000000000573,1532350213422020129,'C_SMS','N','0',null,8511000000000288,'S',8511000000000073,'601','O2018082307.P1042','2020-07-13 04:16:40','2099-12-31 23:59:59',850100000000000250,850100000000000250,'E',66010001,4865183546,'2020-07-13 04:16:51',null,null,null,'2020-07-13 04:16:51',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:16:51',999999);

1 rows affected.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (7911000000000456,7911000000000612,1478848289073239599,'PM_DELIVERY_LIMIT_AD','N','0',null,7911000000000306,'S',7911000000001087,'601','O2018082306.P1053','2020-07-13 04:16:43','2099-12-31 23:59:59',790100000000000265,790100000000000265,'E',66010001,4865183546,'2020-07-13 04:16:53',null,null,null,'2020-07-13 04:16:53',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:16:53',999999);

1 rows affected.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (9111000000001475,9111000000001618,1478848289073239599,'PM_DELIVERY_LIMIT_AD','N','0',null,9111000000001308,'S',9111000000000082,'601','O2018082307.P1053','2020-07-13 04:16:45','2099-12-31 23:59:59',910100000000001266,910100000000001266,'E',66010001,4865183546,'2020-07-13 04:16:58',null,null,null,'2020-07-13 04:16:58',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:16:58',999999);

1 rows affected.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (811000000001523,811000000001680,1478848289073239599,'PM_DELIVERY_LIMIT_AD','N','0',null,811000000001348,'S',811000000001098,'601','O2019003027.P1053','2020-07-13 04:17:00','2099-12-31 23:59:59',80100000000001297,80100000000001297,'E',66010001,4865183546,'2020-07-13 04:17:10',null,null,null,'2020-07-13 04:17:10',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:17:10',999999);

1 rows affected.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (2111000000001548,2111000000001714,1478848289073239599,'PM_DELIVERY_LIMIT_AD','N','0',null,2111000000001365,'S',2111000000000093,'601','O2018082307.P1053','2020-07-13 04:17:05','2099-12-31 23:59:59',210100000000001310,210100000000001310,'E',66010001,4865183546,'2020-07-13 04:17:17',null,null,null,'2020-07-13 04:17:17',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:17:17',999999);

1 rows affected.

SQL> INSERT INTO "INF_PROD_PROP" ("PROP_INST_ID","PROD_INST_ID","PROP_ID","PROP_CODE","COMPLEX_FLAG","PROP_VALUE","P_PROP_INST_ID","OFFERING_INST_ID","OWNER_ENTITY_TYPE","OWNER_ENTITY_ID","MODIFY_CHANNEL_TYPE","ENTITY_ROUTE","EFF_DATE","EXP_DATE","CREATE_ORDER_ID","LAST_MOD_ORDER_ID","CREATE_PROLE_TYPE","CREATE_PROLE_ID","CREATE_DEPT_ID","CREATE_TIME","MODIFY_PROLE_TYPE","MODIFY_PROLE_ID","MODIFY_DEPT_ID","MODIFY_TIME","PARTITION_ID","EX_FIELD1","EX_FIELD2","EX_FIELD3","EX_FIELD4","EX_FIELD5","EX_FIELD6","EX_FIELD7","EX_FIELD8","EX_FIELD9","EX_FIELD10","BE_ID","PREVIOUS_DATA_VERSION","DATA_VERSION","TENANT_ID") values
  2   (4211000000000916,4211000000006247,1532350213422020129,'C_SMS','N','0',null,4211000000000620,'S',4211000000001170,'601','O2018082306.P1042','2020-07-13 04:18:35','2099-12-31 23:59:59',420100000000000537,420100000000000537,'E',66010001,4865183546,'2020-07-13 04:18:46',null,null,null,'2020-07-13 04:18:46',null,null,null,null,null,null,null,null,null,null,null,101,null,'2020-07-13 04:18:46',999999);

1 rows affected.

SQL> commit;

Succeed.

SQL> DROP TABLE IF EXISTS "MKM_T_DASHBOARD" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "MKM_T_DASHBOARD"
  2 (
  3   "OBJECTID" VARCHAR(40 BYTE) NOT NULL,
  4   "USERID" VARCHAR(40 BYTE) NOT NULL,
  5   "VISUALIZEID" VARCHAR(40 BYTE) NOT NULL,
  6   "DSPLAYNO" NUMBER(5) NOT NULL,
  7   "EXTENSIONINFO" VARCHAR(4000 BYTE),
  8   "TENANT_ID" NUMBER(20) NOT NULL
  9 );

Succeed.

SQL> INSERT INTO "MKM_T_DASHBOARD" ("OBJECTID","USERID","VISUALIZEID","DSPLAYNO","EXTENSIONINFO","TENANT_ID") values
  2   ('9100000001000','66000027','9100000002000',1,null,999999);

1 rows affected.

SQL> INSERT INTO "MKM_T_DASHBOARD" ("OBJECTID","USERID","VISUALIZEID","DSPLAYNO","EXTENSIONINFO","TENANT_ID") values
  2   ('9100000001001','66000027','9100000002001',2,null,999999);

1 rows affected.

SQL> INSERT INTO "MKM_T_DASHBOARD" ("OBJECTID","USERID","VISUALIZEID","DSPLAYNO","EXTENSIONINFO","TENANT_ID") values
  2   ('9100000000000','101','9100000000000',1,null,999999);

1 rows affected.

SQL> INSERT INTO "MKM_T_DASHBOARD" ("OBJECTID","USERID","VISUALIZEID","DSPLAYNO","EXTENSIONINFO","TENANT_ID") values
  2   ('9100000000001','101','9100000001000',2,null,999999);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "MKM_T_DASHBOARD" ADD CONSTRAINT "PK_MKM_T_MKM_T_DASHBOARD" PRIMARY KEY("OBJECTID");

Succeed.

SQL> SELECT
  2   CASE WHEN EXISTS (
  3       SELECT DISTINCT
  4           REF_1.USERID AS C0,
  5           SUBQ_0.C3 AS C1,
  6           SUBQ_0.C1 AS C2,
  7           NULL AS C3,
  8           SUBQ_0.C7 AS C4,
  9           SUBQ_0.C1 AS C5,
 10           REF_1.USERID AS C6,
 11           SUBQ_0.C7 AS C7
 12         FROM
 13           MKM_T_DASHBOARD  REF_1
 14         ORDER BY   SUBQ_0.C3 ASC NULLS FIRST, SUBQ_0.C7 DESC) THEN SUBQ_0.C3 ELSE SUBQ_0.C3 END
 15      AS C7,
 16     STDDEV(
 17       CAST(SUBQ_0.C6 AS NUMBER(20,0))) OVER (PARTITION BY SUBQ_0.C7 ORDER BY SUBQ_0.C1) AS C8
 18 FROM
 19   (SELECT
 20         REF_0.EX_FIELD9 AS C0,
 21         CAST(nullif(REF_0.EX_FIELD3,
 22           REF_0.PROP_CODE) AS VARCHAR(32)) AS C1,
 23         REF_0.COMPLEX_FLAG AS C2,
 24         REF_0.MODIFY_PROLE_TYPE AS C3,
 25         REF_0.BE_ID AS C4,
 26         REF_0.LAST_MOD_ORDER_ID AS C6,
 27         REF_0.DATA_VERSION AS C7
 28       FROM
 29         INF_PROD_PROP AS REF_0
 30       WHERE REF_0.CREATE_PROLE_TYPE LIKE '%')  SUBQ_0
 31 ;

C7   C8
---- ----------------------------------------
     0
     0
     0
     0
     0
     0

6 rows fetched.

SQL>
SQL> SELECT
  2     CORR(0,REF_0.BE_ID) OVER () AS C0,
  3    (SELECT
  4           1
  5         FROM
  6           MKM_T_DASHBOARD AS REF_1
  7         GROUP BY GROUPING SETS( CUBE('9590-11')), REF_0.BE_ID
  8             limit 1) as c1
  9 FROM
 10   INF_PROD_PROP AS REF_0;

C0                                       C1
---------------------------------------- ------------
                                         1
                                         1
                                         1
                                         1
                                         1
                                         1

6 rows fetched.

SQL> 
SQL> 
SQL> SELECT  DISTINCT 
  2     avg(-2.7) OVER (PARTITION BY ref_1.ADDRESS ORDER BY ref_1.ADDRESS) as c0
  3 from
  4     STUDENT as ref_1
  5 WHERE 
  6     EXISTS (SELECT DISTINCT ref_1.SEX as c0 from  SCORE as ref_2) or 
  7     EXISTS (SELECT DISTINCT ref_1.ADDRESS as c2 from SECTIONS as ref_3 LIMIT 82);

C0                                      
----------------------------------------
-2.7                                    

1 rows fetched.

SQL> 
SQL> DROP TABLE "INF_PROD_PROP" CASCADE CONSTRAINTS;

Succeed.

SQL> DROP TABLE "MKM_T_DASHBOARD" CASCADE CONSTRAINTS;

Succeed.

SQL> DROP TABLE "FVT_OBJ_DEFINE_TABLE_FRE1";

Succeed.

SQL> DROP TABLE "STUDENT";

Succeed.

SQL> DROP TABLE "SCORE";

Succeed.

SQL> DROP TABLE "DEPT_MANAGER";

Succeed.

SQL> DROP TABLE "DEPT_EMP";

Succeed.

SQL> DROP TABLE "SALARIES";

Succeed.

SQL> DROP TABLE "TEST";

Succeed.

SQL> DROP TABLE "MY_EMPLOYEES";

Succeed.

SQL> DROP TABLE "EMPLOYEES";

Succeed.

SQL> DROP TABLE "DEPARTMENTS";

Succeed.

SQL> --DTS202103220IO2P0P0K00
SQL> drop table if exists first_value_t001;

Succeed.

SQL> CREATE TABLE  first_value_t001(COL_1 BINARY_BIGINT, COL_19 BINARY(20), COL_20 VARBINARY(20), COL_23 RAW(20));

Succeed.

SQL> insert into first_value_t001 values( 1, 1001, 100001, '10000001' );

1 rows affected.

SQL> insert into first_value_t001 values( 2, 1002, 100002, '10000002' );

1 rows affected.

SQL> insert into first_value_t001 values( 3, 1003, 100003, '10000003' );

1 rows affected.

SQL> commit;

Succeed.

SQL> SELECT COL_1,COL_19,FIRST_VALUE(COL_19) OVER(partition by COL_1 ORDER BY COL_1) a FROM first_value_t001;

COL_1                COL_19                                                           A                                                               
-------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1                    1001                                                             1001                                                            
2                    1002                                                             1002                                                            
3                    1003                                                             1003                                                            

3 rows fetched.

SQL> SELECT COL_1,COL_20,FIRST_VALUE(COL_20) OVER(partition by COL_1 ORDER BY COL_1) a FROM first_value_t001;

COL_1                COL_20                                                           A                                                               
-------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1                    100001                                                           100001                                                          
2                    100002                                                           100002                                                          
3                    100003                                                           100003                                                          

3 rows fetched.

SQL> SELECT COL_1,COL_23,FIRST_VALUE(COL_23) OVER(partition by COL_1 ORDER BY COL_1) a FROM first_value_t001;

COL_1                COL_23                                                           A                                                               
-------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1                    10000001                                                         10000001                                                        
2                    10000002                                                         10000002                                                        
3                    10000003                                                         10000003                                                        

3 rows fetched.

SQL> drop table if exists first_value_t001;

Succeed.

SQL> drop table if exists t_subquery_order_001;

Succeed.

SQL> create table t_subquery_order_001(c_int int not null) ;

Succeed.

SQL> begin
  2     for i in 1..500 loop
  3         insert into t_subquery_order_001 values(i);
  4     end loop;
  5 end;
  6 /

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> select count(1) from ( select max(c_int) over() a1 from t_subquery_order_001  order by a1 desc limit 300);

COUNT(1)
--------------------
300

1 rows fetched.

SQL> drop table t_subquery_order_001;

Succeed.
