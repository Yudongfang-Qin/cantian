

SQL> --
SQL> -- Temporary table
SQL> --
SQL> 
SQL> create global temporary table ww_temp1(id int, description varchar(400)) ON COMMIT preserve ROWS; 

Succeed.

SQL> 
SQL> insert into ww_temp1 values(1, 'aaaaaaa'), (3, 'bbbb'), (5, 'xxxxxx');

3 rows affected.

SQL> 
SQL> create table ww_norm_t1(id int);

Succeed.

SQL> insert into ww_norm_t1 values(1),(2),(5);

3 rows affected.

SQL> 
SQL> select a.description from ww_temp1 a inner join ww_norm_t1 b on a.id=b.id;

DESCRIPTION                                                     
----------------------------------------------------------------
aaaaaaa                                                         
xxxxxx                                                          

2 rows fetched.

SQL> 
SQL> delete from ww_temp1 where rowid in ( select a.rowid from ww_temp1 a inner join ww_norm_t1 b on a.id=b.id); 

2 rows affected.

SQL> 
SQL> select * from ww_temp1;

ID           DESCRIPTION                                                     
------------ ----------------------------------------------------------------
3            bbbb                                                            

1 rows fetched.

SQL> 
SQL> create global temporary table tmp_t1(id int, name varchar(4000)) on commit preserve rows;

Succeed.

SQL> insert into tmp_t1 values (1,lpad('a',20,'a'));

1 rows affected.

SQL> insert into tmp_t1 values (2,lpad('b',20,'b'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('a',30,'a') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('b',30,'b') where id=2;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  
2            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                                  

2 rows fetched.

SQL> update tmp_t1 set name=lpad('a',40,'a') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('b',40,'a') where id=2;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                        
2            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab                        

2 rows fetched.

SQL> update tmp_t1 set name=lpad('a',50,'a') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('b',50,'b') where id=2;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa              
2            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb              

2 rows fetched.

SQL> update tmp_t1 set name=lpad('a',40,'a') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('b',40,'b') where id=2;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                        
2            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                        

2 rows fetched.

SQL> update tmp_t1 set name=lpad('a',30,'a') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('b',30,'b') where id=2;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  
2            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                                  

2 rows fetched.

SQL> truncate table tmp_t1;

Succeed.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> select id from tmp_t1 where id=1;	

ID          
------------

0 rows fetched.

SQL> insert into tmp_t1 values (1,lpad('a',20,'a'));

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaa                                            

1 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> insert into tmp_t1 values (1,lpad('a',20,'a'));

1 rows affected.

SQL> commit;

Succeed.

SQL> update tmp_t1 set name=lpad('a',30,'a') where id=1;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  

1 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaa                                            

1 rows fetched.

SQL> update tmp_t1 set name=lpad('a',30,'a') where id=1;

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  

1 rows fetched.

SQL> update tmp_t1 set name=lpad('a',20,'a') where id=1;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaa                                            

1 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  

1 rows fetched.

SQL> update tmp_t1 set name=lpad('b',30,'b') where id=1;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                                  

1 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  

1 rows fetched.

SQL> delete from tmp_t1;

1 rows affected.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> rollback;

Succeed.

SQL> select * from tmp_t1;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                                  

1 rows fetched.

SQL> truncate table tmp_t1;

Succeed.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> insert into tmp_t1 values (1, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (2, lpad('2',4000,'2'));

1 rows affected.

SQL> insert into tmp_t1 values (3, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (4, lpad('4',4000,'4'));

1 rows affected.

SQL> insert into tmp_t1 values (5, lpad('5',4000,'5'));

1 rows affected.

SQL> insert into tmp_t1 values (6, lpad('6',4000,'6'));

1 rows affected.

SQL> insert into tmp_t1 values (7, lpad('7',4000,'7'));

1 rows affected.

SQL> insert into tmp_t1 values (8, lpad('8',4000,'8'));

1 rows affected.

SQL> insert into tmp_t1 values (9, lpad('9',4000,'9'));

1 rows affected.

SQL> insert into tmp_t1 values (10, lpad('0',4000,'0'));

1 rows affected.

SQL> create unique index tmp_ti1 on tmp_t1(id);

Succeed.

SQL> create unique index tmp_ti2 on tmp_t1(id) online;

CT-00130, Operation create index online is not supported on temporary table
SQL> insert into tmp_t1 values (11, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (12, lpad('2',4000,'2'));

1 rows affected.

SQL> insert into tmp_t1 values (13, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (14, lpad('4',4000,'4'));

1 rows affected.

SQL> insert into tmp_t1 values (15, lpad('5',4000,'5'));

1 rows affected.

SQL> insert into tmp_t1 values (16, lpad('6',4000,'6'));

1 rows affected.

SQL> insert into tmp_t1 values (17, lpad('7',4000,'7'));

1 rows affected.

SQL> insert into tmp_t1 values (18, lpad('8',4000,'8'));

1 rows affected.

SQL> insert into tmp_t1 values (19, lpad('9',4000,'9'));

1 rows affected.

SQL> insert into tmp_t1 values (20, lpad('0',4000,'0'));

1 rows affected.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
20                  

1 rows fetched.

SQL> select id from tmp_t1 where id=2;

ID          
------------
2           

1 rows fetched.

SQL> insert into tmp_t1 values (21,'aa'),(22,'bb'),(23,'cc'),(24,'dd'),(25,'ee');

5 rows affected.

SQL> update tmp_t1 set name='bbbbbbbbbbbbbb' where id=22;

1 rows affected.

SQL> select * from tmp_t1 where id=21;

ID           NAME                                                            
------------ ----------------------------------------------------------------
21           aa                                                              

1 rows fetched.

SQL> select * from tmp_t1 where id=22;

ID           NAME                                                            
------------ ----------------------------------------------------------------
22           bbbbbbbbbbbbbb                                                  

1 rows fetched.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
25                  

1 rows fetched.

SQL> select id from tmp_t1 where id=16;

ID          
------------
16          

1 rows fetched.

SQL> select id from tmp_t1 where id=17;

ID          
------------
17          

1 rows fetched.

SQL> select id from tmp_t1 where id=18;

ID          
------------
18          

1 rows fetched.

SQL> select id from tmp_t1 where id=19;

ID          
------------
19          

1 rows fetched.

SQL> select id from tmp_t1 where id=20;

ID          
------------
20          

1 rows fetched.

SQL> select id from tmp_t1 where id=21;

ID          
------------
21          

1 rows fetched.

SQL> delete from tmp_t1 where id<=5;

5 rows affected.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
20                  

1 rows fetched.

SQL> select id from tmp_t1 order by id;

ID          
------------
6           
7           
8           
9           
10          
11          
12          
13          
14          
15          
16          
17          
18          
19          
20          
21          
22          
23          
24          
25          

20 rows fetched.

SQL> insert into tmp_t1 values (1, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (2, lpad('2',4000,'2'));

1 rows affected.

SQL> insert into tmp_t1 values (3, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (4, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (5, lpad('0',4000,'0'));

1 rows affected.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
25                  

1 rows fetched.

SQL> select id from tmp_t1 order by id;

ID          
------------
1           
2           
3           
4           
5           
6           
7           
8           
9           
10          
11          
12          
13          
14          
15          
16          
17          
18          
19          
20          
21          
22          
23          
24          
25          

25 rows fetched.

SQL> select id from tmp_t1 where id=4;

ID          
------------
4           

1 rows fetched.

SQL> delete from tmp_t1 where id>10 and id<=15;

5 rows affected.

SQL> select id from tmp_t1 order by id;

ID          
------------
1           
2           
3           
4           
5           
6           
7           
8           
9           
10          
16          
17          
18          
19          
20          
21          
22          
23          
24          
25          

20 rows fetched.

SQL> insert into tmp_t1 values (11, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (12, lpad('2',4000,'2'));

1 rows affected.

SQL> insert into tmp_t1 values (13, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (14, lpad('4',4000,'4'));

1 rows affected.

SQL> insert into tmp_t1 values (15, lpad('5',4000,'5'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=1;

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=3;

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=5;

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=7;

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=9;

1 rows affected.

SQL> delete from tmp_t1 where id>20;

5 rows affected.

SQL> insert into tmp_t1 values (21, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (22, lpad('2',4000,'2'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=21;

1 rows affected.

SQL> insert into tmp_t1 values (23, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (24, lpad('4',4000,'4'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=23;

1 rows affected.

SQL> insert into tmp_t1 values (25, lpad('5',4000,'5'));

1 rows affected.

SQL> insert into tmp_t1 values (26, lpad('6',4000,'6'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=25;

1 rows affected.

SQL> insert into tmp_t1 values (27, lpad('7',4000,'7'));

1 rows affected.

SQL> insert into tmp_t1 values (28, lpad('8',4000,'8'));

1 rows affected.

SQL> update tmp_t1 set name=lpad('0',2000,'0') where id=27;

1 rows affected.

SQL> insert into tmp_t1 values (29, lpad('9',4000,'9'));

1 rows affected.

SQL> insert into tmp_t1 values (30, lpad('0',4000,'0'));

1 rows affected.

SQL> insert into tmp_t1 values (31, lpad('1',4000,'1'));

1 rows affected.

SQL> insert into tmp_t1 values (32, lpad('2',4000,'2'));

1 rows affected.

SQL> insert into tmp_t1 values (33, lpad('3',4000,'3'));

1 rows affected.

SQL> insert into tmp_t1 values (34, lpad('4',4000,'4'));

1 rows affected.

SQL> insert into tmp_t1 values (35, lpad('5',4000,'5'));

1 rows affected.

SQL> select id from tmp_t1 order by id;

ID          
------------
1           
2           
3           
4           
5           
6           
7           
8           
9           
10          
11          
12          
13          
14          
15          
16          
17          
18          
19          
20          
21          
22          
23          
24          
25          
26          
27          
28          
29          
30          
31          
32          
33          
34          
35          

35 rows fetched.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
35                  

1 rows fetched.

SQL> select id from tmp_t1 where id=18;

ID          
------------
18          

1 rows fetched.

SQL> select id from tmp_t1 where id=1;

ID          
------------
1           

1 rows fetched.

SQL> select id from tmp_t1 where id=5;

ID          
------------
5           

1 rows fetched.

SQL> select id from tmp_t1 where id=12;

ID          
------------
12          

1 rows fetched.

SQL> update tmp_t1 set id=40 where id=35;

1 rows affected.

SQL> select id from tmp_t1 where id=40;

ID          
------------
40          

1 rows fetched.

SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
35                  

1 rows fetched.

SQL> insert into tmp_t1 values (1, lpad('1',4000,'1'));

CT-00729, Unique constraint violated, index TMP_TI1, duplicate key 1
SQL> insert into tmp_t1 values (2, lpad('2',4000,'2'));

CT-00729, Unique constraint violated, index TMP_TI1, duplicate key 2
SQL> explain select id from tmp_t1 where id=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TMP_T1  |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN         | SYS   | TMP_TI1 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 1                                           

10 rows fetched.

SQL> explain update tmp_t1 set name='aaaaa' where id=5;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TMP_T1  |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | TMP_TI1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 5                                           

10 rows fetched.

SQL> explain delete from tmp_t1 where id=3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TMP_T1  |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | TMP_TI1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = 3                                           

10 rows fetched.

SQL> alter index tmp_ti1 rebuild online;

CT-00130, Operation rebuild index online is not supported on temporary table
SQL> select count(*) from tmp_t1;

COUNT(*)            
--------------------
35                  

1 rows fetched.

SQL> drop table tmp_t1;

Succeed.

SQL> create global temporary table tmp_t2(id int, name varchar(32));

Succeed.

SQL> create index tmp_ti3 on tmp_t2(id);

Succeed.

SQL> create index tmp_ti4 on tmp_t2(name);

Succeed.

SQL> insert into tmp_t2 values (1, lpad('a',20,'a'));

1 rows affected.

SQL> insert into tmp_t2 values (2, lpad('b',20,'b'));

1 rows affected.

SQL> insert into tmp_t2 values (3, lpad('c',20,'c'));

1 rows affected.

SQL> insert into tmp_t2 values (4, lpad('d',20,'d'));

1 rows affected.

SQL> insert into tmp_t2 values (5, lpad('e',20,'e'));

1 rows affected.

SQL> insert into tmp_t2 values (6, lpad('f',20,'f'));

1 rows affected.

SQL> insert into tmp_t2 values (7, lpad('g',20,'g'));

1 rows affected.

SQL> insert into tmp_t2 values (8, lpad('h',20,'h'));

1 rows affected.

SQL> insert into tmp_t2 values (9, lpad('i',20,'i'));

1 rows affected.

SQL> insert into tmp_t2 values (10, lpad('j',20,'j'));

1 rows affected.

SQL> select * from tmp_t2 where id=9 and name='iiiiiiiiiiiiiiiiiiii';

ID           NAME                            
------------ --------------------------------
9            iiiiiiiiiiiiiiiiiiii            

1 rows fetched.

SQL> select * from tmp_t2 where id=10 and name='iiiiiiiiiiiiiiiiiiii';

ID           NAME                            
------------ --------------------------------

0 rows fetched.

SQL> explain select * from tmp_t2 where id=9 and name='aaaaaaaaaaaaaaaaaaaa';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TMP_T2  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TMP_TI3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NAME = 'aaaaaaaaaaaaaaaaaaaa'                    
   2 - access: ID = 9                                           

11 rows fetched.

SQL> select count(*) from tmp_t2;

COUNT(*)            
--------------------
10                  

1 rows fetched.

SQL> commit;

Succeed.

SQL> select count(*) from tmp_t2;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> drop index tmp_ti4 on tmp_t2;

Succeed.

SQL> drop table tmp_t2;

Succeed.

SQL> create global temporary table tmp_t3(id int, name varchar(32)) on commit preserve rows;

Succeed.

SQL> create index tmp_ti3 on tmp_t3(id);

Succeed.

SQL> create index tmp_ti4 on tmp_t3(name);

Succeed.

SQL> insert into tmp_t3 values (1, lpad('a',20,'a'));

1 rows affected.

SQL> insert into tmp_t3 values (2, lpad('b',20,'b'));

1 rows affected.

SQL> insert into tmp_t3 values (3, lpad('c',20,'c'));

1 rows affected.

SQL> insert into tmp_t3 values (4, lpad('d',20,'d'));

1 rows affected.

SQL> insert into tmp_t3 values (5, lpad('e',20,'e'));

1 rows affected.

SQL> insert into tmp_t3 values (6, lpad('f',20,'f'));

1 rows affected.

SQL> insert into tmp_t3 values (7, lpad('g',20,'g'));

1 rows affected.

SQL> insert into tmp_t3 values (8, lpad('h',20,'h'));

1 rows affected.

SQL> insert into tmp_t3 values (9, lpad('i',20,'i'));

1 rows affected.

SQL> insert into tmp_t3 values (10, lpad('j',20,'j'));

1 rows affected.

SQL> select * from tmp_t3 where id=9 and name='iiiiiiiiiiiiiiiiiiii';

ID           NAME                            
------------ --------------------------------
9            iiiiiiiiiiiiiiiiiiii            

1 rows fetched.

SQL> drop index tmp_ti4 on tmp_t2;

Succeed.

SQL> select * from tmp_t3 where id=1;

ID           NAME                            
------------ --------------------------------
1            aaaaaaaaaaaaaaaaaaaa            

1 rows fetched.

SQL> drop table tmp_t3;

Succeed.

SQL> create global temporary table tmp_t5(id int, name varchar(32));

Succeed.

SQL> create index tmp_ti5 on tmp_t5(id);

Succeed.

SQL> create index tmp_ti6 on tmp_t5(name);

Succeed.

SQL> insert into tmp_t5 values (1, lpad('a',20,'a'));

1 rows affected.

SQL> insert into tmp_t5 values (2, lpad('b',20,'b'));

1 rows affected.

SQL> insert into tmp_t5 values (3, lpad('c',20,'c'));

1 rows affected.

SQL> insert into tmp_t5 values (4, lpad('d',20,'d'));

1 rows affected.

SQL> insert into tmp_t5 values (5, lpad('e',20,'e'));

1 rows affected.

SQL> insert into tmp_t5 values (6, lpad('f',20,'f'));

1 rows affected.

SQL> insert into tmp_t5 values (7, lpad('g',20,'g'));

1 rows affected.

SQL> insert into tmp_t5 values (8, lpad('h',20,'h'));

1 rows affected.

SQL> insert into tmp_t5 values (9, lpad('i',20,'i'));

1 rows affected.

SQL> insert into tmp_t5 values (10, lpad('j',20,'j'));

1 rows affected.

SQL> update tmp_t5 set name='iiiiii' where id=9;

1 rows affected.

SQL> update tmp_t5 set name='jjjjj' where id=10;

1 rows affected.

SQL> delete from tmp_t5 where id=4;

1 rows affected.

SQL> delete from tmp_t5 where id=5;

1 rows affected.

SQL> delete from tmp_t5;

8 rows affected.

SQL> rollback;

Succeed.

SQL> 
SQL> create temporary tablespace tmp_sp1 tempfile 'temp1' size 64M;

CT-00130, Operation create temporary lead  is not supported on temporary tablespace
SQL> create global temporary table tmp_t1(id int) tablespace user1;

CT-00780, The tablespace USER1 does not exist.
SQL> 
SQL> -- DTS2018080308859 
SQL> drop table if exists storage_exp_global_tbl_000;

Succeed.

SQL> create table storage_exp_global_tbl_000(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(16) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data varchar(1000),c_text binary(1000),c_clob varchar(1000));

Succeed.

SQL> CREATE UNIQUE INDEX storage_exp_global_indx_000_1 ON storage_exp_global_tbl_000(c_id,c_d_id);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_000_2 ON storage_exp_global_tbl_000(c_id);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_000_3 ON storage_exp_global_tbl_000(c_city);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_000_4 ON storage_exp_global_tbl_000(c_first,c_state);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_000_5 ON storage_exp_global_tbl_000(c_id,c_d_id,c_middle);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_000_6 ON storage_exp_global_tbl_000(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> 
SQL> alter table storage_exp_global_tbl_000 add constraint storage_exp_global_constraint_000 primary key(c_id,c_w_id) using index(create index storage_exp_global_indx_000 on storage_exp_global_tbl_000(c_id,c_w_id) pctfree 30 initrans 10);

Succeed.

SQL> CREATE or replace procedure storage_exp_global_func_000(start_n int,endall int) IS
  2 i INT;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN start_n..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     insert into storage_exp_global_tbl_000 select i,i,i,'is'||j||'cmRDs'||j,'OE','BAR'||j||'Bar'||j,'bkili'||j||'fcrRGF'||j,'pmbwo'||j||'vhSDGj'||j,'dyf'||j||'rDa'||j,'uq',4801||j
  8 ,940||j||215||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate,lpad('QVLDETANRBRBUfSMNTECC3489354CufvCDSF',200,'sadfu87324'),lpad('DEfcf31436',200,'789dfafd'),lpad('QVLDC3489354CufvCDSF',200,'sadfu
  9 87324') from dual;
 10   END LOOP;
 11 END;
 12 /

Succeed.

SQL> 
SQL> call storage_exp_global_func_000(1,1000);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> drop table if exists storage_exp_global_tbl_001;

Succeed.

SQL> create global temporary table storage_exp_global_tbl_001 as select * from storage_exp_global_tbl_000;

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_001_3 ON storage_exp_global_tbl_001(c_city);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_001_4 ON storage_exp_global_tbl_001(c_first,c_state);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_001_5 ON storage_exp_global_tbl_001(c_id,c_d_id,c_middle);

Succeed.

SQL> CREATE INDEX storage_exp_global_indx_001_6 ON storage_exp_global_tbl_001(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> 
SQL> alter table storage_exp_global_tbl_001 add constraint storage_exp_global_constraint_001 primary key(c_id) using index(create index storage_exp_global_indx_001 on storage_exp_global_tbl_001(c_id) pctfree 30 initrans 10);

Succeed.

SQL> 
SQL> CREATE or replace procedure storage_exp_global_func_001(start_n int,endall int) IS
  2 i INT;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN start_n..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     insert into storage_exp_global_tbl_001 select i,i,i,'is'||j||'cmRDs'||j,'OE','BAR'||j||'Bar'||j,'bkili'||j||'fcrRGF'||j,'pmbwo'||j||'vhSDGj'||j,'dyf'||j||'rDa'||j,'uq',4801||j
  8 ,940||j||215||j,sysdate,'GC',50010.0,0.4361328,-10.0,10.0,1,true,sysdate,lpad('QVLDETANRBRBUfSMNTECC3489354CufvCDSF',200,'sadfu87324'),lpad('DEfcf31436',200,'789dfafd'),lpad('QVLDC3489354CufvCDSF',200,'sadfu
  9 87324') from dual;
 10   END LOOP;
 11 END;
 12 /

Succeed.

SQL> 
SQL> call storage_exp_global_func_001(1,10);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> insert into storage_exp_global_tbl_001 select * from storage_exp_global_tbl_000;

1000 rows affected.

SQL> update storage_exp_global_tbl_001 set c_id=c_id+1001,c_first=c_first||'a',c_data=lpad('QVLDC3489354CufvCDSF',300,'sadfu87324'),c_text=lpad('DEfcf31436',300,'789dfafd') where c_id>500 and c_id<=1001;

500 rows affected.

SQL> select sum(c_id) from storage_exp_global_tbl_001;

SUM(C_ID)           
--------------------
1001000             

1 rows fetched.

SQL> commit;

Succeed.

SQL> 
SQL> 
SQL> ----DTS2018082210679
SQL> DROP TABLE IF EXISTS storage_row_link_global_tbl_000;

Succeed.

SQL> create table storage_row_link_global_tbl_000(c_id int,c_d_id bigint NOT NULL,c_w_id tinyint unsigned NOT NULL,c_first varchar(16) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 varchar(8000),c_data2 varchar(8000),c_data3 varchar(8000),c_data4 varchar(8000),c_data5 varchar(8000),c_data6 varchar(8000),c_data7 varchar(6000),c_data8 varchar(4000),c_clob varchar(3000),c_text varchar(3000));

Succeed.

SQL> CREATE or replace procedure storage_row_link_global_proc_000(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     insert into storage_row_link_global_tbl_000 select i,i,i,'iscmRDs'||j,'OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,1,sysdate,lpad('QVBRfSCC3484942ZCSfjvCF',4000,'QVLDBURhlhfrc484ZCSfjF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',3000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',1000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',1000,'1435764ABC7890abcdef') from dual;
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> call storage_row_link_global_proc_000(1,1000);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> DROP TABLE IF EXISTS storage_row_link_global_tbl_001;

Succeed.

SQL> create global temporary table storage_row_link_global_tbl_001 as select * from storage_row_link_global_tbl_000;

Succeed.

SQL> CREATE UNIQUE INDEX storage_row_link_global_indx_001_1 ON storage_row_link_global_tbl_001(c_id,c_d_id);

Succeed.

SQL> CREATE INDEX storage_row_link_global_indx_001_2 ON storage_row_link_global_tbl_001(c_id);

Succeed.

SQL> CREATE INDEX storage_row_link_global_indx_001_3 ON storage_row_link_global_tbl_001(c_city);

Succeed.

SQL> CREATE INDEX storage_row_link_global_indx_001_4 ON storage_row_link_global_tbl_001(c_first,c_state);

Succeed.

SQL> CREATE INDEX storage_row_link_global_indx_001_5 ON storage_row_link_global_tbl_001(c_id,c_d_id,c_middle);

Succeed.

SQL> CREATE INDEX storage_row_link_global_indx_001_6 ON storage_row_link_global_tbl_001(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> --I2.Update变短，行链接—>普通
SQL> insert into storage_row_link_global_tbl_001 select * from storage_row_link_global_tbl_000;

CT-00727, insert row size 33228 exceeds the limitation 8000
SQL> --1000 rows affected.
SQL> update storage_row_link_global_tbl_001 set c_d_id=c_d_id+1,c_w_id=c_w_id+1,c_since=sysdate,c_first='aaaaaaa',c_data1='aaaaaaaaaaaa',c_data2='bbbbbbbbbb',c_data3='cccccccccc',c_data4='dddddddddd',c_data5='eeeeeeeeee',c_data6='ffffffffff',c_data7='gggggggggg',c_data8='aaaaaaaaaa',c_text='aaaaaaaaaa',c_clob='1111111111';

0 rows affected.

SQL> --1000 rows affected.
SQL> COMMIT;

Succeed.

SQL> 
SQL> --DTS2018081506766, migr row
SQL> drop table if exists global_strg_func_tbl_000;

Succeed.

SQL> create table global_strg_func_tbl_000(c_id int,
  2 c_d_id int NOT NULL,
  3 c_w_id int NOT NULL,
  4 c_first varchar(16) NOT NULL,
  5 c_middle char(2),
  6 c_last varchar(16) NOT NULL,
  7 c_street_1 varchar(20) NOT NULL,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) NOT NULL,
 10 c_state char(2) NOT NULL,
 11 c_zip char(9) NOT NULL,
 12 c_phone char(16) NOT NULL,
 13 c_since timestamp,
 14 c_credit char(2) NOT NULL,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real NOT NULL,
 19 c_payment_cnt number NOT NULL,
 20 c_delivery_cnt bool NOT NULL,
 21 c_end date NOT NULL,
 22 c_data varchar(1000),
 23 c_text raw(1000),
 24 c_clob varchar(1000),
 25 primary key (c_id,c_d_id,c_w_id));

Succeed.

SQL> insert into global_strg_func_tbl_000 values (1,1,1,'zdftvbktwqmv','OE','BARBARPRES','bmzqwgevtzuky','hwgqmnmedtfzpqdmhkcl','wwlywigjzzgrpo','ew','189611111','3547275456392941','2013-01-04 11:26:41','GC',50000.0,0.24249771,-10.0,10.0,1,false,'2013-01-04 10:26:41','qvldetanrbrburbmzqujshoqnggsmnteccipriirdhirwiynpfzcsykxxyscdsfqafhatdokmjogfgslucunvwbtbfsqzjeclbacpjqdhjchvgbnrkjrgjrycsgppsocnevautzfeosviaxbvobffnjuqhlvnwuqhtgjqsbfacwjpbvpgthpyxcpmnutcjxrbxxbmrmwwxcepwiixvvleyajautcesljhrsfsmsnmzjcxvcuxdwmyijbwywiirsgocwktedbbokhynznceaesuifkgoaafagugetfhbcylksrjukvbufqcvbffaxnzssyquidvwefktknrchyxfphunqktwnipnsrvqswsymocnoexbabwnpmnxsvshdsjhazcauvqjgvqjfkjjgqrceyjmbumkapmcbxeashybpgekjkfezthnjbhfqiwbutbxtkjkndyyhjchvgbnrkjrgjrycsgppsocnevautzfeosviaxbvobf','431543254325636536465390148338192473147389574574295482974528942574827543289574239574239574239857428564236829543295874283574382574238957842357234857482357432985749235845254235425432542354325423454235423542354325432543276576878798026537657368790','qvldetanrbrburbmzqujshoqnggsmnteccipriirdhirwiynpfzcsykxxyscdsfqafhatdokmjogfgslucunvwbtbfsqzjeclbacpjqdhjchvgbnrkjrgjrycsgppsocnevautzfeosviaxbvobffnjuqhlvnwuqhtgjqsbfacwjpbvpgthdaffdafdafdafdasfdbmrmwwxcepwiixvvleyajautcesljhrsfsmsnmzjcxvcuxdwmyijbwywiirsgocwktedbbokhynznceaesuifkgoaafagugetfhbcylksrjukvbufqcvbffaxnzssyquidvwefktknrchyxfphunqktwnipnsrvqswsymocnoexbabwnpmnxsvshdsjhazcauvqjgvqjfkjjgqrceyjmbumkapmcbxeashybpgekjkfezthnjbhfqiwbutbxtkjkndyyhjchvgbnrkjrgjrycsgppsocnevautzfsdfeosviax');

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=1;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=2;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=3;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=4;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=5;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=6;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=7;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=8;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+1,c_d_id+1,c_w_id+1,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000 where c_id=9;

1 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+10,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

10 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+20,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

20 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+40,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

40 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+80,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

80 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+160,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

160 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+320,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

320 rows affected.

SQL> insert into global_strg_func_tbl_000 select c_id+640,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_text,c_clob from global_strg_func_tbl_000;

640 rows affected.

SQL> delete from global_strg_func_tbl_000 where c_id>1000;

280 rows affected.

SQL> 
SQL> drop table if exists global_strg_func_tbl_117;

Succeed.

SQL> create global temporary table global_strg_func_tbl_117(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(16) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data clob,c_text blob,c_clob clob) on commit preserve rows;

Succeed.

SQL> 
SQL> create or replace procedure GLOBAL_ACID_FUNC_117_1(name varchar) is
  2 str varchar(4000);
  3 tablename varchar(200) :=name;
  4 begin
  5 str := 'update' ||' '||tablename||' '||'set c_first=c_first||''aa'',c_data=lpad(''sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm'',500,''yxcfgdsgtcsdsjxrbxxbm''),c_text=lpad(''12432454325654632455425644354325'',450,''7687389015''),c_clob=lpad(''sbfacwjpbvpgthpyxcpmnutcjdfaxrbxxbm'',500,''yxcpmnutcjxrbxxbm'') where mod(c_id,4)=1';
  6 EXECUTE IMMEDIATE str;
  7 end;
  8 /

Succeed.

SQL> 
SQL> create or replace procedure GLOBAL_ACID_FUNC_117_2(name varchar) is
  2 str varchar(4000);
  3 tablename varchar(200) :=name;
  4 begin
  5 str := 'update' ||' '||tablename||' '||'set c_first=c_first||''aa'',c_data=lpad(''sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm'',500,''yxcfgdsgtcsdsjxrbxxbm''),c_text=lpad(''12432454325654632455425644354325'',450,''7687389015''),c_clob=lpad(''sbfacwjpbvpgthpyxcpmnutcjdfaxrbxxbm'',500,''yxcpmnutcjxrbxxbm'')';
  6 EXECUTE IMMEDIATE str;
  7 end;
  8 /

Succeed.

SQL> CREATE UNIQUE INDEX global_acid_func_indx_117_1 ON global_strg_func_tbl_117(c_id,c_d_id);

Succeed.

SQL> CREATE INDEX global_acid_func_indx_117_2 ON global_strg_func_tbl_117(c_id);

Succeed.

SQL> CREATE INDEX global_acid_func_indx_117_3 ON global_strg_func_tbl_117(c_city);

Succeed.

SQL> CREATE INDEX global_acid_func_indx_117_4 ON global_strg_func_tbl_117(c_first,c_state);

Succeed.

SQL> CREATE INDEX global_acid_func_indx_117_5 ON global_strg_func_tbl_117(c_id,c_d_id,c_middle);

Succeed.

SQL> CREATE INDEX global_acid_func_indx_117_6 ON global_strg_func_tbl_117(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> insert into global_strg_func_tbl_117 select * from global_strg_func_tbl_000;

1000 rows affected.

SQL> 
SQL> delete from global_strg_func_tbl_117 where mod(c_id,2)=0;

500 rows affected.

SQL> commit;--begin transaction;

Succeed.

SQL> call GLOBAL_ACID_FUNC_117_1('global_strg_func_tbl_117');

PL/SQL procedure successfully completed.

SQL> select distinct c_first,count(*) from global_strg_func_tbl_117 group by c_first order by 1,2;

C_FIRST          COUNT(*)            
---------------- --------------------
zdftvbktwqmv     250                 
zdftvbktwqmvaa   250                 

2 rows fetched.

SQL> savepoint aa;

Succeed.

SQL> call GLOBAL_ACID_FUNC_117_2('global_strg_func_tbl_117');

PL/SQL procedure successfully completed.

SQL> select distinct c_first,count(*) from global_strg_func_tbl_117 group by c_first order by 1,2;

C_FIRST          COUNT(*)            
---------------- --------------------
zdftvbktwqmvaa   250                 
zdftvbktwqmvaaaa 250                 

2 rows fetched.

SQL> rollback;

Succeed.

SQL> select distinct c_first,count(*) from global_strg_func_tbl_117 group by c_first order by 1,2;

C_FIRST          COUNT(*)            
---------------- --------------------
zdftvbktwqmv     500                 

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS temp_add_col;

Succeed.

SQL> CREATE GLOBAL TEMPORARY TABLE temp_add_col (col1 INTEGER NOT NULL, col2 VARCHAR(32)) ON COMMIT PRESERVE ROWS;

Succeed.

SQL> INSERT INTO temp_add_col VALUES (1, 'aaa');

1 rows affected.

SQL> ALTER TABLE temp_add_col ADD col3 BINARY(20) DEFAULT 'abcd';

Succeed.

SQL> SELECT col1, col2, IFNULL(col3, 'NULL') FROM temp_add_col;

COL1         COL2                             IFNULL(COL3, 'NULL')                                            
------------ -------------------------------- ----------------------------------------------------------------
1            aaa                              abcd                                                            

1 rows fetched.

SQL> DROP TABLE temp_add_col;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS temp_spc_table;

Succeed.

SQL> CREATE TABLE temp_spc_table (col1 INTEGER NOT NULL, col2 VARCHAR(32)) tablespace temp;

CT-00853, Attempt to create permanent object in a temporary tablespace
SQL> 
SQL> 
SQL> drop table if exists t1;

Succeed.

SQL> create table t1(i int);

Succeed.

SQL> drop table if exists temp_001;

Succeed.

SQL> create global temporary table temp_001(i int) on commit preserve rows;

Succeed.

SQL> create index tmp_ti1 on temp_001(i);

Succeed.

SQL> insert into temp_001 values(1);

1 rows affected.

SQL> insert into temp_001 values(1);

1 rows affected.

SQL> insert into t1 values (1);

1 rows affected.

SQL> insert into t1 values (1);

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from temp_001;

I           
------------
1           
1           

2 rows fetched.

SQL> 
SQL> update temp_001 set i=10;

2 rows affected.

SQL> update t1 set i=10;

2 rows affected.

SQL> select * from temp_001;

I           
------------
10          
10          

2 rows fetched.

SQL> select * from t1;

I           
------------
10          
10          

2 rows fetched.

SQL> prepare transaction '1.ab.cd';

CT-00832, Xa transaction can't change temp table
SQL> rollback;

Succeed.

SQL> update t1 set i=10;

2 rows affected.

SQL> select * from temp_001;

I           
------------
1           
1           

2 rows fetched.

SQL> select * from t1;

I           
------------
10          
10          

2 rows fetched.

SQL> prepare transaction '1.ab.cd';

Succeed.

SQL> rollback prepared '1.ab.cd';

Succeed.

SQL> select * from temp_001;

I           
------------
1           
1           

2 rows fetched.

SQL> select * from t1;

I           
------------
1           
1           

2 rows fetched.

SQL> 
SQL> delete from temp_001;

2 rows affected.

SQL> delete from t1;

2 rows affected.

SQL> select * from temp_001;

I           
------------

0 rows fetched.

SQL> select * from t1;

I           
------------

0 rows fetched.

SQL> prepare transaction '1.ab.cd';

CT-00832, Xa transaction can't change temp table
SQL> rollback;

Succeed.

SQL> delete from t1;

2 rows affected.

SQL> select * from temp_001;

I           
------------
1           
1           

2 rows fetched.

SQL> select * from t1;

I           
------------

0 rows fetched.

SQL> prepare transaction '1.ab.cd';

Succeed.

SQL> rollback prepared '1.ab.cd';

Succeed.

SQL> select * from temp_001;

I           
------------
1           
1           

2 rows fetched.

SQL> select * from t1;

I           
------------
1           
1           

2 rows fetched.

SQL> 
SQL> CREATE GLOBAL TEMPORARY TABLE temp_btree (id int, str varchar(96));

Succeed.

SQL> CREATE INDEX idx1 ON temp_btree(id);

Succeed.

SQL> 
SQL> insert into temp_btree values (0, 'this is a very very long string.this is a very very long string.this is a very very long string.');

1 rows affected.

SQL> insert into temp_btree (id, str) select id + 1, str from temp_btree;

1 rows affected.

SQL> insert into temp_btree (id, str) select id + 2, str from temp_btree;

2 rows affected.

SQL> insert into temp_btree (id, str) select id + 4, str from temp_btree;

4 rows affected.

SQL> insert into temp_btree (id, str) select id + 8, str from temp_btree;

8 rows affected.

SQL> insert into temp_btree (id, str) select id + 16, str from temp_btree;

16 rows affected.

SQL> insert into temp_btree (id, str) select id + 32, str from temp_btree;

32 rows affected.

SQL> insert into temp_btree (id, str) select id + 64, str from temp_btree;

64 rows affected.

SQL> insert into temp_btree (id, str) select id + 128, str from temp_btree;

128 rows affected.

SQL> insert into temp_btree (id, str) select id + 256, str from temp_btree;

256 rows affected.

SQL> insert into temp_btree (id, str) select id + 512, str from temp_btree;

512 rows affected.

SQL> insert into temp_btree (id, str) select id + 1024, str from temp_btree;

1024 rows affected.

SQL> insert into temp_btree (id, str) select id + 2048, str from temp_btree;

2048 rows affected.

SQL> insert into temp_btree (id, str) select id + 4096, str from temp_btree;

4096 rows affected.

SQL> insert into temp_btree (id, str) select id + 8192, str from temp_btree;

8192 rows affected.

SQL> drop TEMPORARY table temp_btree;

Succeed.

SQL> --DTS2018110103159:btree split and rescan
SQL> drop table if exists tt0;

Succeed.

SQL> create table tt0(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000),primary key(c_id,c_d_id,c_w_id));

Succeed.

SQL> 
SQL> insert into tt0 select 1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4800||'1',940||'1'||205||'1','1800-01-01 10:51:47','GC',50000.0,0.4361328,-10.0,10.0,1,true,'1800-01-01 10:51:47',1,1,lpad('1234ABCDRFGHopqrstuvwxyz8',1500,'ABfgCDefgh'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbxxbm',200,'yxcfgdsgtcjxrbxxbm'),lpad('124324543256546324554354325',200,'7687389015'),lpad('sbfacwjpbvpgthpyxcpmnutcjdfaxrbxxbm',200,'yxcpmnutcjxrbxxbm'),lpad('123dSHGGefasdy',200,'678ASVDFopqrst9234'),lpad('12345abcdegf',200,'adbede1fghij1kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp2345abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123895ab456cdef');

1 rows affected.

SQL> commit;

Succeed.

SQL> CREATE or replace procedure temp_table_func1(startall int,endall int) as
  2 i INT;
  3 BEGIN
  4  if startall > endall then
  5   return;
  6  else
  7   FOR i IN startall..endall LOOP
  8         insert into tt0 select c_id+i,c_d_id+i,c_w_id+i,'AA'||'is'||i||'cmvls',c_middle,'AA'||'BAR'||i||'ddBARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,'940'||i||'205'||i,c_since+i,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end+i,c_unsig+i,c_big+100000*i,c_vchar,c_data,c_text,c_clob,c_image,lpad('12345abcdegf',200,'adbede1fghij'||i||'kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp23'||i||'45abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123'||i||'895ab456cdef') from tt0 where c_id=1;commit;
  9   END LOOP;
 10   return;
 11  end if;
 12 END;
 13 /

Succeed.

SQL> exec temp_table_func1(1,1999);

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000)) partition by hash(c_w_id,c_last) (partition part_1,partition part_2,partition part_3,partition part_4,partition part_5,partition part_6,partition part_7,partition part_8);

Succeed.

SQL> 
SQL> drop table if exists tmp_t;

Succeed.

SQL> create global temporary table tmp_t(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000)) on commit preserve rows;

Succeed.

SQL> 
SQL> create unique index ltt_index1 ON tmp_t(c_id,c_d_id);

Succeed.

SQL> create index ltt_index2 ON tmp_t(c_id);

Succeed.

SQL> create unique index ltt_index3 ON tmp_t(c_big);

Succeed.

SQL> create index ltt_index4 ON tmp_t(c_first,c_binary);

Succeed.

SQL> create index ltt_index5 ON tmp_t(c_id,c_d_id,c_varbinary);

Succeed.

SQL> create index ltt_index6 ON tmp_t(c_id,c_d_id,c_street_1,c_raw);

Succeed.

SQL> 
SQL> insert into tt1 select * from tt0 where mod(c_id,2)=1;

1000 rows affected.

SQL> select count(*) from tt1;

COUNT(*)            
--------------------
1000                

1 rows fetched.

SQL> insert into tmp_t select * from tt0;

2000 rows affected.

SQL> select count(*) from tmp_t;

COUNT(*)            
--------------------
2000                

1 rows fetched.

SQL> 
SQL> commit;

Succeed.

SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
1000                

1 rows fetched.

SQL> 
SQL> insert into tt1 select a.c_id+1000000,a.c_d_id,a.c_w_id,a.c_first,a.c_middle,a.c_last,a.c_street_1,a.c_street_2,a.c_city,a.c_state,a.c_zip,a.c_phone,a.c_since,a.c_credit,a.c_credit_lim,a.c_discount,a.c_balance,a.c_ytd_payment,a.c_payment_cnt,a.c_delivery_cnt,a.c_end,a.c_unsig,a.c_big+10000000000,a.c_vchar,a.c_data,a.c_text,a.c_clob,a.c_image,a.c_binary,a.c_varbinary,a.c_raw from tt1 a,tmp_t b where a.c_binary=b.c_binary and mod(a.c_id,3)=1 and mod(b.c_d_id,5)=1;

67 rows affected.

SQL> 
SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
1000                

1 rows fetched.

SQL> select distinct a.c_first,sum(a.c_id) from tt1 a,tmp_t b where a.c_d_id=b.c_d_id and a.c_first='aaaaaaaaaaaa' group by a.c_first order by 1,2;

C_FIRST                          SUM(A.C_ID)         
-------------------------------- --------------------

0 rows fetched.

SQL> select distinct c_first,sum(c_id) from tt1 where c_id in (select a.c_id from tt1 a,tmp_t b where a.c_street_1=b.c_street_1 and b.c_first like 'AAis80%') and c_first like 'AAis80%' group by c_first,c_id order by 1,2;

C_FIRST                          SUM(C_ID)           
-------------------------------- --------------------
AAis800cmvls                     801                 
AAis802cmvls                     803                 
AAis804cmvls                     805                 
AAis806cmvls                     807                 
AAis808cmvls                     809                 
AAis80cmvls                      81                  

6 rows fetched.

SQL> select distinct a.c_first,sum(a.c_id) from tt1 a,tmp_t b where a.c_d_id=b.c_d_id and a.c_first='aaaaaaaaaaaa' and a.c_d_id in (select c_d_id from tt1) group by a.c_first order by 1,2;

C_FIRST                          SUM(A.C_ID)         
-------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> 
SQL> update tt1 set c_id=c_id+10000000,c_first='aaaaaaaaaaaa',c_data=lpad('datalong',300,'aystrdatadataopest'),c_text=lpad('11111111111',300,'abcdef2345adb'),c_vchar=lpad('vcharchar',300,'abcdefytsops'),c_image=lpad('image',300,'rstabde1234sopstADCE'),c_binary=lpad('binary',300,'abcdrstyesdd'),c_varbinary=rpad('varbinary',300,'rstuvwopqbn'),c_raw=rpad('abcdef123',300,'11111111122222222') where c_first in(select a.c_first from tt1 a,tmp_t b where a.c_first=b.c_first and a.c_d_id=b.c_d_id and a.c_first like 'AAis1%' and b.c_last like 'AABAR1%');

593 rows affected.

SQL> 
SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
444                 

1 rows fetched.

SQL> select distinct a.c_first,sum(a.c_id) from tt1 a,tmp_t b where a.c_d_id=b.c_d_id and a.c_first='aaaaaaaaaaaa' group by a.c_first order by 1,2;

C_FIRST                          SUM(A.C_ID)         
-------------------------------- --------------------
aaaaaaaaaaaa                     5967807563          

1 rows fetched.

SQL> select distinct c_first,sum(c_id) from tt1 where c_id in (select a.c_id from tt1 a,tmp_t b where a.c_street_1=b.c_street_1 and b.c_first like 'AAis80%') and c_first like 'AAis80%' group by c_first,c_id order by 1,2;

C_FIRST                          SUM(C_ID)           
-------------------------------- --------------------
AAis800cmvls                     801                 
AAis802cmvls                     803                 
AAis804cmvls                     805                 
AAis806cmvls                     807                 
AAis808cmvls                     809                 
AAis80cmvls                      81                  

6 rows fetched.

SQL> 
SQL> delete from tt1 where mod(c_id,3)=1 and c_first in (select a.c_first from tt1 a,tmp_t b where a.c_id=b.c_id and mod(a.c_id,3)=mod(b.c_id,2));

147 rows affected.

SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
297                 

1 rows fetched.

SQL> select distinct a.c_first,sum(a.c_id) from tt1 a,tmp_t b where a.c_d_id=b.c_d_id and a.c_first='aaaaaaaaaaaa' group by a.c_first order by 1,2;

C_FIRST                          SUM(A.C_ID)         
-------------------------------- --------------------
aaaaaaaaaaaa                     5967807563          

1 rows fetched.

SQL> select distinct c_first,sum(c_id) from tt1 where c_id in (select a.c_id from tt1 a,tmp_t b where a.c_street_1=b.c_street_1 and b.c_first like 'AAis80%') and c_first like 'AAis80%' group by c_first,c_id order by 1,2;

C_FIRST                          SUM(C_ID)           
-------------------------------- --------------------
AAis800cmvls                     801                 
AAis802cmvls                     803                 
AAis806cmvls                     807                 
AAis808cmvls                     809                 
AAis80cmvls                      81                  

5 rows fetched.

SQL> 
SQL> commit;

Succeed.

SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
297                 

1 rows fetched.

SQL> insert into tmp_t select b.c_id+1000000,b.c_d_id,b.c_w_id,b.c_first,b.c_middle,b.c_last,b.c_street_1,b.c_street_2,b.c_city,b.c_state,b.c_zip,b.c_phone,b.c_since,b.c_credit,b.c_credit_lim,b.c_discount,b.c_balance,b.c_ytd_payment,b.c_payment_cnt,b.c_delivery_cnt,b.c_end,b.c_unsig,b.c_big+10000000000,b.c_vchar,b.c_data,b.c_text,b.c_clob,b.c_image,b.c_binary,b.c_varbinary,b.c_raw from tt1 a,tmp_t b where a.c_binary=b.c_binary and mod(a.c_id,5)=1 and mod(b.c_d_id,7)=1;

13 rows affected.

SQL> 
SQL> select count(*) from tt1 a,tmp_t b where a.c_id=b.c_id;

COUNT(*)            
--------------------
301                 

1 rows fetched.

SQL> select distinct a.c_first,sum(a.c_id) from tt1 a,tmp_t b where a.c_d_id=b.c_d_id and a.c_first='aaaaaaaaaaaa' group by a.c_first order by 1,2;

C_FIRST                          SUM(A.C_ID)         
-------------------------------- --------------------
aaaaaaaaaaaa                     5967807563          

1 rows fetched.

SQL> select distinct c_first,sum(c_id) from tmp_t where c_id in (select b.c_id from tt1 a,tmp_t b where a.c_street_1=b.c_street_1 and a.c_first like 'AAis80%') and c_first like 'AAis80%' group by c_first,c_id order by 1,2;

C_FIRST                          SUM(C_ID)           
-------------------------------- --------------------
AAis800cmvls                     801                 
AAis801cmvls                     802                 
AAis802cmvls                     803                 
AAis803cmvls                     804                 
AAis804cmvls                     805                 
AAis805cmvls                     806                 
AAis806cmvls                     807                 
AAis807cmvls                     808                 
AAis808cmvls                     809                 
AAis809cmvls                     810                 
AAis80cmvls                      81                  

11 rows fetched.

SQL> 
SQL> update tmp_t set c_id=c_id+1000000,c_d_id=c_d_id+1000000,c_first='aaaaaaaaaaaa',c_data=lpad('datalong',300,'aystrdatadataopest'),c_text=lpad('11111111111',300,'abcdef2345adb'),c_vchar=lpad('vcharchar',300,'abcdefytsops'),c_image=lpad('image',300,'rstabde1234sopstADCE'),c_binary=lpad('binary',300,'abcdrstyesdd'),c_varbinary=rpad('varbinary',300,'rstuvwopqbn'),c_raw=rpad('abcdef123',300,'11111111122222222') where c_first in(select b.c_first from tt1 a,tmp_t b where a.c_first=b.c_first and a.c_d_id=b.c_d_id and a.c_first like 'AAis9%') and c_last like 'AABAR9%';

43 rows affected.

SQL> 
SQL> drop table if exists constraint_index_glo_tbl_005;

Succeed.

SQL> create global temporary table constraint_index_glo_tbl_005(c_id int, c_d_id int NOT NULL, c_w_id int, c_first varchar(32), c_middle char(2), c_last varchar(32) NOT NULL) on commit preserve rows;

Succeed.

SQL> create index glo_tbl_005_index_001 on constraint_index_glo_tbl_005(c_d_id);

Succeed.

SQL> alter table constraint_index_glo_tbl_005 add constraint glo_tbl_005_constraint_002 unique(c_d_id);

CT-00130, Operation would cause rebuiding index, which is not supported on temporary table
SQL> create unique index glo_tbl_005_index_002 on constraint_index_glo_tbl_005(c_id);

Succeed.

SQL> insert into constraint_index_glo_tbl_005 values (1, 2, 3, 'aa', 'bb', 'ccc');

1 rows affected.

SQL> CREATE or replace procedure func005(startall int,endall int) as
  2 i INT;
  3 BEGIN
  4  if startall > endall then
  5   return;
  6  else
  7   FOR i IN startall..endall LOOP
  8 		insert into constraint_index_glo_tbl_005 select c_id + i * 2,  c_d_id, c_w_id, c_first, c_middle, c_last  from constraint_index_glo_tbl_005 where c_id = 1; commit;
  9   END LOOP;
 10   return;
 11  end if;
 12 END;
 13 /

Succeed.

SQL> exec func005(1,200);

PL/SQL procedure successfully completed.

SQL> insert into constraint_index_glo_tbl_005 select  c_id + 100000,  c_d_id, c_w_id, c_first, c_middle, c_last from constraint_index_glo_tbl_005 where c_id = 1;

1 rows affected.

SQL> insert into constraint_index_glo_tbl_005 select  c_id + 100003,  c_d_id, c_w_id, c_first, c_middle, c_last from constraint_index_glo_tbl_005 where c_id < 999;

201 rows affected.

SQL> drop table constraint_index_glo_tbl_005;

Succeed.

SQL> 
SQL> ---	DTS2018120417435
SQL> alter system set TEMP_BUFFER_SIZE=5;

CT-00601, [1:35]Sql syntax error: size value is smaller than minimum(33554432) required
SQL> 
SQL> create user temhz identified by Cantian_234;

Succeed.

SQL> GRANT CREATE SESSION TO temhz;

Succeed.

SQL> grant dba to temhz;

Succeed.

SQL> grant create table to temhz;

Succeed.

SQL> 
SQL> 
SQL> alter tablespace USERS autopurge off;purge recyclebin;

Succeed.


Succeed.

SQL> drop table if exists temhz.STORAGE_LOB_INLINE_TBL_000;

Succeed.

SQL> CREATE TABLE temhz.STORAGE_LOB_INLINE_TBL_000(C_ID INT,
  2 C_D_ID int NOT NULL,
  3 C_W_ID int NOT NULL,
  4 C_FIRST1 VARCHAR(100) NOT NULL,
  5 C_FIRST2 VARCHAR(100) NOT NULL,
  6 C_FIRST3 VARCHAR(100) NOT NULL,
  7 C_FIRST4 VARCHAR(100) NOT NULL,
  8 C_FIRST5 VARCHAR(100) NOT NULL,
  9 C_FIRST6 VARCHAR(100) NOT NULL,
 10 C_FIRST7 VARCHAR(100) NOT NULL,
 11 C_FIRST8 VARCHAR(100) NOT NULL,
 12 C_DATA LONG,
 13 C_TEXT BLOB,
 14 C_CLOB CLOB);

Succeed.

SQL> insert into  temhz.STORAGE_LOB_INLINE_TBL_000 values(0,0,0,'AA','BB','CC','DD','EE','FF','GG','HH','LONG','111','CLOB');

1 rows affected.

SQL> commit;

Succeed.

SQL> CREATE or replace procedure temhz_lob_inline_func_001(startall int,endall int)  as
  2 i INT;
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5         insert into temhz.STORAGE_LOB_INLINE_TBL_000 select c_id+i,c_d_id+i,c_w_id+i,'AA'||i,'BB'||i,'CC'||i,'DD'||i,'EE'||i,'FF'||i,'GG'||i,'HH'||i,c_data,c_text,c_clob from temhz.STORAGE_LOB_INLINE_TBL_000 where c_id=0;commit;
  6   END LOOP;
  7 END;
  8 /

Succeed.

SQL> call temhz_lob_inline_func_001(1,1000);

PL/SQL procedure successfully completed.

SQL> 
SQL> alter tablespace USERS autopurge off;

Succeed.

SQL> drop table if exists temhz.STORAGE_LOB_INLINE_GOT_004;

Succeed.

SQL> CREATE GLOBAL TEMPORARY TABLE temhz.STORAGE_LOB_INLINE_GOT_004(C_ID INT,C_D_ID int NOT NULL,C_W_ID int NOT NULL,C_FIRST1 VARCHAR(8000) NOT NULL,C_FIRST2 VARCHAR(8000) NOT NULL,C_FIRST3 VARCHAR(8000) NOT NULL,C_FIRST4 VARCHAR(8000) NOT NULL,C_FIRST5 VARCHAR(8000) NOT NULL,C_FIRST6 VARCHAR(8000) NOT NULL,C_FIRST7 VARCHAR(8000) NOT NULL,C_FIRST8 VARCHAR(8000) NOT NULL,C_DATA LONG,C_TEXT BLOB,C_CLOB CLOB) on commit preserve rows;

Succeed.

SQL> 
SQL> insert into temhz.STORAGE_LOB_INLINE_GOT_004 select C_ID,C_D_ID,C_W_ID,C_FIRST1,C_FIRST2,C_FIRST3,C_FIRST4,C_FIRST5,C_FIRST6,C_FIRST7,C_FIRST8,C_DATA,C_TEXT,C_CLOB from temhz.STORAGE_LOB_INLINE_TBL_000 where mod(c_id,3)=0;

334 rows affected.

SQL> 
SQL> insert into temhz.STORAGE_LOB_INLINE_GOT_004 select C_ID,C_D_ID,C_W_ID,lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',7000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbfgxxbm',8000,'yxcfgdsgtcsdsjxrbxxbm'),C_DATA,C_TEXT,C_CLOB from temhz.STORAGE_LOB_INLINE_TBL_000 where mod(c_id,3)=1;

CT-00727, insert row size 63076 exceeds the limitation 8000
SQL> 
SQL> insert into temhz.STORAGE_LOB_INLINE_GOT_004 select C_ID,C_D_ID,C_W_ID,C_FIRST1,C_FIRST2,C_FIRST3,C_FIRST4,C_FIRST5,C_FIRST6,C_FIRST7,C_FIRST8,lpad('c_datajhfpyxcpmnutcjxrbfgxxbm',4000,'yxcfgdsgtcsdsjxrbxxbm'),lpad('123456656565767',4000,'565656576768787'),C_CLOB from temhz.STORAGE_LOB_INLINE_TBL_000 where mod(c_id,3)=2;

333 rows affected.

SQL> 
SQL> 
SQL> commit;

Succeed.

SQL> 
SQL> drop user temhz cascade;

Succeed.

SQL> 
SQL> 
SQL> --temp table with store procedure
SQL> set serveroutput on;

ON
SQL> drop table if exists tmp_t10;

Succeed.

SQL> create global temporary table tmp_t10(id int);

Succeed.

SQL> declare
  2 	cursor c1 is select id from tmp_t10;
  3 	b int;
  4 begin
  5 	insert into tmp_t10(id) values(1);
  6 	insert into tmp_t10(id) values(2);
  7 	open c1;
  8 	fetch c1 into b;
  9 	begin
 10 		dbe_output.print_line(b);
 11 		execute immediate 'truncate table tmp_t10';
 12 	    insert into tmp_t10(id) values(5);
 13 	end;
 14 	fetch c1 into b;
 15 	dbe_output.print_line(b);
 16 	close c1;
 17 end;
 18 /

1
CT-00932, [14:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[14:2] CT-00905, The cursor was invalid.

SQL> 
SQL> declare
  2 	cursor c1 is select id from tmp_t10;
  3 	b int;
  4 begin
  5 	insert into tmp_t10(id) values(1);
  6 	insert into tmp_t10(id) values(2);
  7 	open c1;
  8 	fetch c1 into b;
  9 	begin
 10 		dbe_output.print_line(b);
 11 	    insert into tmp_t10(id) values(5);
 12 	end;
 13 	fetch c1 into b;
 14 	dbe_output.print_line(b);
 15 	close c1;
 16 end;
 17 /

1
2

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 	cursor c1 is select id from tmp_t10;
  3 	b int;
  4 begin
  5 	insert into tmp_t10(id) values(1);
  6 	insert into tmp_t10(id) values(2);
  7 	open c1;
  8 	fetch c1 into b;
  9 	begin
 10 		dbe_output.print_line(b);
 11         delete from tmp_t10;
 12 	end;
 13 	fetch c1 into b;
 14 	dbe_output.print_line(b);
 15 	close c1;
 16 end;
 17 /

1
CT-00932, [13:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[13:2] CT-00905, The cursor was invalid.

SQL> 
SQL> drop table if exists tmp_t10;

Succeed.

SQL> create global temporary table tmp_t10(id int) on commit preserve rows;

Succeed.

SQL> declare
  2 	cursor c1 is select id from tmp_t10;
  3 	b int;
  4 begin
  5 	insert into tmp_t10(id) values(1);
  6 	insert into tmp_t10(id) values(2);
  7 	open c1;
  8 	fetch c1 into b;
  9 	begin
 10 		dbe_output.print_line(b);
 11 		execute immediate 'truncate table tmp_t10';
 12 	    insert into tmp_t10(id) values(5);
 13 	end;
 14 	fetch c1 into b;
 15 	dbe_output.print_line(b);
 16 	close c1;
 17 end;
 18 /

1
CT-00932, [14:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[14:2] CT-00905, The cursor was invalid.

SQL> 
SQL> drop table if exists tmp_t10;

Succeed.

SQL> create global temporary table tmp_t10(id int) on commit preserve rows;

Succeed.

SQL> declare
  2 	cursor c1 is select id from tmp_t10;
  3 	b int;
  4 begin
  5 	insert into tmp_t10(id) values(1);
  6 	insert into tmp_t10(id) values(2);
  7 	open c1;
  8 	fetch c1 into b;
  9 	begin
 10 		dbe_output.print_line(b);
 11 		execute immediate 'drop table tmp_t10';
 12 		execute immediate 'create global temporary table tmp_t10(id int)';
 13 	    insert into tmp_t10(id) values(1);
 14 	end;
 15 	fetch c1 into b;
 16 	dbe_output.print_line(b);
 17 	close c1;
 18 end;
 19 /

1
CT-00932, [15:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[15:2] CT-00905, The cursor was invalid.

SQL> 
SQL> drop table if exists tmp_t10;

Succeed.

SQL> create global temporary table tmp_t10(id int, name varchar(64));

Succeed.

SQL> insert into tmp_t10(id) values(1);

1 rows affected.

SQL> insert into tmp_t10(id) values(2);

1 rows affected.

SQL> savepoint aa;

Succeed.

SQL> delete from tmp_t10;

2 rows affected.

SQL> select * from tmp_t10;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> insert into tmp_t10(id) values(3);

1 rows affected.

SQL> rollback to savepoint aa;

Succeed.

SQL> select * from tmp_t10;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> drop table if exists tmp_t10;

Succeed.

SQL> create global temporary table tmp_t10(id int, name varchar(64));

Succeed.

SQL> create index ti_1 on tmp_t10(name);

Succeed.

SQL> create unique index ti_2 on tmp_t10(id);

Succeed.

SQL> insert into tmp_t10 values (1,'aa');

1 rows affected.

SQL> savepoint aa;

Succeed.

SQL> insert into tmp_t10 values (2,'bb');

1 rows affected.

SQL> insert into tmp_t10 values (2,'bb');

CT-00729, Unique constraint violated, index TI_2, duplicate key 2
SQL> select /* +full(tmp_t10*/ * from tmp_t10;

ID           NAME                                                            
------------ ----------------------------------------------------------------
1            aa                                                              
2            bb                                                              

2 rows fetched.

SQL> delete from tmp_t10;

2 rows affected.

SQL> select /* +full(tmp_t10*/ * from tmp_t10;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> insert into tmp_t10 values (1,'aa');

1 rows affected.

SQL> insert into tmp_t10 values (2,'bb');

1 rows affected.

SQL> rollback to savepoint aa;

Succeed.

SQL> select /* +full(tmp_t10*/ * from tmp_t10;

ID           NAME                                                            
------------ ----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> drop table if exists oracle_insert_dul_dml_tbl_005;

Succeed.

SQL> create global temporary table oracle_insert_dul_dml_tbl_005(c_id int,
  2 c_d_id bigint ,
  3 c_w_id tinyint unsigned ,
  4 c_first varchar(16) ,
  5 c_middle char(2),
  6 c_last varchar(16) ,
  7 c_street_1 varchar(20) ,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) ,
 10 c_state char(2) ,
 11 c_zip char(9) ,
 12 c_phone char(16) ,
 13 c_since timestamp,
 14 c_credit char(2) ,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real ,
 19 c_payment_cnt number ,
 20 c_delivery_cnt bool ,
 21 c_end date ,
 22 c_data1 varchar(8000),
 23 c_data2 varchar(8000),
 24 c_data3 varchar(8000),
 25 c_data4 varchar(8000),
 26 c_data5 varchar(8000),
 27 c_data6 varchar(8000),
 28 c_data7 varchar(8000),
 29 c_data8 varchar(8000),
 30 c_clob clob,
 31 c_blob blob,
 32 add_varchar2_289 varchar2(100) default 'a');

Succeed.

SQL> CREATE INDEX oracle_insert_dul_dml_tbl_005_indx_1 ON oracle_insert_dul_dml_tbl_005(to_char(c_first),upper(c_since));

Succeed.

SQL> CREATE INDEX oracle_insert_dul_dml_tbl_005_indx_3 ON oracle_insert_dul_dml_tbl_005(to_char(c_since));

Succeed.

SQL> CREATE INDEX oracle_insert_dul_dml_tbl_005_indx_4 ON oracle_insert_dul_dml_tbl_005(upper(c_first),c_state);

Succeed.

SQL> CREATE INDEX oracle_insert_dul_dml_tbl_005_indx_5 ON oracle_insert_dul_dml_tbl_005(c_id,c_d_id,c_since);

Succeed.

SQL> CREATE INDEX oracle_insert_dul_dml_tbl_005_indx_6 ON oracle_insert_dul_dml_tbl_005(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> --#lob<4k,row size>64k --#lob<4k,row size<64k  --#lob<4k row_size<8k
SQL> CREATE or replace procedure oracle_insert_dul_dml_tbl_005_proc(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     --if mod(i,3)=0 then
  8     --insert into oracle_insert_dul_dml_tbl_005(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) select i,i,i,'is'||j||'cmRDs','OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate+i,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate+i,lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',8000,'bbb'),lpad('aaa',8000,'bbb'),lpad('aaa',8000,'bbb'),lpad('aaa',8000,'bbb'),lpad('aaa',8000,'bbb'),lpad('aaa',3000,'bbb'),lpad('111',3000,'222') from dual;
  9    --elsif mod(i,3)=1 then
 10    --insert into oracle_insert_dul_dml_tbl_005(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) select i,i,i,'is'||j||'cmRDs','OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate+i,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate+i,lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',5000,'bbb'),lpad('aaa',3000,'bbb'),lpad('111',3000,'222') from dual;
 11   --else
 12    insert into oracle_insert_dul_dml_tbl_005(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) select i,i,i,'is'||j||'cmRDs','OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate+i,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate+i,lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('aaa',5,'bbb'),lpad('111',5,'222') from dual;
 13   --end if;
 14   END LOOP;
 15 END;
 16 /

Succeed.

SQL> call oracle_insert_dul_dml_tbl_005_proc(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> alter table oracle_insert_dul_dml_tbl_005 add constraint oracle_insert_dul_dml_tbl_003_con_1 primary key(c_id,c_first,c_end);

Succeed.

SQL> insert into oracle_insert_dul_dml_tbl_005(c_id,c_first,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) values(1,'is1cmRDs',to_date('2018-01-01 12:00:00','yyyy-mm-dd hh24:mi:ss'),lpad('data1',5,'data1'),lpad('data2',5,'data2'),lpad('data3',5,'data3'),lpad('data4',5,'data4'),lpad('data5',5,'data5'),lpad('data6',5,'data6'),lpad('data7',5,'data7'),lpad('data8',5,'data8'),lpad('clob',5,'clob'),lpad('b12345',5,'b12345')) on duplicate key update c_id=c_id+1000,c_first=c_first||c_id,c_end=c_end-1000,c_data1=lpad('data1',10,'data1'),c_data2=lpad('data2',10,'data2'),c_data3=lpad('data3',10,'data3'),c_data4=lpad('data4',10,'data4'),c_data5=lpad('data5',10,'data5'),c_data6=lpad('data6',10,'data6'),c_data7=lpad('data7',10,'data7'),c_data8=lpad('data8',10,'data8'),c_clob=lpad('clob',4000,'clob'),c_blob=lpad('111',10,'b');

1 rows affected.

SQL> insert into oracle_insert_dul_dml_tbl_005(c_id,c_first,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) values(1,'is1cmRDs',to_date('2018-01-01 12:00:00','yyyy-mm-dd hh24:mi:ss'),lpad('data1',5,'data1'),lpad('data2',5,'data2'),lpad('data3',5,'data3'),lpad('data4',5,'data4'),lpad('data5',5,'data5'),lpad('data6',5,'data6'),lpad('data7',5,'data7'),lpad('data8',5,'data8'),lpad('clob',5,'clob'),lpad('b12345',5,'b12345')) on duplicate key update c_id=c_id+1000,c_first=c_first||c_id,c_end=c_end-1000,c_data1=lpad('data1',10,'data1'),c_data2=lpad('data2',10,'data2'),c_data3=lpad('data3',10,'data3'),c_data4=lpad('data4',10,'data4'),c_data5=lpad('data5',10,'data5'),c_data6=lpad('data6',10,'data6'),c_data7=lpad('data7',10,'data7'),c_data8=lpad('data8',10,'data8'),c_clob=lpad('clob',4000,'clob'),c_blob=lpad('111',10,'b');

2 rows affected.

SQL> update oracle_insert_dul_dml_tbl_005 set c_id=c_id+1000,c_first=c_first||c_id,c_end=c_end-1000,c_data1=lpad('data1',10,'data1'),c_data2=lpad('data2',10,'data2'),c_data3=lpad('data3',10,'data3'),c_data4=lpad('data4',10,'data4'),c_data5=lpad('data5',10,'data5'),c_data6=lpad('data6',10,'data6'),c_data7=lpad('data7',10,'data7'),c_data8=lpad('data8',10,'data8'),c_clob=lpad('clob',10,'clob'),c_blob=lpad('111',10,'b');

1 rows affected.

SQL> 
SQL> --test temp table batch update of primary key 
SQL> drop table if exists test_temp_pk;

Succeed.

SQL> create global temporary table test_temp_pk(id int primary key, val varchar(10)) on commit preserve rows;

Succeed.

SQL> insert into test_temp_pk values(1, 'a'), (2, 'b'), (6, 'c'), (10, 'd'), (50, 'e');

5 rows affected.

SQL> commit;

Succeed.

SQL> update test_temp_pk set id = id+1 where id<3;

2 rows affected.

SQL> update test_temp_pk set id = id+1 where id<10;

3 rows affected.

SQL> select * from test_temp_pk order by id;

ID           VAL       
------------ ----------
3            a         
4            b         
7            c         
10           d         
50           e         

5 rows fetched.

SQL> update test_temp_pk set id = id - 1 where id > 3;

CT-00729, Unique constraint violated
SQL> update test_temp_pk set id = id - 1;

5 rows affected.

SQL> update test_temp_pk set id = id - 1;

5 rows affected.

SQL> select * from test_temp_pk order by id;

ID           VAL       
------------ ----------
1            a         
2            b         
5            c         
8            d         
48           e         

5 rows fetched.

SQL> rollback;

Succeed.

SQL> drop table test_temp_pk;

Succeed.

SQL> 
SQL> drop table if exists test_temp_pk;

Succeed.

SQL> create global temporary table test_temp_pk(id int, val varchar(10));

Succeed.

SQL> create unique index idx_test_pk on test_temp_pk(id) crmode row;

Succeed.

SQL> insert into test_temp_pk values(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e');

5 rows affected.

SQL> update test_temp_pk set id = id+1 where id<3;

CT-00729, Unique constraint violated
SQL> update test_temp_pk set id = id+1 where id<10;

5 rows affected.

SQL> select * from test_temp_pk order by id;

ID           VAL       
------------ ----------
2            a         
3            b         
4            c         
5            d         
6            e         

5 rows fetched.

SQL> update test_temp_pk set id = id - 1 where id > 3;

CT-00729, Unique constraint violated
SQL> update test_temp_pk set id = id - 1;

5 rows affected.

SQL> update test_temp_pk set id = id - 1;

5 rows affected.

SQL> select * from test_temp_pk order by id;

ID           VAL       
------------ ----------
0            a         
1            b         
2            c         
3            d         
4            e         

5 rows fetched.

SQL> rollback;

Succeed.

SQL> drop table test_temp_pk;

Succeed.

SQL> 
SQL> alter system set local_temporary_table_enabled=true;

Succeed.

SQL> create temporary table if not exists #tmp (id int primary key);

Succeed.

SQL> insert into #tmp values (1), (2), (3), (4);

4 rows affected.

SQL> update #tmp set id = id+1 where id<3;

CT-00729, Unique constraint violated
SQL> update #tmp set id = id+1 where id<10;

4 rows affected.

SQL> select * from #tmp order by id;

ID          
------------
2           
3           
4           
5           

4 rows fetched.

SQL> update #tmp set id = id - 1 where id > 3;

CT-00729, Unique constraint violated
SQL> update #tmp set id = id - 1;

4 rows affected.

SQL> update #tmp set id = id - 1;

4 rows affected.

SQL> select * from #tmp order by id;

ID          
------------
0           
1           
2           
3           

4 rows fetched.

SQL> drop table #tmp;

Succeed.

SQL> alter system set local_temporary_table_enabled=false;

Succeed.

SQL> 
SQL> drop table if exists t1;

Succeed.

SQL> create global temporary table t1(id int auto_increment primary key, name varchar(32)) on commit preserve rows;

Succeed.

SQL> select * from t1;

ID           NAME                            
------------ --------------------------------

0 rows fetched.

SQL> insert into t1(name) values ('aa');

1 rows affected.

SQL> insert into t1(name) values ('bb');

1 rows affected.

SQL> insert into t1(name) values ('cc');

1 rows affected.

SQL> select * from t1;

ID           NAME                            
------------ --------------------------------
1            aa                              
2            bb                              
3            cc                              

3 rows fetched.

SQL> truncate table t1;

Succeed.

SQL> insert into t1(name) values ('aa');

1 rows affected.

SQL> insert into t1(name) values ('bb');

1 rows affected.

SQL> insert into t1(name) values ('cc');

1 rows affected.

SQL> select * from t1;

ID           NAME                            
------------ --------------------------------
1            aa                              
2            bb                              
3            cc                              

3 rows fetched.

SQL> drop table if exists t2;

Succeed.

SQL> create global temporary table t2(id int auto_increment primary key, name varchar(32));

Succeed.

SQL> insert into t2(name) values ('aa');

1 rows affected.

SQL> insert into t2(name) values ('bb');

1 rows affected.

SQL> select * from t2;

ID           NAME                            
------------ --------------------------------
1            aa                              
2            bb                              

2 rows fetched.

SQL> truncate table t2;

Succeed.

SQL> insert into t2(name) values ('aa');

1 rows affected.

SQL> insert into t2(name) values ('bb');

1 rows affected.

SQL> select * from t2;

ID           NAME                            
------------ --------------------------------
1            aa                              
2            bb                              

2 rows fetched.

SQL> drop table if exists t3;

Succeed.

SQL> create global temporary table t3(id int primary key, name varchar(32)) on commit preserve rows;

Succeed.

SQL> insert into t3 values (1,'aa');

1 rows affected.

SQL> insert into t3 values (2,'bb');

1 rows affected.

SQL> ALTER TABLE T3 MODIFY ID AUTO_INCREMENT;

Succeed.

SQL> delete from t3;

2 rows affected.

SQL> ALTER TABLE T3 MODIFY ID BIGINT;

CT-00130, Operation would cause rebuiding index, which is not supported on non-empty temporary table
SQL> truncate table t3;

Succeed.

SQL> insert into t3(name) values ('aa');

1 rows affected.

SQL> insert into t3(name) values ('bb');

1 rows affected.

SQL> insert into t3(name) values ('cc');

1 rows affected.

SQL> select * from t3;

ID           NAME                            
------------ --------------------------------
1            aa                              
2            bb                              
3            cc                              

3 rows fetched.

SQL> drop table t1;

Succeed.

SQL> drop table t2;

Succeed.

SQL> drop table t3;

Succeed.

SQL> drop table if exists META_ENUM1;

Succeed.

SQL> CREATE global TEMPORARY TABLE META_ENUM1
  2 (
  3  ID1 int AUTO_INCREMENT,
  4  ID2 int NOT NULL,
  5  PRIMARY KEY (ID1)
  6 )AUTO_INCREMENT=100;

Succeed.

SQL> insert into META_ENUM1(id2) values(1);

1 rows affected.

SQL> insert into META_ENUM1(id2) values(1);

1 rows affected.

SQL> select * from meta_enum1;

ID1          ID2         
------------ ------------
100          1           
101          1           

2 rows fetched.

SQL> truncate table meta_enum1;

Succeed.

SQL> insert into META_ENUM1(id2) values(1);

1 rows affected.

SQL> insert into META_ENUM1(id2) values(1);

1 rows affected.

SQL> select * from meta_enum1;

ID1          ID2         
------------ ------------
100          1           
101          1           

2 rows fetched.

SQL> DROP TABLE IF EXISTS META_ENUM;

Succeed.

SQL> CREATE global TEMPORARY TABLE IF NOT EXISTS META_ENUM
  2 (
  3  ID int NOT NULL AUTO_INCREMENT,
  4  NAME VARCHAR(60) NOT NULL,
  5  PRIMARY KEY (ID,NAME)
  6 )AUTO_INCREMENT=1000;

Succeed.

SQL> 
SQL> insert into META_ENUM(ID,NAME) values(10,1);

1 rows affected.

SQL> insert into META_ENUM(NAME) values(2);

1 rows affected.

SQL> insert into META_ENUM(NAME) values(3);

1 rows affected.

SQL> insert into META_ENUM(ID,NAME) values(4,4);

1 rows affected.

SQL> insert into META_ENUM(NAME) values(5);

1 rows affected.

SQL> select * from META_ENUM order by name;

ID           NAME                                                        
------------ ------------------------------------------------------------
10           1                                                           
1000         2                                                           
1001         3                                                           
4            4                                                           
1002         5                                                           

5 rows fetched.

SQL> drop table META_ENUM1;

Succeed.

SQL> drop table META_ENUM;

Succeed.

SQL> drop table if exists tmp_t11;

Succeed.

SQL> create global temporary table tmp_t11(id int, name varchar(32)) on commit preserve rows;

Succeed.

SQL> insert into tmp_t11 values (1,'aaaaaaaa');

1 rows affected.

SQL> insert into tmp_t11 values (2,'bbbbbbbb');

1 rows affected.

SQL> insert into tmp_t11 values (3,'ccccccccc');

1 rows affected.

SQL> insert into tmp_t11 values (4,'ddddddd');

1 rows affected.

SQL> insert into tmp_t11 values (5,'eeeeeeeee');

1 rows affected.

SQL> select * from tmp_t11 where rowid in (select rowid from tmp_t11 limit 2);

ID           NAME                            
------------ --------------------------------
1            aaaaaaaa                        
2            bbbbbbbb                        

2 rows fetched.

SQL> select * from tmp_t11 where rowid='000099999900000000';

CT-00639, The row ID was invalid
SQL> --select * from tmp_t11 where rowid='000000000199999999';
SQL> drop table tmp_t11;

Succeed.

SQL> 
SQL> drop table if exists  PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010;

Succeed.

SQL> create GLOBAL TEMPORARY table PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000),primary key(c_id,c_d_id,c_w_id)) ON COMMIT DELETE rows;

Succeed.

SQL> 
SQL> CREATE or replace procedure PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_PRO_010(startall int,endall int) as
  2 i INT;
  3 m int;
  4 f_start timestamp;
  5 f_end timestamp;
  6 f_interval INTERVAL DAY(7) TO SECOND(6);
  7 BEGIN
  8     delete from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010;
  9 
 10     FOR a in 1..120 LOOP
 11         insert into PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010 select 1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4800||'1',940||'1'||205||'1','1800-01-01 10:51:47','GC',50000.0,0.4361328,-10.0,10.0,1,true,'1800-01-01 10:51:47',1,1,lpad('1234ABCDRFGHopqrstuvwxyz8',1500,'ABfgCDefgh'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbxxbm',200,'yxcfgdsgtcjxrbxxbm'),lpad('124324543256546324554354325',200,'7687389015'),lpad('sbfacwjpbvpgthpyxcpmnutcjdfaxrbxxbm',200,'yxcpmnutcjxrbxxbm'),lpad('123dSHGGefasdy',200,'678ASVDFopqrst9234'),lpad('12345abcdegf',200,'adbede1fghij1kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp2345abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123895ab456cdef');
 12 
 13        select count(*) into m from (select distinct c_id from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010);
 14 
 15      dbe_output.print_line(m);
 16 
 17         select sysdate into f_start from dual;
 18 
 19         FOR i IN startall..endall LOOP
 20             insert into PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010 select c_id+i,c_d_id+i,c_w_id+i,'AA'||'is'||i||'cmvls',c_middle,'AA'||'BAR'||i||'ddBARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,'940'||i||'205'||i,c_since+i,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end+i,c_unsig+i,c_big+100000*i,c_vchar,c_data,c_text,c_clob,c_image,lpad('12345abcdegf',200,'adbede1fghij'||i||'kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp23'||i||'45abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123'||i||'895ab456cdef') from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010 where c_id=1;
 21         END LOOP;
 22      update PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010 set c_first='qwertyuityuiopasdfghjkl',c_street_1='qwertyuityu',c_last='qwertyuityuiopasdfghjklwertyuityuiopasdfg' where rowid>10;
 23 
 24        select count(*) into m from (select c_id from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010);
 25      dbe_output.print_line(m);
 26 
 27      update PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010 set c_first='qwert',c_street_1='qwerty',c_last='qwertyuityuio' where rowid>10000;
 28 
 29      delete from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010;
 30 
 31   select sysdate into f_end from dual;
 32 
 33  -- dbe_output.print_line(f_end - f_start);
 34   END LOOP;
 35 END;
 36 /

Succeed.

SQL> SET serveroutput ON;

ON
SQL> 
SQL> select count(*) c_id from PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010;

C_ID                
--------------------
0                   

1 rows fetched.

SQL> 
SQL> call PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_PRO_010(1,1);

1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2
1
2

PL/SQL procedure successfully completed.

SQL> 
SQL> call PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_PRO_010(1,10);

1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11
1
11

PL/SQL procedure successfully completed.

SQL> 
SQL> call PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_PRO_010(1,100);

1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101
1
101

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table PROC_FOR_LOOP_JOIN_1_DML_TRUNCATE_TAB_010;

Succeed.

SQL> 
SQL> drop table if exists delete_left_join_temptb_001;

Succeed.

SQL> drop table if exists delete_left_join_temptb_006;

Succeed.

SQL> create table delete_left_join_temptb_001(i int not null,j int,k varchar(15));

Succeed.

SQL> create GLOBAL TEMPORARY table delete_left_join_temptb_006(i int,j int,k varchar(15));

Succeed.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abcdefg lmn');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(1,1,'abcdefg lmn');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(10,16,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(11,17,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_001 values(12,18,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abc');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,2,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abc hijk');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(1,1,'abcdefg hijk');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(8,14,'abcdefg');

1 rows affected.

SQL> insert into delete_left_join_temptb_006 values(9,15,'abc23');

1 rows affected.

SQL> delete a from delete_left_join_temptb_001 a left join delete_left_join_temptb_006 b on (a.i=b.i or a.j=b.j ) and a.k=b.k;

10 rows affected.

SQL> drop table if exists delete_left_join_temptb_001;

Succeed.

SQL> drop table if exists delete_left_join_temptb_006;

Succeed.

SQL> 
SQL> drop table if exists rm_temp_table;

Succeed.

SQL> create global temporary table rm_temp_table (id int);

Succeed.

SQL> 
SQL> drop sequence if exists rm_temp_seq;

Succeed.

SQL> create sequence rm_temp_seq start with 1 maxvalue 20 increment by 1 cycle cache 5;

Succeed.

SQL> 
SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> insert into rm_temp_table values(rm_temp_seq.nextval);

1 rows affected.

SQL> 
SQL> select * from rm_temp_table;

ID          
------------
1           
2           
3           
4           
5           
6           
7           
8           
9           
10          

10 rows fetched.

SQL> commit;

Succeed.

SQL> select * from rm_temp_table;

ID          
------------

0 rows fetched.

SQL> 
SQL> drop table if exists rm_temp_table;

Succeed.

SQL> drop sequence if exists rm_temp_seq;

Succeed.

SQL> 
SQL> drop table if  exists test_auto_increment;

Succeed.

SQL> create global temporary table test_auto_increment(a int primary key auto_increment);

Succeed.

SQL> alter table test_auto_increment auto_increment=2;

Succeed.

SQL> drop table if  exists test_auto_increment;

Succeed.

SQL> 
SQL> drop table if exists test_desc_order;

Succeed.

SQL> drop index if exists idx on test_desc_order;

Succeed.

SQL> create global temporary table test_desc_order(a char(3000));

Succeed.

SQL> create index idx on test_desc_order(a);

Succeed.

SQL> 
SQL> declare
  2     i int := 0;
  3 begin
  4     for i in 1..50 loop
  5         insert into test_desc_order values (i);
  6     end loop;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select * from test_desc_order where a = 50 order by a desc;

A                                                               
----------------------------------------------------------------
50                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      

1 rows fetched.

SQL> drop index if exists idx on test_desc_order;

Succeed.

SQL> drop table if exists test_desc_order;

Succeed.

SQL> 
SQL> drop table if exists test_create_as_tt1;

Succeed.

SQL> drop table if exists test_create_as_tt2;

Succeed.

SQL> create table test_create_as_tt1(a int);

Succeed.

SQL> insert into test_create_as_tt1 values (10);

1 rows affected.

SQL> create table test_create_as_tt2(a int);

Succeed.

SQL> insert into test_create_as_tt2 values (20);

1 rows affected.

SQL> create table test_create_as_tt2 as select * from test_create_as_tt1;

CT-01301, SYS.TEST_CREATE_AS_TT2 already exists
SQL> create table if not exists test_create_as_tt2 as select * from test_create_as_tt1;

Succeed.

SQL> select * from test_create_as_tt2;

A           
------------
20          

1 rows fetched.

SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED=true;

Succeed.

SQL> drop table if exists #test_create_as_tt1;

Succeed.

SQL> drop table if exists #test_create_as_tt2;

Succeed.

SQL> create temporary table #test_create_as_tt1(a int);

Succeed.

SQL> insert into #test_create_as_tt1 values (10);

1 rows affected.

SQL> create temporary table #test_create_as_tt2(a int);

Succeed.

SQL> insert into #test_create_as_tt2 values (20);

1 rows affected.

SQL> create temporary table #test_create_as_tt2 as select * from test_create_as_tt1;

CT-00753, The object SYS #TEST_CREATE_AS_TT2 already exists.
SQL> create temporary table if not exists #test_create_as_tt2 as select * from #test_create_as_tt1;

Succeed.

SQL> select * from #test_create_as_tt2;

A           
------------
20          

1 rows fetched.

SQL> 
SQL> connect sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists liu_temp_1 cascade;

Succeed.

SQL> drop user if exists liu_temp_2 cascade;

Succeed.

SQL> create user liu_temp_1 identified by Lh00420062;

Succeed.

SQL> create user liu_temp_2 identified by Lh00420062;

Succeed.

SQL> grant dba to liu_temp_1;

Succeed.

SQL> grant dba to liu_temp_2;

Succeed.

SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED=true;

Succeed.

SQL> create temporary table liu_temp_1.#tmp(a int, b varchar(100));

Succeed.

SQL> insert into liu_temp_1.#tmp values(10001,'var101sql');

1 rows affected.

SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED=false;

Succeed.

SQL> connect liu_temp_2/Lh00420062@127.0.0.1:1611

connected.

SQL> insert into liu_temp_1.#tmp values(10001,'var101sql');

CT-00843, [1:13]The table or view LIU_TEMP_1.#TMP does not exist.
SQL> connect sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists liu_temp_1 cascade;

Succeed.

SQL> drop user if exists liu_temp_2 cascade;drop table if exists test_desc_order;

Succeed.


Succeed.

SQL> 
SQL> drop table if exists temp_num;

Succeed.

SQL> create GLOBAL TEMPORARY table temp_num(id decimal primary key);

Succeed.

SQL> insert into temp_num values(1000805);

1 rows affected.

SQL> select id from temp_num where id=1000805;

ID                                      
----------------------------------------
1000805                                 

1 rows fetched.

SQL> drop table temp_num;

Succeed.

SQL> 

SQL> alter database datafile 1 autoextend on maxsize 1G;

Succeed.

SQL> select DISK_EXTENTS from dv_temp_pools;

DISK_EXTENTS
------------
 0          

1 rows fetched.

SQL> 
SQL> 
SQL> create tablespace nologging_spc datafile ' nologging_extent_dynamic' size 128M nologging;

Succeed.

SQL> CREATE TABLESPACE spc_encrypt DATAFILE 'spc_encrypt_1' size 128M nologging encryption;

Succeed.

SQL> drop table if exists temp_table;

Succeed.

SQL> create global temporary table temp_table (i int) tablespace temp2;

CT-00130, Operation create temporary table is not supported on non-swap tablespace
SQL> create global temporary table temp_table (i int) tablespace nologging_spc;

CT-00130, Operation create temporary table is not supported on non-swap tablespace
SQL> create global temporary table temp_table (i int) tablespace spc_encrypt;

CT-00130, Operation create temporary table is not supported on non-swap tablespace
SQL> create global temporary table temp_table (i int) tablespace temp;

Succeed.

SQL> create index idx_tmp on temp_table(i) tablespace temp;

Succeed.

SQL> drop index idx_tmp on temp_table;

Succeed.

SQL> create index idx_tmp on temp_table(i) tablespace nologging_spc;

CT-00130, Operation create temporary object is not supported on non-swap object
SQL> create index idx_tmp on temp_table(i) tablespace spc_encrypt;

CT-00130, Operation create temporary object is not supported on non-swap object
SQL> create index idx_tmp on temp_table(i) tablespace temp2;

CT-00130, Operation create temporary object is not supported on non-swap object
SQL> create index idx_tmp on temp_table(i) tablespace temp;

Succeed.

SQL> alter index idx_tmp on temp_table rebuild tablespace temp2;

CT-00130, Operation modify index properties is not supported on index rebuild in different type space
SQL> alter index idx_tmp on temp_table rebuild tablespace nologging_spc;

CT-00130, Operation modify index properties is not supported on index rebuild in different type space
SQL> alter index idx_tmp on temp_table rebuild tablespace temp;

Succeed.

SQL> alter index idx_tmp on temp_table rebuild tablespace spc_encrypt;

CT-00130, Operation modify index properties is not supported on index rebuild in different type space
SQL> drop table temp_table;

Succeed.

SQL> drop tablespace nologging_spc;

Succeed.

SQL> drop tablespace spc_encrypt;
Succeed.




