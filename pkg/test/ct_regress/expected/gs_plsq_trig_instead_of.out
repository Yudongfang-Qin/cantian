

SQL> set serveroutput on;

ON
SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists gs_plsql_insteadof cascade;

Succeed.

SQL> create user gs_plsql_insteadof identified by Lh00420062;

Succeed.

SQL> grant dba to gs_plsql_insteadof;

Succeed.

SQL> 
SQL> conn gs_plsql_insteadof/Lh00420062@127.0.0.1:1611

connected.

SQL> 
SQL> --case from oracle
SQL> drop table if exists customers;

Succeed.

SQL> CREATE TABLE customers
  2 (
  3 customer_id      number,
  4 cust_last_name   varchar2(32),
  5 cust_first_name  varchar2(32)
  6 );

Succeed.

SQL> drop table if exists orders;

Succeed.

SQL> CREATE TABLE orders
  2 (
  3 order_id         number,
  4 customer_id      number,
  5 order_date       date,
  6 order_status     int
  7 );

Succeed.

SQL> 
SQL> CREATE OR REPLACE VIEW order_info AS
  2 SELECT c.customer_id, c.cust_last_name, c.cust_first_name,
  3 o.order_id, o.order_date, o.order_status
  4 FROM customers c, orders o
  5 WHERE c.customer_id = o.customer_id;

Succeed.

SQL> 
SQL> CREATE OR REPLACE TRIGGER order_info_insert INSTEAD OF INSERT ON order_info
  2 DECLARE
  3 duplicate_info EXCEPTION;
  4 PRAGMA EXCEPTION_INIT(duplicate_info, -20001);
  5 BEGIN
  6 INSERT INTO customers(customer_id, cust_last_name, cust_first_name) VALUES (:new.customer_id, :new.cust_last_name, :new.cust_first_name);
  7 INSERT INTO orders (order_id, order_date, customer_id) VALUES (:new.order_id, :new.order_date, :new.customer_id);
  8 END order_info_insert;
  9 /

Succeed.

SQL> INSERT INTO order_info VALUES (999, 'Smith', 'John', 2500, to_date('13-01-2001','dd-mm-yyyy'), 0);

1 rows affected.

SQL> select * from order_info;

CUSTOMER_ID                              CUST_LAST_NAME                   CUST_FIRST_NAME                  ORDER_ID                                 ORDER_DATE             ORDER_STATUS
---------------------------------------- -------------------------------- -------------------------------- ---------------------------------------- ---------------------- ------------
999                                      Smith                            John                             2500                                     2001-01-13 00:00:00                

1 rows fetched.

SQL> select * from customers;

CUSTOMER_ID                              CUST_LAST_NAME                   CUST_FIRST_NAME                 
---------------------------------------- -------------------------------- --------------------------------
999                                      Smith                            John                            

1 rows fetched.

SQL> select * from orders;

ORDER_ID                                 CUSTOMER_ID                              ORDER_DATE             ORDER_STATUS
---------------------------------------- ---------------------------------------- ---------------------- ------------
2500                                     999                                      2001-01-13 00:00:00                

1 rows fetched.

SQL> 
SQL> --expect wrong
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a int,b int);

Succeed.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select * from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of insert on ttv_notexists for each row
  2 begin
  3  :new.a := :new.a+1;
  4 end;
  5 /

CT-00843, The table or view GS_PLSQL_INSTEADOF.TTV_NOTEXISTS does not exist.
SQL> create or replace trigger ttv_trig instead of insert on ttv for each row
  2 begin
  3  :new.a := :new.a+1;
  4 end;
  5 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_INSTEADOF.TTV_TRIG) terminated with compiling errors
[3:2] PLC-00916 PL/SQL:syntax error(':new.' can only modified in before insert/update row trigger, word = :NEW.A)


SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select a+1 as a_new from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of insert on ttv for each row
  2 begin
  3 dbe_output.print_line(:new.a_new);
  4 end;
  5 /

Succeed.

SQL> 
SQL> --view from one table, case insert
SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select a as a_new from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of insert on ttv for each row
  2 begin
  3  insert into tt1(a) values(:new.a_new);
  4 end;
  5 /

Succeed.

SQL> insert into ttv values (10);

1 rows affected.

SQL> select * from tt1;

A            B           
------------ ------------
10                       

1 rows fetched.

SQL> 
SQL> --view from one table, case insert
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a int, b int);

Succeed.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select a as a_new, b from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of insert on ttv for each row
  2 begin
  3 dbe_output.print_line('insert a= '||:new.a_new||' b= '||:new.b);
  4  insert into tt1 values(:new.a_new,:new.b);
  5 end;
  6 /

Succeed.

SQL> insert into ttv values(10,20);

insert a= 10 b= 20

1 rows affected.

SQL> select * from ttv;

A_NEW        B           
------------ ------------
10           20          

1 rows fetched.

SQL> 
SQL> --view from one table, case update
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a int, b int);

Succeed.

SQL> insert into tt1 values(10,20);

1 rows affected.

SQL> insert into tt1 values(11,21);

1 rows affected.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select a as a_new, b from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of update on ttv for each row
  2 begin
  3 dbe_output.print_line('update old a= '||:old.a_new||' b= '||:old.b);
  4 dbe_output.print_line('update new a= '||:new.a_new||' b= '||:new.b);
  5  update tt1 set a=:new.a_new, b=:new.b;
  6 end;
  7 /

Succeed.

SQL> update ttv set a_new=a_new+10;

update old a= 10 b= 20
update new a= 20 b= 20
update old a= 11 b= 21
update new a= 21 b= 21

2 rows affected.

SQL> select * from tt1;

A            B           
------------ ------------
21           21          
21           21          

2 rows fetched.

SQL> 
SQL> --view from one table, case delete
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a int, b int);

Succeed.

SQL> insert into tt1 values(10,20);

1 rows affected.

SQL> insert into tt1 values(11,21);

1 rows affected.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select a as a_new, b from tt1;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of delete on ttv for each row
  2 begin
  3 dbe_output.print_line('delete a= '||:old.a_new||' b= '||:old.b);
  4  delete from tt1 where a= :old.a_new and b=:old.b;
  5 end;
  6 /

Succeed.

SQL> delete from ttv where a_new=10;

delete a= 10 b= 20

1 rows affected.

SQL> select * from tt1;

A            B           
------------ ------------
11           21          

1 rows fetched.

SQL> 
SQL> --view from two table, case insert
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a1 int,b1 int);

Succeed.

SQL> drop table if exists tt2;

Succeed.

SQL> create table tt2(a2 int,b2 int);

Succeed.

SQL> insert into tt1 values(10,20);

1 rows affected.

SQL> insert into tt1 values(11,30);

1 rows affected.

SQL> insert into tt2 values(10,200);

1 rows affected.

SQL> insert into tt2 values(11,300);

1 rows affected.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select tt1.a1 as a_new, tt1.b1, tt2.b2 from tt1,tt2 where tt1.a1=tt2.a2;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of insert on ttv for each row
  2 begin
  3 dbe_output.print_line('insert a1=a2 '||:new.a_new||' b1= '||:new.b1||' b2= '||:new.b2);
  4 insert into tt1 values(:new.a_new,:new.b1);
  5 insert into tt2 values(:new.a_new,:new.b2);
  6 end;
  7 /

Succeed.

SQL> insert into ttv values(1,2,3);

insert a1=a2 1 b1= 2 b2= 3

1 rows affected.

SQL> select * from ttv order 1,2;

CT-00601, [1:25]Sql syntax error: by expected
SQL> 
SQL> --view from two table, case update
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a1 int,b1 int);

Succeed.

SQL> drop table if exists tt2;

Succeed.

SQL> create table tt2(a2 int,b2 int);

Succeed.

SQL> insert into tt1 values(10,20);

1 rows affected.

SQL> insert into tt1 values(11,30);

1 rows affected.

SQL> insert into tt2 values(10,200);

1 rows affected.

SQL> insert into tt2 values(11,300);

1 rows affected.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select tt1.a1 as a_new, tt1.b1, tt2.b2 from tt1,tt2 where tt1.a1=tt2.a2;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of update on ttv for each row
  2 begin
  3 dbe_output.print_line('update old a= '||:old.a_new||' b1= '||:old.b1);
  4 dbe_output.print_line('update new a= '||:new.a_new||' b1= '||:new.b1);
  5  update tt1 set a1=:new.a_new, b1=:new.b1;
  6  update tt2 set a2=:new.a_new;
  7 end;
  8 /

Succeed.

SQL> update ttv set a_new=a_new+10,b1=b1+20;

update old a= 10 b1= 20
update new a= 20 b1= 40
update old a= 11 b1= 30
update new a= 21 b1= 50

2 rows affected.

SQL> select * from ttv order by 1,2;

A_NEW        B1           B2          
------------ ------------ ------------
21           50           200         
21           50           300
21           50           200
21           50           300

4 rows fetched.

SQL> 
SQL> --view from two table, case delete
SQL> drop table if exists tt1;

Succeed.

SQL> create table tt1(a1 int,b1 int);

Succeed.

SQL> drop table if exists tt2;

Succeed.

SQL> create table tt2(a2 int,b2 int);

Succeed.

SQL> insert into tt1 values(10,20);

1 rows affected.

SQL> insert into tt1 values(11,30);

1 rows affected.

SQL> insert into tt2 values(10,200);

1 rows affected.

SQL> insert into tt2 values(11,300);

1 rows affected.

SQL> drop view if exists ttv;

Succeed.

SQL> create view ttv as select tt1.a1 as a_new, tt1.b1, tt2.b2 from tt1,tt2 where tt1.a1=tt2.a2;

Succeed.

SQL> drop trigger if exists ttv_trig;

Succeed.

SQL> create or replace trigger ttv_trig instead of delete on ttv for each row
  2 begin
  3 dbe_output.print_line('delete a= '||:old.a_new||' b1= '||:old.b1);
  4  delete from tt1 where a1= :old.a_new and b1 = :old.b1;
  5  delete from tt2 where a2=:old.a_new;
  6 end;
  7 /

Succeed.

SQL> delete from ttv where a_new=10 and b1 > 1;

delete a= 10 b1= 20

1 rows affected.

SQL> select * from ttv order by 1,2;

A_NEW        B1           B2          
------------ ------------ ------------
11           30           300         

1 rows fetched.

SQL> delete from ttv where a_new=11 and b1 > 1;

delete a= 11 b1= 30

1 rows affected.

SQL> select * from ttv order by 1,2;

A_NEW        B1           B2          
------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> 
SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user IF EXISTS sec cascade;

Succeed.

SQL> CREATE USER sec identified BY 'Sec$123456';

Succeed.

SQL> 
SQL> drop TABLE IF EXISTS sec.test;

Succeed.

SQL> CREATE TABLE IF NOT EXISTS sec.test(id INTEGER auto_increment PRIMARY KEY
  2                      ,name VARCHAR(10)
  3                      ,addr VARCHAR(10)
  4                      );

Succeed.

SQL> delete sec.test;

0 rows affected.

SQL> INSERT INTO sec.test(name,addr) values('n1','a1');

1 rows affected.

SQL> INSERT INTO sec.test(name,addr) values('n1','a1');

1 rows affected.

SQL> INSERT INTO sec.test(id,name,addr) values(22,'n1','a1');

1 rows affected.

SQL> INSERT INTO sec.test(id,name,addr) values(25,'n1','a1');

1 rows affected.

SQL> SELECT * FROM sec.test order by 1;

ID           NAME       ADDR      
------------ ---------- ----------
1            n1         a1        
2            n1         a1        
22           n1         a1        
25           n1         a1        

4 rows fetched.

SQL> commit;

Succeed.

SQL> 
SQL> CREATE or replace function IF NOT EXISTS sec.enc(
  2   v_varchar varchar2
  3 )
  4 return varchar2 AS
  5   o_varchar varchar2(200);
  6 BEGIN
  7   o_varchar:= v_varchar||'enc';
  8   RETURN o_varchar;
  9 END;
 10 /

Succeed.

SQL> 
SQL> CREATE or replace function IF NOT EXISTS sec.dec(
  2   v_varchar varchar2
  3 )
  4 return varchar2
  5 AS
  6   o_varchar varchar2(200);
  7 BEGIN
  8   o_varchar:= substr(v_varchar,1,length(v_varchar)-3);
  9   RETURN o_varchar;
 10 END;
 11 /

Succeed.

SQL> 
SQL> grant execute on sec.dec to public;

Succeed.

SQL> grant execute on sec.enc to public;

Succeed.

SQL> 
SQL> SELECT sec.dec('xxxenc');

SEC.DEC('XXXENC')                                               
----------------------------------------------------------------
xxx                                                             

1 rows fetched.

SQL> SELECT sec.enc('xxxenc');

SEC.ENC('XXXENC')                                               
----------------------------------------------------------------
xxxencenc                                                       

1 rows fetched.

SQL> 
SQL> ALTER TABLE sec.test RENAME TO SBDC_3CF2C888EFF911E99577D9C70700FFFE;

Succeed.

SQL> ALTER TABLE sec.SBDC_3CF2C888EFF911E99577D9C70700FFFE ADD COLUMN name_ text;

Succeed.

SQL> UPDATE sec.SBDC_3CF2C888EFF911E99577D9C70700FFFE SET name_=name||'enc',name=NULL;

4 rows affected.

SQL> 
SQL> CREATE OR REPLACE VIEW sec.test_inner AS
  2 SELECT id,
  3        sec.DEC(name_) AS name,
  4        addr
  5   FROM sec.SBDC_3CF2C888EFF911E99577D9C70700FFFE;

Succeed.

SQL> 
SQL> CREATE OR REPLACE VIEW sec.test AS
  2     SELECT id,
  3            name,
  4            addr
  5       FROM sec.test_inner;

Succeed.

SQL> 
SQL> select * from sec.SBDC_3CF2C888EFF911E99577D9C70700FFFE order by 1;

ID           NAME       ADDR       NAME_                                                           
------------ ---------- ---------- ----------------------------------------------------------------
1                       a1         n1enc                                                           
2                       a1         n1enc                                                           
22                      a1         n1enc                                                           
25                      a1         n1enc                                                           

4 rows fetched.

SQL> select * from sec.test order by 1;

ID           NAME                                                             ADDR      
------------ ---------------------------------------------------------------- ----------
1            n1                                                               a1        
2            n1                                                               a1        
22           n1                                                               a1        
25           n1                                                               a1        

4 rows fetched.

SQL> 
SQL> create or replace trigger sec.tri_ins_sbdc_3cf2c888eff911e99577d9c70700fffe
  2 instead of insert on sec.test for each row
  3 begin
  4   insert into sec.sbdc_3cf2c888eff911e99577d9c70700fffe(id,name,addr,name_)
  5   values (:new.id,:new.name,:new.addr,sec.enc(:new.name));
  6    update sec.sbdc_3cf2c888eff911e99577d9c70700fffe
  7       set name=null
  8     where id=:old.id;
  9 end;
 10 /

Succeed.

SQL> 
SQL> create or replace trigger sec.tri_upd_sbdc_3cf2c888eff911e99577d9c70700fffe
  2 instead of update on sec.test for each row
  3 begin
  4   update sec.sbdc_3cf2c888eff911e99577d9c70700fffe
  5      set id =:new.id,name=:new.name,addr=:new.addr,name_=sec.enc(:new.name)
  6    where id =:old.id;
  7 
  8   update sec.sbdc_3cf2c888eff911e99577d9c70700fffe
  9      set name=null
 10    where id  =:old.id;
 11 end;
 12 /

Succeed.

SQL> 
SQL> create or replace trigger sec.tri_del_sbdc_3cf2c888eff911e99577d9c70700fffe
  2 instead of delete on sec.test for each row
  3 begin
  4   delete from sec.sbdc_3cf2c888eff911e99577d9c70700fffe where id=:old.id;
  5 end;
  6 /

Succeed.

SQL> 
SQL> delete sec.test where id = 1;

1 rows affected.

SQL> select * from sec.sbdc_3cf2c888eff911e99577d9c70700fffe order by 1;

ID           NAME       ADDR       NAME_                                                           
------------ ---------- ---------- ----------------------------------------------------------------
2                       a1         n1enc                                                           
22                      a1         n1enc                                                           
25                      a1         n1enc                                                           

3 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> update sec.test set name='oracle' where id = 22;

1 rows affected.

SQL> select * from sec.sbdc_3cf2c888eff911e99577d9c70700fffe order by 1;

ID           NAME       ADDR       NAME_                                                           
------------ ---------- ---------- ----------------------------------------------------------------
1                       a1         n1enc                                                           
2                       a1         n1enc                                                           
22                      a1         oracleenc                                                       
25                      a1         n1enc                                                           

4 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> INSERT INTO sec.test(name,addr) values('n1','a1');

1 rows affected.

SQL> select * from sec.sbdc_3cf2c888eff911e99577d9c70700fffe order by 1;

ID           NAME       ADDR       NAME_                                                           
------------ ---------- ---------- ----------------------------------------------------------------
1                       a1         n1enc                                                           
2                       a1         n1enc                                                           
22                      a1         n1enc                                                           
25                      a1         n1enc                                                           
26           n1         a1         n1enc                                                           

5 rows fetched.

SQL> 
SQL> drop table if exists cus_rowid;

Succeed.

SQL> drop view if exists cus_view;

Succeed.

SQL> CREATE TABLE cus_rowid(customer_id number);

Succeed.

SQL> insert into cus_rowid values(10);

1 rows affected.

SQL> create view cus_view as select * from cus_rowid;

Succeed.

SQL> create or replace trigger rowid_instead instead of delete on cus_view
  2 begin
  3     delete from cus_rowid where rowid = :old.rowid;
  4 end;
  5 /

Succeed.

SQL> delete from cus_view where rowid = (select rowid from cus_view where customer_id=10);

1 rows affected.

SQL> select count(*) from cus_view;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> 
SQL> drop table if exists fvt_format_csf_table_05_02;

Succeed.

SQL> create table fvt_format_csf_table_05_02
  2 (
  3 c_int number,
  4 c_number number,
  5 c_varchar number default 0,
  6 c_date number not null
  7 );

Succeed.

SQL> 
SQL> create unique index fvt_format_csf_table_05_02_idx1 on fvt_format_csf_table_05_02(c_int,c_number,c_varchar,c_date);

Succeed.

SQL> create or replace view fvt_format_csf_table_05_02_v as select * from fvt_format_csf_table_05_02;

Succeed.

SQL> 
SQL> create or replace trigger fvt_format_csf_tri_01  instead of insert on fvt_format_csf_table_05_02_v
  2 begin
  3        insert into fvt_format_csf_table_05_02 values(:new.c_Int,:new.c_number,:new.c_varchar,:new.c_date);
  4 end;
  5 /

Succeed.

SQL> 
SQL> insert into fvt_format_csf_table_05_02_v values(1,3.25,0,0);

1 rows affected.

SQL> replace into fvt_format_csf_table_05_02_v values(1,3.25,0,0);

CT-00932, [3:8] PL/SQL(SYS.FVT_FORMAT_CSF_TRI_01) terminated with execute errors
[3:8] CT-00729, Unique constraint violated, index FVT_FORMAT_CSF_TABLE_05_02_IDX1, duplicate key 1-3.25-0-0

SQL> 
SQL> drop user sec cascade;

Succeed.

SQL> set serveroutput off;
OFF



