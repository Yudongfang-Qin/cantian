

SQL> --DTS2019012409416
SQL> create table hash_join_t1(f1 int,f2 int, f3 int);

Succeed.

SQL> create table hash_join_t2(f1 int,f2 int);

Succeed.

SQL> create index ind_hash_join_t2 on hash_join_t2(f1);

Succeed.

SQL> insert into hash_join_t1 values(1,3,3);

1 rows affected.

SQL> insert into hash_join_t2 values(1,2);

1 rows affected.

SQL> select 1 from hash_join_t1 where f1 in
  2 (
  3     select f1 from hash_join_t2 where f2 in
  4     (
  5         select 3 from hash_join_t1 t3 where hash_join_t1.f3 = t3.f3  and exists (select 1 from dual)
  6     )
  7 );

1           
------------

0 rows fetched.

SQL> drop table hash_join_t1;

Succeed.

SQL> drop table hash_join_t2;

Succeed.

SQL> drop table if exists zsharding_tbl_p1;

Succeed.

SQL> create table zsharding_tbl_p1(
  2 c_id int, c_int int, c_integer integer, c_bool bool, c_boolean boolean, c_bigint bigint,
  3 c_real real, c_double double,
  4 c_decimal decimal(38), c_number number(38), c_numeric numeric(38),
  5 c_char char(50) default null, c_varchar varchar(20), c_varchar2 varchar2(4000),
  6 c_date date, c_datetime datetime, c_timestamp timestamp,c_float float default null
  7 );

Succeed.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 20, 0, 10, 1, 0, -1088618496, 500000, 1000, 9, 5, 8, 'a', 'def', '2003-02-28', TO_DATE('2002-03-18', 'YYYY-MM-DD'), TO_DATE('2003-11-25', 'YYYY-MM-DD'), TO_TIMESTAMP('2004-08-19 21:38:09', 'YYYY-MM-DD HH24:Mi:SS') ,-1.79E+308);

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 21, 30000, 20000, 0, 1, 30000, 294453248, 0, 2, -110231552, 9, 'ghi', '2004-05-24', 'kbvumx', TO_DATE('2010-08-08', 'YYYY-MM-DD'), TO_DATE('1995-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2018-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS'),1.79E+308 );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 22, 12, 20000, 1, 1, 0, 1, 10, 3000, 13, 0, 'ekb', 'eekbvumxm', 'd', TO_DATE('1995-08-08', 'YYYY-MM-DD'), TO_DATE('2009-11-25', 'YYYY-MM-DD'), TO_TIMESTAMP('1885-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') ,'');

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 23, -1294729216, -1349124096, 1, 1, 1421737984, 10, 20000, 2, 3000, 3000, 'b', '%b%', '2004-06-20 20:20:31', TO_DATE('1880-08-08', 'YYYY-MM-DD'), TO_DATE('2009-11-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2002-05-28 01:05:16', 'YYYY-MM-DD HH24:Mi:SS'),9999999999.123456789 );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 24, -1485242368, -480182272, 1, 0, 3000, 1000, 0, 12, 11, 1000, '2005-09-02', 'q', '2001-08-18 14:31:12', TO_DATE('2002-05-09', 'YYYY-MM-DD'), TO_DATE('2005-08-06', 'YYYY-MM-DD'), TO_TIMESTAMP('2012-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS'),'' );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 25, 1000, 0, 1, 0, 4, 20000, 3000, -1371799552, -1394540544, 3, 'def', 'abc', '%b%', TO_DATE('2009-02-10', 'YYYY-MM-DD'), TO_DATE('2001-05-14', 'YYYY-MM-DD'), TO_TIMESTAMP('2001-02-18 14:25:33', 'YYYY-MM-DD HH24:Mi:SS'),''  );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 26, 1, 10, 1, 0, 1971322880, 11, 30000, 0, 1088159744, 9, 'abc', '_a_%', 'abe', TO_DATE('2002-12-07', 'YYYY-MM-DD'), TO_DATE('2000-07-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2000-01-01 01:01:01', 'YYYY-MM-DD HH24:Mi:SS') ,'' );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 27, 1199702016, 10, 0, 1, 500000, -1063911424, 12, 0, 11, 5, 'abcdef', 'a', 'c', TO_DATE('2009-04-08', 'YYYY-MM-DD'), TO_DATE('2010-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('1880-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') ,'' );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 28, 5, 30000, 1, 1, 14, 500000, 5, 292421632, 5, 13, 'c', 'mab', 'b', TO_DATE('2006-02-08', 'YYYY-MM-DD'), TO_DATE('2000-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS'),''  );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 29, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, '', '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') ,'' );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 30, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, 'abcdefgaaaaaaaaa', '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS'),''  );

1 rows affected.

SQL> INSERT INTO zsharding_tbl_p1 VALUES ( 31, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, null, '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') ,'' );

1 rows affected.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE P1 IS A BOOLEAN ;
  2  TYPE CURTY IS REF CURSOR ;
  3  CURSOR1 SYS_REFCURSOR;
  4  CURSOR2 CURTY ;
  5  BEGIN
  6  OPEN CURSOR2 FOR SELECT C_BOOLEAN FROM ZSHARDING_TBL_P1 C WHERE C_BOOLEAN IN (SELECT C_BOOLEAN FROM ZSHARDING_TBL_P1 WHERE C_BOOL!=C_BOOLEAN ) ORDER BY C_CHAR , C_VARCHAR , C_VARCHAR2 , C_INT , C_INTEGER , C_BIGINT , C_DECIMAL , C_NUMBER , C_NUMERIC , C_BOOL , C_BOOLEAN , C_TIMESTAMP, C_DATE, C_DATETIME,C_FLOAT ;
  7  CURSOR1 := CURSOR2 ;
  8  DBE_SQL.RETURN_CURSOR(CURSOR1);
  9  END P1;
 10  /

Succeed.

SQL>  BEGIN
  2  P1();
  3  END;
  4  /

PL/SQL procedure successfully completed.

ResultSet #1

C_BOOLEAN
---------
FALSE    
FALSE    
FALSE    
TRUE     
FALSE    
TRUE     
TRUE     
FALSE    
TRUE     
TRUE     
FALSE    
FALSE    

12 rows fetched.


SQL>  DROP PROCEDURE P1;

Succeed.

SQL> 
SQL> 
SQL> drop table if exists hj_t1;

Succeed.

SQL> drop table if exists hj_t2;

Succeed.

SQL> drop table if exists hj_t3;

Succeed.

SQL> create table hj_t1(f1 int, f2 int, f3 varchar(100), constraint pk_t1_f1 primary key (f1));

Succeed.

SQL> create table hj_t2(f1 int, f2 int, f3 varchar(100), constraint pk_t2_f1 primary key (f1));

Succeed.

SQL> create table hj_t3(f1 int, f2 int, f3 varchar(100), constraint pk_t3_f1 primary key (f1));

Succeed.

SQL> 
SQL> insert into hj_t1 values(1,1,'a');

1 rows affected.

SQL> insert into hj_t1 values(2,2,'b');

1 rows affected.

SQL> insert into hj_t1 values(4,4,'c');

1 rows affected.

SQL> insert into hj_t1 values(5,2,'c');

1 rows affected.

SQL> insert into hj_t2 values(1,2,'b');

1 rows affected.

SQL> insert into hj_t2 values(2,3,'b');

1 rows affected.

SQL> insert into hj_t2 values(3,null,null);

1 rows affected.

SQL> insert into hj_t3 values(1,1,'c');

1 rows affected.

SQL> insert into hj_t3 values(2,2,'c');

1 rows affected.

SQL> insert into hj_t3 values(4,4,'c');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain select hj_t1.f1,hj_t1.f2,hj_t2.f2 from hj_t1 left join hj_t2 on abs(hj_t1.f1) = abs(hj_t2.f1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: ABS(HJ_T1.F1) = ABS(HJ_T2.F1)                    

11 rows fetched.

SQL> 
SQL> explain select hj_t1.f1,hj_t1.f2,hj_t2.f2 from hj_t1 left join hj_t2 on abs(hj_t1.f1) + 2 = abs(hj_t2.f1) * 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: ABS(HJ_T1.F1) + 2 = ABS(HJ_T2.F1) * 10           

11 rows fetched.

SQL> 
SQL> explain select hj_t1.f1,hj_t1.f2,hj_t2.f2 from hj_t1 left join hj_t2 on abs(hj_t1.f1) + hj_t1.f2 = abs(hj_t2.f1) * 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: ABS(HJ_T1.F1) + HJ_T1.F2 = ABS(HJ_T2.F1) * 10    

11 rows fetched.

SQL> 
SQL> explain select hj_t1.f1,hj_t1.f2,hj_t2.f2 from hj_t1 left join hj_t2 on abs(hj_t1.f1) + hj_t2.f2 = abs(hj_t2.f1) * 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   NESTED LOOPS OUTER   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: ABS(HJ_T1.F1) + HJ_T2.F2 = ABS(HJ_T2.F1) * 10    

11 rows fetched.

SQL> 
SQL> explain select hj_t1.f1,hj_t1.f2,hj_t2.f2 from hj_t1 left join hj_t2 on hj_t2.f3||'' = hj_t1.f3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F3 = HJ_T2.F3 || ''                        

11 rows fetched.

SQL> 
SQL> explain select a.f1, b.f1 from hj_t1 a left join hj_t2 b on (a.f2 = b.f2 or a.f3 = b.f2) and a.f2 = b.f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description            | Owner | Name    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |         |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |         |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 A |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 B |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.F2 = B.F2                                      
       filter: A.F2 = B.F2 OR A.F3 = B.F2                       

12 rows fetched.

SQL> 
SQL> explain select a.f1, b.f1 from hj_t1 a left join hj_t2 b on a.f1 = b.f1 or a.f2 = b.f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description            | Owner | Name    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |         |      |      |       |        |
| 1   |   NESTED LOOPS OUTER   |       |         |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 A |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 B |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: A.F1 = B.F1 OR A.F2 = B.F2                       

11 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 IN ((SELECT f2 FROM hj_t2 WHERE hj_t2.f2=2),(SELECT f2 FROM hj_t2 WHERE hj_t2.f2=3));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   KERNEL FILTER        |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F2 IN((SELECT F2 FROM HJ_T2 WHERE HJ_T2.F2 = 2), (SELECT F2 FROM HJ_T2 WHERE HJ_T2.F2 = 3))
   3 - filter: HJ_T2.F2 = 2                                     
   4 - filter: HJ_T2.F2 = 3                                     

14 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 IN (SELECT f2 FROM hj_t2 WHERE hj_t2.f2=2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F2 = F2                                    
   3 - filter: HJ_T2.F2 = 2                                     

13 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 IN (SELECT f2 FROM hj_t2 WHERE 1 = 1 and hj_t2.f2 in (select f2 from hj_t2 where hj_t2.f3 = 'a'));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)          |       |       |      |      |       |        |
| 2   |     SUBSELECT                |       |       |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 4   |         SUBSELECT            |       |       |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T2 |      |      |       |        |
| 7   |     TABLE ACCESS FULL        | SYS   | HJ_T1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F2 = F2                                    
   3 - access: HJ_T2.F2 = HJ_T2.F2                              
   5 - filter: HJ_T2.F3 = 'a'                                   

17 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 IN (SELECT f2 FROM hj_t2 WHERE hj_t2.f2=hj_t1.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F2 = F2 AND HJ_T2.F2 = HJ_T1.F2            

12 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 NOT IN (SELECT f2 FROM hj_t2 WHERE hj_t2.f3 = 'a');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: F2 = F2                                          
   4 - filter: HJ_T2.F3 = 'a'                                   

13 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE f2 NOT IN (SELECT f2 FROM hj_t2 WHERE hj_t2.f3 = 'a') and f2 > 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: F2 = F2                                          
   2 - filter: F2 > 2                                           
   4 - filter: HJ_T2.F3 = 'a'                                   

14 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE exists (SELECT * FROM hj_t2 WHERE hj_t2.f2 = hj_t1.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F2 = HJ_T1.F2                              

12 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE NOT EXISTS (SELECT * FROM hj_t2 WHERE hj_t1.f2=hj_t2.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F2 = HJ_T2.F2                              

12 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE NOT EXISTS (SELECT * FROM hj_t2 WHERE hj_t1.f2=hj_t2.f2 and hj_t1.f3=hj_t2.f3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F3 = HJ_T2.F3 AND HJ_T1.F2 = HJ_T2.F2      

12 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE t1.f2 IN (SELECT f2 FROM hj_t2 WHERE 1 = 1 ) 
  2 and t1.f3 in (SELECT f3 FROM hj_t3 WHERE 1 = 1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   NESTED LOOPS               |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)        |       |          |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 4   |         SUBSELECT            |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 7   |       SUBSELECT              |       |          |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | HJ_T3    |      |      |       |        |
| 9   |     TABLE ACCESS FULL        | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.F3 = HJ_T3.F3                                 
   3 - access: HJ_T2.F2 = T1.F2                                 

18 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE t1.f2 IN (SELECT f2 FROM hj_t2 WHERE 1 = 1 ) 
  2 and t2.f3 in (SELECT f3 FROM hj_t3 WHERE 1 = 1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   NESTED LOOPS             |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 6   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 7   |       SUBSELECT            |       |          |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | HJ_T3    |      |      |       |        |
| 9   |       TABLE ACCESS FULL    | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: HJ_T2.F2 = T1.F2                                 
   6 - access: HJ_T3.F3 = T2.F3                                 

18 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 left join hj_t2 t2 on t1.f1=t2.f1+0 WHERE t1.f2 IN (SELECT f2 FROM hj_t2 WHERE 1 = 1 ) 
  2 and t1.f3 in (SELECT f3 FROM hj_t3 WHERE 1 = 1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)        |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 5   |       HASH JOIN OUTER(R)   |       |          |      |      |       |        |
| 6   |         TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 8   |     SUBSELECT              |       |          |      |      |       |        |
| 9   |       TABLE ACCESS FULL    | SYS   | HJ_T3    |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F3 = HJ_T3.F3                                 
   2 - access: HJ_T2.F2 = T1.F2                                 
   5 - access: T1.F1 = T2.F1 + 0                                

19 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 right join hj_t2 t2 on t1.f1=t2.f1+0 WHERE t1.f2 IN (SELECT f2 FROM hj_t2 WHERE 1 = 1 ) 
  2 and t2.f3 in (SELECT f3 FROM hj_t3 WHERE 1 = 1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)          |       |          |      |      |       |        |
| 2   |     HASH JOIN(L)             |       |          |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 4   |         SUBSELECT            |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 7   |       TABLE ACCESS FULL      | SYS   | HJ_T2 T2 |      |      |       |        |
| 8   |     SUBSELECT                |       |          |      |      |       |        |
| 9   |       TABLE ACCESS FULL      | SYS   | HJ_T3    |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F3 = HJ_T3.F3                                 
   2 - access: T1.F1 = T2.F1 + 0                                
   3 - access: HJ_T2.F2 = T1.F2                                 

19 rows fetched.

SQL> 
SQL> explain delete from hj_t1 where rowid in (
  2 select a.rowid from hj_t1 a where a.f1 = 1 and a.f2 = 1 
  3 and not exists (select 1 from hj_t2 where f1 = a.f1 and f2 = a.f2 and (f3=a.f3 or (f3 is null and a.f3 is null))));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                       |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                         |       |          |      |      |       |        |
| 2   |     SUBSELECT                          |       |          |      |      |       |        |
| 3   |       HASH DISTINCT                    |       |          |      |      |       |        |
| 4   |         KERNEL FILTER                  |       |          |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 A  |      |      |       |        |
| 6   |             INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2    |      |      |       |        |
| 8   |             INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 9   |     TABLE ACCESS BY ROWID              | SYS   | HJ_T1    |      |      |       |        |
| 10  |       ROWID SCAN                       |       |          |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: A.F2 = 1 AND NOT EXISTS(SELECT 1 FROM HJ_T2 WHERE F1 = 1 AND F2 = 1 AND F2 = A.F2 AND F1 = A.F1 AND 
               F3 = A.F3 OR F3 IS NULL AND A.F3 IS NULL)        
   6 - access: A.F1 = 1 AND A.F1 = A.F2                         
   7 - filter: F3 = A.F3 OR F3 IS NULL AND A.F3 IS NULL AND F2 = A.F2 AND F2 = 1
   8 - access: F1 = 1 AND F1 = A.F1                             
   10 - access: ROWID = ROWID                                   

23 rows fetched.

SQL> delete from hj_t1 where rowid in (
  2 select a.rowid from hj_t1 a where a.f1 = 1 and a.f2 = 1 
  3 and not exists (select 1 from hj_t2 where f1 = a.f1 and f2 = a.f2 and (f3=a.f3 or (f3 is null and a.f3 is null))));

1 rows affected.

SQL> rollback;

Succeed.

SQL> 
SQL> -----------------------------------------------------------------------------------------------------------------------
SQL> explain select avg(f1) from hj_t1 where f2 in (select f2 from hj_t2) and exists(select f2 from hj_t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |       |      |      |       |        |
| 1   |   AGGR                       |       |       |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)        |       |       |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 4   |         SUBSELECT            |       |       |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 7   |       SUBSELECT              |       |       |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | HJ_T3 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NA = NA                                          
   3 - access: HJ_T2.F2 = F2                                    

17 rows fetched.

SQL> 
SQL> explain select avg(f1) from hj_t1 where exists (select f2 from hj_t2) and exists(select f2 from hj_t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name     | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |          |      |      |       |        |
| 1   |   AGGR                              |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)               |       |          |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)             |       |          |      |      |       |        |
| 4   |         SUBSELECT                   |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL         | SYS   | HJ_T2    |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ONLY  | SYS   | HJ_T1    |      |      |       |        |
| 7   |           INDEX FAST FULL SCAN      | SYS   | PK_T1_F1 |      |      |       |        |
| 8   |       SUBSELECT                     |       |          |      |      |       |        |
| 9   |         TABLE ACCESS FULL           | SYS   | HJ_T3    |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NA = NA                                          
   3 - access: NA = NA                                          

18 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE exists (SELECT * FROM hj_t2 WHERE hj_t1.f2 > 2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: NA = NA                                          
   4 - filter: HJ_T1.F2 > 2                                     

13 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE exists (SELECT * FROM hj_t2 WHERE hj_t2.f2 = hj_t1.f2 and hj_t1.f1 > 2 and hj_t2.f1 > 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)                |       |          |      |      |       |        |
| 2   |     SUBSELECT                      |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2    |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | PK_T2_F1 |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID    | SYS   | HJ_T1    |      |      |       |        |
| 6   |       INDEX RANGE SCAN             | SYS   | PK_T1_F1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F2 = HJ_T1.F2                              
   4 - access: HJ_T2.F1 > 1                                     
   6 - access: HJ_T1.F1 > 2                                     

16 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE NOT EXISTS (SELECT * FROM hj_t2 WHERE hj_t1.f2=hj_t2.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F2 = HJ_T2.F2                              

12 rows fetched.

SQL> 
SQL> explain SELECT f1,f2 FROM hj_t1 WHERE NOT EXISTS (SELECT * FROM hj_t2 WHERE hj_t1.f2=hj_t2.f2 and hj_t1.f3 = hj_t2.f3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F3 = HJ_T2.F3 AND HJ_T1.F2 = HJ_T2.F2      

12 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t1.f1 >= 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)              |       |          |      |      |       |        |
| 3   |       SUBSELECT                    |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL          | SYS   | HJ_T3 T3 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | PK_T1_F1 |      |      |       |        |
| 7   |     TABLE ACCESS FULL              | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T3.F2 = T1.F2                                    
   6 - access: T1.F1 >= 1                                       

16 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t1.f2 >= 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   NESTED LOOPS             |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 6   |     TABLE ACCESS FULL      | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T3.F2 = T1.F2                                    
   5 - filter: T1.F2 >= 1                                       

15 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE NOT EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t1.f1 >= 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   NESTED LOOPS           |       |          |      |      |       |        |
| 2   |     KERNEL FILTER        |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 5   |     KERNEL FILTER        |       |          |      |      |       |        |
| 6   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 7   |       TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: NOT EXISTS(SELECT 1 FROM HJ_T3 T3 WHERE T1.F1 >= 1 AND T3.F2 = T1.F2)
   4 - filter: T1.F1 >= 1 AND T3.F2 = T1.F2                     
   7 - filter: T1.F1 >= 1 AND T3.F2 = T1.F2                     

17 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1, hj_t2 t2 WHERE EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t1.f1 = t2.f1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)                |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     SUBSELECT                      |       |          |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F2 = T3.F2                                    
   5 - access: T1.F1 = T2.F1                                    

16 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 inner join hj_t2 t2 on t1.f1=t2.f1 WHERE NOT EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t2.f2 = t3.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)                |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     SUBSELECT                      |       |          |      |      |       |        |
| 7   |       TABLE ACCESS FULL            | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F2 = T3.F2 AND T1.F2 = T3.F2                  
   5 - access: T1.F1 = T2.F1                                    

16 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 inner join hj_t2 t2 on t1.f1=t2.f1 
  2 WHERE NOT EXISTS (SELECT * FROM hj_t3 t3 WHERE t1.f2=t3.f2 and t2.f2 = t3.f2 and t3.f1=1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)                |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     SUBSELECT                      |       |          |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T3 T3 |      |      |       |        |
| 8   |         INDEX UNIQUE SCAN          | SYS   | PK_T3_F1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F2 = T3.F2 AND T1.F2 = T3.F2                  
   5 - access: T1.F1 = T2.F1                                    
   8 - access: T3.F1 = 1                                        

18 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 inner join hj_t2 t2 on t1.f1=t2.f1 
  2 WHERE NOT EXISTS (SELECT * FROM hj_t3 t3 inner join hj_t3 t4 on t3.f1=t4.f1 WHERE t1.f2=t3.f2 and t2.f2 = t3.f2 and t3.f1=1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)                  |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                     |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL              | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID    | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN            | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     SUBSELECT                        |       |          |      |      |       |        |
| 7   |       NESTED LOOPS                   |       |          |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T3 T3 |      |      |       |        |
| 9   |           INDEX UNIQUE SCAN          | SYS   | PK_T3_F1 |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T3 T4 |      |      |       |        |
| 11  |           INDEX UNIQUE SCAN          | SYS   | PK_T3_F1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F2 = T3.F2 AND T1.F2 = T3.F2                  
   5 - access: T1.F1 = T2.F1                                    
   9 - access: T3.F1 = 1                                        
   10 - filter: T3.F1 = T4.F1                                   
   11 - access: T4.F1 = 1                                       

23 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 WHERE EXISTS (SELECT * FROM hj_t2 t2,hj_t3 t3 WHERE t1.f2=t3.f2 and t2.f1 = t3.f1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name     | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)                   |       |          |      |      |       |        |
| 2   |     SUBSELECT                         |       |          |      |      |       |        |
| 3   |       NESTED LOOPS                    |       |          |      |      |       |        |
| 4   |         NESTED LOOPS                  |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL           | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ONLY  | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |             INDEX UNIQUE SCAN         | SYS   | PK_T3_F1 |      |      |       |        |
| 8   |         TABLE ACCESS BY ROWID         | SYS   | HJ_T3 T3 |      |      |       |        |
| 9   |           ROWID SCAN                  |       |          |      |      |       |        |
| 10  |     TABLE ACCESS FULL                 | SYS   | HJ_T1 T1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T3.F2 = T1.F2                                    
   7 - access: T2.F1 = T3.F1                                    

19 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 WHERE EXISTS (SELECT * FROM hj_t2 t2 inner join hj_t3 t3 on t1.f2=t3.f2 and t2.f1 = t3.f1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name     | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)                   |       |          |      |      |       |        |
| 2   |     SUBSELECT                         |       |          |      |      |       |        |
| 3   |       NESTED LOOPS                    |       |          |      |      |       |        |
| 4   |         NESTED LOOPS                  |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL           | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ONLY  | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |             INDEX UNIQUE SCAN         | SYS   | PK_T3_F1 |      |      |       |        |
| 8   |         TABLE ACCESS BY ROWID         | SYS   | HJ_T3 T3 |      |      |       |        |
| 9   |           ROWID SCAN                  |       |          |      |      |       |        |
| 10  |     TABLE ACCESS FULL                 | SYS   | HJ_T1 T1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T3.F2 = T1.F2                                    
   7 - access: T2.F1 = T3.F1                                    

19 rows fetched.

SQL> 
SQL> explain SELECT * FROM hj_t1 t1 WHERE EXISTS (SELECT distinct f2 from hj_t2 t2 where t1.f2=t2.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F2 = T1.F2                                    

12 rows fetched.

SQL> 
SQL> --never change the following plan unless you known what it means
SQL> explain SELECT * FROM hj_t1 t1 WHERE t1.f1 IN (select t2.f1 from hj_t2 t2 join hj_t3 t3 on t2.f2=t3.f2 and t3.f1 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                           |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                         |       |          |      |      |       |        |
| 3   |       SUBSELECT                          |       |          |      |      |       |        |
| 4   |         HASH DISTINCT                    |       |          |      |      |       |        |
| 5   |           HASH JOIN(L)                   |       |          |      |      |       |        |
| 6   |             TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |               INDEX UNIQUE SCAN          | SYS   | PK_T3_F1 |      |      |       |        |
| 8   |             TABLE ACCESS FULL            | SYS   | HJ_T2 T2 |      |      |       |        |
| 9   |       TABLE ACCESS BY INDEX ONLY         | SYS   | HJ_T1 T1 |      |      |       |        |
| 10  |         INDEX UNIQUE SCAN                | SYS   | PK_T1_F1 |      |      |       |        |
| 11  |     TABLE ACCESS BY ROWID                | SYS   | HJ_T1 T1 |      |      |       |        |
| 12  |       ROWID SCAN                         |       |          |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T3.F2 = T2.F2                                    
   7 - access: T3.F1 = 1                                        
   10 - access: T1.F1 = T2.F1                                   

22 rows fetched.

SQL> 
SQL> explain select count(*) as numwait from hj_t1 t1, hj_t2 t2, hj_t3 t3 where t1.f1 = t2.f1 and t3.f1 = t2.f1 and t2.f2 > t2.f1 
  2 and exists (select * from hj_t2 l2 where l2.f1 = t2.f1 and l2.f2 <> t2.f2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |          |      |      |       |        |
| 1   |   AGGR                                 |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |          |      |      |       |        |
| 3   |       NESTED LOOPS                     |       |          |      |      |       |        |
| 4   |         KERNEL FILTER                  |       |          |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ONLY   | SYS   | HJ_T1 T1 |      |      |       |        |
| 6   |             INDEX FAST FULL SCAN       | SYS   | PK_T1_F1 |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 L2 |      |      |       |        |
| 8   |             INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 9   |         KERNEL FILTER                  |       |          |      |      |       |        |
| 10  |           TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 11  |             INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 12  |           TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 L2 |      |      |       |        |
| 13  |             INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 14  |       KERNEL FILTER                    |       |          |      |      |       |        |
| 15  |         TABLE ACCESS BY INDEX ONLY     | SYS   | HJ_T3 T3 |      |      |       |        |
| 16  |           INDEX UNIQUE SCAN            | SYS   | PK_T3_F1 |      |      |       |        |
| 17  |         TABLE ACCESS BY INDEX ROWID    | SYS   | HJ_T2 L2 |      |      |       |        |
| 18  |           INDEX UNIQUE SCAN            | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - filter: L2.F2 != T2.F2                                   
   8 - access: L2.F1 = T2.F1                                    
   10 - filter: T2.F2 > T2.F1 AND EXISTS(SELECT 1 FROM HJ_T2 L2 WHERE L2.F2 != T2.F2)
   11 - access: T1.F1 = T2.F1                                   
   12 - filter: L2.F2 != T2.F2                                  
   13 - access: L2.F1 = T2.F1                                   
   15 - filter: T1.F1 = T3.F1                                   
   16 - access: T2.F1 = T3.F1                                   
   17 - filter: L2.F2 != T2.F2                                  
   18 - access: L2.F1 = T2.F1                                   

35 rows fetched.

SQL> 
SQL> --delete/update using NL (with index)
SQL> explain  delete from t1, t2 using hj_t1 t1, hj_t2 t2 where t1.f1 = t2.f1 and t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                 |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.F1 = 1                                        
   5 - access: T2.F1 = 1 AND T1.F1 = T2.F1                      

14 rows fetched.

SQL> explain delete from t1, t2 using hj_t1 t1 left join hj_t2 t2 on t1.f1 = t2.f1 where t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                 |       |          |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.F1 = 1                                        
   5 - access: T2.F1 = 1 AND T1.F1 = T2.F1                      

14 rows fetched.

SQL> explain delete from hj_t1 t1 where t1.f1 in (select f1 from hj_t2 t2 where t2.f2 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                 |       |          |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE T2.F2 = 1 AND T1.F1 = T2.F1)
   3 - filter: T2.F2 = 1                                        
   4 - access: T1.F1 = T2.F1                                    

14 rows fetched.

SQL> explain delete from hj_t1 t1 where exists (select 1 from hj_t2 t2 where t2.f1 = t1.f1 and t2.f2 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                 |       |          |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE T2.F2 = 1 AND T2.F1 = T1.F1)
   3 - filter: T2.F2 = 1                                        
   4 - access: T2.F1 = T1.F1                                    

14 rows fetched.

SQL> explain delete from t1,t2,t3 using hj_t1 t1 left join hj_t2 t2 on t1.f1=t2.f1 join hj_t3 t3 on t2.f1=t3.f1; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID    | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |       INDEX UNIQUE SCAN            | SYS   | PK_T3_F1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T2.F1 = T1.F1                                    
   7 - access: T3.F1 = T1.F1 AND T2.F1 = T3.F1                  

16 rows fetched.

SQL> explain update hj_t1 t1, hj_t2 t2 set t1.f3 = 'aaa', t2.f3 = 'bbb' where t1.f1=t2.f1 and t1.f1 = 1;  

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                 |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.F1 = 1                                        
   5 - access: T2.F1 = 1 AND T1.F1 = T2.F1                      

14 rows fetched.

SQL> explain update hj_t1 t1 join hj_t2 t2 on t1.f1=t2.f1 set t1.f3 = 'aaa', t2.f3 = 'bbb' where t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                 |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |       INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.F1 = 1                                        
   5 - access: T2.F1 = 1 AND T1.F1 = T2.F1                      

14 rows fetched.

SQL> explain update hj_t1 t1, hj_t2 t2, hj_t3 t3 set t1.f3 = 'aaa', t2.f3 = 'bbb', t3.f3 = t2.f3 where t1.f1=t2.f1 and t2.f2=t3.f2; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                   |       |          |      |      |       |        |
| 1   |   HASH JOIN(L)                     |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |     TABLE ACCESS FULL              | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F2 = T3.F2                                    
   5 - access: T1.F1 = T2.F1                                    

15 rows fetched.

SQL> explain update hj_t1 t1 left join hj_t2 t2 on t1.f1=t2.f1 join hj_t3 t3 on t2.f1=t3.f1 set t1.f3 = 'aaa', t2.f3 = 'bbb', t3.f3 = t2.f3 where t1.f1=1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                   |       |          |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |         INDEX UNIQUE SCAN          | SYS   | PK_T1_F1 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 7   |     TABLE ACCESS BY INDEX ROWID    | SYS   | HJ_T3 T3 |      |      |       |        |
| 8   |       INDEX UNIQUE SCAN            | SYS   | PK_T3_F1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.F1 = 1                                        
   6 - access: T2.F1 = 1 AND T2.F1 = T1.F1                      
   8 - access: T3.F1 = 1 AND T3.F1 = T1.F1 AND T2.F1 = T3.F1    

18 rows fetched.

SQL> 
SQL> --subselect_as_table optimz
SQL> explain update hj_t1 t1 set f2 = 111 where exists(select 1 from (select distinct f1,f2 from hj_t2 where exists(select 1 from hj_t1)) s2 where s2.f1=t1.f1 and(s2.f2 != t1.f2 or t1.f2 is null) AND exists(select 1 from hj_t2));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                   |       |          |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     KERNEL FILTER                  |       |          |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | HJ_T2    |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_T2_F1 |      |      |       |        |
| 6   |       TABLE ACCESS BY INDEX ONLY   | SYS   | HJ_T1    |      |      |       |        |
| 7   |         INDEX FAST FULL SCAN       | SYS   | PK_T1_F1 |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ONLY   | SYS   | HJ_T2    |      |      |       |        |
| 9   |         INDEX FAST FULL SCAN       | SYS   | PK_T2_F1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM HJ_T2 WHERE HJ_T2.F1 = T1.F1 AND EXISTS(SELECT 1 FROM HJ_T1) AND EXISTS(SELECT 1 FROM 
               HJ_T2) AND HJ_T2.F2 != T1.F2 OR T1.F2 IS NULL)   
   4 - filter: EXISTS(SELECT 1 FROM HJ_T2) AND EXISTS(SELECT 1 FROM HJ_T1) AND HJ_T2.F2 != T1.F2 OR T1.F2 IS NULL
   5 - access: HJ_T2.F1 = T1.F1                                 

20 rows fetched.

SQL> update hj_t1 t1 set f2 = 111 where exists(select 1 from (select distinct f1,f2 from hj_t2 where exists(select 1 from hj_t1)) s2 where s2.f1=t1.f1 and(s2.f2 != t1.f2 or t1.f2 is null) AND exists(select 1 from hj_t2));

2 rows affected.

SQL> select * from hj_t1 order by f1;

F1           F2           F3                                                              
------------ ------------ ----------------------------------------------------------------
1            111          a                                                               
2            111          b                                                               
4            4            c                                                               
5            2            c                                                               

4 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> drop table hj_t1;

Succeed.

SQL> drop table hj_t2;

Succeed.

SQL> drop table hj_t3;

Succeed.

SQL> 
SQL> drop table if exists hash_join_table;

Succeed.

SQL> create table hash_join_table(id int not null,c_intger integer,c_char char(10));

Succeed.

SQL> insert into hash_join_table values(1,1000,1000);

1 rows affected.

SQL> insert into hash_join_table values(2,2000,1000);

1 rows affected.

SQL> insert into hash_join_table values(3,2001,null);

1 rows affected.

SQL> insert into hash_join_table values(4,2002,'a');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select count(*) from hash_join_table t1 right join hash_join_table t2 on t1.id=t2.id
  2 inner join hash_join_table t3 on t1.id=t3.id
  3 right join hash_join_table t4 on t1.id=t4.id
  4 left join hash_join_table t5 on t1.id=t5.id
  5 inner join hash_join_table t6 on t1.id=t6.id
  6 left join hash_join_table t7 on t1.id=t7.id
  7 full outer join hash_join_table t8 on t1.id=t8.id
  8 full join hash_join_table t9 on t1.id=t9.id
  9 full outer join hash_join_table t10 on t1.id=t10.id
 10 right join hash_join_table t11 on t1.id=t11.id
 11 full outer join hash_join_table t12 on t1.id=t12.id
 12 full outer join hash_join_table t13 on t1.id=t13.id
 13 right join hash_join_table t14 on t1.id=t14.id
 14 right join hash_join_table t15 on t1.id=t15.id
 15 right join hash_join_table t16 on t1.id=t16.id
 16 full outer join hash_join_table t17 on t1.id=t17.id
 17 left join hash_join_table t18 on t1.id=t18.id
 18 left join hash_join_table t19 on t1.id=t19.id
 19 right join hash_join_table t20 on t1.id=t20.id
 20 full outer join hash_join_table t21 on t1.id=t21.id
 21 right join hash_join_table t22 on t1.id=t22.id
 22 full outer join hash_join_table t23 on t1.id=t23.id
 23 left join hash_join_table t24 on t1.id=t24.id
 24 inner join hash_join_table t25 on t1.id=t25.id;

COUNT(*)            
--------------------
4                   

1 rows fetched.

SQL> 
SQL> drop table hash_join_table;

Succeed.

SQL> 
SQL> drop table if exists all_datatype_table;

Succeed.

SQL> create table all_datatype_table(id int not null,c_intger integer,c_char char(10))
  2 PARTITION BY RANGE (c_intger)
  3 (
  4 partition P_20180121 values less than (2018),
  5 partition P_20190122 values less than (2019),
  6 partition P_20200123 values less than (2020),
  7 partition P_max values less than (2050)
  8 );

Succeed.

SQL> insert into all_datatype_table values(1,1000,1000);

1 rows affected.

SQL> insert into all_datatype_table values(2,2000,1000);

1 rows affected.

SQL> insert into all_datatype_table values(3,2001,null);

1 rows affected.

SQL> insert into all_datatype_table values(4,2002,'a');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain select * from all_datatype_table t1 join all_datatype_table t2 on t1.c_intger=t2.c_char order by 1,2,3,4,5,6;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                       |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                |       |                       |      |      |       |        |
| 2   |     HASH JOIN(L)                     |       |                       |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[0,4) | SYS   | ALL_DATATYPE_TABLE T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL Filter:[0,4) | SYS   | ALL_DATATYPE_TABLE T2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.C_INTGER = T2.C_CHAR                          

12 rows fetched.

SQL> drop table all_datatype_table;

Succeed.

SQL> 
SQL> ----for choose hash table by table extent pages -------------------------------------------------------------
SQL> drop table if exists hash_join_tbl_000;

Succeed.

SQL> drop table if exists hash_join_com_tbl_001;

Succeed.

SQL> drop table if exists hash_join_com_tbl_001_1;

Succeed.

SQL> create table hash_join_tbl_000(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000),primary key(c_id,c_d_id,c_w_id));

Succeed.

SQL> 
SQL> insert into hash_join_tbl_000 values(1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4800||'1',940||'1'||205||'1',to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,10.0,to_date(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),1,1,lpad('1234ABCDRFGHopqrstuvwxyz8',1500,'ABfgCDefgh'),lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbxxbm',200,'yxcfgdsgtcjxrbxxbm'),lpad('124324543256546324554354325',200,'7687389015'),lpad('sbfacwjpbvpgthpyxcpmnutcjdfaxrbxxbm',200,'yxcpmnutcjxrbxxbm'),lpad('123dSHGGefasdy',200,'678ASVDFopqrst9234'),lpad('12345abcdegf',200,'adbede1fghij1kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp2345abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123895ab456cdef'));

1 rows affected.

SQL> 
SQL> CREATE or replace procedure hash_join_proc_001(startall int,endall int) as
  2 i INT;
  3 BEGIN
  4  if startall < endall then
  5   FOR i IN startall..endall LOOP
  6         insert into hash_join_tbl_000 select c_id+i,c_d_id+i,c_w_id+i,'AA'||'is'||i||'cmvls',c_middle,'AA'||'BAR'||i||'ddBARBAR',c_street_1,c_street_2,c_city,c_state,c_zip,'940205',c_since+i,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end+i,c_unsig+i,c_big+100000*i,c_vchar,lpad('sbfacwjdafgjyjhfpyxcpmnutcjxrbxxbm',200,'yxcfgdsgtcjxrbxxbm'),c_text,c_clob,c_image,lpad('12345abcdegf',200,'adbede1fghij'||i||'kLMHG3FFHUK'),lpad('ede1fghij1kLMHG3',200,'xcp23'||i||'45abcdepmnu'),lpad('1234567890abcdfe',200,'abc1d2fe123'||i||'895ab456cdef') from hash_join_tbl_000 where c_id=1;
  7   END LOOP;
  8  end if;
  9 END;
 10 /

Succeed.

SQL> 
SQL> call hash_join_proc_001(1,1999);

PL/SQL procedure successfully completed.

SQL> 
SQL> create table hash_join_com_tbl_001(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> create unique index primary_key on hash_join_com_tbl_001(c_id,c_d_id,c_w_id);

Succeed.

SQL> 
SQL> create unique index hash_join_indx_001_1 ON hash_join_com_tbl_001(c_id,c_d_id);

Succeed.

SQL> 
SQL> create index hash_join_indx_001_2 ON hash_join_com_tbl_001(c_id);

Succeed.

SQL> 
SQL> create unique index hash_join_indx_001_3 ON hash_join_com_tbl_001(c_big);

Succeed.

SQL> 
SQL> create index hash_join_indx_001_4 ON hash_join_com_tbl_001(c_first,c_binary);

Succeed.

SQL> 
SQL> create index hash_join_indx_001_5 ON hash_join_com_tbl_001(c_id,c_d_id,c_varbinary);

Succeed.

SQL> 
SQL> create index hash_join_indx_001_6 ON hash_join_com_tbl_001(c_id,c_d_id,c_street_1,c_raw);

Succeed.

SQL> 
SQL> 
SQL> create table hash_join_com_tbl_001_1(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> insert into hash_join_com_tbl_001 select * from hash_join_tbl_000 where mod(c_id,2)=1;

1000 rows affected.

SQL> 
SQL> select count(*) from hash_join_com_tbl_001;

COUNT(*)            
--------------------
1000                

1 rows fetched.

SQL> 
SQL> insert into hash_join_com_tbl_001_1 select * from hash_join_tbl_000 where mod(c_id,5)=1;

400 rows affected.

SQL> 
SQL> select count(*) from hash_join_com_tbl_001_1;

COUNT(*)            
--------------------
400                 

1 rows fetched.

SQL> 
SQL> explain select count(1) from hash_join_com_tbl_001_1 t1 inner join hash_join_com_tbl_001 t2 on t1.c_id=t2.c_id+0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   AGGR                            |       |                            |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | HASH_JOIN_COM_TBL_001 T2   |      |      |       |        |
| 4   |         INDEX FAST FULL SCAN      | SYS   | PRIMARY_KEY                |      |      |       |        |
| 5   |       TABLE ACCESS FULL           | SYS   | HASH_JOIN_COM_TBL_001_1 T1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.C_ID + 0 = T1.C_ID                            

13 rows fetched.

SQL> explain select count(1) from hash_join_com_tbl_001 t1 inner join hash_join_com_tbl_001_1 t2 on t1.c_id=t2.c_id+0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   AGGR                            |       |                            |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | HASH_JOIN_COM_TBL_001_1 T2 |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | HASH_JOIN_COM_TBL_001 T1   |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | HASH_JOIN_INDX_001_2       |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.C_ID = T2.C_ID + 0                            

13 rows fetched.

SQL> 
SQL> drop table hash_join_tbl_000;

Succeed.

SQL> drop table hash_join_com_tbl_001;

Succeed.

SQL> drop table hash_join_com_tbl_001_1;

Succeed.

SQL> 
SQL> drop table if exists t_hash_join_plan;

Succeed.

SQL> create table t_hash_join_plan(
  2         c_id int, c_int int, c_integer integer, c_bool int, c_boolean int, c_bigint integer, 
  3         c_real real, c_double real, 
  4         c_decimal decimal(38), c_number number(38), c_numeric numeric(38), 
  5         c_char char(50) default null, c_varchar varchar(20), c_varchar2 varchar2(4000),
  6         c_date date, c_datetime date, c_timestamp timestamp
  7 ) 
  8 PARTITION BY RANGE (c_integer)
  9 (
 10         partition P_20180121 values less than (0),
 11         partition P_20190122 values less than (50000),
 12         partition P_20200123 values less than (100000),
 13         partition P_max values less than (maxvalue)
 14 );

Succeed.

SQL> INSERT INTO t_hash_join_plan VALUES ( 20, 0, 10, 1, 0, -1088618496, 500000, 1000, 9, 5, 8, 'a', 'def', '2003-02-28', TO_DATE('2002-03-18', 'YYYY-MM-DD'), TO_DATE('2003-11-25', 'YYYY-MM-DD'), TO_TIMESTAMP('2004-08-19 21:38:09', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 21, 30000, 20000, 0, 1, 30000, 294453248, 0, 2, -110231552, 9, 'ghi', '2004-05-24', 'kbvumx', TO_DATE('2010-08-08', 'YYYY-MM-DD'), TO_DATE('1995-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2018-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 22, 12, 20000, 1, 1, 0, 1, 10, 3000, 13, 0, 'ekb', 'eekbvumxm', 'd', TO_DATE('1995-08-08', 'YYYY-MM-DD'), TO_DATE('2009-11-25', 'YYYY-MM-DD'), TO_TIMESTAMP('1885-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 23, -1294729216, -1349124096, 1, 1, 1421737984, 10, 20000, 2, 3000, 3000, 'b', '%b%', '2004-06-20 20:20:31', TO_DATE('1880-08-08', 'YYYY-MM-DD'), TO_DATE('2009-11-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2002-05-28 01:05:16', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 24, -1485242368, -480182272, 1, 0, 3000, 1000, 0, 12, 11, 1000, '2005-09-02', 'q', '2001-08-18 14:31:12', TO_DATE('2002-05-09', 'YYYY-MM-DD'), TO_DATE('2005-08-06', 'YYYY-MM-DD'), TO_TIMESTAMP('2012-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 25, 1000, 0, 1, 0, 4, 20000, 3000, -1371799552, -1394540544, 3, 'def', 'abc', '%b%', TO_DATE('2009-02-10', 'YYYY-MM-DD'), TO_DATE('2001-05-14', 'YYYY-MM-DD'), TO_TIMESTAMP('2001-02-18 14:25:33', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 26, 1, 10, 1, 0, 1971322880, 11, 30000, 0, 1088159744, 9, 'abc', '_a_%', 'abe', TO_DATE('2002-12-07', 'YYYY-MM-DD'), TO_DATE('2000-07-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2000-01-01 01:01:01', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 27, 1199702016, 10, 0, 1, 500000, -1063911424, 12, 0, 11, 5, 'abcdef', 'a', 'c', TO_DATE('2009-04-08', 'YYYY-MM-DD'), TO_DATE('2010-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('1880-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 28, 5, 30000, 1, 1, 14, 500000, 5, 292421632, 5, 13, 'c', 'mab', 'b', TO_DATE('2006-02-08', 'YYYY-MM-DD'), TO_DATE('2000-08-08', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 29, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, '', '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 30, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, 'abcdefgaaaaaaaaa', '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> INSERT INTO t_hash_join_plan VALUES ( 31, 1000, 500000, 1, 0, 1221525504, 20000, 2077491200, 13, 12, 40000, null, '2003-07-06 21:08:14', '2004-05-15', TO_DATE('2000-04-20', 'YYYY-MM-DD'), TO_DATE('2008-01-02', 'YYYY-MM-DD'), TO_TIMESTAMP('2011-08-08 08:08:08', 'YYYY-MM-DD HH24:Mi:SS') );

1 rows affected.

SQL> create index t_hash_join_plan_idx1 on t_hash_join_plan(c_id);

Succeed.

SQL> create index t_hash_join_plan_idx2 on t_hash_join_plan(c_integer);

Succeed.

SQL> create index t_hash_join_plan_idx3 on t_hash_join_plan(c_varchar);

Succeed.

SQL> create index t_hash_join_plan_idx4 on t_hash_join_plan(c_char);

Succeed.

SQL> create index t_hash_join_plan_idx5 on t_hash_join_plan(c_timestamp);

Succeed.

SQL> create index t_hash_join_plan_idx6 on t_hash_join_plan(c_id,c_integer,c_number);

Succeed.

SQL> create index t_hash_join_plan_idx7 on t_hash_join_plan(c_id,c_varchar,c_char,c_timestamp);

Succeed.

SQL> commit;

Succeed.

SQL> explain SELECT t1.c_id,t1.c_varchar FROM t_hash_join_plan t1 where t1.c_varchar = any (select c_varchar from t_hash_join_plan where rowid not in (select rowid from t_hash_join_plan where c_id<25));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
| Id  | Description                                   | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                              |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                               |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,4)   | SYS   | T_HASH_JOIN_PLAN T1   |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN                    | SYS   | T_HASH_JOIN_PLAN_IDX7 |      |      |       |        |
| 4   |     KERNEL FILTER                             |       |                       |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 6   |         INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX3 |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 8   |         INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM T_HASH_JOIN_PLAN WHERE ROWID NOT IN((SELECT ROWID FROM T_HASH_JOIN_PLAN WHERE C_ID < 25)))
   5 - filter: ROWID NOT IN((SELECT ROWID FROM T_HASH_JOIN_PLAN WHERE C_ID < 25))
   6 - access: T1.C_VARCHAR = T_HASH_JOIN_PLAN.C_VARCHAR        
   8 - access: C_ID < 25                                        

19 rows fetched.

SQL> explain SELECT t1.c_id,t1.c_varchar FROM t_hash_join_plan t1 where t1.c_varchar = any (select c_varchar from t_hash_join_plan where rowid in (select rowid from t_hash_join_plan where c_id<25));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
| Id  | Description                                   | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                              |       |                       |      |      |       |        |
| 1   |   KERNEL FILTER                               |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,4)   | SYS   | T_HASH_JOIN_PLAN T1   |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN                    | SYS   | T_HASH_JOIN_PLAN_IDX7 |      |      |       |        |
| 4   |     KERNEL FILTER                             |       |                       |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 6   |         INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX3 |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 8   |         INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM T_HASH_JOIN_PLAN WHERE ROWID IN((SELECT ROWID FROM T_HASH_JOIN_PLAN WHERE C_ID < 25)))
   5 - filter: ROWID IN((SELECT ROWID FROM T_HASH_JOIN_PLAN WHERE C_ID < 25))
   6 - access: T1.C_VARCHAR = T_HASH_JOIN_PLAN.C_VARCHAR        
   8 - access: C_ID < 25                                        

19 rows fetched.

SQL> explain select c_id from t_hash_join_plan where rowid not in (select rowid from t_hash_join_plan where c_id=25);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
| Id  | Description                                   | Owner | Name                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                              |       |                       |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)                        |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,4)   | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN                    | SYS   | T_HASH_JOIN_PLAN_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                                 |       |                       |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 6   |         INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: ROWID = ROWID                                    
   6 - access: C_ID = 25                                        

15 rows fetched.

SQL> explain select c_id from t_hash_join_plan where rowid in (select rowid from t_hash_join_plan where c_id=25);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                     | Owner | Name                  | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                                |       |                       |      |      |       |        |
| 1   |   NESTED LOOPS                                  |       |                       |      |      |       |        |
| 2   |     SUBSELECT                                   |       |                       |      |      |       |        |
| 3   |       HASH DISTINCT                             |       |                       |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY Filter:[0,4) | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 5   |           INDEX RANGE SCAN                      | SYS   | T_HASH_JOIN_PLAN_IDX1 |      |      |       |        |
| 6   |     TABLE ACCESS BY ROWID                       | SYS   | T_HASH_JOIN_PLAN      |      |      |       |        |
| 7   |       ROWID SCAN                                |       |                       |      |      |       |        |
------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: C_ID = 25                                        
   7 - access: ROWID = ROWID                                    

16 rows fetched.

SQL> drop table t_hash_join_plan;

Succeed.

SQL> 
SQL> DROP TABLE if exists hj_t1;

Succeed.

SQL> DROP TABLE if exists hj_t2;

Succeed.

SQL> DROP TABLE if exists hj_t3;

Succeed.

SQL> DROP TABLE if exists hj_t4;

Succeed.

SQL> 
SQL> --hash join should not have index
SQL> create table hj_t1(f1 int, f2 int, f3 varchar(100));

Succeed.

SQL> create table hj_t2(f1 int, f2 int, f3 varchar(100));

Succeed.

SQL> create table hj_t3(f1 int, f2 int, f3 varchar(100));

Succeed.

SQL> create table hj_t4(f1 int, f2 int, f3 varchar(100));

Succeed.

SQL> 
SQL> insert into hj_t1 values(1,1,'a');

1 rows affected.

SQL> insert into hj_t1 values(2,2,'a');

1 rows affected.

SQL> insert into hj_t1 values(4,4,'a');

1 rows affected.

SQL> insert into hj_t1 values(5,2,'c');

1 rows affected.

SQL> insert into hj_t2 values(1,2,'a');

1 rows affected.

SQL> insert into hj_t2 values(2,3,'a');

1 rows affected.

SQL> insert into hj_t2 values(3,null,'a');

1 rows affected.

SQL> insert into hj_t3 values(1,1,'a');

1 rows affected.

SQL> insert into hj_t3 values(2,2,'b');

1 rows affected.

SQL> insert into hj_t3 values(4,4,'c');

1 rows affected.

SQL> insert into hj_t4 values(1,1,'c');

1 rows affected.

SQL> insert into hj_t4 values(3,3,'b');

1 rows affected.

SQL> insert into hj_t4 values(4,4,'a');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> EXPLAIN SELECT * FROM hj_t1 t1,hj_t2 t2 WHERE EXISTS(SELECT 1 FROM hj_t3 t3 where t3.f1=t1.f1 and t3.f2=t2.f2) order by t1.f1,t2.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)      |       |          |      |      |       |        |
| 3   |       NESTED LOOPS         |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |       SUBSELECT            |       |          |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F2 = T3.F2 AND T1.F1 = T3.F1                  

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1,hj_t2 t2 WHERE NOT EXISTS(SELECT 1 FROM hj_t3 t3 where t3.f1=t1.f1 and t3.f2=t2.f2) order by t1.f1,t2.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 3   |       NESTED LOOPS         |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |       SUBSELECT            |       |          |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F2 = T3.F2 AND T1.F1 = T3.F1                  

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND ROWNUM < 2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       ROWNUM FILTER        |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE ROWNUM < 2 AND T2.F1 = T1.F1)
   4 - filter: ROWNUM < 2                                       
   5 - filter: T2.F1 = T1.F1                                    

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND ROWNUM < 2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       ROWNUM FILTER        |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: NOT EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE ROWNUM < 2 AND T2.F1 = T1.F1)
   4 - filter: ROWNUM < 2                                       
   5 - filter: T2.F1 = T1.F1                                    

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1, (SELECT * FROM hj_t2 order by f2) t2 WHERE EXISTS(SELECT 1 FROM hj_t3 t3 where t3.f1=t1.f1 and t3.f2=t2.f2) order by t1.f1,t2.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(R)        |       |          |      |      |       |        |
| 3   |       NESTED LOOPS           |       |          |      |      |       |        |
| 4   |         SUBSELECT            |       | T2       |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 7   |       SUBSELECT              |       |          |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F2 = T3.F2 AND T1.F1 = T3.F1                  

16 rows fetched.

SQL> 
SQL> --not exists has OR cond
SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND (t1.f1 is null or t2.f1 is null));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |          |      |      |       |        |
| 1   |   KERNEL FILTER        |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: NOT EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE T2.F1 = T1.F1 AND T1.F1 IS NULL OR T2.F1 IS NULL)
   3 - filter: T2.F1 = T1.F1 AND T1.F1 IS NULL OR T2.F1 IS NULL 

12 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND (t2.f2 is null or t2.f2 = 0));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |          |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   4 - filter: T2.F2 IS NULL OR T2.F2 = 0                       

13 rows fetched.

SQL> 
SQL> --sql cannot use semi or anti join
SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND ROWNUM < 2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       ROWNUM FILTER        |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE ROWNUM < 2 AND T2.F1 = T1.F1)
   4 - filter: ROWNUM < 2                                       
   5 - filter: T2.F1 = T1.F1                                    

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 WHERE t2.f1=t1.f1 AND ROWNUM < 2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       ROWNUM FILTER        |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: NOT EXISTS(SELECT 1 FROM HJ_T2 T2 WHERE ROWNUM < 2 AND T2.F1 = T1.F1)
   4 - filter: ROWNUM < 2                                       
   5 - filter: T2.F1 = T1.F1                                    

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE t1.f1 IN (SELECT t2.f1 FROM hj_t2 t2 WHERE ROWNUM < 2 ) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)        |       |          |      |      |       |        |
| 3   |       SUBSELECT              |       |          |      |      |       |        |
| 4   |         ROWNUM FILTER        |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |       TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F1 = T1.F1                                       
   4 - filter: ROWNUM < 2                                       

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE t1.f1 NOT IN (SELECT t2.f1 FROM hj_t2 t2 WHERE ROWNUM < 2 ) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |          |      |      |       |        |
| 2   |     HASH JOIN ANTI NA(R)     |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       SUBSELECT              |       |          |      |      |       |        |
| 5   |         ROWNUM FILTER        |       |          |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.F1 = F1                                       
   5 - filter: ROWNUM < 2                                       

15 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE EXISTS(SELECT 1 FROM hj_t2 t2 LEFT JOIN hj_t3 t3 ON t2.f2=t3.f2 where t3.f1=t1.f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)        |       |          |      |      |       |        |
| 3   |       SUBSELECT              |       |          |      |      |       |        |
| 4   |         HASH JOIN OUTER(R)   |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |       TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T3.F1 = T1.F1                                    
   4 - access: T2.F2 = T3.F2                                    

16 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE EXISTS(SELECT 1 FROM hj_t2 t2 LEFT JOIN hj_t3 t3 ON t2.f2=t3.f2 and t3.f1=t1.f1 where t2.f1 = t1.f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       NESTED LOOPS OUTER   |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM HJ_T2 T2 LEFT JOIN HJ_T3 T3 ON T2.F2 = T3.F2 AND T3.F1 = T1.F1 WHERE T2.F1 = T1.F1)
   5 - filter: T2.F1 = T1.F1                                    
   6 - filter: T2.F2 = T3.F2 AND T3.F1 = T1.F1                  

16 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 LEFT JOIN hj_t3 t3 ON t2.f2=t3.f2 where t3.f1=t1.f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |          |      |      |       |        |
| 2   |     HASH JOIN ANTI(R)        |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       SUBSELECT              |       |          |      |      |       |        |
| 5   |         HASH JOIN OUTER(R)   |       |          |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 7   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.F1 = T3.F1                                    
   5 - access: T2.F2 = T3.F2                                    

16 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT 1 FROM hj_t2 t2 LEFT JOIN hj_t3 t3 ON t2.f2=t3.f2 and t3.f1=t1.f1 where t2.f1 = t1.f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     KERNEL FILTER          |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       NESTED LOOPS OUTER   |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: NOT EXISTS(SELECT 1 FROM HJ_T2 T2 LEFT JOIN HJ_T3 T3 ON T2.F2 = T3.F2 AND T3.F1 = T1.F1 WHERE T2.F1 = T1.F1)
   5 - filter: T2.F1 = T1.F1                                    
   6 - filter: T2.F2 = T3.F2 AND T3.F1 = T1.F1                  

16 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE EXISTS(SELECT f1 FROM hj_t2 t2 where t2.f1 = t1.f1 group by f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F1 = T1.F1                                    

13 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE NOT EXISTS(SELECT f1 FROM hj_t2 t2 where t2.f1=t1.f1 group by f1) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       SUBSELECT            |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.F1 = T2.F1                                    

13 rows fetched.

SQL> 
SQL> --sql that can use semi or hash join, but not implemented
SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE t1.f1 IN(SELECT t2.f1 FROM hj_t2 t2 WHERE t2.f2=t1.f2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY      |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F1 = T1.F1 AND T2.F2 = T1.F2                  

13 rows fetched.

SQL> EXPLAIN SELECT * FROM hj_t1 t1 WHERE t1.f1 NOT IN(SELECT t2.f1 FROM hj_t2 t2 WHERE t2.f2=t1.f2) order by t1.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY    |       |          |      |      |       |        |
| 2   |     KERNEL FILTER        |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: T1.F1 NOT IN((SELECT F1 FROM HJ_T2 T2 WHERE T2.F2 = T1.F2))
   4 - filter: T2.F2 = T1.F2                                    

13 rows fetched.

SQL> 
SQL> --delete/update using hash join
SQL> explain  delete from t1, t2 using hj_t1 t1, hj_t2 t2 where t1.f1 = t2.f1 and t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | DELETE STATEMENT       |       |          |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   2 - filter: T1.F1 = 1                                        
   3 - filter: T2.F1 = 1                                        

13 rows fetched.

SQL> explain delete from t1, t2 using hj_t1 t1 left join hj_t2 t2 on t1.f1 = t2.f1 where t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | DELETE STATEMENT       |       |          |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   2 - filter: T1.F1 = 1                                        
   3 - filter: T2.F1 = 1                                        

13 rows fetched.

SQL> explain delete from hj_t1 t1 where t1.f1 in (select f1 from hj_t2 t2 where t2.f2 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F1 = T1.F1                                    
   3 - filter: T2.F2 = 1                                        

13 rows fetched.

SQL> explain delete from hj_t1 t1 where exists (select 1 from hj_t2 t2 where t2.f1 = t1.f1 and t2.f2 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F1 = T1.F1                                    
   3 - filter: T2.F2 = 1                                        

13 rows fetched.

SQL> explain update hj_t1 t1, hj_t2 t2 set t1.f3 = 'aaa', t2.f3 = 'bbb' where t1.f1=t2.f1 and t1.f1 = 1;  

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT       |       |          |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   2 - filter: T1.F1 = 1                                        
   3 - filter: T2.F1 = 1                                        

13 rows fetched.

SQL> explain update hj_t1 t1 join hj_t2 t2 on t1.f1=t2.f1 set t1.f3 = 'aaa', t2.f3 = 'bbb' where t1.f1 = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT       |       |          |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   2 - filter: T1.F1 = 1                                        
   3 - filter: T2.F1 = 1                                        

13 rows fetched.

SQL> --delete/update subselect using hash join
SQL> explain delete from hj_t1 where f1 in (select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F1 = F1                                    

12 rows fetched.

SQL> explain delete from hj_t1 where f1 not in(select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)   |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: F1 = F1                                          

12 rows fetched.

SQL> explain delete from hj_t1 where exists (select 1 from hj_t3 t3 where t3.f1 = hj_t1.f1); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1    |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T3.F1 = HJ_T1.F1                                 

12 rows fetched.

SQL> explain delete from hj_t1 where not exists (select 1 from hj_t2 t2 where t2.f1 = hj_t1.f1); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1    |      |      |       |        |
| 3   |     SUBSELECT            |       |          |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T1.F1 = T2.F1                                 

12 rows fetched.

SQL> explain UPDATE hj_t1 t1 SET t1.f3 = 'aaa' where t1.f1 in (select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F1 = T1.F1                                 

12 rows fetched.

SQL> explain UPDATE hj_t1 t1 SET t1.f3 = 'bbb' where t1.f1 not in (select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)   |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |          |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2    |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = F1                                       

12 rows fetched.

SQL> explain UPDATE hj_t1 t1 SET t1.f3 = 'ccc' where exists (select 1 from hj_t2 t2 where t2.f1 = t1.f1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 2   |     SUBSELECT            |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F1 = T1.F1                                    

12 rows fetched.

SQL> explain UPDATE hj_t1 t1 SET t1.f3 = 'ddd' where not exists (select 1 from hj_t2 t2 where t2.f1 = t1.f1); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |          |      |      |       |        |
| 1   |   HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |          |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    

12 rows fetched.

SQL> 
SQL> --delete cannot rewrite
SQL> explain delete from hj_t1 where rowid in (
  2 select a.rowid from hj_t1 a where a.f1 = 1 and a.f2 = 1 
  3 and not exists (select 1 from hj_t2 where f1 = a.f1 and f2 = a.f2 and (f3=a.f3 or (f3 is null and a.f3 is null))));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT             |       |         |      |      |       |        |
| 1   |   NESTED LOOPS               |       |         |      |      |       |        |
| 2   |     SUBSELECT                |       |         |      |      |       |        |
| 3   |       HASH DISTINCT          |       |         |      |      |       |        |
| 4   |         KERNEL FILTER        |       |         |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T1 A |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T2   |      |      |       |        |
| 7   |     TABLE ACCESS BY ROWID    | SYS   | HJ_T1   |      |      |       |        |
| 8   |       ROWID SCAN             |       |         |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: A.F1 = 1 AND A.F1 = A.F2 AND A.F2 = 1 AND NOT EXISTS(SELECT 1 FROM HJ_T2 WHERE F1 = 1 AND 
               F2 = 1 AND F2 = A.F2 AND F1 = A.F1 AND F3 = A.F3 OR F3 IS NULL AND A.F3 IS NULL)
   6 - filter: F1 = 1 AND F3 = A.F3 OR F3 IS NULL AND A.F3 IS NULL AND F2 = A.F2 AND F2 = 1 AND F1 = A.F1
   8 - access: ROWID = ROWID                                    

19 rows fetched.

SQL> delete from hj_t1 where rowid in (
  2 select a.rowid from hj_t1 a where a.f1 = 1 and a.f2 = 1 
  3 and not exists (select 1 from hj_t2 where f1 = a.f1 and f2 = a.f2 and (f3=a.f3 or (f3 is null and a.f3 is null))));

1 rows affected.

SQL> 
SQL> --in to exist with rowid
SQL> explain delete from hj_t1 where rowid in (select t1.rowid from hj_t1 t1 where t1.f1 >1 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT           |       |          |      |      |       |        |
| 1   |   NESTED LOOPS             |       |          |      |      |       |        |
| 2   |     SUBSELECT              |       |          |      |      |       |        |
| 3   |       HASH DISTINCT        |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 5   |     TABLE ACCESS BY ROWID  | SYS   | HJ_T1    |      |      |       |        |
| 6   |       ROWID SCAN           |       |          |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: T1.F1 > 1                                        
   6 - access: ROWID = ROWID                                    

15 rows fetched.

SQL> explain delete from hj_t1 where rowid in (select hj_t1.rowid from hj_t2 t1, hj_t3 t2 where t1.f1 = t2.f1 and 
  2 not exists (select 1 from hj_t1 c where c.f1 = t1.f1 and c.f1 = 1));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)          |       |          |      |      |       |        |
| 2   |     SUBSELECT                |       |          |      |      |       |        |
| 3   |       HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T2 |      |      |       |        |
| 7   |         SUBSELECT            |       |          |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | HJ_T1 C  |      |      |       |        |
| 9   |     TABLE ACCESS FULL        | SYS   | HJ_T1    |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: NA = NA                                          
   3 - access: T1.F1 = C.F1                                     
   4 - access: T1.F1 = T2.F1                                    
   8 - filter: C.F1 = 1                                         

20 rows fetched.

SQL> explain delete from hj_t1 where rowid in (select hj_t1.rowid from hj_t2 t1, hj_t3 t2 where hj_t1.f1 = t1.f1 and t1.f1 = t2.f1 and 
  2 not exists (select 1 from hj_t1 c where c.f1 = t1.f1 and c.f1 = 1));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)          |       |          |      |      |       |        |
| 2   |     SUBSELECT                |       |          |      |      |       |        |
| 3   |       HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T2 |      |      |       |        |
| 7   |         SUBSELECT            |       |          |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | HJ_T1 C  |      |      |       |        |
| 9   |     TABLE ACCESS FULL        | SYS   | HJ_T1    |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = HJ_T1.F1 AND T2.F1 = HJ_T1.F1            
   3 - access: T1.F1 = C.F1                                     
   4 - access: T1.F1 = T2.F1                                    
   8 - filter: C.F1 = 1                                         

20 rows fetched.

SQL> explain delete from hj_t1 where rowid in (select hj_t1.rowid from hj_t2 t1, hj_t3 t2 where hj_t1.f1 = t1.f1 and t1.f1 = t2.f1 and 
  2 not exists (select 1 from hj_t1 c where c.f1 = t1.f1 and c.f1 = 1));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)          |       |          |      |      |       |        |
| 2   |     SUBSELECT                |       |          |      |      |       |        |
| 3   |       HASH JOIN ANTI(R)      |       |          |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T2 |      |      |       |        |
| 7   |         SUBSELECT            |       |          |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | HJ_T1 C  |      |      |       |        |
| 9   |     TABLE ACCESS FULL        | SYS   | HJ_T1    |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = HJ_T1.F1 AND T2.F1 = HJ_T1.F1            
   3 - access: T1.F1 = C.F1                                     
   4 - access: T1.F1 = T2.F1                                    
   8 - filter: C.F1 = 1                                         

20 rows fetched.

SQL> 
SQL> --or cond with no ancestor 
SQL> explain select * from hj_t1 t1 where exists (select 1 from hj_t2 t2, hj_t3 t3 where t2.f1 = t1.f1 and t2.f2=t3.f2 and (t2.f1=1 or t2.f1 = 0));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)        |       |          |      |      |       |        |
| 2   |     SUBSELECT              |       |          |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 6   |     TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T2.F1 = T1.F1                                    
   3 - access: T2.F2 = T3.F2                                    
   4 - filter: T2.F1 = 1 OR T2.F1 = 0                           

16 rows fetched.

SQL> 
SQL> --DTS2018122802240
SQL> delete from hj_t1;

3 rows affected.

SQL> delete from hj_t2;

3 rows affected.

SQL> delete from hj_t3;

3 rows affected.

SQL> insert into hj_t1 values(1,1,'a');

1 rows affected.

SQL> insert into hj_t1 values(2,2,'a');

1 rows affected.

SQL> insert into hj_t1 values(4,4,'a');

1 rows affected.

SQL> insert into hj_t1 values(5,2,'c');

1 rows affected.

SQL> insert into hj_t2 values(1,2,'a');

1 rows affected.

SQL> insert into hj_t2 values(2,3,'a');

1 rows affected.

SQL> insert into hj_t2 values(3,null,'a');

1 rows affected.

SQL> insert into hj_t3 values(1,1,'a');

1 rows affected.

SQL> insert into hj_t3 values(2,2,'b');

1 rows affected.

SQL> insert into hj_t3 values(4,4,'c');

1 rows affected.

SQL> commit;

Succeed.

SQL> update hj_t1 join hj_t2 on hj_t1.f1=hj_t2.f2 set hj_t1.f3 = 'aaaa' where hj_t2.f2 in (select f2 from hj_t3);

1 rows affected.

SQL> select hj_t1.* from hj_t1 join hj_t2 on hj_t1.f1=hj_t2.f2 where hj_t2.f2 in (select f2 from hj_t3) order by 1;

F1           F2           F3                                                              
------------ ------------ ----------------------------------------------------------------
2            2            aaaa                                                            

1 rows fetched.

SQL> UPDATE hj_t1 set f3 = 'aaa' where f1 = (select MIN(F1) from hj_t2);

1 rows affected.

SQL> DELETE FROM hj_t1 where f1 = (select MIN(F2) from hj_t2);

1 rows affected.

SQL> INSERT INTO hj_t3(f1, f2, f3) SELECT * from hj_t1 where not exists (select 1 from hj_t2 where hj_t2.f1 = hj_t1.f1);

2 rows affected.

SQL> SELECT * FROM HJ_T1 ORDER BY F1;

F1           F2           F3                                                              
------------ ------------ ----------------------------------------------------------------
1            1            aaa                                                             
4            4            a                                                               
5            2            c                                                               

3 rows fetched.

SQL> SELECT * FROM HJ_T3 ORDER BY F1, F2, F3;

F1           F2           F3                                                              
------------ ------------ ----------------------------------------------------------------
1            1            a                                                               
2            2            b                                                               
4            4            a                                                               
4            4            c                                                               
5            2            c                                                               

5 rows fetched.

SQL> 
SQL> explain update hj_t1 t1 set t1.f3 = (select concat(t2.f3,t3.f3) from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t2.f1=t1.f1) where exists(select 1 from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t2.f1=t1.f1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)         |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)        |       |          |      |      |       |        |
| 3   |       SUBSELECT              |       |          |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |       TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
| 8   |     SUBSELECT                |       |          |      |      |       |        |
| 9   |       HASH JOIN(L)           |       |          |      |      |       |        |
| 10  |         TABLE ACCESS FULL    | SYS   | HJ_T2 T2 |      |      |       |        |
| 11  |         TABLE ACCESS FULL    | SYS   | HJ_T3 T3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T3.F1 AND T1.F1 = T2.F1                  
   2 - access: T3.F1 = T1.F1 AND T2.F1 = T1.F1                  
   4 - access: T2.F1 = T3.F1                                    
   9 - access: T2.F1 = T3.F1                                    

22 rows fetched.

SQL> explain update hj_t1 t1 set t1.f3 = (select concat(t2.f3,t3.f3) from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t2.f1=1) where exists (select 1 from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t2.f1=1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT           |       |          |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)        |       |          |      |      |       |        |
| 2   |     SUBSELECT              |       |          |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T2 T2 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 6   |     TABLE ACCESS FULL      | SYS   | HJ_T1 T1 |      |      |       |        |
| 7   |   HASH JOIN(L)             |       |          |      |      |       |        |
| 8   |     TABLE ACCESS FULL      | SYS   | HJ_T2 T2 |      |      |       |        |
| 9   |     TABLE ACCESS FULL      | SYS   | HJ_T3 T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: NA = NA                                          
   3 - access: T2.F1 = T3.F1                                    
   4 - filter: T2.F1 = 1                                        
   5 - filter: T3.F1 = 1                                        
   7 - access: T2.F1 = T3.F1                                    
   8 - filter: T2.F1 = 1                                        
   9 - filter: T3.F1 = 1                                        

23 rows fetched.

SQL> explain update hj_t1 t1 set f3 = (select t2.f3||t3.f3 from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t1.f1=t2.f1 union select t3.f3||t4.f3 from hj_t3 t3 join hj_t4 t4 on t3.f1=t4.f1 where exists(select 1 from hj_t1 t1 where t1.f1=t3.f1)) where exists (select 1 from hj_t2 t2 join hj_t3 t3 on t2.f1=t3.f1 where t1.f1=t2.f1 union select 1 from hj_t3 t3 join hj_t4 t4 on t3.f1=t4.f1 where exists(select 1 from hj_t1 t1 where t1.f1=t3.f1));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT             |       |          |      |      |       |        |
| 1   |   KERNEL FILTER              |       |          |      |      |       |        |
| 2   |     TABLE ACCESS FULL        | SYS   | HJ_T1 T1 |      |      |       |        |
| 3   |     HASH UNION               |       |          |      |      |       |        |
| 4   |       NESTED LOOPS           |       |          |      |      |       |        |
| 5   |         TABLE ACCESS FULL    | SYS   | HJ_T2 T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | HJ_T3 T3 |      |      |       |        |
| 7   |       NESTED LOOPS           |       |          |      |      |       |        |
| 8   |         KERNEL FILTER        |       |          |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | HJ_T3 T3 |      |      |       |        |
| 10  |           TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 11  |         KERNEL FILTER        |       |          |      |      |       |        |
| 12  |           TABLE ACCESS FULL  | SYS   | HJ_T4 T4 |      |      |       |        |
| 13  |           TABLE ACCESS FULL  | SYS   | HJ_T1 T1 |      |      |       |        |
| 14  |   HASH UNION                 |       |          |      |      |       |        |
| 15  |     NESTED LOOPS             |       |          |      |      |       |        |
| 16  |       TABLE ACCESS FULL      | SYS   | HJ_T2 T2 |      |      |       |        |
| 17  |       TABLE ACCESS FULL      | SYS   | HJ_T3 T3 |      |      |       |        |
| 18  |     NESTED LOOPS             |       |          |      |      |       |        |
| 19  |       KERNEL FILTER          |       |          |      |      |       |        |
| 20  |         TABLE ACCESS FULL    | SYS   | HJ_T3 T3 |      |      |       |        |
| 21  |         TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 22  |       KERNEL FILTER          |       |          |      |      |       |        |
| 23  |         TABLE ACCESS FULL    | SYS   | HJ_T4 T4 |      |      |       |        |
| 24  |         TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS((SELECT 1 FROM HJ_T2 T2 INNER JOIN HJ_T3 T3 WHERE T3.F1 = T1.F1 AND T2.F1 = T1.F1 AND 
               T2.F1 = T3.F1) UNION (SELECT 1 FROM HJ_T3 T3 INNER JOIN HJ_T4 T4 WHERE T3.F1 = T4.F1 AND 
               EXISTS(SELECT 1 FROM HJ_T1 T1 WHERE T1.F1 = T3.F1)))
   5 - filter: T2.F1 = T1.F1                                    
   6 - filter: T3.F1 = T1.F1 AND T2.F1 = T3.F1                  
   9 - filter: EXISTS(SELECT 1 FROM HJ_T1 T1 WHERE T1.F1 = T3.F1)
   10 - filter: T1.F1 = T3.F1                                   
   12 - filter: T3.F1 = T4.F1                                   
   13 - filter: T1.F1 = T3.F1                                   
   16 - filter: T2.F1 = T1.F1                                   
   17 - filter: T3.F1 = T1.F1 AND T2.F1 = T3.F1                 
   20 - filter: EXISTS(SELECT 1 FROM HJ_T1 T1 WHERE T1.F1 = T3.F1)
   21 - filter: T1.F1 = T3.F1                                   
   23 - filter: T3.F1 = T4.F1                                   
   24 - filter: T1.F1 = T3.F1                                   

46 rows fetched.

SQL> 
SQL> 
SQL> --Bugfix: in hash optimz coredump--
SQL> CREATE or replace procedure sp_Init_RXUBPSupport_A4() is
  2 i int := 1;
  3 cunt INT := 0;
  4 BEGIN
  5   if i IN (1,2,3,4,5,6,7,8,9,10) then
  6     insert into hj_t1(f1,f2) select f1,f2 from hj_t2 where f1 in(1,2,3,4,5,6,7,8,9,10);
  7     select count(*) INTO cunt from hj_t1 where f1 in(1,2,3,4,5,6,7,8,9,10);
  8     dbe_output.print_line(cunt);
  9   end if;
 10 END;
 11 /

Succeed.

SQL> set serveroutput on;

ON
SQL> call sp_Init_RXUBPSupport_A4();

6

PL/SQL procedure successfully completed.

SQL> set serveroutput off;

OFF
SQL> drop procedure sp_Init_RXUBPSupport_A4;

Succeed.

SQL> 
SQL> --any optimizer
SQL> --f1=any => in
SQL> --f1>any => f1>min
SQL> --f1<>any => exists
SQL> explain select * from hj_t1 where f1 = any(select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |       |      |      |       |        |
| 2   |     SUBSELECT            |       |       |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: HJ_T2.F1 = F1                                    

12 rows fetched.

SQL> explain select * from hj_t1 where f1 > any(select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description              | Owner | Name  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |       |      |      |       |        |
| 1   |   KERNEL FILTER          |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | HJ_T1 |      |      |       |        |
| 3   |     AGGR                 |       |       |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F1 > (SELECT MIN(HJ_T2.F1) FROM HJ_T2)           

12 rows fetched.

SQL> explain select * from hj_t1 where f1 <> any(select f1 from hj_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------
| Id  | Description            | Owner | Name  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |       |      |      |       |        |
| 1   |   KERNEL FILTER        |       |       |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | HJ_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | HJ_T2 |      |      |       |        |
-------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM HJ_T2 WHERE HJ_T2.F1 != F1) 
   3 - filter: HJ_T2.F1 != F1                                   

12 rows fetched.

SQL> 
SQL> DROP TABLE hj_t1;

Succeed.

SQL> DROP TABLE hj_t2;

Succeed.

SQL> DROP TABLE hj_t3;

Succeed.

SQL> DROP TABLE hj_t4;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS LINEITEM;

Succeed.

SQL> CREATE TABLE LINEITEM ( L_ORDERKEY    INTEGER NOT NULL,			
  2                              L_PARTKEY     INTEGER NOT NULL,			
  3                              L_SUPPKEY     INTEGER NOT NULL,			
  4                              L_LINENUMBER  INTEGER NOT NULL,			
  5                              L_QUANTITY    DECIMAL(15,2) NOT NULL,			
  6                              L_EXTENDEDPRICE  DECIMAL(15,2) NOT NULL,			
  7                              L_DISCOUNT    DECIMAL(15,2) NOT NULL,			
  8                              L_TAX         DECIMAL(15,2) NOT NULL,			
  9                              L_RETURNFLAG  CHAR(1) NOT NULL,			
 10                              L_LINESTATUS  CHAR(1) NOT NULL,			
 11                              L_SHIPDATE    DATE NOT NULL,			
 12                              L_COMMITDATE  DATE NOT NULL,			
 13                              L_RECEIPTDATE DATE NOT NULL,			
 14                              L_SHIPINSTRUCT CHAR(25) NOT NULL,			
 15                              L_SHIPMODE     CHAR(10) NOT NULL,			
 16                              L_COMMENT      VARCHAR(44) NOT NULL);			

Succeed.

SQL> 
SQL> ALTER TABLE LINEITEM ADD CONSTRAINT PK_LINEITEM PRIMARY KEY (L_ORDERKEY,L_LINENUMBER);

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS PART;

Succeed.

SQL> CREATE TABLE PART  ( P_PARTKEY     INTEGER NOT NULL,			
  2                           P_NAME        VARCHAR(55) NOT NULL,			
  3                           P_MFGR        CHAR(25) NOT NULL,			
  4                           P_BRAND       CHAR(10) NOT NULL,			
  5                           P_TYPE        VARCHAR(25) NOT NULL,			
  6                           P_SIZE        INTEGER NOT NULL,			
  7                           P_CONTAINER   CHAR(10) NOT NULL,			
  8                           P_RETAILPRICE DECIMAL(15,2) NOT NULL,			
  9                           P_COMMENT     VARCHAR(23) NOT NULL );			

Succeed.

SQL> 
SQL> ALTER TABLE PART ADD CONSTRAINT PK_PART PRIMARY KEY (P_PARTKEY);	

Succeed.

SQL> 
SQL> explain plan for select
  2  sum(l_extendedprice* (1 - l_discount)) as revenue
  3 from
  4  lineitem,
  5  part
  6 where
  7  (
  8   p_partkey  =  l_partkey
  9   and p_brand = 'Brand#43'
 10   and p_container in ('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG')
 11   and l_quantity >= 9 and l_quantity <= 9 + 10
 12   and p_size between 1 and 5
 13   and l_shipmode in ('AIR', 'AIR REG')
 14   and l_shipinstruct = 'DELIVER IN PERSON'
 15  )
 16  or
 17  (
 18   p_partkey  =  l_partkey
 19   and p_brand = 'Brand#34'
 20   and p_container in ('MED BAG', 'MED BOX', 'MED PKG', 'MED PACK')
 21   and l_quantity >= 10 and l_quantity <= 10 + 10
 22   and p_size between 1 and 10
 23   and l_shipmode in ('AIR', 'AIR REG')
 24   and l_shipinstruct = 'DELIVER IN PERSON'
 25  )
 26  or
 27  (
 28   p_partkey  =  l_partkey
 29   and p_brand = 'Brand#14'
 30   and p_container in ('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG')
 31   and l_quantity >= 23 and l_quantity <= 23 + 10
 32   and p_size between 1 and 15
 33   and l_shipmode in ('AIR', 'AIR REG')
 34   and l_shipinstruct = 'DELIVER IN PERSON'
 35  );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |          |      |      |       |        |
| 1   |   AGGR                             |       |          |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |          |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | LINEITEM |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | PART     |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN          | SYS   | PK_PART  |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: L_SHIPMODE IN('AIR', 'AIR REG') AND L_SHIPINSTRUCT = 'DELIVER IN PERSON'
   4 - filter: P_BRAND = 'Brand#43' AND P_CONTAINER IN('SM CASE', 'SM BOX', 'SM PACK', 'SM PKG') AND L_QUANTITY >= 9 AND 
               L_QUANTITY <= 19 AND P_SIZE BETWEEN 1 AND 5 OR P_BRAND = 'Brand#34' AND P_CONTAINER IN('MED BAG', 
               'MED BOX', 'MED PKG', 'MED PACK') AND L_QUANTITY >= 10 AND L_QUANTITY <= 20 AND P_SIZE BETWEEN 1 AND 10 OR 
               P_BRAND = 'Brand#14' AND P_CONTAINER IN('LG CASE', 'LG BOX', 'LG PACK', 'LG PKG') AND L_QUANTITY >= 23 AND 
               L_QUANTITY <= 33 AND P_SIZE BETWEEN 1 AND 15     
   5 - access: P_PARTKEY = L_PARTKEY                            

19 rows fetched.

SQL> 
SQL> drop table if exists offers_20050701;

Succeed.

SQL> create table offers_20050701
  2 (
  3     PROMO_ID VARCHAR(10) NOT NULL ,
  4     PARTY_ID VARCHAR(10) NULL,
  5     LOCATION_ID number(17,0) NULL ,
  6     PARTY_FIRSTNAME VARCHAR(20) NULL ,
  7     PARTY_LASTNAME VARCHAR(20) NULL ,
  8     VISITS number(38,20) NULL ,
  9     CLUB_LEVEL CHAR(7) NULL 
 10 );

Succeed.

SQL> create unique index index_007 on offers_20050701(promo_id,LOCATION_ID,club_level);

Succeed.

SQL> 
SQL> drop table if exists all_divisions;

Succeed.

SQL> create table all_divisions
  2 (
  3     all_divisions_cd varchar(50) not null ,
  4     all_divisions_name varchar(100) null
  5 );

Succeed.

SQL> create unique index index_008 on all_divisions(all_divisions_cd);

Succeed.

SQL> 
SQL> explain SELECT Table_005.all_divisions_cd   Column_005,
  2        Table_005.all_divisions_name Column_006
  3   FROM offers_20050701 Table_007, all_divisions Table_005
  4  RIGHT OUTER JOIN all_divisions
  5     ON Table_005.all_divisions_cd <> Table_005.all_divisions_cd
  6    AND Table_005.all_divisions_name = Table_005.all_divisions_name
  7  ORDER BY 1, 2 DESC LIMIT 8;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                           |      |      |       |        |
| 1   |   QUERY LIMIT                         |       |                           |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM        |       |                           |      |      |       |        |
| 3   |       NESTED LOOPS                    |       |                           |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY    | SYS   | OFFERS_20050701 TABLE_007 |      |      |       |        |
| 5   |           INDEX FAST FULL SCAN        | SYS   | INDEX_007                 |      |      |       |        |
| 6   |         NESTED LOOPS OUTER            |       |                           |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ONLY  | SYS   | ALL_DIVISIONS             |      |      |       |        |
| 8   |             INDEX FAST FULL SCAN      | SYS   | INDEX_008                 |      |      |       |        |
| 9   |           TABLE ACCESS FULL           | SYS   | ALL_DIVISIONS TABLE_005   |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   9 - filter: TABLE_005.ALL_DIVISIONS_CD != TABLE_005.ALL_DIVISIONS_CD AND TABLE_005.ALL_DIVISIONS_NAME = TABLE_005.ALL_DIVISIONS_NAME

17 rows fetched.

SQL> 
SQL> drop table if exists offers_20050701;

Succeed.

SQL> drop table if exists all_divisions;

Succeed.

SQL> 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> drop table if exists t_join_base_102;

Succeed.

SQL> drop table if exists t_join_base_103;

Succeed.

SQL> drop table if exists t_join_base_104;

Succeed.

SQL> drop table if exists t_join_base_105;

Succeed.

SQL> 
SQL> create table t_join_base_001(id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> insert into t_join_base_001 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_001 values(0,null,null,null,null,null,null,null,null,null,null,null,null,null,null);

1 rows affected.

SQL> 
SQL> create table t_join_base_101 as select * from t_join_base_001;    

Succeed.

SQL> create table t_join_base_102 as select * from t_join_base_001;  

Succeed.

SQL> create table t_join_base_103 as select * from t_join_base_001; 

Succeed.

SQL> create table t_join_base_104 as select * from t_join_base_001; 

Succeed.

SQL> create table t_join_base_105 as select * from t_join_base_001; 

Succeed.

SQL> 
SQL> explain select count(*) from t_join_base_001 t1 join t_join_base_101 t2 on t1.id=t2.id join t_join_base_102 t3 on t1.id=t2.id where exists (select * from (select t2.id from t_join_base_105));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   AGGR                         |       |                    |      |      |       |        |
| 2   |     NESTED LOOPS               |       |                    |      |      |       |        |
| 3   |       HASH JOIN(L)             |       |                    |      |      |       |        |
| 4   |         KERNEL FILTER          |       |                    |      |      |       |        |
| 5   |           TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_001 T1 |      |      |       |        |
| 6   |           SUBSELECT            |       |                    |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 8   |         KERNEL FILTER          |       |                    |      |      |       |        |
| 9   |           TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_101 T2 |      |      |       |        |
| 10  |           SUBSELECT            |       |                    |      |      |       |        |
| 11  |             TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 12  |       KERNEL FILTER            |       |                    |      |      |       |        |
| 13  |         TABLE ACCESS FULL      | SYS   | T_JOIN_BASE_102 T3 |      |      |       |        |
| 14  |         SUBSELECT              |       |                    |      |      |       |        |
| 15  |           TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_105    |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.ID = T2.ID                                    
       filter: EXISTS(SELECT 1 FROM (SELECT T2.ID FROM T_JOIN_BASE_105))

24 rows fetched.

SQL> explain delete from t1 using t_join_base_001 t1 join t_join_base_101 t2 on t1.id=t2.id join t_join_base_102 t3 on t1.id=t2.id where exists (select * from (select t2.id from t_join_base_105));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT             |       |                    |      |      |       |        |
| 1   |   NESTED LOOPS               |       |                    |      |      |       |        |
| 2   |     HASH JOIN(L)             |       |                    |      |      |       |        |
| 3   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_001 T1 |      |      |       |        |
| 5   |         SUBSELECT            |       |                    |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 7   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_101 T2 |      |      |       |        |
| 9   |         SUBSELECT            |       |                    |      |      |       |        |
| 10  |           TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 11  |     KERNEL FILTER            |       |                    |      |      |       |        |
| 12  |       TABLE ACCESS FULL      | SYS   | T_JOIN_BASE_102 T3 |      |      |       |        |
| 13  |       SUBSELECT              |       |                    |      |      |       |        |
| 14  |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_105    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.ID = T2.ID                                    
       filter: EXISTS(SELECT 1 FROM (SELECT T2.ID FROM T_JOIN_BASE_105))

23 rows fetched.

SQL> explain update t_join_base_001 t1 join t_join_base_101 t2 on t1.id=t2.id join t_join_base_102 t3 on t1.id=t2.id set t1.c_vchar = 'aaaaaa' where exists (select * from (select t2.id from t_join_base_105));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT             |       |                    |      |      |       |        |
| 1   |   NESTED LOOPS               |       |                    |      |      |       |        |
| 2   |     HASH JOIN(L)             |       |                    |      |      |       |        |
| 3   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_001 T1 |      |      |       |        |
| 5   |         SUBSELECT            |       |                    |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 7   |       KERNEL FILTER          |       |                    |      |      |       |        |
| 8   |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_101 T2 |      |      |       |        |
| 9   |         SUBSELECT            |       |                    |      |      |       |        |
| 10  |           TABLE ACCESS FULL  | SYS   | T_JOIN_BASE_105    |      |      |       |        |
| 11  |     KERNEL FILTER            |       |                    |      |      |       |        |
| 12  |       TABLE ACCESS FULL      | SYS   | T_JOIN_BASE_102 T3 |      |      |       |        |
| 13  |       SUBSELECT              |       |                    |      |      |       |        |
| 14  |         TABLE ACCESS FULL    | SYS   | T_JOIN_BASE_105    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.ID = T2.ID                                    
       filter: EXISTS(SELECT 1 FROM (SELECT T2.ID FROM T_JOIN_BASE_105))

23 rows fetched.

SQL> select count(*) from t_join_base_001 t1 join t_join_base_101 t2 on t1.id=t2.id join t_join_base_102 t3 on t1.id=t2.id where exists (select * from (select t2.id from t_join_base_105));

COUNT(*)            
--------------------
4                   

1 rows fetched.

SQL> 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> drop table if exists t_join_base_102;

Succeed.

SQL> drop table if exists t_join_base_103;

Succeed.

SQL> drop table if exists t_join_base_104;

Succeed.

SQL> drop table if exists t_join_base_105;

Succeed.

SQL> 
SQL> --SELECT_AS_TABLE optimizer
SQL> DROP TABLE IF EXISTS "T_P_EUTRANINTRAFREQNCELL_A1FC" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "T_P_EUTRANINTRAFREQNCELL_A1FC"
  2 (
  3   "PLANID" BINARY_INTEGER NOT NULL,
  4   "PHYID" BINARY_INTEGER NOT NULL,
  5   "CMENEID" BINARY_INTEGER NOT NULL,
  6   "ENTITYMOOPID" BINARY_INTEGER,
  7   "OBJECTID" BINARY_INTEGER NOT NULL,
  8   "ANRFLAG" BINARY_INTEGER,
  9   "ATTACHCELLSWITCH" BINARY_INTEGER,
 10   "CELLID" BINARY_INTEGER NOT NULL,
 11   "CELLINDIVIDUALOFFSET" BINARY_INTEGER,
 12   "CELLMEASPRIORITY" BINARY_INTEGER,
 13   "CELLQOFFSET" BINARY_INTEGER,
 14   "CELLRANGEEXPANSION" BINARY_INTEGER,
 15   "CTRLMODE" BINARY_INTEGER,
 16   "ENODEBID" BINARY_INTEGER NOT NULL,
 17   "HIGHSPEEDCELLINDOFFSET" BINARY_INTEGER,
 18   "LOCALCELLID" BINARY_INTEGER NOT NULL,
 19   "LOCALCELLNAME" VARCHAR(256 BYTE),
 20   "MCC" VARCHAR(256 BYTE) NOT NULL,
 21   "MNC" VARCHAR(256 BYTE) NOT NULL,
 22   "NCELLADDITIONTIME" DATE,
 23   "NCELLCLASSLABEL" BINARY_INTEGER,
 24   "NEIGHBOURCELLNAME" VARCHAR(256 BYTE),
 25   "NOHOFLAG" BINARY_INTEGER,
 26   "NORMVFLAG" BINARY_INTEGER,
 27   "VECTORCELLFLAG" BINARY_INTEGER
 28 );

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "USRMODP_LCELLCHGINFO" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "USRMODP_LCELLCHGINFO"
  2 (
  3   "PLANID" BINARY_INTEGER,
  4   "CMENEID" BINARY_INTEGER NOT NULL,
  5   "OLDLOCALCELLID" BINARY_INTEGER NOT NULL,
  6   "NEWLOCALCELLID" BINARY_INTEGER,
  7   "NEWCELLID" BINARY_INTEGER,
  8   "NEWCELLNAME" VARCHAR(255 BYTE),
  9   "NEWSECTORNO" BINARY_INTEGER,
 10   "OLDENODEBID" BINARY_INTEGER,
 11   "OLDSECTORNO" BINARY_INTEGER,
 12   "OLDCELLID" BINARY_INTEGER,
 13   "OLDCELLNAME" VARCHAR(255 BYTE)
 14 );

Succeed.

SQL> 
SQL> CREATE INDEX "IDX2#_P_472_01234_A1FC" ON "T_P_EUTRANINTRAFREQNCELL_A1FC"("PLANID", "PHYID", "LOCALCELLID", "MCC", "MNC", "ENODEBID", "CELLID");

Succeed.

SQL> CREATE INDEX "IDX2#_P_472_50515253_A1FC" ON "T_P_EUTRANINTRAFREQNCELL_A1FC"("PLANID", "MCC", "MNC", "ENODEBID", "CELLID");

Succeed.

SQL> ALTER TABLE "T_P_EUTRANINTRAFREQNCELL_A1FC" ADD CONSTRAINT "PK#_P_472_A1FC" PRIMARY KEY("PLANID", "OBJECTID");

Succeed.

SQL> CREATE INDEX "IDX_LCELLCHGINFO_USRMODP" ON "USRMODP_LCELLCHGINFO"("PLANID", "CMENEID", "OLDLOCALCELLID");

Succeed.

SQL> 
SQL> 
SQL> EXPLAIN UPDATE t_P_EUTRANINTRAFREQNCELL_A1FC
  2    SET (LOCALCELLNAME) =
  3        (SELECT s2.LOCALCELLNAME
  4           FROM t_P_EUTRANINTRAFREQNCELL_A1FC s1
  5           JOIN (SELECT DISTINCT A.OLDLOCALCELLID,
  6                                A.NEWCELLNAME AS LOCALCELLNAME,
  7                                A.CMENEID
  8                  FROM UsrModP_LCELLCHGINFO A
  9                 WHERE (A.OLDCELLNAME != A.NEWCELLNAME)
 10                   AND (A.PlanID = 1)) s2
 11             ON (s1.CMENEID = s2.CMENEID)
 12            AND (s1.LOCALCELLID = s2.OLDLOCALCELLID)
 13            AND ((s1.LOCALCELLNAME != s2.LOCALCELLNAME) OR
 14                ((s1.LOCALCELLNAME IS NULL) AND
 15                (s2.LOCALCELLNAME IS NOT NULL)) OR
 16                ((s1.LOCALCELLNAME IS NOT NULL) AND
 17                (s2.LOCALCELLNAME IS NULL)))
 18          WHERE (t_P_EUTRANINTRAFREQNCELL_A1FC.PlanID = s1.PlanID)
 19            AND (t_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID = s1.CMENEID)
 20            AND (t_P_EUTRANINTRAFREQNCELL_A1FC.objectId = s1.objectId)
 21            AND (s1.PlanID = 1))
 22  WHERE (t_P_EUTRANINTRAFREQNCELL_A1FC.PlanID = 1)
 23    AND (EXISTS (SELECT 1
 24                   FROM (SELECT DISTINCT A.OLDLOCALCELLID,
 25                                         A.NEWCELLNAME AS LOCALCELLNAME,
 26                                         A.CMENEID
 27                           FROM UsrModP_LCELLCHGINFO A
 28                          WHERE (A.OLDCELLNAME != A.NEWCELLNAME)
 29                            AND (A.PlanID = 1)) s3
 30                  WHERE (t_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID = s3.CMENEID)
 31                    AND (t_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLID =  s3.OLDLOCALCELLID)
 32                    AND ((t_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME != s3.LOCALCELLNAME) OR 
 33                         ((t_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NULL) AND (s3.LOCALCELLNAME IS NOT NULL)) OR
 34                         ((t_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NOT NULL) AND (s3.LOCALCELLNAME IS NULL))
 35                        )
 36                   )
 37         );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                             | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                     |       |                                  |      |      |       |        |
| 1   |   KERNEL FILTER                      |       |                                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID      | SYS   | T_P_EUTRANINTRAFREQNCELL_A1FC    |      |      |       |        |
| 3   |       INDEX RANGE SCAN               | SYS   | PK#_P_472_A1FC                   |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID      | SYS   | USRMODP_LCELLCHGINFO A           |      |      |       |        |
| 5   |       INDEX RANGE SCAN               | SYS   | IDX_LCELLCHGINFO_USRMODP         |      |      |       |        |
| 6   |   NESTED LOOPS                       |       |                                  |      |      |       |        |
| 7   |     SUBSELECT                        |       | S2                               |      |      |       |        |
| 8   |       HASH DISTINCT                  |       |                                  |      |      |       |        |
| 9   |         TABLE ACCESS BY INDEX ROWID  | SYS   | USRMODP_LCELLCHGINFO A           |      |      |       |        |
| 10  |           INDEX RANGE SCAN           | SYS   | IDX_LCELLCHGINFO_USRMODP         |      |      |       |        |
| 11  |     TABLE ACCESS BY INDEX ROWID      | SYS   | T_P_EUTRANINTRAFREQNCELL_A1FC S1 |      |      |       |        |
| 12  |       INDEX UNIQUE SCAN              | SYS   | PK#_P_472_A1FC                   |      |      |       |        |
------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM USRMODP_LCELLCHGINFO A WHERE A.PLANID = 1 AND A.OLDLOCALCELLID = T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLID AND 
               A.CMENEID = T_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID AND A.OLDCELLNAME != A.NEWCELLNAME AND 
               T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME != A.NEWCELLNAME OR T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NULL AND 
               A.NEWCELLNAME IS NOT NULL OR T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NOT NULL AND 
               A.NEWCELLNAME IS NULL)                           
   3 - access: T_P_EUTRANINTRAFREQNCELL_A1FC.PLANID = 1         
   4 - filter: T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME != A.NEWCELLNAME OR T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NULL AND 
               A.NEWCELLNAME IS NOT NULL OR T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLNAME IS NOT NULL AND 
               A.NEWCELLNAME IS NULL AND A.OLDCELLNAME != A.NEWCELLNAME
   5 - access: A.PLANID = 1 AND A.OLDLOCALCELLID = T_P_EUTRANINTRAFREQNCELL_A1FC.LOCALCELLID AND A.CMENEID = T_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID
   7 - filter: S2.CMENEID = T_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID
   9 - filter: A.OLDCELLNAME != A.NEWCELLNAME                   
   10 - access: A.PLANID = 1 AND A.CMENEID = T_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID
   11 - filter: S1.CMENEID = T_P_EUTRANINTRAFREQNCELL_A1FC.CMENEID AND S1.CMENEID = S2.CMENEID AND S1.LOCALCELLNAME != S2.LOCALCELLNAME OR 
               S1.LOCALCELLNAME IS NULL AND S2.LOCALCELLNAME IS NOT NULL OR S1.LOCALCELLNAME IS NOT NULL AND 
               S2.LOCALCELLNAME IS NULL AND S1.LOCALCELLID = S2.OLDLOCALCELLID
   12 - access: S1.PLANID = 1 AND S1.PLANID = T_P_EUTRANINTRAFREQNCELL_A1FC.PLANID AND S1.OBJECTID = T_P_EUTRANINTRAFREQNCELL_A1FC.OBJECTID

36 rows fetched.

SQL> DROP TABLE T_P_EUTRANINTRAFREQNCELL_A1FC;

Succeed.

SQL> DROP TABLE USRMODP_LCELLCHGINFO;

Succeed.

SQL> 
SQL> --DTS2019012802625 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> drop table if exists t_join_base_102;

Succeed.

SQL> 
SQL> create table t_join_base_001(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date) ;

Succeed.

SQL> create table t_join_base_101(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date) ;

Succeed.

SQL> create table t_join_base_102(id int,c_int int not null,c_vchar varchar(100) not null,c_clob clob not null,c_blob blob not null,c_date date) ;

Succeed.

SQL> 
SQL> create index idx_join_base_001_1 on t_join_base_001(c_int);

Succeed.

SQL> create index idx_join_base_001_2 on t_join_base_001(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_001_3 on t_join_base_001(c_int,c_vchar,c_date);

Succeed.

SQL> create index idx_join_base_101_1 on t_join_base_101(c_int);

Succeed.

SQL> create index idx_join_base_101_2 on t_join_base_101(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_101_3 on t_join_base_101(c_int,c_vchar,c_date);

Succeed.

SQL> create index idx_join_base_102_1 on t_join_base_102(c_int);

Succeed.

SQL> create index idx_join_base_102_2 on t_join_base_102(c_int,c_vchar);

Succeed.

SQL> create index idx_join_base_102_3 on t_join_base_102(c_int,c_vchar,c_date);

Succeed.

SQL> 
SQL> insert into t_join_base_001 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_101 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_join_base_102 values(1,1000,'abc123',lpad('123abc',50,'abc'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select count(*) from (select * from t_join_base_001) t1 inner join (select * from (select * from t_join_base_101)) t2 on t1.c_vchar=t2.c_vchar inner join (select * from t_join_base_102) t3 on t1.c_int<>t2.c_int and t1.c_int is not null where exists(select * from (select * from t_join_base_001) t4 where t1.c_int=t4.c_int or t2.c_int=t4.c_int or t3.c_vchar>t4.c_vchar or t1.c_int>t2.c_int or t2.c_int<=t3.c_int and t1.c_int is null or t2.c_int between 20 and 1000 or t3.c_vchar in (select c_vchar from (select * from (select * from t_join_base_101))) and exists(select * from (select * from t_join_base_102) t5 where t1.c_vchar!=t5.c_vchar ) or 1=2 or 1=3 );

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> 
SQL> drop table t_join_base_001;

Succeed.

SQL> drop table t_join_base_101;

Succeed.

SQL> drop table t_join_base_102;

Succeed.

SQL> 
SQL> --support (f1,f2) in (select f1,f2 from t2) to hash join
SQL> drop table if exists customer;

Succeed.

SQL> create table customer
  2 (
  3     c_customer_sk             integer               not null,
  4     c_customer_id             char(16)              not null,
  5     c_current_cdemo_sk        integer                       ,
  6     c_current_hdemo_sk        integer                       ,
  7     c_current_addr_sk         integer                       ,
  8     c_first_shipto_date_sk    integer                       ,
  9     c_first_sales_date_sk     integer                       ,
 10     c_salutation              char(10)                      ,
 11     c_first_name              char(20)                      ,
 12     c_last_name               char(30)                      ,
 13     c_preferred_cust_flag     char(1)                       ,
 14     c_birth_day               integer                       ,
 15     c_birth_month             integer                       ,
 16     c_birth_year              integer                       ,
 17     c_birth_country           varchar(20)                   ,
 18     c_login                   char(13)                      ,
 19     c_email_address           char(50)                      ,
 20     c_last_review_date        char(10)
 21 );

Succeed.

SQL> create index customer_index on customer(c_customer_sk);

Succeed.

SQL> 
SQL> drop table if exists inventory;

Succeed.

SQL> create table inventory
  2 (
  3     inv_date_sk               integer               not null,
  4     inv_item_sk               integer               not null,
  5     inv_warehouse_sk          integer               not null,
  6     inv_quantity_on_hand      integer
  7 )
  8 partition by range(inv_date_sk)
  9 (
 10         partition p1 values less than(2451179),
 11         partition p2 values less than(2451544),
 12         partition p3 values less than(2451910),
 13         partition p4 values less than(2452275),
 14         partition p5 values less than(2452640),
 15         partition p6 values less than(2453005),
 16         partition p7 values less than(maxvalue)
 17 );

Succeed.

SQL> 
SQL> explain select c_first_name, max(c_last_name), min(c_preferred_cust_flag), 'ABC'
  2   from customer
  3  where (c_birth_day, c_birth_month) in
  4        (select c_birth_day, c_birth_month
  5           from customer
  6          where c_birth_year < 2000)
  7 and c_birth_country like '%J%'
  8  group by c_first_name
  9  having max(c_last_name) like '%n%' and min(c_preferred_cust_flag)='Y'
 10  order by 1, 2, 3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |          |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |          |      |      |       |        |
| 2   |     HAVING                     |       |          |      |      |       |        |
| 3   |       HASH GROUP BY            |       |          |      |      |       |        |
| 4   |         HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 5   |           SUBSELECT            |       |          |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | CUSTOMER |      |      |       |        |
| 7   |           TABLE ACCESS FULL    | SYS   | CUSTOMER |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: MAX(C_LAST_NAME) LIKE '%n%' AND MIN(C_PREFERRED_CUST_FLAG) = 'Y'
   4 - access: CUSTOMER.C_BIRTH_MONTH = C_BIRTH_MONTH AND CUSTOMER.C_BIRTH_DAY = C_BIRTH_DAY
   6 - filter: C_BIRTH_YEAR < 2000                              
   7 - filter: C_BIRTH_COUNTRY LIKE '%J%'                       

18 rows fetched.

SQL> 
SQL> explain select count(distinct(inv_date_sk)), max(inv_warehouse_sk)
  2   from inventory
  3  where (inv_item_sk, inv_date_sk, inv_warehouse_sk) not in
  4        (select inv_warehouse_sk, inv_date_sk, inv_item_sk
  5           from inventory
  6          where inv_quantity_on_hand > 20 
  7          and inv_date_sk < 2451544);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |           |      |      |       |        |
| 1   |   AGGR                                 |       |           |      |      |       |        |
| 2   |     HASH JOIN ANTI(R)                  |       |           |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[0,7)   | SYS   | INVENTORY |      |      |       |        |
| 4   |       SUBSELECT                        |       |           |      |      |       |        |
| 5   |         TABLE ACCESS FULL Filter:[0,2) | SYS   | INVENTORY |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: INV_WAREHOUSE_SK = INVENTORY.INV_ITEM_SK AND INV_ITEM_SK = INVENTORY.INV_WAREHOUSE_SK AND 
               INV_DATE_SK = INVENTORY.INV_DATE_SK              
   5 - filter: INV_QUANTITY_ON_HAND > 20 AND INV_DATE_SK < 2451544

15 rows fetched.

SQL> 
SQL> drop table customer;

Succeed.

SQL> drop table inventory;

Succeed.

SQL> 
SQL> drop table if exists catalog_returns;

Succeed.

SQL> create table catalog_returns
  2 (
  3     cr_returned_date_sk       integer                       ,
  4     cr_returned_time_sk       integer                       ,
  5     cr_item_sk                integer               not null,
  6     cr_refunded_customer_sk   integer                       ,
  7     cr_refunded_cdemo_sk      integer                       ,
  8     cr_refunded_hdemo_sk      integer                       ,
  9     cr_refunded_addr_sk       integer                       ,
 10     cr_returning_customer_sk  integer                       ,
 11     cr_returning_cdemo_sk     integer                       ,
 12     cr_returning_hdemo_sk     integer                       ,
 13     cr_returning_addr_sk      integer                       ,
 14     cr_call_center_sk         integer                       ,
 15     cr_catalog_page_sk        integer                       ,
 16     cr_ship_mode_sk           integer                       ,
 17     cr_warehouse_sk           integer                       ,
 18     cr_reason_sk              integer                       ,
 19     cr_order_number           bigint                not null,
 20     cr_return_quantity        integer                       ,
 21     cr_return_amount          decimal(7,2)                  ,
 22     cr_return_tax             decimal(7,2)                  ,
 23     cr_return_amt_inc_tax     decimal(7,2)                  ,
 24     cr_fee                    decimal(7,2)                  ,
 25     cr_return_ship_cost       decimal(7,2)                  ,
 26     cr_refunded_cash          decimal(7,2)                  ,
 27     cr_reversed_charge        decimal(7,2)                  ,
 28     cr_store_credit           decimal(7,2)                  ,
 29     cr_net_loss               decimal(7,2)
 30 );

Succeed.

SQL> create index catalog_returns_index on catalog_returns(cr_item_sk, cr_order_number);

Succeed.

SQL> 
SQL> drop table if exists catalog_page;

Succeed.

SQL> create table catalog_page
  2 (
  3     cp_catalog_page_sk        integer               not null,
  4     cp_catalog_page_id        char(16)              not null,
  5     cp_start_date_sk          integer                       ,
  6     cp_end_date_sk            integer                       ,
  7     cp_department             varchar(50)                   ,
  8     cp_catalog_number         integer                       ,
  9     cp_catalog_page_number    integer                       ,
 10     cp_description            varchar(100)                  ,
 11     cp_type                   varchar(100)
 12 );

Succeed.

SQL> create index catalog_page_index on catalog_page (cp_catalog_page_sk);

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS web_returns CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE web_returns
  2 (
  3     WR_RETURNED_DATE_SK      BINARY_INTEGER,
  4     WR_RETURNED_TIME_SK      BINARY_INTEGER,
  5     WR_ITEM_SK               BINARY_INTEGER NOT NULL,
  6     WR_REFUNDED_CUSTOMER_SK  BINARY_INTEGER,
  7     WR_REFUNDED_CDEMO_SK     BINARY_INTEGER,
  8     WR_REFUNDED_HDEMO_SK     BINARY_INTEGER,
  9     WR_REFUNDED_ADDR_SK      BINARY_INTEGER,
 10     WR_RETURNING_CUSTOMER_SK BINARY_INTEGER,
 11     WR_RETURNING_CDEMO_SK    BINARY_INTEGER,
 12     WR_RETURNING_HDEMO_SK    BINARY_INTEGER,
 13     WR_RETURNING_ADDR_SK     BINARY_INTEGER,
 14     WR_WEB_PAGE_SK           BINARY_INTEGER,
 15     WR_REASON_SK             BINARY_INTEGER,
 16     WR_ORDER_NUMBER          BINARY_BIGINT NOT NULL,
 17     WR_RETURN_QUANTITY       BINARY_INTEGER,
 18     WR_RETURN_AMT            NUMBER(7, 2),
 19     WR_RETURN_TAX            NUMBER(7, 2),
 20     WR_RETURN_AMT_INC_TAX    NUMBER(7, 2),
 21     WR_FEE                   NUMBER(7, 2),
 22     WR_RETURN_SHIP_COST      NUMBER(7, 2),
 23     WR_REFUNDED_CASH         NUMBER(7, 2),
 24     WR_REVERSED_CHARGE       NUMBER(7, 2),
 25     WR_ACCOUNT_CREDIT        NUMBER(7, 2),
 26     WR_NET_LOSS              NUMBER(7, 2)
 27 );

Succeed.

SQL> 
SQL> explain select cr_return_quantity,max(cr_return_amt_inc_tax)+cr_fee
  2   from catalog_returns
  3  where (cr_returned_date_sk, cr_returned_time_sk) in
  4        (select wr_returned_date_sk,
  5                (select cr_returned_time_sk
  6                   from catalog_returns
  7                  where cr_refunded_customer_sk< 100
  8      and cr_returned_time_sk -1 not in
  9                        (select cr_returned_date_sk
 10                           from catalog_returns
 11                          where cr_return_quantity > 10
 12                            and not exists (select cp_start_date_sk
 13                                    from catalog_page
 14                                    where cp_type like '%as%'))
 15         order by 1 limit 1)
 16           from web_returns
 17          where wr_return_quantity / 10 > 5)
 18 group by cr_return_quantity, cr_fee order by 1,2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |                 |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                    |       |                 |      |      |       |        |
| 2   |     HASH GROUP BY                        |       |                 |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)                  |       |                 |      |      |       |        |
| 4   |         SUBSELECT                        |       |                 |      |      |       |        |
| 5   |           QUERY LIMIT                    |       |                 |      |      |       |        |
| 6   |             QUERY SORT ORDER BY ROWNUM   |       |                 |      |      |       |        |
| 7   |               HASH JOIN ANTI NA(R)       |       |                 |      |      |       |        |
| 8   |                 TABLE ACCESS FULL        | SYS   | CATALOG_RETURNS |      |      |       |        |
| 9   |                 SUBSELECT                |       |                 |      |      |       |        |
| 10  |                   HASH JOIN ANTI(R)      |       |                 |      |      |       |        |
| 11  |                     TABLE ACCESS FULL    | SYS   | CATALOG_RETURNS |      |      |       |        |
| 12  |                     SUBSELECT            |       |                 |      |      |       |        |
| 13  |                       TABLE ACCESS FULL  | SYS   | CATALOG_PAGE    |      |      |       |        |
| 14  |           TABLE ACCESS FULL              | SYS   | WEB_RETURNS     |      |      |       |        |
| 15  |         TABLE ACCESS FULL                | SYS   | CATALOG_RETURNS |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: WR_RETURNED_DATE_SK = CR_RETURNED_DATE_SK AND (SELECT CATALOG_RETURNS.CR_RETURNED_TIME_SK FROM 
               CATALOG_RETURNS INNER JOIN (SELECT CR_RETURNED_DATE_SK FROM CATALOG_RETURNS INNER JOIN (SELECT 1 FROM 
               CATALOG_PAGE WHERE CP_TYPE LIKE '%as%')) ORDER BY CATALOG_RETURNS.CR_RETURNED_TIME_SK LIMIT 
               1) = CR_RETURNED_TIME_SK                         
   7 - access: CR_RETURNED_TIME_SK - 1 = CR_RETURNED_DATE_SK    
   8 - filter: CR_REFUNDED_CUSTOMER_SK < 100                    
   10 - access: NA = NA                                         
   11 - filter: CR_RETURN_QUANTITY > 10                         
   13 - filter: CP_TYPE LIKE '%as%'                             
   14 - filter: WR_RETURN_QUANTITY / 10 > 5                     

32 rows fetched.

SQL> 
SQL> drop table catalog_returns;

Succeed.

SQL> drop table catalog_page;

Succeed.

SQL> drop table web_returns;

Succeed.

SQL> 
SQL> --DTS2019030110040
SQL> drop table if exists hash_join_compare_tbl_000;

Succeed.

SQL> create table hash_join_compare_tbl_000(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> ALTER TABLE hash_join_compare_tbl_000 ADD CONSTRAINT pk_hj_com_tbl_000 primary key(c_id,c_d_id,c_w_id);

Succeed.

SQL> 
SQL> drop table if exists hash_join_com_tbl_140;

Succeed.

SQL> create table hash_join_com_tbl_140(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> ALTER TABLE hash_join_com_tbl_140 ADD CONSTRAINT pk_hj_com_tbl_140 primary key(c_id,c_d_id,c_w_id);

Succeed.

SQL> 
SQL> create unique index hash_join_indx_140_1 ON hash_join_com_tbl_140(c_id,c_d_id);

Succeed.

SQL> create index hash_join_indx_140_2 ON hash_join_com_tbl_140(c_id);

Succeed.

SQL> create unique index hash_join_indx_140_3 ON hash_join_com_tbl_140(c_big);

Succeed.

SQL> create index hash_join_indx_140_4 ON hash_join_com_tbl_140(c_first,c_binary);

Succeed.

SQL> create index hash_join_indx_140_5 ON hash_join_com_tbl_140(c_id,c_d_id,c_varbinary);

Succeed.

SQL> create index hash_join_indx_140_6 ON hash_join_com_tbl_140(c_id,c_d_id,c_street_1,c_raw);

Succeed.

SQL> 
SQL> drop table if exists hash_join_tbl_global_140_1;

Succeed.

SQL> create table hash_join_tbl_global_140_1(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> drop table if exists hash_join_com_tbl_140_2;

Succeed.

SQL> create table hash_join_com_tbl_140_2(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(32) NOT NULL,c_middle char(2),c_last varchar(50) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt real NOT NULL,c_end date NOT NULL,c_unsig int,c_big number(20,0),c_vchar varchar2(2000),c_data varchar2(1500),c_text blob,c_clob clob,c_image clob,c_binary varchar2(3000),c_varbinary varchar2(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> explain select distinct a.c_first, sum(b.c_id)
  2   from hash_join_com_tbl_140 a
  3  inner join (select a.c_id, a.c_first
  4                from hash_join_tbl_global_140_1 a
  5               inner join hash_join_com_tbl_140_2 b
  6                  on a.c_last = b.c_last
  7                 and (a.c_w_id + 10 = b.c_w_id or
  8                     mod(a.c_id, 2) = a.c_id * 2 + 10)
  9               where a.c_w_id not in (select c_w_id
 10                                        from hash_join_com_tbl_140
 11                                       where c_w_id > 1000)) b
 12     on a.c_id = b.c_id
 13    and (a.c_id + 10 < 1000 or mod(b.c_id, 2) = 1)   
 14    inner join hash_join_com_tbl_140_2 c
 15       on a.c_id = c.c_id
 16  where c.c_id not in
 17        (select a.c_id
 18           from hash_join_com_tbl_140 a
 19          inner join hash_join_tbl_global_140_1 b
 20             on a.c_id * 2 + 1 = b.c_id + 10
 21            and (a.c_first like 'AAis8%' or a.c_first like 'AAis7%')
 22          where a.c_id < 800)
 23    and a.c_first like 'AAis8%'
 24  group by a.c_first, b.c_id
 25  order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                   | Owner | Name                         | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                              |       |                              |      |      |       |        |
| 1   |   SORT DISTINCT                               |       |                              |      |      |       |        |
| 2   |     HASH GROUP BY                             |       |                              |      |      |       |        |
| 3   |       HASH JOIN ANTI NA(R)                    |       |                              |      |      |       |        |
| 4   |         HASH JOIN(L)                          |       |                              |      |      |       |        |
| 5   |           NESTED LOOPS                        |       |                              |      |      |       |        |
| 6   |             SUBSELECT                         |       | B                            |      |      |       |        |
| 7   |               HASH JOIN ANTI(R)               |       |                              |      |      |       |        |
| 8   |                 HASH JOIN(L)                  |       |                              |      |      |       |        |
| 9   |                   TABLE ACCESS FULL           | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 A |      |      |       |        |
| 10  |                   TABLE ACCESS FULL           | SYS   | HASH_JOIN_COM_TBL_140_2 B    |      |      |       |        |
| 11  |                 SUBSELECT                     |       |                              |      |      |       |        |
| 12  |                   TABLE ACCESS BY INDEX ONLY  | SYS   | HASH_JOIN_COM_TBL_140        |      |      |       |        |
| 13  |                     INDEX FAST FULL SCAN      | SYS   | PK_HJ_COM_TBL_140            |      |      |       |        |
| 14  |             TABLE ACCESS BY INDEX ROWID       | SYS   | HASH_JOIN_COM_TBL_140 A      |      |      |       |        |
| 15  |               INDEX RANGE SCAN                | SYS   | HASH_JOIN_INDX_140_2         |      |      |       |        |
| 16  |           TABLE ACCESS FULL                   | SYS   | HASH_JOIN_COM_TBL_140_2 C    |      |      |       |        |
| 17  |         SUBSELECT                             |       |                              |      |      |       |        |
| 18  |           HASH JOIN(L)                        |       |                              |      |      |       |        |
| 19  |             TABLE ACCESS BY INDEX ROWID       | SYS   | HASH_JOIN_COM_TBL_140 A      |      |      |       |        |
| 20  |               INDEX RANGE SCAN                | SYS   | HASH_JOIN_INDX_140_2         |      |      |       |        |
| 21  |             TABLE ACCESS FULL                 | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 B |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: C.C_ID = C_ID                                    
   4 - access: A.C_ID = C.C_ID AND B.C_ID = C.C_ID              
   7 - access: A.C_W_ID = HASH_JOIN_COM_TBL_140.C_W_ID          
   8 - access: A.C_LAST = B.C_LAST                              
       filter: A.C_W_ID + 10 = B.C_W_ID OR MOD(A.C_ID, 2) = A.C_ID * 2 + 10
   12 - filter: C_W_ID > 1000                                   
   14 - filter: A.C_FIRST LIKE 'AAis8%' AND A.C_ID + 10 < 1000 OR MOD(B.C_ID, 2) = 1
   15 - access: A.C_ID = B.C_ID                                 
   18 - access: A.C_ID * 2 + 1 = B.C_ID + 10                    
   19 - filter: A.C_FIRST LIKE 'AAis8%' OR A.C_FIRST LIKE 'AAis7%'
   20 - access: A.C_ID < 800                                    

39 rows fetched.

SQL> 
SQL> explain select distinct a.c_id, b.c_id
  2   from hash_join_com_tbl_140_2 a
  3  inner join hash_join_tbl_global_140_1 b
  4     on a.c_id + a.c_d_id + 10 = b.c_id * 2
  5    and (a.c_id < 900 or a.c_id > 1000)
  6  inner join hash_join_tbl_global_140_1 c
  7     on a.c_id + 5 = c.c_id
  8  where a.c_id < 1000
  9    and b.c_first not in
 10        (select a.c_first
 11           from hash_join_com_tbl_140_2 a
 12          inner join hash_join_tbl_global_140_1 b
 13             on a.c_id = b.c_id + 10
 14            and (length(a.c_first || 'b') = length(b.c_first) or
 15                b.c_id is not null)
 16          where a.c_id not in (select c_id
 17                                 from hash_join_com_tbl_140_2
 18                                where c_id > 1000)
 19            and a.c_first in
 20                (select a.c_first
 21                   from hash_join_com_tbl_140_2 a
 22                  inner join hash_join_tbl_global_140_1 b
 23                     on a.c_first = b.c_first
 24                    and (a.c_id * 2 / 3 = b.c_id + 1 or a.c_first = b.c_first)
 25                  where a.c_first not in
 26                        (select c_first
 27                           from hash_join_com_tbl_140_2
 28                          where c_first > 'AAis8')))
 29  group by a.c_id, b.c_id
 30  order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name                         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |                              |      |      |       |        |
| 1   |   SORT DISTINCT                          |       |                              |      |      |       |        |
| 2   |     HASH GROUP BY                        |       |                              |      |      |       |        |
| 3   |       HASH JOIN ANTI(R)                  |       |                              |      |      |       |        |
| 4   |         HASH JOIN(L)                     |       |                              |      |      |       |        |
| 5   |           HASH JOIN(L)                   |       |                              |      |      |       |        |
| 6   |             TABLE ACCESS FULL            | SYS   | HASH_JOIN_COM_TBL_140_2 A    |      |      |       |        |
| 7   |             TABLE ACCESS FULL            | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 B |      |      |       |        |
| 8   |           TABLE ACCESS FULL              | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 C |      |      |       |        |
| 9   |         SUBSELECT                        |       |                              |      |      |       |        |
| 10  |           HASH JOIN ANTI NA(R)           |       |                              |      |      |       |        |
| 11  |             HASH JOIN(L)                 |       |                              |      |      |       |        |
| 12  |               HASH JOIN SEMI(L)          |       |                              |      |      |       |        |
| 13  |                 SUBSELECT                |       |                              |      |      |       |        |
| 14  |                   HASH JOIN ANTI(R)      |       |                              |      |      |       |        |
| 15  |                     HASH JOIN(L)         |       |                              |      |      |       |        |
| 16  |                       TABLE ACCESS FULL  | SYS   | HASH_JOIN_COM_TBL_140_2 A    |      |      |       |        |
| 17  |                       TABLE ACCESS FULL  | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 B |      |      |       |        |
| 18  |                     SUBSELECT            |       |                              |      |      |       |        |
| 19  |                       TABLE ACCESS FULL  | SYS   | HASH_JOIN_COM_TBL_140_2      |      |      |       |        |
| 20  |                 TABLE ACCESS FULL        | SYS   | HASH_JOIN_COM_TBL_140_2 A    |      |      |       |        |
| 21  |               TABLE ACCESS FULL          | SYS   | HASH_JOIN_TBL_GLOBAL_140_1 B |      |      |       |        |
| 22  |             SUBSELECT                    |       |                              |      |      |       |        |
| 23  |               TABLE ACCESS FULL          | SYS   | HASH_JOIN_COM_TBL_140_2      |      |      |       |        |
------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: B.C_FIRST = A.C_FIRST                            
   4 - access: A.C_ID + 5 = C.C_ID                              
   5 - access: A.C_ID + A.C_D_ID + 10 = B.C_ID * 2              
   6 - filter: A.C_ID < 1000 AND A.C_ID < 900 OR A.C_ID > 1000  
   10 - access: A.C_ID = C_ID                                   
   11 - access: A.C_ID = B.C_ID + 10                            
        filter: LENGTH(A.C_FIRST || 'b') = LENGTH(B.C_FIRST) OR B.C_ID IS NOT NULL
   12 - access: A.C_FIRST = A.C_FIRST                           
   14 - access: A.C_FIRST = HASH_JOIN_COM_TBL_140_2.C_FIRST     
   15 - access: A.C_FIRST = B.C_FIRST                           
        filter: A.C_ID * 2 / 3 = B.C_ID + 1 OR A.C_FIRST = B.C_FIRST
   19 - filter: C_FIRST > 'AAis8'                               
   23 - filter: C_ID > 1000                                     

43 rows fetched.

SQL> 
SQL> drop table hash_join_compare_tbl_000;

Succeed.

SQL> drop table hash_join_com_tbl_140;

Succeed.

SQL> drop table hash_join_tbl_global_140_1;

Succeed.

SQL> drop table hash_join_com_tbl_140_2;

Succeed.

SQL> 
SQL> --dts
SQL> drop table if exists RQG_LIST_DATATYPE_034;

Succeed.

SQL> CREATE TABLE RQG_LIST_DATATYPE_034(C_INT INT ,C_INTEGER INTEGER NOT NULL ,C_BIGINT BIGINT ,C_NUMBER NUMBER DEFAULT 0.2332,C_DOUBLE DOUBLE,C_DECIMAL DECIMAL,C_REAL REAL ,C_CHAR CHAR(100)  ,C_VARCHAR VARCHAR(100) ,C_VARCHAR2 VARCHAR2(4000),C_NUMERIC NUMERIC,C_DATETIME DATETIME  ,C_TIMESTAMP TIMESTAMP default '9999-12-31 23:59:59.999999',C_TIMESTAMP1 TIMESTAMP(6),C_BOOL BOOL);

Succeed.

SQL> insert into RQG_LIST_DATATYPE_034 values(629080064,1147338752,5169287947291197440,21342134134.324,347676.34356,21342134134.324,347676.34356,'12.34','12.34','12.34',2134217676.324,'2002-10-28 07:54:49','2018-04-05 10:23:45.999999','2018-04-05 10:23:45.999999',1);

1 rows affected.

SQL> insert into RQG_LIST_DATATYPE_034 values(2057961472,-1604452352,-5301018236391784448,21342134134.324,347676.34356,21342134134.324,347676.34356,'12.34','12.34','12.34',2134217676.324,'2003-07-12 05:49:07','2018-04-05 10:23:45.999999','2018-04-05 10:23:45.999999',FALSE);

1 rows affected.

SQL> insert into RQG_LIST_DATATYPE_034 values(-1130758144,-98959360,-1732478481654087680,21342134134.324,347676.34356,21342134134.324,347676.34356,'12.34','12.34','12.34',2134217676.324,'2002-10-13 01:09:24','2018-04-05 10:23:45.999999','2018-04-05 10:23:45.999999',true);

1 rows affected.

SQL> insert into RQG_LIST_DATATYPE_034 values(1880293376,-1145569280,6243677933395771392,21342134134.324,347676.34356,21342134134.324,347676.34356,'12.34','12.34','12.34',2134217676.324,'2007-05-28 17:02:24','2018-04-05 10:23:45.999999','2018-04-05 10:23:45.999999',0);

1 rows affected.

SQL> insert into RQG_LIST_DATATYPE_034 values(1550123008,1695547392,8818892495321563136,21342134134.324,347676.34356,21342134134.324,347676.34356,'12.34','12.34','12.34',2134217676.324,'2003-05-17 18:46:00','2018-04-05 10:23:45.999999','2018-04-05 10:23:45.999999',FALSE);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select C_INT from RQG_LIST_DATATYPE_034 where C_TIMESTAMP IN (select C_REAL from RQG_LIST_DATATYPE_034) order by c_int,c_number,c_real limit 5;

CT-00606, [1:47]Inconsistent datatypes, expected BINARY_DOUBLE - got TIMESTAMP
SQL> select C_INT,C_BOOL,C_BIGINT from RQG_LIST_DATATYPE_034 where C_BOOL IN (select C_BIGINT from RQG_LIST_DATATYPE_034) order by c_int,c_number,c_real;

C_INT        C_BOOL C_BIGINT            
------------ ------ --------------------

0 rows fetched.

SQL> select C_INT,C_BOOL,C_BIGINT from RQG_LIST_DATATYPE_034 where C_BOOL IN (2,3,4,5,6,'true','false',5169287947291197440,true,false) order by c_int,c_number,c_real;

C_INT        C_BOOL C_BIGINT            
------------ ------ --------------------
-1130758144  TRUE   -1732478481654087680
629080064    TRUE   5169287947291197440 
1550123008   FALSE  8818892495321563136 
1880293376   FALSE  6243677933395771392 
2057961472   FALSE  -5301018236391784448

5 rows fetched.

SQL> drop table RQG_LIST_DATATYPE_034;

Succeed.

SQL> 
SQL> --  DTS2019090404766
SQL> drop table if exists table_emp_lob_017 ;

Succeed.

SQL> create table table_emp_lob_017(f1 int,f2 blob not null,f3 clob default EMPTY_CLOB);

Succeed.

SQL> insert into table_emp_lob_017 values(1,EMPTY_BLOB,'');

1 rows affected.

SQL> insert into table_emp_lob_017 values(2,'001001001',EMPTY_CLOB);

1 rows affected.

SQL> insert into table_emp_lob_017 values(3,'001001001','EMPTY_LOB');

1 rows affected.

SQL> insert into table_emp_lob_017 values(5,'001001001','EMPTY_CLOB');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> drop table if exists table_emp_lob_017_01 ;

Succeed.

SQL> create table table_emp_lob_017_01(f1 int,f2 blob not null,f3 clob default EMPTY_CLOB);

Succeed.

SQL> insert into table_emp_lob_017_01 values(1,EMPTY_BLOB,'EMPTY');

1 rows affected.

SQL> insert into table_emp_lob_017_01 values(2,EMPTY_BLOB,EMPTY_CLOB);

1 rows affected.

SQL> insert into table_emp_lob_017_01 values(4,EMPTY_BLOB,EMPTY_CLOB);

1 rows affected.

SQL> insert into table_emp_lob_017_01 values(6,'01001',EMPTY_CLOB);

1 rows affected.

SQL> commit;

Succeed.

SQL> select t1.f1,t1.f2,length(t1.f2),t1.f3,length(t1.f3) from table_emp_lob_017 t1 inner join table_emp_lob_017_01 t2 on t1.f2 = t2.f2;

F1           F2                                                               LENGTH(T1.F2)        F3                                                               LENGTH(T1.F3)       
------------ ---------------------------------------------------------------- -------------------- ---------------------------------------------------------------- --------------------

0 rows fetched.

SQL> select t1.f1,t1.f2,length(t1.f2),t1.f3,length(t1.f3) from table_emp_lob_017 t1 inner join table_emp_lob_017_01 t2 on t1.f3 = t2.f3;

F1           F2                                                               LENGTH(T1.F2)        F3                                                               LENGTH(T1.F3)       
------------ ---------------------------------------------------------------- -------------------- ---------------------------------------------------------------- --------------------

0 rows fetched.

SQL> 
SQL> select * from table_emp_lob_017 t1 where f1 < 0 or t1.f3 in (select f3 from table_emp_lob_017_01 t2);

F1           F2                                                               F3                                                              
------------ ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> select * from table_emp_lob_017 t1 where t1.f3 in (select f3 from table_emp_lob_017_01 t2);

F1           F2                                                               F3                                                              
------------ ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> drop table table_emp_lob_017 ;

Succeed.

SQL> drop table table_emp_lob_017_01 ;

Succeed.

SQL> 
SQL> --DTS2019090614302
SQL> drop table if exists item;

Succeed.

SQL> drop table if exists customer;

Succeed.

SQL> drop table if exists web_site;

Succeed.

SQL> drop table if exists web_page;

Succeed.

SQL> 
SQL> create table item
  2 (
  3     i_item_sk                 integer               not null,
  4     i_item_id                 char(16)              not null,
  5     i_rec_start_date          date                          ,
  6     i_rec_end_date            date                          ,
  7     i_item_desc               varchar(200)                  ,
  8     i_current_price           decimal(7,2)                  ,
  9     i_wholesale_cost          decimal(7,2)                  ,
 10     i_brand_id                integer                       ,
 11     i_brand                   char(50)                      ,
 12     i_class_id                integer                       ,
 13     i_class                   char(50)                      ,
 14     i_category_id             integer                       ,
 15     i_category                char(50)                      ,
 16     i_manufact_id             integer                       ,
 17     i_manufact                char(50)                      ,
 18     i_size                    char(20)                      ,
 19     i_formulation             char(20)                      ,
 20     i_color                   char(20)                      ,
 21     i_units                   char(10)                      ,
 22     i_container               char(10)                      ,
 23     i_manager_id              integer                       ,
 24     i_product_name            char(50)                      ,
 25     constraint pk_item_sk primary key (i_item_sk)
 26 );

Succeed.

SQL> 
SQL> create table customer
  2 (
  3     c_customer_sk             integer               not null,
  4     c_customer_id             char(16)              not null,
  5     c_current_cdemo_sk        integer                       ,
  6     c_current_hdemo_sk        integer                       ,
  7     c_current_addr_sk         integer                       ,
  8     c_first_shipto_date_sk    integer                       ,
  9     c_first_sales_date_sk     integer                       ,
 10     c_salutation              char(10)                      ,
 11     c_first_name              char(20)                      ,
 12     c_last_name               char(30)                      ,
 13     c_preferred_cust_flag     char(1)                       ,
 14     c_birth_day               integer                       ,
 15     c_birth_month             integer                       ,
 16     c_birth_year              integer                       ,
 17     c_birth_country           varchar(20)                   ,
 18     c_login                   char(13)                      ,
 19     c_email_address           char(50)                      ,
 20     c_last_review_date        char(10)                      ,
 21     constraint pk_customer_sk primary key (c_customer_sk)
 22 );

Succeed.

SQL> 
SQL> create table web_site
  2 (
  3     web_site_sk               integer               not null,
  4     web_site_id               char(16)              not null,
  5     web_rec_start_date        date                          ,
  6     web_rec_end_date          date                          ,
  7     web_name                  varchar(50)                   ,
  8     web_open_date_sk          integer                       ,
  9     web_close_date_sk         integer                       ,
 10     web_class                 varchar(50)                   ,
 11     web_manager               varchar(40)                   ,
 12     web_mkt_id                integer                       ,
 13     web_mkt_class             varchar(50)                   ,
 14     web_mkt_desc              varchar(100)                  ,
 15     web_market_manager        varchar(40)                   ,
 16     web_company_id            integer                       ,
 17     web_company_name          char(50)                      ,
 18     web_street_number         char(10)                      ,
 19     web_street_name           varchar(60)                   ,
 20     web_street_type           char(15)                      ,
 21     web_suite_number          char(10)                      ,
 22     web_city                  varchar(60)                   ,
 23     web_county                varchar(30)                   ,
 24     web_state                 char(2)                       ,
 25     web_zip                   char(10)                      ,
 26     web_country               varchar(20)                   ,
 27     web_gmt_offset            decimal(5,2)                  ,
 28     web_tax_percentage        decimal(5,2)                  ,
 29     constraint pk_web_site_sk primary key (web_site_sk)
 30 );

Succeed.

SQL> 
SQL> create table web_page
  2 (
  3     wp_web_page_sk            integer               not null,
  4     wp_web_page_id            char(16)              not null,
  5     wp_rec_start_date         date                          ,
  6     wp_rec_end_date           date                          ,
  7     wp_creation_date_sk       integer                       ,
  8     wp_access_date_sk         integer                       ,
  9     wp_autogen_flag           char(1)                       ,
 10     wp_customer_sk            integer                       ,
 11     wp_url                    varchar(100)                  ,
 12     wp_type                   char(50)                      ,
 13     wp_char_count             integer                       ,
 14     wp_link_count             integer                       ,
 15     wp_image_count            integer                       ,
 16     wp_max_ad_count           integer                       ,
 17     constraint pk_web_page_sk primary key (wp_web_page_sk)
 18 );

Succeed.

SQL> 
SQL> explain select web_mkt_id, wp_rec_start_date
  2   from web_site
  3   right join web_page
  4     on web_site_sk = wp_web_page_sk
  5    and web_mkt_id =
  6        (select min(c_birth_day)
  7           from customer, item
  8          where c_birth_country like '%J%'
  9            and c_birth_month = extract(month from web_rec_start_date)
 10            and i_category_id = web_mkt_id)
 11  where wp_rec_start_date is not null
 12  group by web_mkt_id, wp_rec_start_date
 13  order by 1,2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                |      |      |       |        |
| 1   |   SORT GROUP BY                      |       |                |      |      |       |        |
| 2   |     KERNEL FILTER                    |       |                |      |      |       |        |
| 3   |       NESTED LOOPS OUTER             |       |                |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | WEB_PAGE       |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID  | SYS   | WEB_SITE       |      |      |       |        |
| 6   |           INDEX UNIQUE SCAN          | SYS   | PK_WEB_SITE_SK |      |      |       |        |
| 7   |       HASH MATERIALIZE               |       |                |      |      |       |        |
| 8   |         NESTED LOOPS                 |       |                |      |      |       |        |
| 9   |           SUBSELECT                  |       |                |      |      |       |        |
| 10  |             HASH GROUP BY            |       |                |      |      |       |        |
| 11  |               TABLE ACCESS FULL      | SYS   | CUSTOMER       |      |      |       |        |
| 12  |           TABLE ACCESS FULL          | SYS   | ITEM           |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: WP_REC_START_DATE IS NOT NULL                    
   5 - filter: WEB_MKT_ID = (SELECT MIN(MIN(C_BIRTH_DAY)) FROM (SELECT C_BIRTH_MONTH, MIN(C_BIRTH_DAY) FROM 
               CUSTOMER WHERE C_BIRTH_COUNTRY LIKE '%J%' GROUP BY C_BIRTH_MONTH), ITEM GROUP BY I_CATEGORY_ID,
               C_BIRTH_MONTH)                                   
   6 - access: WEB_SITE_SK = WP_WEB_PAGE_SK                     
   7 - access: I_CATEGORY_ID = WEB_MKT_ID AND C_BIRTH_MONTH = EXTRACT(MONTH FROM WEB_REC_START_DATE)
   11 - filter: C_BIRTH_COUNTRY LIKE '%J%'                      

26 rows fetched.

SQL> 
SQL> explain select c_birth_month,i_category_id, min(c_birth_day), max(i_wholesale_cost)
  2   from customer, item
  3   where c_birth_country like '%J%'
  4   group by c_birth_month,i_category_id;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |          |      |      |       |        |
| 1   |   HASH GROUP BY              |       |          |      |      |       |        |
| 2   |     NESTED LOOPS             |       |          |      |      |       |        |
| 3   |       SUBSELECT              |       |          |      |      |       |        |
| 4   |         HASH GROUP BY        |       |          |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | CUSTOMER |      |      |       |        |
| 6   |       VM VIEW                |       |          |      |      |       |        |
| 7   |         HASH GROUP BY        |       |          |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | ITEM     |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: C_BIRTH_COUNTRY LIKE '%J%'                       

16 rows fetched.

SQL> 
SQL> drop table if exists item;

Succeed.

SQL> drop table if exists customer;

Succeed.

SQL> drop table if exists web_site;

Succeed.

SQL> drop table if exists web_page;

Succeed.

SQL> 
SQL> 
SQL> drop table if exists hj_t1;

Succeed.

SQL> drop table if exists hj_t2;

Succeed.

SQL> drop table if exists hj_t3;

Succeed.

SQL> create table hj_t1(f1 int, f2 int);

Succeed.

SQL> create table hj_t2(f1 int, f2 int);

Succeed.

SQL> create table hj_t3(f1 int);

Succeed.

SQL> insert into hj_t1 values(1,1),(2,2);

2 rows affected.

SQL> insert into hj_t2 values(1,1),(2,2);

2 rows affected.

SQL> insert into hj_t3 values(1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain select t1.* from (
  2     select T0.* FROM (
  3         SELECT t1.f1, t2.f2 from hj_t1 t1, hj_t2 t2 where t1.f1=t2.f1
  4     )   T0 WHERE t0.f1 in (select f1 from hj_t3)
  5 )t1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name     | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |          |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |          |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |          |      |      |       |        |
| 3   |       SUBSELECT            |       |          |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | HJ_T3    |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | HJ_T1 T1 |      |      |       |        |
| 6   |     TABLE ACCESS FULL      | SYS   | HJ_T2 T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.F1 = T2.F1                                    
   2 - access: HJ_T3.F1 = T1.F1                                 

15 rows fetched.

SQL> select t1.* from (
  2     select T0.* FROM (
  3         SELECT t1.f1, t2.f2 from hj_t1 t1, hj_t2 t2 where t1.f1=t2.f1
  4     )   T0 WHERE t0.f1 in (select f1 from hj_t3)
  5 )t1;

F1           F2          
------------ ------------
1            1           

1 rows fetched.

SQL> drop table if exists hj_t1;

Succeed.

SQL> drop table if exists hj_t2;

Succeed.

SQL> drop table if exists hj_t3;

Succeed.

SQL> 
SQL> drop table if exists oss_t1;

Succeed.

SQL> drop table if exists oss_t2;

Succeed.

SQL> create table oss_t1(id int not null, k int, c varchar(20), pad varchar(200));

Succeed.

SQL> create table oss_t2(groupid int not null, resid int, staff varchar(200));

Succeed.

SQL> create unique index oss_t1_pk on oss_t1(id);

Succeed.

SQL> create unique index oss_t2_pk on oss_t2(groupid, resid);

Succeed.

SQL> create index oss_t2_idx on oss_t2(resid);

Succeed.

SQL> explain select * from oss_t1 where id in (select resid from oss_t2 where groupid in (1,2,3,4,5,6,7,8,9,10) and staff='abc');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |           |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |           |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | OSS_T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | OSS_T2    |      |      |       |        |
| 4   |       OPTIMIZED INDEX RANGE SCAN | SYS   | OSS_T2_PK |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM OSS_T2 WHERE STAFF = 'abc' AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 
               10) AND ID = OSS_T2.RESID)                       
   3 - filter: STAFF = 'abc'                                    
   4 - access: ID = OSS_T2.RESID AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

15 rows fetched.

SQL> explain select * from oss_t1 where id in (select resid from oss_t2 where groupid in (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20) and staff = 'abc');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |           |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |           |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | OSS_T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | OSS_T2    |      |      |       |        |
| 4   |       OPTIMIZED INDEX RANGE SCAN | SYS   | OSS_T2_PK |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM OSS_T2 WHERE STAFF = 'abc' AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 
               10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20) AND ID = OSS_T2.RESID)
   3 - filter: STAFF = 'abc'                                    
   4 - access: ID = OSS_T2.RESID AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
               17, 18, 19, 20)                                  

16 rows fetched.

SQL> explain select * from oss_t1 where id in (select resid from oss_t2 where groupid in (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,38,40) and staff='abc');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |            |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | OSS_T1     |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | OSS_T2     |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | OSS_T2_IDX |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM OSS_T2 WHERE STAFF = 'abc' AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 
               10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
               32, 33, 34, 35, 36, 37, 38, 38, 40))             
   3 - filter: STAFF = 'abc' AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
               18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 38, 
               40)                                              
   4 - access: ID = OSS_T2.RESID                                

18 rows fetched.

SQL> 
SQL> DROP INDEX oss_t2_idx on oss_t2;

Succeed.

SQL> explain select * from oss_t1 where id in (select resid from oss_t2 where groupid in (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,38,40) and staff='abc');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |           |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |           |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | OSS_T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | OSS_T2    |      |      |       |        |
| 4   |       OPTIMIZED INDEX RANGE SCAN | SYS   | OSS_T2_PK |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM OSS_T2 WHERE STAFF = 'abc' AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 
               10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
               32, 33, 34, 35, 36, 37, 38, 38, 40) AND ID = OSS_T2.RESID)
   3 - filter: STAFF = 'abc'                                    
   4 - access: ID = OSS_T2.RESID AND GROUPID IN(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 
               17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 
               38, 40)                                          

18 rows fetched.

SQL> drop table if exists oss_t1;

Succeed.

SQL> drop table if exists oss_t2;

Succeed.

SQL> 
SQL> 
SQL> 
SQL> drop table if exists test_hash_join;

Succeed.

SQL> create table test_hash_join(id int, grantor int);

Succeed.

SQL> insert into test_hash_join values(0,0);

1 rows affected.

SQL> insert into test_hash_join values(2,2);

1 rows affected.

SQL> insert into test_hash_join values(3,3);

1 rows affected.

SQL> insert into test_hash_join values(4,4);

1 rows affected.

SQL> 
SQL> insert into test_hash_join values(5,5);

1 rows affected.

SQL> insert into test_hash_join values(6,6);

1 rows affected.

SQL> insert into test_hash_join values(7,7);

1 rows affected.

SQL> insert into test_hash_join values(8,8);

1 rows affected.

SQL> insert into test_hash_join values(9,9);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain select  
  2   74 as c15
  3 from 
  4   (((((((test_hash_join as ref_10)
  5                 inner join ((test_hash_join as ref_11)
  6                   inner join (test_hash_join as ref_12)
  7                   on (false))
  8                 on (((false) 
  9                       or (false)) 
 10                     or (ref_10.GRANTOR is not NULL)))
 11               inner join ((test_hash_join as ref_13)
 12                 left join (test_hash_join as ref_14)
 13                 on (true))
 14               on (true))
 15             inner join ((test_hash_join as ref_15)
 16               right join ((test_hash_join as ref_16)
 17                 left join (test_hash_join as ref_17)
 18                 on (ref_16.ID = ref_17.ID ))
 19               on (false))
 20             on (((ref_11.GRANTOR is NULL) 
 21                   or (((ref_15.ID is NULL)) 
 22                     and (true)))))
 23           inner join (((((test_hash_join as ref_19)
 24                   right join (test_hash_join as ref_20)
 25                   on (ref_19.ID = ref_20.ID ))
 26                 inner join (test_hash_join as ref_21)
 27                 on (ref_19.GRANTOR is not NULL))
 28               left join (test_hash_join as ref_22)
 29               on ((true) 
 30                   or ((false) 
 31                     and (false))))
 32             left join (test_hash_join as ref_23)
 33             on ((select ID from test_hash_join limit 1 offset 1)
 34                    is not NULL))
 35           on (ref_16.ID = ref_20.ID ))
 36         ));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                       |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                 |       |                       |      |      |       |        |
| 3   |       NESTED LOOPS               |       |                       |      |      |       |        |
| 4   |         NESTED LOOPS             |       |                       |      |      |       |        |
| 5   |           NESTED LOOPS           |       |                       |      |      |       |        |
| 6   |             TABLE ACCESS FULL    | SYS   | TEST_HASH_JOIN REF_10 |      |      |       |        |
| 7   |             TABLE ACCESS FULL    | SYS   | TEST_HASH_JOIN REF_11 |      |      |       |        |
| 8   |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_12 |      |      |       |        |
| 9   |         NESTED LOOPS OUTER       |       |                       |      |      |       |        |
| 10  |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_13 |      |      |       |        |
| 11  |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_14 |      |      |       |        |
| 12  |       NESTED LOOPS OUTER         |       |                       |      |      |       |        |
| 13  |         HASH JOIN OUTER(R)       |       |                       |      |      |       |        |
| 14  |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_16 |      |      |       |        |
| 15  |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_17 |      |      |       |        |
| 16  |         TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_15 |      |      |       |        |
| 17  |     KERNEL FILTER                |       |                       |      |      |       |        |
| 18  |       NESTED LOOPS OUTER         |       |                       |      |      |       |        |
| 19  |         NESTED LOOPS OUTER       |       |                       |      |      |       |        |
| 20  |           NESTED LOOPS           |       |                       |      |      |       |        |
| 21  |             HASH JOIN(L)         |       |                       |      |      |       |        |
| 22  |               TABLE ACCESS FULL  | SYS   | TEST_HASH_JOIN REF_20 |      |      |       |        |
| 23  |               TABLE ACCESS FULL  | SYS   | TEST_HASH_JOIN REF_19 |      |      |       |        |
| 24  |             TABLE ACCESS FULL    | SYS   | TEST_HASH_JOIN REF_21 |      |      |       |        |
| 25  |           TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_22 |      |      |       |        |
| 26  |         TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_23 |      |      |       |        |
| 27  |       QUERY LIMIT                |       |                       |      |      |       |        |
| 28  |         TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN        |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   13 - access: REF_16.ID = REF_17.ID                           
   21 - access: REF_20.ID = REF_19.ID                           
   23 - filter: REF_19.GRANTOR IS NOT NULL                      
   26 - filter: (SELECT ID FROM TEST_HASH_JOIN LIMIT 1 OFFSET 1) IS NOT NULL

39 rows fetched.

SQL> 
SQL> select  
  2   74 as c15
  3 from 
  4   (((((((test_hash_join as ref_10)
  5                 inner join ((test_hash_join as ref_11)
  6                   inner join (test_hash_join as ref_12)
  7                   on (false))
  8                 on (((false) 
  9                       or (false)) 
 10                     or (ref_10.GRANTOR is not NULL)))
 11               inner join ((test_hash_join as ref_13)
 12                 left join (test_hash_join as ref_14)
 13                 on (true))
 14               on (true))
 15             inner join ((test_hash_join as ref_15)
 16               right join ((test_hash_join as ref_16)
 17                 left join (test_hash_join as ref_17)
 18                 on (ref_16.ID = ref_17.ID ))
 19               on (false))
 20             on (((ref_11.GRANTOR is NULL) 
 21                   or (((ref_15.ID is NULL)) 
 22                     and (true)))))
 23           inner join (((((test_hash_join as ref_19)
 24                   right join (test_hash_join as ref_20)
 25                   on (ref_19.ID = ref_20.ID ))
 26                 inner join (test_hash_join as ref_21)
 27                 on (ref_19.GRANTOR is not NULL))
 28               left join (test_hash_join as ref_22)
 29               on ((true) 
 30                   or ((false) 
 31                     and (false))))
 32             left join (test_hash_join as ref_23)
 33             on ((select ID from test_hash_join limit 1 offset 1)
 34                    is not NULL))
 35           on (ref_16.ID = ref_20.ID ))
 36         ));

C15         
------------

0 rows fetched.

SQL> 
SQL> explain select  
  2   subq_0.c0 as c0, 
  3   ref_23.GRANTOR as c1, 
  4   subq_2.c2 as c3, 
  5   13 as c4
  6 from 
  7   ((((test_hash_join as ref_0)
  8           left join ((select  
  9                 ref_1.GRANTOR as c0
 10               from 
 11                 test_hash_join as ref_1
 12               limit 80) as subq_0)
 13           on (ref_0.ID = subq_0.c0 ))
 14         right join ((test_hash_join as ref_9)
 15                 inner join ((test_hash_join as ref_10))
 16                 on false)
 17         on ((ref_10.GRANTOR is not NULL) 
 18             and (EXISTS (
 19               select  
 20                   subq_0.c0 as c0
 21                 from 
 22                   test_hash_join as ref_15
 23                 where ((ref_9.GRANTOR is NULL)) 
 24                   or (ref_10.GRANTOR is not NULL)
 25                 limit 53))))
 26       inner join ((select  
 27             1
 28           from 
 29             test_hash_join as ref_16) as subq_1)
 30       on false)
 31     inner join (((select   
 32             ref_17.GRANTOR as c2, 
 33             ref_17.GRANTOR as c3
 34           from 
 35             test_hash_join as ref_17
 36           where (false) 
 37           limit 175) as subq_2)
 38       inner join (((((test_hash_join as ref_23)
 39               left join (test_hash_join as ref_24)
 40               on (((ref_23.ID is NULL) or (ref_23.ID is not NULL) ) or (true)))
 41             inner join (test_hash_join as ref_26)
 42             on ( (70 is not NULL)))
 43           left join (test_hash_join as ref_29)
 44           on (true))
 45         inner join (((test_hash_join as ref_30)
 46             right join (test_hash_join as ref_31)
 47             on (ref_30.GRANTOR is NULL))
 48           )
 49         on ((ref_29.GRANTOR is not NULL) 
 50             or (( (EXISTS (
 51                   select  
 52                       ref_31.GRANTOR as c0
 53                     from 
 54                       SYS_AUDIT as ref_43
 55                     where false))))))
 56       on (subq_2.c3 = ref_26.id ))
 57     on ((subq_2.c3 is NULL 
 58                     or ref_23.GRANTOR is NULL) 
 59           or (subq_2.c3 is not NULL))
 60 limit 88;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name                  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                       |      |      |       |        |
| 1   |   QUERY LIMIT                          |       |                       |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |                       |      |      |       |        |
| 3   |       NESTED LOOPS                     |       |                       |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                       |      |      |       |        |
| 5   |           NESTED LOOPS                 |       |                       |      |      |       |        |
| 6   |             SUBSELECT                  |       | SUBQ_1                |      |      |       |        |
| 7   |               TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_16 |      |      |       |        |
| 8   |             SUBSELECT                  |       | SUBQ_2                |      |      |       |        |
| 9   |               QUERY LIMIT              |       |                       |      |      |       |        |
| 10  |                 ROWNUM COUNT           |       |                       |      |      |       |        |
| 11  |                   TABLE ACCESS FULL    | SYS   | TEST_HASH_JOIN REF_17 |      |      |       |        |
| 12  |           KERNEL FILTER                |       |                       |      |      |       |        |
| 13  |             NESTED LOOPS OUTER         |       |                       |      |      |       |        |
| 14  |               NESTED LOOPS             |       |                       |      |      |       |        |
| 15  |                 TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_9  |      |      |       |        |
| 16  |                 TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_10 |      |      |       |        |
| 17  |               HASH JOIN OUTER(R)       |       |                       |      |      |       |        |
| 18  |                 TABLE ACCESS FULL      | SYS   | TEST_HASH_JOIN REF_0  |      |      |       |        |
| 19  |                 SUBSELECT              |       | SUBQ_0                |      |      |       |        |
| 20  |                   QUERY LIMIT          |       |                       |      |      |       |        |
| 21  |                     TABLE ACCESS FULL  | SYS   | TEST_HASH_JOIN REF_1  |      |      |       |        |
| 22  |             QUERY LIMIT                |       |                       |      |      |       |        |
| 23  |               TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_15 |      |      |       |        |
| 24  |         NESTED LOOPS OUTER             |       |                       |      |      |       |        |
| 25  |           NESTED LOOPS                 |       |                       |      |      |       |        |
| 26  |             NESTED LOOPS OUTER         |       |                       |      |      |       |        |
| 27  |               TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_23 |      |      |       |        |
| 28  |               TABLE ACCESS FULL        | SYS   | TEST_HASH_JOIN REF_24 |      |      |       |        |
| 29  |             TABLE ACCESS FULL          | SYS   | TEST_HASH_JOIN REF_26 |      |      |       |        |
| 30  |           TABLE ACCESS FULL            | SYS   | TEST_HASH_JOIN REF_29 |      |      |       |        |
| 31  |       NESTED LOOPS OUTER               |       |                       |      |      |       |        |
| 32  |         TABLE ACCESS FULL              | SYS   | TEST_HASH_JOIN REF_31 |      |      |       |        |
| 33  |         TABLE ACCESS FULL              | SYS   | TEST_HASH_JOIN REF_30 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   10 - filter: NULL IS NOT NULL                                
   13 - access: REF_10.GRANTOR IS NOT NULL AND EXISTS(SELECT 1 FROM TEST_HASH_JOIN REF_15 WHERE REF_9.GRANTOR IS NULL OR 
               REF_10.GRANTOR IS NOT NULL LIMIT 53)             
   17 - access: REF_0.ID = SUBQ_0.C0                            
   23 - filter: REF_9.GRANTOR IS NULL OR REF_10.GRANTOR IS NOT NULL
   33 - filter: REF_30.GRANTOR IS NULL                          

46 rows fetched.

SQL> 
SQL> select  
  2   subq_0.c0 as c0, 
  3   ref_23.GRANTOR as c1, 
  4   subq_2.c2 as c3, 
  5   13 as c4
  6 from 
  7   ((((test_hash_join as ref_0)
  8           left join ((select  
  9                 ref_1.GRANTOR as c0
 10               from 
 11                 test_hash_join as ref_1
 12               limit 80) as subq_0)
 13           on (ref_0.ID = subq_0.c0 ))
 14         right join ((test_hash_join as ref_9)
 15                 inner join ((test_hash_join as ref_10))
 16                 on false)
 17         on ((ref_10.GRANTOR is not NULL) 
 18             and (EXISTS (
 19               select  
 20                   subq_0.c0 as c0
 21                 from 
 22                   test_hash_join as ref_15
 23                 where ((ref_9.GRANTOR is NULL)) 
 24                   or (ref_10.GRANTOR is not NULL)
 25                 limit 53))))
 26       inner join ((select  
 27             1
 28           from 
 29             test_hash_join as ref_16) as subq_1)
 30       on false)
 31     inner join (((select   
 32             ref_17.GRANTOR as c2, 
 33             ref_17.GRANTOR as c3
 34           from 
 35             test_hash_join as ref_17
 36           where (false) 
 37           limit 175) as subq_2)
 38       inner join (((((test_hash_join as ref_23)
 39               left join (test_hash_join as ref_24)
 40               on (((ref_23.ID is NULL) or (ref_23.ID is not NULL) ) or (true)))
 41             inner join (test_hash_join as ref_26)
 42             on ( (70 is not NULL)))
 43           left join (test_hash_join as ref_29)
 44           on (true))
 45         inner join (((test_hash_join as ref_30)
 46             right join (test_hash_join as ref_31)
 47             on (ref_30.GRANTOR is NULL))
 48           )
 49         on ((ref_29.GRANTOR is not NULL) 
 50             or (( (EXISTS (
 51                   select  
 52                       ref_31.GRANTOR as c0
 53                     from 
 54                       SYS_AUDIT as ref_43
 55                     where false))))))
 56       on (subq_2.c3 = ref_26.id ))
 57     on ((subq_2.c3 is NULL 
 58                     or ref_23.GRANTOR is NULL) 
 59           or (subq_2.c3 is not NULL))
 60 limit 88;

C0           C1           C3           C4          
------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> select   
  2   count(*)
  3 from 
  4   ((test_hash_join as ref_0)
  5       inner join (((select 
  6               ref_1.ID as c1
  7             from 
  8               test_hash_join as ref_1
  9             limit 171) as subq_0)
 10         right join (((test_hash_join as ref_2)
 11             left join (test_hash_join as ref_3)
 12             on false)
 13           inner join (select  
 14                 ref_5.GRANTOR as c0, 
 15                 ref_4.GRANTOR as c1
 16               from 
 17                 (test_hash_join as ref_4)
 18                   left join (test_hash_join as ref_5)
 19                   on (ref_4.ID = ref_5.ID))
 20           on (75 is not NULL))
 21         on (subq_0.c1 = ref_3.ID ))
 22       on subq_0.c1 is NULL)
 23 where ((ref_3.ID is NULL)
 24     or (subq_0.c1 is not NULL));

COUNT(*)            
--------------------
729                 

1 rows fetched.

SQL> 
SQL> select   
  2   count(*)
  3 from 
  4   ((test_hash_join as ref_0)
  5       inner join (((select 
  6               ref_1.ID as c1
  7             from 
  8               test_hash_join as ref_1
  9             limit 171) as subq_0)
 10         full join (((test_hash_join as ref_2)
 11             left join (test_hash_join as ref_3)
 12             on false)
 13           inner join (select  
 14                 ref_5.GRANTOR as c0, 
 15                 ref_4.GRANTOR as c1
 16               from 
 17                 (test_hash_join as ref_4)
 18                   left join (test_hash_join as ref_5)
 19                   on (ref_4.ID = ref_5.ID))
 20           on (75 is not NULL))
 21         on (subq_0.c1 = ref_3.ID ))
 22       on subq_0.c1 is NULL)
 23 where ((ref_3.ID is NULL)
 24     or (subq_0.c1 is not NULL));

COUNT(*)            
--------------------
729                 

1 rows fetched.

SQL> drop table if exists test_hash_join;

Succeed.

SQL> 
SQL> --    NL -T4.OWNER IS NULL
SQL> --   /  \
SQL> --  T1 NLFULL
SQL> --     /    \
SQL> --   HJ(L)  NL
SQL> --   / \   / \
SQL> --  T2 T4 T5 T6
SQL> -- Cannot match condition (T4.OWNER IS NULL) while fetching from T5, if T2 is EOF.
SQL> SELECT 1
  2 FROM
  3   ((SYS.SYS_PART_OBJECTS AS T1))
  4     CROSS JOIN (((SYS.MY_SUBPART_KEY_COLUMNS AS T2)
  5         INNER JOIN ((SYS.DB_VIEW_DEPENDENCIES AS T4))
  6         ON (T2.COLUMN_NAME = T4.OWNER ))
  7       FULL OUTER JOIN (((SYS.MY_TAB_MODIFICATIONS AS T5)
  8           CROSS JOIN (SYS.ADM_ARGUMENTS AS T6)))
  9       ON (true))
 10 WHERE T4.OWNER IS NULL limit 1;

1           
------------
1           

1 rows fetched.

SQL> 
SQL> --hash_cursor is null while fetching hash join
SQL> DROP TABLE IF EXISTS "SK_MY_EMPLOYEES" ;

Succeed.

SQL> CREATE TABLE "SK_MY_EMPLOYEES"
  2 (
  3   "ID" BINARY_INTEGER,
  4   "DD" CLOB,
  5   "FLAG" CHAR(1 BYTE),
  6   "BB" BOOLEAN,
  7   "DBL" BINARY_DOUBLE
  8 );

Succeed.

SQL> INSERT INTO "SK_MY_EMPLOYEES" ("ID","DD","FLAG","BB","DBL") values (0,'dddddddddddddddddddddddd','m',TRUE,301415902);

1 rows affected.

SQL> INSERT INTO "SK_MY_EMPLOYEES" ("ID","DD","FLAG","BB","DBL") values (111,'ssssssssssssssssssssss','f',FALSE,0.1415902);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> DROP TABLE IF EXISTS "SK_STATES" ;

Succeed.

SQL> CREATE TABLE "SK_STATES"
  2 (
  3   "STATE_ID" CHAR(2 BYTE) NOT NULL,
  4   "STATE_NAME" VARCHAR(40 BYTE),
  5   "AREA_ID" NUMBER
  6 );

Succeed.

SQL> INSERT INTO "SK_STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('AR','Argentina',2);

1 rows affected.

SQL> INSERT INTO "SK_STATES" ("STATE_ID","STATE_NAME","AREA_ID") values
  2   ('AU','Australia',3);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "SK_STATES" ADD CONSTRAINT "SK_STATE_C_ID_PK" PRIMARY KEY("STATE_ID");

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_STAFFS" ;

Succeed.

SQL> CREATE TABLE "SK_STAFFS"
  2 (
  3   "STAFF_ID" NUMBER(6) NOT NULL,
  4   "FIRST_NAME" VARCHAR(20 BYTE),
  5   "LAST_NAME" VARCHAR(25 BYTE),
  6   "EMAIL" VARCHAR(25 BYTE),
  7   "PHONE_NUMBER" VARCHAR(20 BYTE),
  8   "HIRE_DATE" DATE,
  9   "EMPLOYMENT_ID" VARCHAR(10 BYTE),
 10   "SALARY" NUMBER(8, 2),
 11   "COMMISSION_PCT" NUMBER(2, 2),
 12   "MANAGER_ID" NUMBER(6),
 13   "SECTION_ID" NUMBER(4),
 14   "GRADUATED_NAME" VARCHAR(60 BYTE)
 15 );

Succeed.

SQL> INSERT INTO "SK_STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values (198,'Donald','OConnell','DOCONNEL','650.507.9833','1999-06-21 00:00:00','SH_CLERK',2600,null,124,50,null);

1 rows affected.

SQL> INSERT INTO "SK_STAFFS" ("STAFF_ID","FIRST_NAME","LAST_NAME","EMAIL","PHONE_NUMBER","HIRE_DATE","EMPLOYMENT_ID","SALARY","COMMISSION_PCT","MANAGER_ID","SECTION_ID","GRADUATED_NAME") values (199,'Douglas','Grant','DGRANT','650.507.9844','2000-01-13 00:00:00','SH_CLERK',2600,null,124,50,null);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_SCORE" ;

Succeed.

SQL> CREATE TABLE "SK_SCORE"
  2 (
  3   "ID" BINARY_INTEGER NOT NULL,
  4   "STU_ID" BINARY_INTEGER NOT NULL,
  5   "C_NAME" VARCHAR(50 BYTE),
  6   "GRADE" BINARY_INTEGER
  7 );

Succeed.

SQL> INSERT INTO "SK_SCORE" ("ID","STU_ID","C_NAME","GRADE") values (1,901,'计算机',98);

1 rows affected.

SQL> INSERT INTO "SK_SCORE" ("ID","STU_ID","C_NAME","GRADE") values (2,901,'英语',80);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "SK_SCORE" ADD CONSTRAINT "SK_SCORE_ID_PK" PRIMARY KEY("ID");

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_FVT_OBJ_DEFINE_TABLE_FRE1" ;

Succeed.

SQL> CREATE TABLE "SK_FVT_OBJ_DEFINE_TABLE_FRE1"
  2 (
  3   "COL_3" BOOLEAN,
  4   "COL_6" BINARY_INTEGER,
  5   "COL_13" BOOLEAN,
  6   "COL_14" BOOLEAN,
  7   "COL_49" BOOLEAN,
  8   "COL_119" BOOLEAN,
  9   "COL_182" DATE
 10 );

Succeed.

SQL> 
SQL> SELECT
  2   ref_0.DD AS C10
  3 FROM
  4   (SK_MY_EMPLOYEES AS ref_0)
  5     CROSS JOIN ((SK_STATES AS ref_1)
  6       FULL JOIN ((((SK_STAFFS AS ref_7)
  7             INNER JOIN (SK_SCORE AS ref_10)
  8             ON ((SELECT COL_3 FROM SK_FVT_OBJ_DEFINE_TABLE_FRE1 LIMIT 1)
  9                    < (SELECT COL_3 FROM SK_FVT_OBJ_DEFINE_TABLE_FRE1 LIMIT 1 OFFSET 6)))
 10           INNER JOIN (SK_FVT_OBJ_DEFINE_TABLE_FRE1 AS ref_11)
 11           ON (ref_10.STU_ID = ref_11.COL_6 )))
 12       ON (ref_11.COL_119 >= ref_11.COL_49))
 13 WHERE ref_11.COL_3 >= ref_0.BB;

C10                                                             
----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT
  2   ref_0.DD AS C10
  3 FROM
  4   ((SK_MY_EMPLOYEES AS ref_0)
  5         FULL OUTER JOIN ((SK_FVT_OBJ_DEFINE_TABLE_FRE1 AS ref_1)
  6           CROSS JOIN ((SK_STAFFS AS ref_2)
  7             INNER JOIN ((SK_SCORE AS ref_3)
  8               LEFT JOIN (SK_STATES AS ref_4)
  9               ON (ref_3.STU_ID = ref_4.AREA_ID ))
 10             ON (ref_3.ID <> ref_3.ID)))
 11         ON (ref_1.COL_3 >= ref_1.COL_3))
 12       INNER JOIN ((SELECT
 13               *
 14             FROM
 15               SK_STATES AS ref_5
 16             LIMIT 136) AS subq_0)
 17       ON (subq_0.STATE_ID <= ref_1.COL_119)
 18 ;

C10                                                             
----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> SELECT
  2   ref_0.DD AS C10
  3 FROM
  4   ((SK_MY_EMPLOYEES AS ref_0)
  5         FULL OUTER JOIN ((SK_FVT_OBJ_DEFINE_TABLE_FRE1 AS ref_1)
  6           CROSS JOIN ((SK_STAFFS AS ref_2)
  7             INNER JOIN ((SK_SCORE AS ref_3)
  8               FULL OUTER JOIN (SK_STATES AS ref_4)
  9               ON (ref_3.STU_ID = ref_4.AREA_ID))
 10             ON (true)))
 11         ON (ref_1.COL_3 >= ref_1.COL_3))
 12       INNER JOIN ((SELECT
 13               *
 14             FROM
 15               SK_STATES AS ref_5
 16             LIMIT 136) AS subq_0)
 17       ON (subq_0.STATE_ID <= ref_1.COL_119)
 18 ;

C10                                                             
----------------------------------------------------------------

0 rows fetched.

SQL> --DTS2020101004TWWHP0K00
SQL> DROP TABLE IF EXISTS "SK_PLACES" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "SK_PLACES"
  2 (
  3   "PLACE_ID" NUMBER(4) NOT NULL,
  4   "STREET_ADDRESS" VARCHAR(40 BYTE),
  5   "POSTAL_CODE" VARCHAR(12 BYTE),
  6   "CITY" VARCHAR(30 BYTE),
  7   "STATE_PROVINCE" VARCHAR(25 BYTE),
  8   "STATE_ID" CHAR(2 BYTE)
  9 );

Succeed.

SQL> INSERT INTO "SK_PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values (1000,'1297 Via Cola di Rie','00989','Roma',null,'IT');

1 rows affected.

SQL> INSERT INTO "SK_PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values (1100,'93091 Calle della Testa','10934','Venice',null,'IT');

1 rows affected.

SQL> INSERT INTO "SK_PLACES" ("PLACE_ID","STREET_ADDRESS","POSTAL_CODE","CITY","STATE_PROVINCE","STATE_ID") values (1200,'2017 Shinjuku-ku','1689','Tokyo','Tokyo Prefecture','JP');

1 rows affected.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_COLLEGE" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "SK_COLLEGE"
  2 (
  3   "SK_COLLEGE_ID" NUMBER,
  4   "SK_COLLEGE_NAME" VARCHAR(40 BYTE)
  5 );

Succeed.

SQL> INSERT INTO "SK_COLLEGE" ("SK_COLLEGE_ID","SK_COLLEGE_NAME") values (1001,'The University of Melbourne');

1 rows affected.

SQL> INSERT INTO "SK_COLLEGE" ("SK_COLLEGE_ID","SK_COLLEGE_NAME") values (1002,'Duke University');

1 rows affected.

SQL> INSERT INTO "SK_COLLEGE" ("SK_COLLEGE_ID","SK_COLLEGE_NAME") values(1003,'New York University');

1 rows affected.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_SECTIONS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "SK_SECTIONS"
  2 (
  3   "SECTION_ID" NUMBER(4) NOT NULL,
  4   "SECTION_NAME" VARCHAR(30 BYTE),
  5   "MANAGER_ID" NUMBER(6),
  6   "PLACE_ID" NUMBER(4)
  7 );

Succeed.

SQL> INSERT INTO "SK_SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values (10,'Administration',200,1700);

1 rows affected.

SQL> INSERT INTO "SK_SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values (20,'Marketing',201,1800);

1 rows affected.

SQL> INSERT INTO "SK_SECTIONS" ("SECTION_ID","SECTION_NAME","MANAGER_ID","PLACE_ID") values (30,'Purchasing',114,1700);

1 rows affected.

SQL> 
SQL> DROP TABLE IF EXISTS "SK_DEPT_MANAGER" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "SK_DEPT_MANAGER"
  2 (
  3   "EMP_NO" BINARY_INTEGER NOT NULL,
  4   "DEPT_NO" CHAR(30 BYTE) NOT NULL,
  5   "FROM_DATE" DATE NOT NULL,
  6   "TO_DATE" DATE NOT NULL
  7 );

Succeed.

SQL> INSERT INTO "SK_DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10017,'d001                          ','1985-01-01 00:00:00','1991-10-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SK_DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10020,'d002                          ','1991-10-01 00:00:00','9999-01-01 00:00:00');

1 rows affected.

SQL> INSERT INTO "SK_DEPT_MANAGER" ("EMP_NO","DEPT_NO","FROM_DATE","TO_DATE") values (10013,'d003                          ','1985-01-01 00:00:00','1989-12-17 00:00:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE "SK_DEPT_MANAGER" ADD CONSTRAINT "SK_DEPT_MANAGER_PK" PRIMARY KEY("EMP_NO", "DEPT_NO");

Succeed.

SQL> 
SQL> SELECT
  2   1
  3 FROM
  4   (SK_FVT_OBJ_DEFINE_TABLE_FRE1 AS ref_3)
  5     RIGHT OUTER JOIN (((SK_PLACES AS ref_6)
  6         FULL OUTER JOIN (SK_COLLEGE AS ref_7)
  7         ON (ref_6.STREET_ADDRESS = ref_7.SK_COLLEGE_NAME ))
  8       INNER JOIN (((SK_DEPT_MANAGER AS ref_9))
  9         FULL JOIN ((SELECT
 10               ref_14.COL_49 AS C0
 11             FROM
 12 			(SK_FVT_OBJ_DEFINE_TABLE_FRE1 AS ref_14)
 13             WHERE ref_14.COL_3 <= ref_14.COL_14) AS subq_2)
 14         ON (false))
 15       ON (NOT EXISTS (
 16           SELECT
 17               ref_6.CITY AS C0
 18             FROM
 19               SK_SECTIONS AS ref_15
 20             WHERE (subq_2.C0 < subq_2.C0))))
 21     ON (ref_3.COL_182 = ref_9.FROM_DATE )
 22 WHERE CAST(nullif(subq_2.C0, ref_3.COL_13) AS BOOLEAN) >= ref_3.COL_14;

1           
------------

0 rows fetched.

SQL> 
SQL> drop table if exists SK_TBL_RANGE26;

Succeed.

SQL> CREATE TABLE SK_TBL_RANGE26(
  2 id BINARY_INTEGER not null,
  3 c_double double,
  4 c_varchar2 varchar2(100) default 1,
  5 c_timestamp_zone timestamp with time zone,
  6 c_yeartomonth interval year to month,
  7 c_bool bool
  8 );

Succeed.

SQL> SELECT
  2   1
  3 FROM
  4   ((((((( SK_TBL_RANGE26 AS ref_0)
  5                 CROSS JOIN ( SK_TBL_RANGE26 AS ref_1))
  6               FULL JOIN ( SK_TBL_RANGE26 AS ref_2)
  7               ON (ref_0.ID = ref_2.ID ))
  8             CROSS JOIN ( SK_DEPT_MANAGER AS ref_3))
  9           FULL JOIN ( SK_COLLEGE AS ref_4)
 10           ON (ref_1.C_BOOL > ref_0.C_BOOL)))
 11       INNER JOIN (( SK_TBL_RANGE26 AS ref_10))
 12       ON (ref_3.EMP_NO = ref_10.ID ))
 13     LEFT OUTER JOIN ((SK_SECTIONS AS ref_11)
 14       FULL OUTER JOIN (((( SK_SECTIONS AS ref_12)
 15             RIGHT JOIN (( SK_TBL_RANGE26 AS ref_15))
 16             ON (ref_12.SECTION_ID = ref_15.ID ))
 17           CROSS JOIN (((( SK_TBL_RANGE26 AS ref_16)
 18                 FULL JOIN ( SK_PLACES AS ref_17)
 19                 ON (ref_16.C_VARCHAR2 IS NULL))
 20               FULL OUTER JOIN (( SK_TBL_RANGE26 AS ref_18)
 21                 LEFT OUTER JOIN ( SK_TBL_RANGE26 AS ref_19)
 22                 ON (ref_19.C_DOUBLE IS NOT NULL))
 23               ON (ref_16.C_YEARTOMONTH = ref_18.C_YEARTOMONTH ))
 24             LEFT JOIN ( SK_TBL_RANGE26 AS ref_20)
 25             ON (true)))
 26         LEFT JOIN ( SK_TBL_RANGE26 AS ref_21)
 27         ON (true))
 28       ON (ref_15.C_BOOL >= ref_20.C_BOOL))
 29     ON ((true)
 30         OR ((ref_19.C_TIMESTAMP_ZONE IS NULL)
 31           AND (ref_0.C_BOOL >= ref_15.C_BOOL)))
 32 WHERE ref_16.C_BOOL >= ref_1.C_BOOL;

1           
------------

0 rows fetched.

SQL> SELECT
  2   1
  3 FROM
  4   ((((((( SK_TBL_RANGE26 AS ref_0)
  5                 CROSS JOIN ( SK_TBL_RANGE26 AS ref_1))
  6               FULL JOIN ( SK_TBL_RANGE26 AS ref_2)
  7               ON (ref_0.ID = ref_2.ID ))
  8             CROSS JOIN ( SK_DEPT_MANAGER AS ref_3))
  9           FULL JOIN ( SK_COLLEGE AS ref_4)
 10           ON (ref_1.C_BOOL > ref_0.C_BOOL)))
 11       INNER JOIN (( SK_TBL_RANGE26 AS ref_10))
 12       ON (ref_3.EMP_NO = ref_10.ID ))
 13     LEFT OUTER JOIN ((SK_SECTIONS AS ref_11)
 14       FULL OUTER JOIN (((( SK_SECTIONS AS ref_12)
 15             INNER JOIN (( SK_TBL_RANGE26 AS ref_15))
 16             ON (ref_12.SECTION_ID = ref_15.ID ))
 17           CROSS JOIN (((( SK_TBL_RANGE26 AS ref_16)
 18                 FULL JOIN ( SK_PLACES AS ref_17)
 19                 ON (ref_16.C_VARCHAR2 IS NULL))
 20               FULL OUTER JOIN (( SK_TBL_RANGE26 AS ref_18)
 21                 LEFT OUTER JOIN ( SK_TBL_RANGE26 AS ref_19)
 22                 ON (ref_19.C_DOUBLE IS NOT NULL))
 23               ON (ref_16.C_YEARTOMONTH = ref_18.C_YEARTOMONTH ))
 24             LEFT JOIN ( SK_TBL_RANGE26 AS ref_20)
 25             ON (true)))
 26         LEFT JOIN ( SK_TBL_RANGE26 AS ref_21)
 27         ON (true))
 28       ON (ref_15.C_BOOL >= ref_20.C_BOOL))
 29     ON ((true)
 30         OR ((ref_19.C_TIMESTAMP_ZONE IS NULL)
 31           AND (ref_0.C_BOOL >= ref_15.C_BOOL)))
 32 WHERE ref_16.C_BOOL >= ref_1.C_BOOL;
1           
------------

0 rows fetched.

SQL> --20201016
SQL> drop table if exists tbl_sqlkiller_39_2;

Succeed.

SQL> drop table if exists tbl_sqlkiller_39_6;

Succeed.

SQL> drop table if exists tbl_subpartition_range2_34;

Succeed.

SQL> drop table if exists tbl_subpartition_range2_15;

Succeed.

SQL> drop table if exists tbl_sqlkiller_45;

Succeed.

SQL> drop table if exists FVT_OBJ_DEFINE_TABLE_FRE1;

Succeed.

SQL> CREATE TABLE "FVT_OBJ_DEFINE_TABLE_FRE1"
  2 (
  3   "COL_1" BINARY_BIGINT,  "COL_2" TIMESTAMP(6),  "COL_3" BOOLEAN,  "COL_4" NUMBER,  "COL_5" CLOB,  "COL_6" BINARY_INTEGER,  "COL_7" CHAR(30 BYTE),
  4   "COL_8" BINARY_DOUBLE,  "COL_9" CLOB,  "COL_10" CLOB,  "COL_11" VARCHAR(30 BYTE),  "COL_12" BINARY_DOUBLE,  "COL_13" BOOLEAN,  "COL_14" BOOLEAN,
  5   "COL_15" BLOB,  "COL_16" BINARY_DOUBLE,  "COL_17" VARCHAR(30 BYTE),  "COL_18" VARCHAR(30 BYTE),  "COL_19" TIMESTAMP(6) WITH TIME ZONE,  "COL_20" CHAR(30 BYTE),
  6   "COL_21" BLOB,  "COL_22" NUMBER,  "COL_23" BLOB,  "COL_24" CHAR(30 BYTE),  "COL_25" BINARY_INTEGER,
  7   "COL_26" BINARY_DOUBLE,  "COL_27" NUMBER,  "COL_28" NUMBER,  "COL_29" BINARY_INTEGER,  "COL_30" BLOB,  "COL_31" BINARY_DOUBLE,  "COL_32" BLOB,  "COL_33" NUMBER,
  8   "COL_34" CHAR(30 BYTE),  "COL_35" BINARY_DOUBLE,  "COL_36" CHAR(30 BYTE),  "COL_37" NUMBER,  "COL_38" TIMESTAMP(6),  "COL_39" BINARY_BIGINT,  "COL_40" BINARY_DOUBLE,
  9   "COL_41" BLOB,  "COL_42" BINARY_INTEGER,  "COL_43" BINARY_DOUBLE,  "COL_44" BINARY_INTEGER,  "COL_45" TIMESTAMP(6),  "COL_46" CLOB,  "COL_47" CHAR(30 BYTE),  "COL_48" NUMBER,
 10   "COL_49" BOOLEAN,  "COL_50" BINARY_INTEGER,  "COL_51" TIMESTAMP(6) WITH TIME ZONE,  "COL_52" BLOB,  "COL_53" BINARY_INTEGER,  "COL_54" BINARY_INTEGER,  "COL_55" NUMBER,
 11   "COL_56" BINARY_INTEGER,  "COL_57" BLOB,  "COL_58" TIMESTAMP(6) WITH TIME ZONE,  "COL_59" NUMBER,  "COL_60" BINARY_DOUBLE,  "COL_61" INTERVAL DAY(2) TO SECOND(6),
 12   "COL_62" BINARY_DOUBLE,  "COL_63" CLOB,  "COL_64" TIMESTAMP(6) WITH TIME ZONE,  "COL_65" TIMESTAMP(6) WITH TIME ZONE,  "COL_66" VARCHAR(30 BYTE),  "COL_67" BOOLEAN,
 13   "COL_68" CHAR(30 CHAR),  "COL_69" BINARY_DOUBLE,  "COL_70" BINARY_DOUBLE,  "COL_71" CHAR(30 BYTE),  "COL_72" VARCHAR(30 BYTE),  "COL_73" BINARY_INTEGER,  "COL_74" BINARY_BIGINT,
 14   "COL_75" BINARY_INTEGER,  "COL_76" CHAR(100 CHAR),  "COL_77" TIMESTAMP(6) WITH TIME ZONE,  "COL_78" NUMBER,  "COL_79" VARCHAR(30 BYTE),  "COL_80" CHAR(30 BYTE),  "COL_81" BLOB,
 15   "COL_82" CLOB,  "COL_83" NUMBER,  "COL_84" BINARY_DOUBLE,  "COL_85" BINARY_INTEGER,  "COL_86" CHAR(30 BYTE),  "COL_87" TIMESTAMP(6) WITH TIME ZONE,  "COL_88" NUMBER,  "COL_89" BINARY_BIGINT,
 16   "COL_90" BLOB,  "COL_91" BLOB,  "COL_92" BINARY_DOUBLE,  "COL_93" BINARY_DOUBLE,  "COL_94" BINARY_INTEGER,  "COL_95" CHAR(30 BYTE),  "COL_96" BINARY_BIGINT,  "COL_97" BINARY_DOUBLE,
 17   "COL_98" BINARY_INTEGER,  "COL_99" CHAR(30 BYTE),  "COL_100" VARCHAR(30 BYTE),  "COL_101" BINARY_BIGINT,  "COL_102" CLOB,  "COL_103" TIMESTAMP(6) WITH LOCAL TIME ZONE,  "COL_104" TIMESTAMP(6),
 18   "COL_105" NUMBER,  "COL_106" NUMBER,  "COL_107" NUMBER,  "COL_108" IMAGE,  "COL_109" BOOLEAN,  "COL_110" BINARY_DOUBLE,  "COL_111" CHAR(30 BYTE),  "COL_112" VARCHAR(30 BYTE),
 19   "COL_113" NUMBER,  "COL_114" BINARY_INTEGER,  "COL_115" VARCHAR(30 BYTE),  "COL_116" NUMBER,  "COL_117" BINARY_BIGINT,  "COL_118" INTERVAL YEAR(2) TO MONTH,  "COL_119" BOOLEAN,"COL_120" NUMBER,
 20   "COL_121" BLOB,  "COL_122" BINARY_DOUBLE,  "COL_123" BINARY_DOUBLE,  "COL_124" BINARY_INTEGER,  "COL_125" BINARY_INTEGER,  "COL_126" BINARY_INTEGER,  "COL_127" TIMESTAMP(6),  "COL_128" BINARY_INTEGER,
 21   "COL_129" TIMESTAMP(6) WITH TIME ZONE,  "COL_130" CHAR(30 BYTE),  "COL_131" BLOB,  "COL_132" CHAR(30 BYTE),  "COL_133" BINARY_BIGINT,  "COL_134" TIMESTAMP(6) WITH TIME ZONE,  "COL_135" BINARY_INTEGER,
 22   "COL_136" NUMBER,  "COL_137" NUMBER,  "COL_138" INTERVAL YEAR(2) TO MONTH,  "COL_139" BLOB,  "COL_140" CHAR(30 BYTE),  "COL_141" NUMBER,  "COL_142" BINARY_DOUBLE,  "COL_143" BINARY_DOUBLE,
 23   "COL_144" CLOB,  "COL_145" BOOLEAN,  "COL_146" BINARY_INTEGER,  "COL_147" BINARY_BIGINT,  "COL_148" CHAR(30 BYTE),  "COL_149" VARCHAR(30 BYTE),  "COL_150" BLOB,  "COL_151" BINARY_DOUBLE,
 24   "COL_152" CHAR(30 BYTE),  "COL_153" BINARY_DOUBLE,  "COL_154" CLOB,  "COL_155" BINARY_BIGINT,  "COL_156" BINARY_INTEGER,  "COL_157" NUMBER,  "COL_158" INTERVAL YEAR(2) TO MONTH,  "COL_159" TIMESTAMP(6) WITH TIME ZONE,
 25   "COL_160" BLOB,  "COL_161" NUMBER,  "COL_162" BINARY_INTEGER,  "COL_163" RAW(100),  "COL_164" NUMBER(6, 2),  "COL_165" BINARY_INTEGER,  "COL_166" CLOB,  "COL_167" BINARY_DOUBLE,  "COL_168" NUMBER(6, 2),
 26   "COL_169" NUMBER(6, 2),  "COL_170" NUMBER(6, 2),  "COL_171" RAW(100),  "COL_172" BINARY_INTEGER,  "COL_173" CLOB,  "COL_174" VARCHAR(50 BYTE),  "COL_175" VARCHAR(30 BYTE),  "COL_176" BINARY_DOUBLE,
 27   "COL_177" TIMESTAMP(6) WITH TIME ZONE,  "COL_178" NUMBER(6, 2),  "COL_179" NUMBER(6, 2),  "COL_180" VARCHAR(100 CHAR),  "COL_181" NUMBER(6, 2),  "COL_182" DATE,  "COL_183" NUMBER(12, 6),
 28   "COL_184" NUMBER(6, 2),  "COL_185" VARCHAR(30 CHAR),  "COL_186" BINARY_INTEGER,  "COL_187" NUMBER(6, 2),  "COL_188" DATE,  "COL_189" DATE,  "COL_190" NUMBER(6, 2),  "COL_191" NUMBER(6, 2),
 29   "COL_192" VARCHAR(30 BYTE),  "COL_193" TIMESTAMP(6),  "COL_194" BINARY_DOUBLE,  "COL_195" IMAGE,  "COL_196" NUMBER(6, 2),  "COL_197" NUMBER(6, 2),  "COL_198" NUMBER(6, 2),  "COL_199" CLOB,
 30   "COL_200" VARCHAR(55 CHAR),  "COL_201" BINARY_DOUBLE,  "COL_202" INTERVAL DAY(2) TO SECOND(6),  "COL_203" NUMBER(6, 2),  "COL_204" VARCHAR(30 BYTE),  "COL_205" NUMBER(6, 2),  "COL_206" NUMBER(6, 2),
 31   "COL_207" VARCHAR(30 BYTE),  "COL_208" RAW(200),  "COL_209" NUMBER(6, 2),  "COL_210" NUMBER(6, 2),  "COL_211" BINARY_DOUBLE,  "COL_212" BINARY_DOUBLE,  "COL_213" NUMBER(6, 2),  "COL_214" VARCHAR(30 BYTE),
 32   "COL_215" CLOB,  "COL_216" BINARY_INTEGER,  "COL_217" NUMBER(6, 2),  "COL_218" NUMBER(6, 2),  "COL_219" CLOB,  "COL_220" VARCHAR(30 BYTE),  "COL_221" BINARY_INTEGER,  "COL_222" NUMBER(6, 2),
 33   "COL_223" TIMESTAMP(6),  "COL_224" VARCHAR(30 BYTE),  "COL_225" DATE,  "COL_226" NUMBER(16, 2),  "COL_227" VARCHAR(100 BYTE),  "COL_228" DATE,  "COL_229" CLOB,  "COL_230" NUMBER(12, 6),  "COL_231" DATE,
 34   "COL_232" NUMBER(6, 2),  "COL_233" BINARY_INTEGER,  "COL_234" DATE,  "COL_235" VARCHAR(200 CHAR),  "COL_236" NUMBER(6, 2),  "COL_237" CLOB,  "COL_238" VARCHAR(300 BYTE),  "COL_239" NUMBER(6, 2),
 35   "COL_240" CLOB,  "COL_241" VARCHAR(30 BYTE),  "COL_242" NUMBER(6, 2),  "COL_243" NUMBER(6, 2),  "COL_244" BINARY_DOUBLE,  "COL_245" VARCHAR(60 BYTE),  "COL_246" BINARY_INTEGER,"COL_247" VARBINARY(200),
 36   "COL_248" VARCHAR(30 BYTE),  "COL_249" BINARY(200),  "COL_250" NUMBER(6, 2),  "COL_251" RAW(100),  "COL_252" BINARY_DOUBLE,  "COL_253" NUMBER(6, 2),  "COL_254" BINARY_DOUBLE,  "COL_255" DATE,  "COL_256" NUMBER(6, 2),
 37   "COL_257" BINARY_INTEGER,  "COL_258" NUMBER(6, 2),  "COL_259" BINARY(100),  "COL_260" RAW(100),  "COL_261" VARCHAR(60 BYTE),  "COL_262" VARCHAR(30 BYTE),  "COL_263" NUMBER(6, 2),  "COL_264" CLOB,
 38   "COL_265" NUMBER(6, 2),  "COL_266" CLOB,  "COL_267" VARCHAR(30 BYTE),  "COL_268" NUMBER(6, 2),  "COL_269" NUMBER(6, 2),  "COL_270" INTERVAL YEAR(2) TO MONTH,  "COL_271" VARCHAR(60 BYTE),  "COL_272" NUMBER(6, 2),
 39   "COL_273" NUMBER(6, 2),  "COL_274" DATE,  "COL_275" BINARY_DOUBLE
 40 );

Succeed.

SQL> CREATE global TEMPORARY TABLE tbl_sqlkiller_45(
  2 id BINARY_INTEGER primary key,
  3 c_short short,c_int int default 0 on update 100,c_uint BINARY_UINT32,c_unsigned INTEGER UNSIGNED not null,
  4 c_bigint BINARY_BIGINT,c_number number,c_decimal decimal,c_double BINARY_DOUBLE,c_real real,
  5 c_varchar varchar(100) default 'varchar',c_char char(50) default 'char' on update '111goodesmen',c_varchar2 varchar2(120) default 1,
  6 c_varchar1 varchar(100) default '{""key1"":""good""}',c_date date ,c_datetime datetime not null,
  7 c_timestamp timestamp(4) default '2019-11-19 17:41:00',c_timestamp1 timestamp,c_timestamp_zone timestamp with time zone,
  8 c_timestamp_localzone timestamp with local time zone,c_yeartomonth interval year to month,c_daytosecond interval day to second,
  9 c_clob clob,c_blob blob,c_varbinary VARBINARY(100),c_binary BINARY(100) default '1000',c_raw raw(100),
 10 c_bytea BYTEA,c_image image,c_bool boolean
 11 );

Succeed.

SQL> CREATE TABLE tbl_subpartition_range2_15(
  2 id BINARY_INTEGER not null,c_short short,c_uint uint,c_bigint bigint,c_number number,c_numeric numeric(20,10),
  3 c_decimal decimal,c_double double,c_real real,c_varchar varchar(8000) default 'varchar',c_char char(1000) default 'char' on update '111goodesmen',
  4 c_varchar2 varchar2(100) default 1,c_date datetime,c_timestamp timestamp default '2019-11-19 17:41:00',c_timestamp_zone timestamp with time zone,
  5 c_timestamp_localzone timestamp with local time zone,c_yeartomonth interval year to month,c_daytosecond interval day(7) to second(6),
  6 c_clob clob,c_blob blob,c_binary VARBINARY(8000),c_raw raw(200),c_image image,c_bool bool
  7 )partition by range(c_bigint)
  8 subpartition by range(c_char)
  9 (partition p1 values less than(50000000)
 10 (       subpartition p11 values less than (lpad('good',50,'cdf')), subpartition p12 values less than (lpad('good',50,'ffg')), subpartition p13 values less than (lpad('good',50,'jjh')), subpartition p14 values less than (lpad('good',50,'mng')),subpartition p15 values less than (lpad('good',50,'opd')), subpartition p16 values less than (maxvalue)
 11 ),partition p2 values less than(100000001)(  subpartition p21 values less than (lpad('good',50,'rrr')), subpartition p22 values less than (lpad('good',50,'tttkkk')), subpartition p23 values less than (maxvalue)));

Succeed.

SQL> CREATE TABLE tbl_subpartition_range2_34(
  2 id BINARY_INTEGER not null,c_short short,c_int int default 0 on update 100,c_uint uint,
  3 c_unsigned INTEGER UNSIGNED not null,c_bigint bigint,c_number number,c_numeric numeric(20,10),
  4 c_decimal decimal,c_double double,c_real real,c_varchar varchar(8000) default 'varchar',
  5 c_char char(1000) default 'char' on update '111goodesmen',c_varchar2 varchar2(100) default 1,
  6 c_varchar1 varchar(1000) default '{""key1"":""good""}' check(c_varchar1 is json),
  7 c_date date ,c_datetime datetime not null,c_timestamp timestamp(4) default '2019-11-19 17:41:00',
  8 c_timestamp1 timestamp,c_timestamp_zone timestamp with time zone,c_timestamp_localzone timestamp with local time zone,
  9 c_yeartomonth interval year to month,c_daytosecond interval day(7) to second(6),c_clob clob,
 10 c_blob blob,c_varbinary VARBINARY(8000),c_binary BINARY(100) default '1000',c_raw raw(200),
 11 c_bytea BYTEA,c_image image,c_bool bool
 12 )partition by hash(c_bigint,c_decimal,c_raw) subpartition by list(c_short,c_varchar2,c_timestamp1)
 13 (partition p1 (    subpartition p11 values ((1000,'gfgfhgffg','1990-10-10 12:30:23.5456')), subpartition p12 values ((2000,'jjjjjjjjjjjjj','1995-10-10 12:30:23.5456')),
 14  subpartition p13 values (default)),partition p2 (
 15     subpartition p21 values((4000,'gfhthteghregreg','2000-10-10 12:30:23.5456'),(5000,'retregdgdvdv','2005-10-10 12:30:23.5456')),
 16  subpartition p22 values(default)
 17 ),partition p3  (       subpartition p31 values((6000,'regrehfbdf!@!333','2006-10-10 12:30:23.5456'),(7000,'@#&#^&$%#$','2007-10-10 12:30:23.5456')),
 18  subpartition p33 values(default)),
 19 partition p4 (       subpartition p41 values((9000,88657454.6576576567,'2008-10-10 12:30:23.5456')), subpartition p42 values(default)));

Succeed.

SQL> create or replace procedure proc_create_table_39(tbl_name varchar,snum int,enum int)
  2 is
  3 str varchar(8000);
  4 str1 varchar(1000);
  5 str2 clob;
  6 str_sum clob;
  7 begin
  8     str :='create table ' || tbl_name || '(';
  9 for i in snum..enum loop
 10     str1 :='c_' || i || ' number(' || (i%20) || ',' || (i%10) || ')';
 11     str2 :=str2 || ',' || str1;
 12 end loop;
 13     str_sum := str || substr(str2,2,length(str2)) || ')';
 14     str_sum := replace(str_sum,'number(0,0)','number');
 15     execute immediate str_sum ;
 16 end;
 17 /

Succeed.

SQL> exec proc_create_table_39('tbl_sqlkiller_39_2',441,840);

PL/SQL procedure successfully completed.

SQL> exec proc_create_table_39('tbl_sqlkiller_39_6',2001,2400);

PL/SQL procedure successfully completed.

SQL> SELECT
  2   DECODE(
  3     CAST(CASE WHEN (          MIN(            CAST((SELECT MAX(C_DATE) FROM TBL_SUBPARTITION_RANGE2_34)               AS TIMESTAMP(6) WITH TIME ZONE)) over (partition by REF_0.C_2272 ORDER BY REF_0.C_2099,REF_0.C_2264) < CURRENT_TIMESTAMP())
  4         AND (FALSE) THEN         MIN(          CAST('m' AS VARCHAR(1))) over (partition by REF_0.C_2068,REF_0.C_2091 ORDER BY REF_0.C_2109) ELSE
  5         MIN(          CAST('m' AS VARCHAR(1))) over (partition by REF_0.C_2068,REF_0.C_2091 ORDER BY REF_0.C_2109) END
  6        AS CHAR(100)),    CAST(CURRENT_TIMESTAMP() AS DATE),
  7     CAST(CASE WHEN EXISTS (        SELECT              REF_0.C_2104 AS C0          FROM             TBL_SQLKILLER_39_2 AS REF_1
  8           WHERE REF_1.C_585 IS NULL          LIMIT 151) THEN CAST(coalesce(NULL,
  9         NULL) AS VARCHAR(8000)) ELSE CAST(coalesce(NULL,
 10         NULL) AS VARCHAR(8000)) END
 11        AS VARCHAR(8000)),
 12     CAST((SELECT MAX(C_VARCHAR) FROM TBL_SUBPARTITION_RANGE2_15)
 13        AS VARCHAR(100))) AS C0,
 14   CURRENT_TIMESTAMP() AS C1,
 15   0 AS C2,
 16   REF_0.C_2283 AS C3,
 17   REF_0.C_2188 AS C4,
 18   CURRENT_TIMESTAMP() AS C5
 19 FROM
 20   TBL_SQLKILLER_39_6 AS REF_0
 21 WHERE CURRENT_TIMESTAMP() < (SELECT MIN(C_DATE) FROM TBL_SQLKILLER_45)
 22 LIMIT 99;

C0                                                               C1                                       C2           C3                                       C4                 C5
---------------------------------------------------------------- ---------------------------------------- ------------ ---------------------------------------- ---------------------------------------- ----------------------------------------

0 rows fetched.

SQL> SELECT
  2   DECODE(
  3     CAST(CASE WHEN (          MIN(            CAST((SELECT MAX(C_DATE) FROM TBL_SUBPARTITION_RANGE2_34)               AS TIMESTAMP(6) WITH TIME ZONE)) over (partition by REF_0.C_2272 ORDER BY REF_0.C_2099,REF_0.C_2264) < SOME(
  4           (SELECT MAX(COL_2) FROM FVT_OBJ_DEFINE_TABLE_FRE1)            ))         AND (FALSE) THEN         MIN(          CAST('m' AS VARCHAR(1))) over (partition by REF_0.C_2068,REF_0.C_2091 ORDER BY REF_0.C_2109) ELSE
  5         MIN(          CAST('m' AS VARCHAR(1))) over (partition by REF_0.C_2068,REF_0.C_2091 ORDER BY REF_0.C_2109) END       AS CHAR(100)),
  6     CAST(CURRENT_TIMESTAMP() AS DATE),
  7     CAST(CASE WHEN EXISTS (        SELECT              REF_0.C_2104 AS C0          FROM             TBL_SQLKILLER_39_2 AS REF_1          WHERE REF_1.C_585 IS NULL
  8           LIMIT 151) THEN CAST(coalesce(NULL,
  9         NULL) AS VARCHAR(8000)) ELSE CAST(coalesce(NULL,
 10         NULL) AS VARCHAR(8000)) END
 11        AS VARCHAR(8000)),
 12     CAST((SELECT MAX(C_VARCHAR) FROM TBL_SUBPARTITION_RANGE2_15)
 13        AS VARCHAR(100))) AS C0,
 14   CURRENT_TIMESTAMP() AS C1,
 15   0 AS C2,
 16   REF_0.C_2283 AS C3,
 17   REF_0.C_2188 AS C4,
 18   CURRENT_TIMESTAMP() AS C5
 19 FROM
 20   TBL_SQLKILLER_39_6 AS REF_0
 21 WHERE CURRENT_TIMESTAMP() < (SELECT MIN(C_DATE) FROM TBL_SQLKILLER_45)
 22 LIMIT 99;

C0                                                               C1                                       C2           C3                                       C4                 C5
---------------------------------------------------------------- ---------------------------------------- ------------ ---------------------------------------- ---------------------------------------- ----------------------------------------

0 rows fetched.

SQL> SELECT 1 FROM
  2   (SELECT
  3         REF_1.C_VARCHAR AS C0,
  4         REF_3.C_609 AS C1,
  5         REF_1.C_DATE AS C2,
  6         REF_0.C_DOUBLE AS C3
  7       FROM
  8         ((TBL_SUBPARTITION_RANGE2_15 AS REF_0)
  9             INNER JOIN (tbl_subpartition_range2_34 AS REF_1)
 10             ON (REF_1.C_VARCHAR1 < SOME(
 11                 SELECT DISTINCT REF_2.C_CHAR AS C1 FROM
 12                     TBL_SUBPARTITION_RANGE2_15 AS REF_2
 13                   WHERE REF_1.C_BLOB IS NOT NULL)))
 14           INNER JOIN (TBL_SQLKILLER_39_2 AS REF_3)
 15           ON (REF_1.C_VARCHAR1 LIKE '%')
 16       WHERE (REF_3.C_547 = SOME(
 17           SELECT
 18               REF_3.C_455 AS C1
 19             FROM
 20               TBL_SUBPARTITION_RANGE2_34 AS REF_4
 21             WHERE REF_4.C_REAL IS NULL))
 22         AND (EXISTS (
 23           SELECT
 24               REF_0.C_TIMESTAMP_LOCALZONE AS C0,
 25               REF_1.C_BOOL AS C2
 26             FROM
 27               TBL_SQLKILLER_39_2 AS REF_5
 28             WHERE REF_0.C_VARCHAR2 LIKE '%'
 29             OFFSET 41))) AS SUBQ_0
 30 WHERE SUBQ_0.C0 IS NOT NULL
 31 LIMIT 47 OFFSET 93;

1
------------

0 rows fetched.

SQL>
SQL> drop table if exists  t_subselect_dept_index;

Succeed.

SQL> drop table if exists  t_subselect_emp_index;

Succeed.

SQL> create table t_subselect_dept_index(
  2        deptno int,
  3        dname varchar(30),
  4        loc varchar(30),
  5        mgr varchar(30)
  6 );

Succeed.

SQL> create table t_subselect_emp_index(
  2        empno int,
  3        ename varchar(30),
  4        job varchar(30),
  5        mgr varchar(30),
  6        hiredate int,
  7        sal int,
  8        comm int,
  9        deptno int
 10 );

Succeed.

SQL> create index t_subselect_emp_index_001 on t_subselect_emp_index(deptno);

Succeed.

SQL> explain plan for select a.deptno,a.dname,a.loc,b.job,b.sal
  2 from t_subselect_dept_index a inner join t_subselect_emp_index b on a.deptno=b.deptno
  3 where ascii(b.sal) = (select ascii(min(c.sal)) from t_subselect_emp_index c inner join t_subselect_dept_index d on d.mgr=c.mgr
  4                       where a.deptno=c.deptno and c.sal >=2000) order by a.deptno,a.dname,a.loc,b.job,b.sal;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                           |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                |       |                           |      |      |       |        |
| 2   |     NESTED LOOPS                     |       |                           |      |      |       |        |
| 3   |       KERNEL FILTER                  |       |                           |      |      |       |        |
| 4   |         TABLE ACCESS FULL            | SYS   | T_SUBSELECT_DEPT_INDEX A  |      |      |       |        |
| 5   |         HASH MATERIALIZE             |       |                           |      |      |       |        |
| 6   |           NESTED LOOPS               |       |                           |      |      |       |        |
| 7   |             TABLE ACCESS FULL        | SYS   | T_SUBSELECT_EMP_INDEX C   |      |      |       |        |
| 8   |             TABLE ACCESS FULL        | SYS   | T_SUBSELECT_DEPT_INDEX D  |      |      |       |        |
| 9   |       KERNEL FILTER                  |       |                           |      |      |       |        |
| 10  |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_SUBSELECT_EMP_INDEX B   |      |      |       |        |
| 11  |           INDEX RANGE SCAN           | SYS   | T_SUBSELECT_EMP_INDEX_001 |      |      |       |        |
| 12  |         HASH MATERIALIZE             |       |                           |      |      |       |        |
| 13  |           NESTED LOOPS               |       |                           |      |      |       |        |
| 14  |             TABLE ACCESS FULL        | SYS   | T_SUBSELECT_EMP_INDEX C   |      |      |       |        |
| 15  |             TABLE ACCESS FULL        | SYS   | T_SUBSELECT_DEPT_INDEX D  |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: C.DEPTNO = A.DEPTNO                              
   7 - filter: C.SAL >= 2000                                    
   8 - filter: D.MGR = C.MGR                                    
   10 - filter: ASCII(B.SAL) = (SELECT ASCII(MIN(C.SAL)) FROM T_SUBSELECT_EMP_INDEX C INNER JOIN T_SUBSELECT_DEPT_INDEX D WHERE C.SAL >= 2000 AND 
               D.MGR = C.MGR GROUP BY C.DEPTNO)                 
   11 - access: A.DEPTNO = B.DEPTNO                             
   12 - access: C.DEPTNO = A.DEPTNO                             
   14 - filter: C.SAL >= 2000                                   
   15 - filter: D.MGR = C.MGR                                   

31 rows fetched.

SQL> drop table t_subselect_dept_index;

Succeed.

SQL> drop table t_subselect_emp_index;

Succeed.
