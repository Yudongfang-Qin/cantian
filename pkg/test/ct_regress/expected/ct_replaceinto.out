

SQL> --DTS202009160ERSORP1F00
SQL> drop table if exists nebula_ddl_range_001;

Succeed.

SQL> drop table if exists oracle_tbl_000;

Succeed.

SQL> drop procedure if exists nebula_dml_range_func_001;

Succeed.

SQL> create table oracle_tbl_000(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(50) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data varchar(8000),c_clob clob,c_text blob);

Succeed.

SQL> CREATE unique INDEX oracle_indx_000 ON oracle_tbl_000(c_id);

Succeed.

SQL> insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select 0,0,0,'iscmRDs','OE','BAR','RGF','SDG','dyfrDa','uq','4801','940215','2017-12-31 10:51:47','GC',50000.0,0.4361328,-10.0,10.0,1,true,'2017-12-31 10:51:47',lpad('QVBRfSCC3484942ZCSfjvCF',500,'QVLDBURhlhfrc484ZCSfjF'),lpad('QVBUflcHOQNvmgfvdPFZSF',500,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',500,'1435764ABC7890abcdef');

1 rows affected.

SQL> CREATE or replace procedure nebula_dml_range_func_001(startall int,endall int)  as
  2 i INT;
  3 j int;
  4 BEGIN
  5   FOR i IN startall..endall LOOP
  6   if  i%8=1 then
  7     select i into j from sys_dummy;
  8     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,lpad('aaa',4000,'bbb'),lpad('QVBUflcHOQNvmgfvdPFZSF',1000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',1000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
  9     elsif i%8=2 then
 10         insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,C_DATA,lpad('QVBUflcHOQNvmgfvdPFZSF',5000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',5000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
 11     elsif i%8=3 then
 12     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,C_DATA,null,null from oracle_tbl_000 where c_id=0;
 13     elsif i%8=4 then
 14     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,C_DATA,lpad('QVBUflcHOQNvmgfvdPFZSF',2000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',5000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
 15     elsif i%8=5 then
 16     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,lpad('aaa',6000,'bbb'),lpad('QVBUflcHOQNvmgfvdPFZSF',1000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',1000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
 17     elsif i%8=6 then
 18     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,lpad('aaa',7000,'bbb'),lpad('QVBUflcHOQNvmgfvdPFZSF',5000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',5000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
 19     elsif i%8=7 then
 20     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,lpad('aaa',7000,'bbb'),null,null from oracle_tbl_000 where c_id=0;
 21     elsif i%8=0 then
 22     insert into oracle_tbl_000(C_ID,C_D_ID,C_W_ID,C_FIRST,C_MIDDLE,C_LAST,C_STREET_1,C_STREET_2,c_city,c_state,C_ZIP,C_PHONE,C_SINCE,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,C_PAYMENT_CNT,C_DELIVERY_CNT,C_END,C_DATA,C_CLOB,c_text) select i,i,i,'is'||i||'aa',C_MIDDLE,'BAR'||i,'RGF'||j||'AB','RGF'||i||'ABC',c_city,c_state,C_ZIP,C_PHONE,C_SINCE+j,C_CREDIT,C_CREDIT_LIM,C_DISCOUNT,C_BALANCE,C_YTD_PAYMENT,i,C_DELIVERY_CNT,C_END+i,lpad('aaa',7000,'bbb'),lpad('QVBUflcHOQNvmgfvdPFZSF',100,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',5000,'1435764ABC7890abcdef') from oracle_tbl_000 where c_id=0;
 23    end if;
 24   END LOOP;
 25 END;
 26 /

Succeed.

SQL> call nebula_dml_range_func_001(1,800);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> create table nebula_ddl_range_001(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(50) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data varchar(8000),c_clob clob,c_text blob, c_add int default 10) partition by range(c_id,c_first) (partition PART_1 values less than (101,'is101') storage(INITIAL 128K maxsize 5G),partition PART_2 values less than (201,'is201'),partition PART_3 values less than (301,'is301'),partition PART_4 values less than (401,'is401'),partition PART_5 values less than (501,'is501'),partition PART_6 values less than (601,'is601'),partition PART_7 values less than (701,'is701'),partition PART_8 values less than (801,'is801') storage(INITIAL 128K maxsize 5G),partition PART_9 values less than (901,'is901'),partition PART_10 values less than (maxvalue,maxvalue));

Succeed.

SQL> CREATE INDEX nebula_ddl_range_indx_001_1 ON nebula_ddl_range_001(c_d_id,c_last,c_end,c_payment_cnt, c_add);

Succeed.

SQL> CREATE INDEX nebula_ddl_range_indx_001_2 ON nebula_ddl_range_001(c_first) local;

Succeed.

SQL> CREATE INDEX nebula_ddl_range_indx_001_3 ON nebula_ddl_range_001(c_id,c_first) local;

Succeed.

SQL> CREATE INDEX nebula_ddl_range_indx_001_4 ON nebula_ddl_range_001(c_id,c_first,c_last);

Succeed.

SQL> insert into nebula_ddl_range_001 select *, c_id from oracle_tbl_000;commit;

801 rows affected.


Succeed.

SQL> ALTER TABLE nebula_ddl_range_001 ADD CONSTRAINT nebula_ddl_range_cstr_001 PRIMARY KEY(c_id,c_first,c_d_id,c_w_id,c_end) USING INDEX LOCAL (PARTITION idx_p1,PARTITION idx_p,PARTITION idx_p3,PARTITION idx_p4,PARTITION idx_p5,PARTITION idx_p6,PARTITION idx_p7,PARTITION idx_p8,PARTITION idx_p9,PARTITION idx_p10);

Succeed.

SQL> replace into nebula_ddl_range_001(c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data,c_clob,c_text) select * from oracle_tbl_000;

1602 rows affected.

SQL> commit;

Succeed.

SQL> drop procedure if exists nebula_dml_range_func_001;

Succeed.

SQL> drop table if exists nebula_ddl_range_001;

Succeed.

SQL> drop table if exists oracle_tbl_000;

Succeed.

SQL> 
SQL> --DTS202007270539T5P1100
SQL> drop table if exists replace_tt1;

Succeed.

SQL> drop trigger if exists replace_tt1_trg;

Succeed.

SQL> create table replace_tt1 (f1 int,f2 int,f3 int);

Succeed.

SQL> CREATE UNIQUE INDEX ttt1_idx on replace_tt1(f1,f2);

Succeed.

SQL> insert into replace_tt1 values(1,3,3),(11,13,13);

2 rows affected.

SQL> commit;

Succeed.

SQL> create or replace trigger replace_tt1_trg before delete on replace_tt1
  2 begin
  3   update replace_tt1 set f2=f2+1,f3=f3+1;
  4 end;
  5 /

Succeed.

SQL> replace into replace_tt1 select f1+10,f2+10,f3+10 from replace_tt1;

3 rows affected.

SQL> drop trigger replace_tt1_trg;

Succeed.

SQL> drop table replace_tt1;

Succeed.

SQL> 
SQL> --DTS202007270K2Q7IP1300
SQL> drop table if exists merge_into_csf_tbl_000;

Succeed.

SQL> drop table if exists merge_into_csf_trg_tbl_001;

Succeed.

SQL> drop procedure if exists merge_into_csf_proc_000;

Succeed.

SQL> drop sequence if exists merge_into_csf_trg_seq_001;

Succeed.

SQL> drop sequence if exists merge_into_csf_trg_seq_001_1;

Succeed.

SQL> drop sequence if exists merge_into_csf_trg_seq_001_2;

Succeed.

SQL> drop trigger if exists merge_into_csf_trg_001;

Succeed.

SQL> drop trigger if exists merge_into_csf_trg_001_1;

Succeed.

SQL> create table merge_into_csf_tbl_000(c_id int,c_d_id bigint NOT NULL,c_w_id tinyint unsigned NOT NULL,c_first varchar(16) NOT NULL,c_middle char(2),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state varchar(20) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 varchar(8000),c_data2 varchar(8000),c_data3 varchar(8000),c_data4 varchar(8000),c_data5 varchar(8000),c_data6 varchar(8000),c_data7 varchar(6000),c_data8 varchar(4000),c_clob clob,c_blob blob);

Succeed.

SQL> CREATE or replace procedure merge_into_csf_proc_000(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(i as varchar(10)) into j from sys_dummy;
  7     insert into merge_into_csf_tbl_000 select i,i,i,'iscmRDs'||j,'OE','BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,1,sysdate,lpad('QVBRfSCC3484942ZCSfjvCF',4000,'QVLDBURhlhfrc484ZCSfjF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',3000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',1000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',5000,'1435764ABC7890abcdef') from sys_dummy;
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> call merge_into_csf_proc_000(1,1000);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> create table merge_into_csf_trg_tbl_001(c_id int,c_d_id bigint,c_w_id tinyint unsigned,c_first varchar(16),c_middle char(2),c_last varchar(16),c_street_1 varchar(20),c_street_2 varchar(20),c_city varchar(20),c_state varchar(20),c_zip char(9),c_phone char(16),c_since timestamp,c_credit char(2),c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real,c_payment_cnt number,c_delivery_cnt bool,c_end date,c_data1 varchar(7744),c_data2 varchar(7744),c_data3 varchar(7744),c_data4 varchar(7744),c_data5 varchar(7744),c_data6 varchar(7744),c_data7 varchar(7744),c_data8 varchar(7744),c_clob clob,c_blob blob) partition by range(c_id) interval(10) (partition PART_1 values less than (21),partition PART_2 values less than (41),partition PART_3 values less than (61),partition PART_4 values less than (81)) format csf;

Succeed.

SQL> CREATE UNIQUE INDEX merge_into_csf_trg_indx_001_1 ON merge_into_csf_trg_tbl_001(c_id,c_d_id);

Succeed.

SQL> CREATE INDEX merge_into_csf_trg_indx_001_2 ON merge_into_csf_trg_tbl_001(c_id);

Succeed.

SQL> CREATE INDEX merge_into_csf_trg_indx_001_3 ON merge_into_csf_trg_tbl_001(c_city);

Succeed.

SQL> CREATE INDEX merge_into_csf_trg_indx_001_4 ON merge_into_csf_trg_tbl_001(c_first,c_state);

Succeed.

SQL> CREATE INDEX merge_into_csf_trg_indx_001_5 ON merge_into_csf_trg_tbl_001(c_id,c_d_id,c_middle);

Succeed.

SQL> CREATE INDEX merge_into_csf_trg_indx_001_6 ON merge_into_csf_trg_tbl_001(c_id,c_d_id,c_middle,c_street_1);

Succeed.

SQL> --I2.创建触发器
SQL> create sequence merge_into_csf_trg_seq_001 start with 1 increment by 1 order;

Succeed.

SQL> create sequence merge_into_csf_trg_seq_001_1 start with 1 increment by 1 order;

Succeed.

SQL> create sequence merge_into_csf_trg_seq_001_2 start with 1 increment by 1 order;

Succeed.

SQL> MERGE INTO merge_into_csf_trg_tbl_001 T1 USING (SELECT * FROM merge_into_csf_tbl_000) T2 on (T1.c_id=T2.c_id) WHEN MATCHED THEN UPDATE SET T1.c_first=T1.c_first||'aa',T1.c_state=T1.c_state||'aa' WHEN NOT MATCHED THEN  INSERT (c_id,c_d_id,c_w_id,c_first,c_middle,c_last,c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_data6,c_data7,c_data8,c_clob,c_blob) VALUES (merge_into_csf_trg_seq_001.nextval,merge_into_csf_trg_seq_001_1.nextval,merge_into_csf_trg_seq_001_2.nextval,'iscmRDs0','OE','BARBar0','bkilifcrRGF0','pmbwovhSDGj0','dyfrDa0','uq','48010','9402150',sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,1,sysdate,lpad('QVBRfSCC3484942ZCSfjvCF',4000,'QVLDBURhlhfrc484ZCSfjF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',4000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',3000,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',3000,'QVLDfscHOQgfvmPFZDSF'),lpad('12314315487569809',3000,'1435764ABC7890abcdef'));

1000 rows affected.

SQL> create or replace trigger merge_into_csf_trg_001 before insert or update or delete on merge_into_csf_trg_tbl_001
  2 begin
  3   DBE_OUTPUT.PRINT_LINE('Hello 1!');
  4 END;
  5 /

Succeed.

SQL> create or replace trigger merge_into_csf_trg_001_1 after insert or update or delete on merge_into_csf_trg_tbl_001
  2 begin
  3   DBE_OUTPUT.PRINT_LINE('Hello 2!');
  4 END;
  5 /

Succeed.

SQL> set serverout on

ON
SQL> replace into merge_into_csf_trg_tbl_001(c_id,c_d_id,c_w_id,c_payment_cnt,c_data1,c_clob,c_blob) select c_id+10,c_d_id+10,c_w_id+10,1234123412341.1,lpad('aaa',4000,'bbb'),lpad('aaa',4000,'bbb'),lpad('1111',4000,'2222') from merge_into_csf_trg_tbl_001;

Hello 1!
Hello 2!

1990 rows affected.

SQL> set serverout off

OFF
SQL> drop table merge_into_csf_tbl_000;

Succeed.

SQL> drop table merge_into_csf_trg_tbl_001;

Succeed.

SQL> drop procedure merge_into_csf_proc_000;

Succeed.

SQL> drop sequence merge_into_csf_trg_seq_001;

Succeed.

SQL> drop sequence merge_into_csf_trg_seq_001_1;

Succeed.

SQL> drop sequence merge_into_csf_trg_seq_001_2;

Succeed.

SQL> 
SQL> --DTS2019061711815
SQL> drop table if exists tbl_dml_js1;

Succeed.

SQL> create table tbl_dml_js1(
  2 id int primary key,
  3 js varchar(8000) check(js is json)
  4 );

Succeed.

SQL> insert into tbl_dml_js1 values(1 ,'{"A":1 ,":":[1,"A1 ",true],"B1 ":{"C ":"1 "},"D":[1 ]}');

1 rows affected.

SQL> insert into tbl_dml_js1 values(2 ,'{"A":2 ,":":[1,"A2 ",true],"B2 ":{"C ":"2 "},"D":[2 ]}');

1 rows affected.

SQL> 
SQL> drop table if exists tbl_js1;

Succeed.

SQL> create table tbl_js1(
  2 id int ,
  3 js varchar(3900)check(js is json)
  4 );

Succeed.

SQL> alter table tbl_js1 add constraint tbl_js1_pk_1 primary key(js);

Succeed.

SQL> replace into tbl_js1 set id = (1),js = (select js from tbl_dml_js1 order by 1 limit 1);

1 rows affected.

SQL> replace into tbl_js1 set id = (1),js = (select js from tbl_dml_js1 order by 1 limit 1);

2 rows affected.

SQL> select * from tbl_js1 order by 2;

ID           JS                                                              
------------ ----------------------------------------------------------------
1            {"A":1 ,":":[1,"A1 ",true],"B1 ":{"C ":"1 "},"D":[1 ]}          

1 rows fetched.

SQL> drop table tbl_dml_js1;

Succeed.

SQL> drop table tbl_js1;

Succeed.

SQL> 
SQL> --test 'REPLACE INTO' in PROCEDURE 
SQL> drop table if exists test_student;

Succeed.

SQL> create table test_student(SId varchar(10) primary key,Sname varchar(10),Sage datetime,Ssex varchar(10));

Succeed.

SQL> 	--two or more brackets are not supported by procedure yet
SQL> CREATE or replace procedure construct_student_pro(startall int,endall int,sex varchar) as 
  2 i INT;
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5 		replace into test_student ((select i+6,'asdf'||i||'f','2012-10-12',sex));
  6 		commit;
  7   END LOOP;
  8 END;
  9 /

Succeed.
Warning:
PL/SQL(SYS.CONSTRUCT_STUDENT_PRO) terminated with compiling errors
[5:38] PLC-00601 Sql syntax error: invalid column name 'I'
[9:1] PLC-00954 more text expected but EOF found


SQL> CREATE or replace procedure construct_student_pro(startall int,endall int,sex varchar) as 
  2 i INT;
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5 		replace into test_student (select i+6,'asdf'||i||'f','2012-10-12',sex);
  6 		commit;
  7   END LOOP;
  8 END;
  9 /

Succeed.

SQL> CREATE or replace procedure construct_student_pro(startall int,endall int,sex varchar) as
  2 i INT;
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5         replace into test_student values(i,'asdf'||i||'f','2012-10-10',sex);
  6 		replace into test_student set sid = i+3, Sname = 'asdf'||i||'f', Sage = '2012-10-11', Ssex = sex; 
  7 		replace into test_student select i+6,'asdf'||i||'f','2012-10-12',sex;
  8 		commit;
  9   END LOOP;
 10 END;
 11 /

Succeed.

SQL> call construct_student_pro(1,3,'man');

PL/SQL procedure successfully completed.

SQL> select * from test_student order by to_number(sid);

SID        SNAME      SAGE                   SSEX      
---------- ---------- ---------------------- ----------
1          asdf1f     2012-10-10 00:00:00    man       
2          asdf2f     2012-10-10 00:00:00    man       
3          asdf3f     2012-10-10 00:00:00    man       
4          asdf1f     2012-10-11 00:00:00    man       
5          asdf2f     2012-10-11 00:00:00    man       
6          asdf3f     2012-10-11 00:00:00    man       
7          asdf1f     2012-10-12 00:00:00    man       
8          asdf2f     2012-10-12 00:00:00    man       
9          asdf3f     2012-10-12 00:00:00    man       

9 rows fetched.

SQL> drop procedure if exists construct_student_pro;

Succeed.

SQL> drop table if exists test_student;

Succeed.

SQL> 
SQL> --test 'REPLACE INTO' in ANONYMOUS 
SQL> drop table if exists test_student;

Succeed.

SQL> create table test_student(SId varchar(10) primary key,Sname varchar(10),Sage datetime,Ssex varchar(10));

Succeed.

SQL> declare 
  2   i int;
  3   str varchar(100);
  4 begin
  5   i := 1;
  6   for i in 1..1 
  7   loop
  8 	str := 'replace into test_student values(1,''asdf1f'',''2012-10-10'',''man'')';
  9 	execute immediate str;
 10 	str := 'replace into test_student set sid = 2, Sname = ''asdf2f'', Sage = ''2012-10-11'', Ssex = ''man''';
 11 	execute immediate str;
 12 	str := 'replace into test_student select 3,''asdf3f'',''2012-10-12'',''man''';
 13 	execute immediate str;
 14   end loop;
 15 end;
 16 /

PL/SQL procedure successfully completed.

SQL> select * from test_student order by to_number(sid);

SID        SNAME      SAGE                   SSEX      
---------- ---------- ---------------------- ----------
1          asdf1f     2012-10-10 00:00:00    man       
2          asdf2f     2012-10-11 00:00:00    man       
3          asdf3f     2012-10-12 00:00:00    man       

3 rows fetched.

SQL> drop table if exists test_student;

Succeed.

SQL> 
SQL> --test 'REPLACE INTO' in FUNCTION
SQL> drop table if exists test_student;

Succeed.

SQL> create table test_student(SId varchar(10) primary key,Sname varchar(10),Sage datetime,Ssex varchar(10));

Succeed.

SQL> CREATE OR REPLACE function select_item_fuc (
  2 startall in number,
  3 endall in number
  4 )
  5 return number
  6 IS
  7 temp VARCHAR2(30);
  8 BEGIN
  9   FOR i IN startall..endall LOOP
 10         replace into test_student values(i,'asdf'||i||'f','2012-10-10','man');
 11 		replace into test_student set sid = i+3, Sname = 'asdf'||i||'f', Sage = '2012-10-11', Ssex = 'man'; 
 12 		replace into test_student select i+6,'asdf'||i||'f','2012-10-12','man';
 13 		commit;
 14   END LOOP;
 15 return 1;
 16 END;
 17 /

Succeed.

SQL> declare
  2 dept_count int;
  3 begin
  4 dept_count:=select_item_fuc(1,3);
  5 end;
  6 /

PL/SQL procedure successfully completed.

SQL> select * from test_student order by to_number(sid);

SID        SNAME      SAGE                   SSEX      
---------- ---------- ---------------------- ----------
1          asdf1f     2012-10-10 00:00:00    man       
2          asdf2f     2012-10-10 00:00:00    man       
3          asdf3f     2012-10-10 00:00:00    man       
4          asdf1f     2012-10-11 00:00:00    man       
5          asdf2f     2012-10-11 00:00:00    man       
6          asdf3f     2012-10-11 00:00:00    man       
7          asdf1f     2012-10-12 00:00:00    man       
8          asdf2f     2012-10-12 00:00:00    man       
9          asdf3f     2012-10-12 00:00:00    man       

9 rows fetched.

SQL> drop function if exists select_item_fuc;

Succeed.

SQL> drop table if exists test_student;

Succeed.

SQL> 
SQL> --test using replace with trigger
SQL> drop table if exists test_replace_trigger;

Succeed.

SQL> drop function if exists func_11;

Succeed.

SQL> drop trigger if exists trigger_a;

Succeed.

SQL> create table test_replace_trigger(a int);

Succeed.

SQL> insert into test_replace_trigger values(11);

1 rows affected.

SQL> create trigger trigger_a after insert on test_replace_trigger for each row
  2 begin
  3 	delete from test_replace_trigger;
  4 end;
  5 /

Succeed.

SQL> create function func_11 return int
  2 is
  3 begin
  4    loop
  5     if (true)
  6       then
  7         replace into test_replace_trigger select 1;
  8         goto end_loop;
  9     end if;
 10    end loop;
 11   <<end_loop>> --label
 12   return 0;
 13 end;
 14 /

Succeed.

SQL> select func_11() from dual;

CT-00932, [7:9] PL/SQL(SYS.FUNC_11) terminated with execute errors
[3:2] PL/SQL(SYS.TRIGGER_A) terminated with execute errors
[3:2] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.TEST_REPLACE_TRIGGER did not find the table.

SQL> replace into test_replace_trigger select 1;

CT-00932, [3:2] PL/SQL(SYS.TRIGGER_A) terminated with execute errors
[3:2] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.TEST_REPLACE_TRIGGER did not find the table.

SQL> replace into test_replace_trigger set a = 1;

CT-00932, [3:2] PL/SQL(SYS.TRIGGER_A) terminated with execute errors
[3:2] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.TEST_REPLACE_TRIGGER did not find the table.

SQL> replace into test_replace_trigger values(1);

CT-00932, [3:2] PL/SQL(SYS.TRIGGER_A) terminated with execute errors
[3:2] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.TEST_REPLACE_TRIGGER did not find the table.

SQL> 
SQL> create or replace trigger trigger_a after insert on test_replace_trigger for each row
  2 DECLARE
  3  NEXT_ID NUMBER;
  4 begin
  5 	select * into NEXT_ID from test_replace_trigger where a = 11;
  6 end;
  7 /

Succeed.

SQL> create or replace function func_11 return int
  2 is
  3 esal number;
  4 begin
  5    loop
  6     if (true)
  7       then
  8         replace into test_replace_trigger select 1;
  9 		replace into test_replace_trigger set a = 1;
 10 		replace into test_replace_trigger values(1);
 11         goto end_loop;
 12     end if;
 13    end loop;
 14   <<end_loop>> --label
 15   return 0;
 16 end;
 17 /

Succeed.

SQL> select func_11() from dual;

FUNC_11()   
------------
0           

1 rows fetched.

SQL> replace into test_replace_trigger select 1;

1 rows affected.

SQL> replace into test_replace_trigger set a = 1;

1 rows affected.

SQL> replace into test_replace_trigger values(1);

1 rows affected.

SQL> 
SQL> drop table if exists test_replace_trigger;

Succeed.

SQL> drop function if exists func_11;

Succeed.

SQL> drop trigger if exists trigger_a;

Succeed.

SQL> 
SQL> --DTS2019060102640
SQL> drop table if exists tbl_replace_range;

Succeed.

SQL> create table tbl_replace_range(
  2 id int,
  3 col_char1 varchar(30),
  4 col_char2 varchar(30),
  5 col_char3 varchar(30)
  6 )partition  by range(id)
  7 (
  8     partition p_range_01 values less than (5),
  9     partition p_range_02 values less than (15),
 10     partition p_range_03 values less than (25),
 11     partition p_range_04 values less than (35)
 12 );

Succeed.

SQL> 
SQL> alter table tbl_replace_range add constraint cos_range_pk1 primary key(id);  

Succeed.

SQL> alter table tbl_replace_range add constraint cos_range_uk1 unique(col_char3);

Succeed.

SQL> 
SQL> replace into tbl_replace_range values(1,'test for range 1','replace into values','...1');

1 rows affected.

SQL> replace into tbl_replace_range values(2,'test for range 2','replace into values','...2');

1 rows affected.

SQL> replace into tbl_replace_range values(3,'test for range 3','replace into values','...3');

1 rows affected.

SQL> replace into tbl_replace_range values(4,'test for range 4','replace into values','...4');

1 rows affected.

SQL> replace into tbl_replace_range value(select 5,'test for range 5','replace into value select','...5' from dual);

1 rows affected.

SQL> replace into tbl_replace_range value(select 6,'test for range 6','replace into value select','...6' from dual);

1 rows affected.

SQL> replace into tbl_replace_range value(select 7,'test for range 7','replace into value select','...7' from dual);

1 rows affected.

SQL> replace into tbl_replace_range value(select 8,'test for range 8','replace into value select','...8' from dual);

1 rows affected.

SQL> replace into tbl_replace_range (select 15,'test for range 15','replace into select ','...15');

1 rows affected.

SQL> replace into tbl_replace_range (select 16,'test for range 16','replace into select ','...16');

1 rows affected.

SQL> replace into tbl_replace_range (select 17,'test for range 17','replace into select ','...17');

1 rows affected.

SQL> replace into tbl_replace_range (select 18,'test for range 18','replace into select ','...18');

1 rows affected.

SQL> replace into tbl_replace_range set id=25,col_char1='test for range 25',col_char2='replace into set',col_char3='...25';

1 rows affected.

SQL> replace into tbl_replace_range set id=26,col_char1='test for range 26',col_char2='replace into set',col_char3='...26';

1 rows affected.

SQL> replace into tbl_replace_range set id=27,col_char1='test for range 27',col_char2='replace into set',col_char3='...27';

1 rows affected.

SQL> replace into tbl_replace_range set id=28,col_char1='test for range 28',col_char2='replace into set',col_char3='...28';

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from tbl_replace_range order by id;

ID           COL_CHAR1                      COL_CHAR2                      COL_CHAR3                     
------------ ------------------------------ ------------------------------ ------------------------------
1            test for range 1               replace into values            ...1                          
2            test for range 2               replace into values            ...2                          
3            test for range 3               replace into values            ...3                          
4            test for range 4               replace into values            ...4                          
5            test for range 5               replace into value select      ...5                          
6            test for range 6               replace into value select      ...6                          
7            test for range 7               replace into value select      ...7                          
8            test for range 8               replace into value select      ...8                          
15           test for range 15              replace into select            ...15                         
16           test for range 16              replace into select            ...16                         
17           test for range 17              replace into select            ...17                         
18           test for range 18              replace into select            ...18                         
25           test for range 25              replace into set               ...25                         
26           test for range 26              replace into set               ...26                         
27           test for range 27              replace into set               ...27                         
28           test for range 28              replace into set               ...28                         

16 rows fetched.

SQL>
SQL> drop table tbl_replace_range;

Succeed.

SQL> 
SQL> -- DTS2019072801741
SQL> alter system SET UPPER_CASE_TABLE_NAMES = false;

Succeed.

SQL> drop table if exists test;

Succeed.

SQL> create table test(f1 int, f2 int);

Succeed.

SQL> replace into test(f1,f2)values(1,3);

1 rows affected.

SQL> alter system SET UPPER_CASE_TABLE_NAMES = true;

Succeed.

SQL> show parameter UPPER_CASE_TABLE_NAMES
NAME                                                             DATATYPE             VALUE                                                            RUNTIME_VALUE                                                    EFFECTIVE           
---------------------------------------------------------------- -------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
UPPER_CASE_TABLE_NAMES                                           CT_TYPE_BOOLEAN      TRUE                                                             TRUE                                                             reboot              


SQL> 
SQL> -- DTS202010300E3ZCMP1300,
SQL> drop table partition_interval_001;

CT-00843, The table or view SYS.PARTITION_INTERVAL_001 does not exist.
SQL> CREATE TABLE partition_interval_001 (
  2 	c_id INT
  3 	,c_d_id BIGINT 
  4 	,c_w_id TINYINT unsigned 
  5 	,c_first VARCHAR(64) 
  6 	,c_middle CHAR(2)
  7 	,c_last VARCHAR(64) 
  8 	,c_street_1 VARCHAR(20) 
  9 	,c_street_2 VARCHAR(2000)
 10 	,c_city VARCHAR(20) 
 11 	,c_state CHAR(2) 
 12 	,c_zip CHAR(9) 
 13 	,c_phone CHAR(16) 
 14 	,c_since TIMESTAMP
 15 	,c_credit CHAR(2) 
 16 	,c_credit_lim NUMERIC(12, 2)
 17 	,c_discount NUMERIC(4, 4)
 18 	,c_balance NUMERIC(12, 2)
 19 	,c_ytd_payment REAL 
 20 	,c_payment_cnt number 
 21 	,c_delivery_cnt bool 
 22 	,c_end DATE 
 23 	,c_vchar VARCHAR(1000)
 24 	,c_data long
 25 	,c_text blob
 26 	,c_clob clob
 27     , add_column blob default lpad('11111',1,'4253365450')
 28 	) PARTITION BY range (c_id) interval (10) (
 29 	PARTITION part_1 VALUES less than(201)
 30 	,PARTITION part_2 VALUES less than(401)
 31 	,PARTITION part_3 VALUES less than(601)
 32 	,PARTITION part_4 VALUES less than(801)
 33 	,PARTITION part_5 VALUES less than(1001)
 34 	,PARTITION part_6 VALUES less than(1201)
 35 	,PARTITION part_7 VALUES less than(1401)
 36 	,PARTITION part_8 VALUES less than(1601)
 37 	,PARTITION part_9 VALUES less than(1801)
 38 	);

Succeed.

SQL> 
SQL> replace into PARTITION_INTERVAL_001 set  C_ID=9749, C_D_ID=8943, C_W_ID=3496, C_SINCE=sysdate, C_CREDIT_LIM=0;

1 rows affected.

SQL> select add_column from PARTITION_INTERVAL_001;

ADD_COLUMN                                                      
----------------------------------------------------------------
01                                                              

1 rows fetched.

SQL> 
SQL> drop table if exists test_load;

Succeed.

SQL> create table test_load (f1 int default 1000, f2 int ,f3 int, f4 int default 2000);

Succeed.

SQL> insert into test_load values(5,50,500,5000);

1 rows affected.

SQL> replace test_load set f1 = f2 = f3,f4 = 6;

CT-00601, [1:33]Sql syntax error: text end expected but = found
SQL> drop table test_load;

Succeed.
