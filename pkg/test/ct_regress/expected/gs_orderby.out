

SQL> DROP TABLE IF EXISTS T_ORDERBY_1;

Succeed.

SQL> CREATE TABLE T_ORDERBY_1 (F_INT1 INT, F_INT2 INT, F_CHAR CHAR(16), F_DATE DATE);

Succeed.

SQL> 
SQL> --ERROR
SQL> select array[1,2] from dual ORDER BY 1;

CT-00601, [1:38]Sql syntax error: unexpected array expression
SQL> SELECT F_INT1 AS '' FROM T_ORDERBY_1;

CT-00601, [1:18]Sql syntax error: invalid variant/object name was found
SQL> SELECT F_INT1 FROM T_ORDERBY_1 null;

CT-00601, [1:32]Sql syntax error: invalid word 'null' found
SQL> SELECT F_INT1 FROM T_ORDERBY_1 ORDER BY 0;

CT-00601, [1:41]Sql syntax error: ORDER BY item must be the number of a SELECT-list expression
SQL> SELECT F_INT1 FROM T_ORDERBY_1 ORDER BY 2;

CT-00601, [1:41]Sql syntax error: ORDER BY item must be the number of a SELECT-list expression
SQL> SELECT F_INT1 F1, F_INT2 F1 FROM T_ORDERBY_1 ORDER BY F1;

CT-00601, Sql syntax error: ambiguous column naming in select list
SQL> SELECT * FROM T_ORDERBY_1 ORDER BY MIN(F_INT1);

CT-01317, [1:36]Unexpected aggregation 'MIN'
SQL> 
SQL> --EMPTY RECORD
SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_INT1,F_INT2;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------

0 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_CHAR,F_INT2;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------

0 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_DATE DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------

0 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_INT1 DESC,F_DATE;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------

0 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY NULL;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------

0 rows fetched.

SQL> 
SQL> INSERT INTO T_ORDERBY_1 VALUES(1,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_1 VALUES(3,4,'C','2017-12-12 16:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_1 VALUES(1,3,'A','2017-12-11 14:18:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_1 VALUES(2,3,'B','2017-12-11 16:08:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT SUM(F_INT1) F1 FROM T_ORDERBY_1 ORDER BY MIN(F_INT1);

F1                  
--------------------
7                   

1 rows fetched.

SQL> SELECT COUNT(1) F1 FROM T_ORDERBY_1 ORDER BY F_INT1;

F1                  
--------------------
4                   

1 rows fetched.

SQL> 
SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_INT1,F_INT2;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_CHAR,F_INT2;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_DATE DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            3            A                2017-12-11 14:18:00   
1            2            A                2017-12-11 14:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY F_INT1 DESC,F_DATE;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   

4 rows fetched.

SQL> SELECT tt.f_date, tt.f_int1 from ( SELECT F_INT1,F_DATE FROM T_ORDERBY_1 WHERE F_INT1 = 1 ORDER BY F_INT1,F_INT2 LIMIT 1,1) TT;

F_DATE                 F_INT1      
---------------------- ------------
2017-12-11 14:18:00    1           

1 rows fetched.

SQL> SELECT DISTINCT A.F_INT1 AS COL1 FROM T_ORDERBY_1 A ORDER BY COL1;

COL1        
------------
1           
2           
3           

3 rows fetched.

SQL> 
SQL> SELECT F_INT1+10 FROM T_ORDERBY_1 ORDER BY F_INT1+10;

F_INT1+10           
--------------------
11                  
11                  
12                  
13                  

4 rows fetched.

SQL> SELECT F_INT1+10 FROM T_ORDERBY_1 ORDER BY 1;

F_INT1+10           
--------------------
11                  
11                  
12                  
13                  

4 rows fetched.

SQL> SELECT F_INT1 F1 FROM T_ORDERBY_1 ORDER BY F1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 "F1" FROM T_ORDERBY_1 ORDER BY F1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 "1" FROM T_ORDERBY_1 ORDER BY "1";

1           
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 "1" FROM T_ORDERBY_1 ORDER BY 1;

1           
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 FROM T_ORDERBY_1 ORDER BY 1;

F_INT1      
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 ORDER BY F1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS "F1" FROM T_ORDERBY_1 ORDER BY F1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS "1F" FROM T_ORDERBY_1 ORDER BY "1F";

1F          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 T1 ORDER BY F1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 T1 GROUP BY F_INT1 ORDER BY F1;

F1          
------------
1           
2           
3           

3 rows fetched.

SQL> SELECT F_INT1+10 AS F1 FROM T_ORDERBY_1 T1 GROUP BY F_INT1+10 ORDER BY F1;

F1                  
--------------------
11                  
12                  
13                  

3 rows fetched.

SQL> SELECT F_INT1+10 AS "1F" FROM T_ORDERBY_1 T1 GROUP BY F_INT1+10 ORDER BY "1F";

1F                  
--------------------
11                  
12                  
13                  

3 rows fetched.

SQL> SELECT F_INT2 F2,F_INT1 F1,F_DATE F4,F_CHAR F3 FROM T_ORDERBY_1 ORDER BY F3,F4,F2,F1;

F2           F1           F4                     F3              
------------ ------------ ---------------------- ----------------
2            1            2017-12-11 14:08:00    A               
3            1            2017-12-11 14:18:00    A               
3            2            2017-12-11 16:08:00    B               
4            3            2017-12-12 16:08:00    C               

4 rows fetched.

SQL> SELECT F_INT2 F2,F_INT1 F1,F_DATE F4,F_CHAR F3 FROM T_ORDERBY_1 ORDER BY 4,3,1,2;

F2           F1           F4                     F3              
------------ ------------ ---------------------- ----------------
2            1            2017-12-11 14:08:00    A               
3            1            2017-12-11 14:18:00    A               
3            2            2017-12-11 16:08:00    B               
4            3            2017-12-12 16:08:00    C               

4 rows fetched.

SQL> SELECT F_INT2 F2,F_INT1 F1,F_DATE F4,F_CHAR F3 FROM T_ORDERBY_1 ORDER BY 4 DESC,3,1 DESC,2;

F2           F1           F4                     F3              
------------ ------------ ---------------------- ----------------
4            3            2017-12-12 16:08:00    C               
3            2            2017-12-11 16:08:00    B               
2            1            2017-12-11 14:08:00    A               
3            1            2017-12-11 14:18:00    A               

4 rows fetched.

SQL> 
SQL> SELECT F_INT1 F1 FROM T_ORDERBY_1 ORDER BY T_ORDERBY_1.F_INT1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 ORDER BY T_ORDERBY_1.F_INT1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 T1 ORDER BY T1.F_INT1;

F1          
------------
1           
1           
2           
3           

4 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 T1 GROUP BY F_INT1 ORDER BY T1.F_INT1;

F1          
------------
1           
2           
3           

3 rows fetched.

SQL> SELECT F_INT1 AS F1 FROM T_ORDERBY_1 T1 WHERE T1.f_int1 > 1 GROUP BY t1.F_INT1 ORDER BY T1.F_INT1;

F1          
------------
2           
3           

2 rows fetched.

SQL> SELECT F_INT2 F2,F_INT1 F1,F_DATE F4,F_CHAR F3 FROM T_ORDERBY_1 ORDER BY F3,T_ORDERBY_1.F_DATE,F2,F1;

F2           F1           F4                     F3              
------------ ------------ ---------------------- ----------------
2            1            2017-12-11 14:08:00    A               
3            1            2017-12-11 14:18:00    A               
3            2            2017-12-11 16:08:00    B               
4            3            2017-12-12 16:08:00    C               

4 rows fetched.

SQL> 
SQL> SELECT F1 FROM (SELECT F_INT1 F1 FROM T_ORDERBY_1) T_SUB where F1 > 1 order by F1;

F1          
------------
2           
3           

2 rows fetched.

SQL> SELECT T_SUB.F1 FROM (SELECT F_INT1 F1 FROM T_ORDERBY_1) T_SUB where T_SUB.F1 > 1 order by T_SUB.F1;

F1          
------------
2           
3           

2 rows fetched.

SQL> 
SQL> SELECT F_INT2 FROM T_ORDERBY_1 WHERE F_CHAR = 'A' ORDER BY F_INT2 DESC;

F_INT2      
------------
3           
2           

2 rows fetched.

SQL> SELECT F_INT2 FROM T_ORDERBY_1 WHERE F_CHAR = 'a' ORDER BY F_INT2 DESC;

F_INT2      
------------

0 rows fetched.

SQL> SELECT F_INT1,F_INT2 FROM T_ORDERBY_1 WHERE (F_INT1) IN (SELECT F_INT1 FROM T_ORDERBY_1) ORDER BY F_INT1,F_INT2;

F_INT1       F_INT2      
------------ ------------
1            2           
1            3           
2            3           
3            4           

4 rows fetched.

SQL> SELECT F_INT1,F_INT2 FROM T_ORDERBY_1 WHERE (F_INT1,F_INT2) IN (SELECT F_INT1+1,F_INT2+1 FROM T_ORDERBY_1) ORDER BY F_INT1,F_INT2;

F_INT1       F_INT2      
------------ ------------
2            3           
3            4           

2 rows fetched.

SQL> SELECT F_INT1,F_INT2 FROM T_ORDERBY_1 WHERE (F_INT1) = (SELECT MAX(F_INT1) FROM T_ORDERBY_1);

F_INT1       F_INT2      
------------ ------------
3            4           

1 rows fetched.

SQL> 
SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN NULL THEN F_INT2 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
3            4            C                2017-12-12 16:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN F_INT1 > F_INT2 THEN F_INT2 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
3            4            C                2017-12-12 16:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN F_INT1 > F_INT2 THEN F_INT2 ELSE F_INT1 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN F_INT1 > F_INT2 THEN F_INT2 ELSE F_INT1 END) DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN F_INT1 > F_INT2 AND F_INT2 > 0 THEN F_INT2 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
3            4            C                2017-12-12 16:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE WHEN NOT F_INT1 > F_INT2 THEN F_INT2 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE F_INT1 - F_INT2 WHEN F_INT1 THEN F_INT2 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
3            4            C                2017-12-12 16:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE F_INT1 - F_INT2 WHEN F_INT1 THEN F_INT2 ELSE F_INT1 END);

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM T_ORDERBY_1 ORDER BY (CASE F_INT1 - F_INT2 WHEN F_INT1 THEN F_INT2 ELSE F_INT1 END) DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   

4 rows fetched.

SQL> 
SQL> --T_ORDERBY_2
SQL> DROP TABLE IF EXISTS T_ORDERBY_2;

Succeed.

SQL> CREATE TABLE T_ORDERBY_2 (F_INT1 INT, F_INT2 INT, F_CHAR CHAR(16), F_DATE DATE);

Succeed.

SQL> 
SQL> INSERT INTO T_ORDERBY_2 VALUES(1,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_2 VALUES(3,4,'C','2017-12-12 16:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_2 VALUES(1,3,'A','2017-12-11 14:18:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_2 VALUES(2,3,'B','2017-12-11 16:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_2 VALUES(NULL,3,'B','2017-12-11 16:08:00');

1 rows affected.

SQL> INSERT INTO T_ORDERBY_2 VALUES(NULL,4,'B','2017-12-11 16:08:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT * FROM T_ORDERBY_2 ORDER BY F_INT1,F_INT2 DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            3            A                2017-12-11 14:18:00   
1            2            A                2017-12-11 14:08:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   
             4            B                2017-12-11 16:08:00   
             3            B                2017-12-11 16:08:00   

6 rows fetched.

SQL> 
SQL> CREATE INDEX IND_ORDERBY_2_1 ON T_ORDERBY_2(F_INT1);

Succeed.

SQL> CREATE INDEX IND_ORDERBY_2_2 ON T_ORDERBY_2(F_INT2, F_CHAR);

Succeed.

SQL> 
SQL> EXPLAIN PLAN FOR SELECT * FROM T_ORDERBY_2 WHERE F_INT1 > 0 ORDER BY F_INT1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_ORDERBY_2     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IND_ORDERBY_2_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT1 > 0                                       

10 rows fetched.

SQL> SELECT * FROM T_ORDERBY_2 WHERE F_INT1 > 0 ORDER BY F_INT1;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_ORDERBY_2 WHERE F_INT1 > 0 ORDER BY F_INT1 DESC;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name            | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID   | SYS   | T_ORDERBY_2     |      |      |       |        |
| 2   |     INDEX RANGE SCAN DESCENDING | SYS   | IND_ORDERBY_2_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT1 > 0                                       

10 rows fetched.

SQL> SELECT * FROM T_ORDERBY_2 WHERE F_INT1 > 0 ORDER BY F_INT1 DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            3            A                2017-12-11 14:18:00   
1            2            A                2017-12-11 14:08:00   

4 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2, F_CHAR;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_ORDERBY_2     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IND_ORDERBY_2_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT2 > 0                                       

10 rows fetched.

SQL> SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2, F_CHAR;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
             3            B                2017-12-11 16:08:00   
             4            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

6 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2 DESC, F_CHAR DESC;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name            | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID   | SYS   | T_ORDERBY_2     |      |      |       |        |
| 2   |     INDEX RANGE SCAN DESCENDING | SYS   | IND_ORDERBY_2_2 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F_INT2 > 0                                       

10 rows fetched.

SQL> SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2 DESC, F_CHAR DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
3            4            C                2017-12-12 16:08:00   
             4            B                2017-12-11 16:08:00   
             3            B                2017-12-11 16:08:00   
2            3            B                2017-12-11 16:08:00   
1            3            A                2017-12-11 14:18:00   
1            2            A                2017-12-11 14:08:00   

6 rows fetched.

SQL> EXPLAIN PLAN FOR SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2, F_CHAR DESC;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_ORDERBY_2     |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IND_ORDERBY_2_2 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F_INT2 > 0                                       

11 rows fetched.

SQL> SELECT * FROM T_ORDERBY_2 WHERE F_INT2 > 0 ORDER BY F_INT2, F_CHAR DESC;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
2            3            B                2017-12-11 16:08:00   
             3            B                2017-12-11 16:08:00   
1            3            A                2017-12-11 14:18:00   
3            4            C                2017-12-12 16:08:00   
             4            B                2017-12-11 16:08:00   

6 rows fetched.

SQL> --DTS2018101003805
SQL> SELECT I.F_INT2 AS F_INT1, F_INT1 FROM T_ORDERBY_2 I GROUP BY I.F_INT1, I.F_INT2 ORDER BY F_INT1;

CT-00601, Sql syntax error: ambiguous column naming in select list
SQL> SELECT DISTINCT F_INT1, F_INT2 AS F_INT1 FROM T_ORDERBY_2 ORDER BY F_INT1;

CT-00601, Sql syntax error: ambiguous column naming in select list
SQL> SELECT DISTINCT F_INT1+1 AS F_INT2, F_INT2 FROM T_ORDERBY_2 ORDER BY F_INT2;

CT-00601, Sql syntax error: ambiguous column naming in select list
SQL> 
SQL> DROP TABLE IF EXISTS T_ORDERBY_3;

Succeed.

SQL> CREATE TABLE T_ORDERBY_3 (F_INT1 INT, F_INT2 INT);

Succeed.

SQL> insert into T_ORDERBY_3 values(4,3),(3,1),(5,2),(1,4);

4 rows affected.

SQL> select * from T_ORDERBY_3 order by 1;

F_INT1       F_INT2      
------------ ------------
1            4           
3            1           
4            3           
5            2           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 1.3;

F_INT1       F_INT2      
------------ ------------
1            4           
3            1           
4            3           
5            2           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 1.8;

F_INT1       F_INT2      
------------ ------------
1            4           
3            1           
4            3           
5            2           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 2.2;

F_INT1       F_INT2      
------------ ------------
3            1           
5            2           
4            3           
1            4           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 0;

CT-00601, [1:36]Sql syntax error: ORDER BY item must be the number of a SELECT-list expression
SQL> select * from T_ORDERBY_3 order by -0;

F_INT1       F_INT2      
------------ ------------
4            3           
3            1           
5            2           
1            4           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 0.5;

CT-00601, [1:36]Sql syntax error: ORDER BY item must be the number of a SELECT-list expression
SQL> select * from T_ORDERBY_3 order by -1.5;

F_INT1       F_INT2      
------------ ------------
4            3           
3            1           
5            2           
1            4           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by '1';

F_INT1       F_INT2      
------------ ------------
4            3           
3            1           
5            2           
1            4           

4 rows fetched.

SQL> select * from T_ORDERBY_3 order by 'aa';

F_INT1       F_INT2      
------------ ------------
4            3           
3            1           
5            2           
1            4           

4 rows fetched.

SQL> 
SQL> select count(1) as m from T_ORDERBY_1 union all select count(1) as m from T_ORDERBY_2 order by m ;

M                   
--------------------
4                   
6                   

2 rows fetched.

SQL> select count(1) as m from T_ORDERBY_1 union all select count(1) as m from T_ORDERBY_2 order by m desc;

M                   
--------------------
6                   
4                   

2 rows fetched.

SQL> 
SQL> drop table if exists DELETE_BY_ROWID_FROM_SUBSEL;

Succeed.

SQL> create table DELETE_BY_ROWID_FROM_SUBSEL(PlanID int, CMENEID int, CELLID int, TRXID int, OperType int, MAXPDCHNUM int, CHNO int, SRN int, SN int, PORTTYPE int, PN int);

Succeed.

SQL> insert into DELETE_BY_ROWID_FROM_SUBSEL values(1,1,1,1,1,1,1,1,1,1,1);

1 rows affected.

SQL> insert into DELETE_BY_ROWID_FROM_SUBSEL values(2,2,2,2,2,2,2,2,2,2,2);

1 rows affected.

SQL> insert into DELETE_BY_ROWID_FROM_SUBSEL values(3,3,3,3,3,3,3,3,3,3,3);

1 rows affected.

SQL> delete from DELETE_BY_ROWID_FROM_SUBSEL where rowid in(select rowid from DELETE_BY_ROWID_FROM_SUBSEL order by 1 limit 1) ;

1 rows affected.

SQL> delete from DELETE_BY_ROWID_FROM_SUBSEL where rowid in(select rowid from DELETE_BY_ROWID_FROM_SUBSEL order by rowid limit 1) ;

1 rows affected.

SQL> delete from DELETE_BY_ROWID_FROM_SUBSEL where planId in(select planId+2 from DELETE_BY_ROWID_FROM_SUBSEL order by 1);

0 rows affected.

SQL> 
SQL> DROP TABLE IF EXISTS store;

Succeed.

SQL> DROP TABLE IF EXISTS customer;

Succeed.

SQL> create table store
  2 (
  3     s_store_sk                integer               not null,
  4     s_store_id                char(16)              not null,
  5     s_rec_start_date          date                          ,
  6     s_rec_end_date            date                          ,
  7     s_closed_date_sk          integer                       ,
  8     s_store_name              varchar(50)                   ,
  9     s_number_employees        integer                       ,
 10     s_floor_space             integer                       ,
 11     s_hours                   char(20)                      ,
 12     s_manager                 varchar(40)                   ,
 13     s_market_id               integer                       ,
 14     s_geography_class         varchar(100)                  ,
 15     s_market_desc             varchar(100)                  ,
 16     s_market_manager          varchar(40)                   ,
 17     s_division_id             integer                       ,
 18     s_division_name           varchar(50)                   ,
 19     s_company_id              integer                       ,
 20     s_company_name            varchar(50)                   ,
 21     s_street_number           varchar(10)                   ,
 22     s_street_name             varchar(60)                   ,
 23     s_street_type             char(15)                      ,
 24     s_suite_number            char(10)                      ,
 25     s_city                    varchar(60)                   ,
 26     s_county                  varchar(30)                   ,
 27     s_state                   char(2)                       ,
 28     s_zip                     char(10)                      ,
 29     s_country                 varchar(20)                   ,
 30     s_gmt_offset              decimal(5,2)                  ,
 31     s_tax_precentage          decimal(5,2)
 32  );

Succeed.

SQL> 
SQL> create table customer
  2 (
  3     c_customer_sk             integer               not null,
  4     c_customer_id             char(16)              not null,
  5     c_current_cdemo_sk        integer                       ,
  6     c_current_hdemo_sk        integer                       ,
  7     c_current_addr_sk         integer                       ,
  8     c_first_shipto_date_sk    integer                       ,
  9     c_first_sales_date_sk     integer                       ,
 10     c_salutation              char(10)                      ,
 11     c_first_name              char(20)                      ,
 12     c_last_name               char(30)                      ,
 13     c_preferred_cust_flag     char(1)                       ,
 14     c_birth_day               integer                       ,
 15     c_birth_month             integer                       ,
 16     c_birth_year              integer                       ,
 17     c_birth_country           varchar(20)                   ,
 18     c_login                   char(13)                      ,
 19     c_email_address           char(50)                      ,
 20     c_last_review_date        char(10)
 21 );

Succeed.

SQL> 
SQL> select count(distinct c_birth_month)
  2   from customer
  3  order by (with tmp1 as (select sum(s_closed_date_sk),
  4                                 s_manager,
  5                                 s_market_id,
  6                                 rank() over(partition by sum(s_closed_date_sk) order by sum(s_closed_date_sk), s_manager, s_market_id)
  7                            from store
  8                           where length(s_manager) > 12
  9                           group by 2, 3
 10                           order by 1, 2, 3, 4)
 11             select s_market_id
 12               from tmp1
 13              order by 1 limit 1);

CT-00609, Expression not in group list
SQL> 
SQL> DROP TABLE IF EXISTS store;

Succeed.

SQL> DROP TABLE IF EXISTS customer;

Succeed.

SQL> 
SQL> --DTS2019013102954
SQL> select group_concat((INTERVAL '12' YEAR),(INTERVAL '4 5:12:10.222' DAY TO SECOND(3)) order by 1 SEPARATOR '#$%~!@') from dual;

GROUP_CONCAT((INTERVAL '12' YEAR),(INTERVAL '4 5:12:10.222' DAY 
----------------------------------------------------------------
+12-00+04 05:12:10.222000                                       

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS "TMP0000000254_ORDER_BY_NULLS";

Succeed.

SQL> CREATE TABLE "TMP0000000254_ORDER_BY_NULLS"
  2 (
  3   "ID"        INT NOT NULL,
  4   "CHR_FIELD" VARCHAR(30),
  5   "VALUE" NUMBER
  6 );

Succeed.

SQL> 
SQL> insert into "TMP0000000254_ORDER_BY_NULLS" 
  2   select rownum, decode(mod(rownum, 2), 0, NULL, rpad('CHR_', 10, chr(rownum + 64))), decode(mod(rownum, 3), 0, NULL, rownum * 10000) from dual connect by rownum < 6;

5 rows affected.

SQL> 
SQL> insert into "TMP0000000254_ORDER_BY_NULLS" 
  2   select rownum + 10, decode(mod(rownum, 2), 0, NULL, rpad('CHR_', 10, chr(rownum + 64))), decode(mod(rownum, 3), 1, NULL, rownum * 10000) from dual connect by rownum < 6;  

5 rows affected.

SQL> 
SQL> insert into "TMP0000000254_ORDER_BY_NULLS" 
  2   select rownum + 15, decode(mod(rownum, 2), 0, NULL, rpad('CHR_', 10, chr(rownum + 64))), decode(mod(rownum, 3), 1, NULL, rownum * 10) from dual connect by rownum < 6;   

5 rows affected.

SQL> 
SQL> commit;

Succeed.

SQL> --syntax test
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, CHR_FIELD DESC NULLS, ID;

CT-00601, [1:98]Sql syntax error: FIRST or LAST expected
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, CHR_FIELD NULLS, ID;

CT-00601, [1:93]Sql syntax error: FIRST or LAST expected
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, CHR_FIELD LAST, ID;

CT-00601, [1:88]Sql syntax error: invalid word 'LAST' found
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, NULLS LAST, ID;

CT-00601, [1:84]Sql syntax error: invalid word 'LAST' found
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, ASC NULLS LAST, ID;

CT-00601, [1:78]Sql syntax error: invalid expression
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC "NULLS" LAST;

CT-00601, [1:66]Sql syntax error: invalid word 'NULLS' found
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS "LAST";

CT-00601, [1:72]Sql syntax error: FIRST or LAST expected
SQL> 
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, CHR_FIELD DESC NULLS FIRST, ID;

ID           CHR_FIELD                      VALUE                                   
------------ ------------------------------ ----------------------------------------
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
4                                           40000                                   
13           CHR_CCCCCC                     30000                                   
2                                           20000                                   
12                                          20000                                   
1            CHR_AAAAAA                     10000                                   
20           CHR_EEEEEE                     50                                      
18           CHR_CCCCCC                     30                                      
17                                          20                                      
14                                                                                  
19                                                                                  
3            CHR_CCCCCC                                                             
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             

15 rows fetched.

SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY VALUE DESC NULLS LAST, CHR_FIELD DESC NULLS LAST, ID;

ID           CHR_FIELD                      VALUE                                   
------------ ------------------------------ ----------------------------------------
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
4                                           40000                                   
13           CHR_CCCCCC                     30000                                   
2                                           20000                                   
12                                          20000                                   
1            CHR_AAAAAA                     10000                                   
20           CHR_EEEEEE                     50                                      
18           CHR_CCCCCC                     30                                      
17                                          20                                      
3            CHR_CCCCCC                                                             
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             
14                                                                                  
19                                                                                  

15 rows fetched.

SQL> 
SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY 3 DESC NULLS LAST, 1 ASC NULLS FIRST;

ID           CHR_FIELD                      VALUE                                   
------------ ------------------------------ ----------------------------------------
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
4                                           40000                                   
13           CHR_CCCCCC                     30000                                   
2                                           20000                                   
12                                          20000                                   
1            CHR_AAAAAA                     10000                                   
20           CHR_EEEEEE                     50                                      
18           CHR_CCCCCC                     30                                      
17                                          20                                      
3            CHR_CCCCCC                                                             
11           CHR_AAAAAA                                                             
14                                                                                  
16           CHR_AAAAAA                                                             
19                                                                                  

15 rows fetched.

SQL> SELECT * FROM "TMP0000000254_ORDER_BY_NULLS" ORDER BY 2 NULLS FIRST, 1 ASC NULLS FIRST;

ID           CHR_FIELD                      VALUE                                   
------------ ------------------------------ ----------------------------------------
2                                           20000                                   
4                                           40000                                   
12                                          20000                                   
14                                                                                  
17                                          20                                      
19                                                                                  
1            CHR_AAAAAA                     10000                                   
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             
3            CHR_CCCCCC                                                             
13           CHR_CCCCCC                     30000                                   
18           CHR_CCCCCC                     30                                      
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
20           CHR_EEEEEE                     50                                      

15 rows fetched.

SQL> SELECT "ID", "CHR_FIELD" CCC, "VALUE" VVV from "TMP0000000254_ORDER_BY_NULLS" ORDER BY CCC DESC NULLS FIRST, VVV ASC NULLS LAST, 1;

ID           CCC                            VVV                                     
------------ ------------------------------ ----------------------------------------
17                                          20                                      
2                                           20000                                   
12                                          20000                                   
4                                           40000                                   
14                                                                                  
19                                                                                  
20           CHR_EEEEEE                     50                                      
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
18           CHR_CCCCCC                     30                                      
13           CHR_CCCCCC                     30000                                   
3            CHR_CCCCCC                                                             
1            CHR_AAAAAA                     10000                                   
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             

15 rows fetched.

SQL> SELECT "ID", "CHR_FIELD" NULLS, "VALUE" VVV from "TMP0000000254_ORDER_BY_NULLS" ORDER BY NULLS NULLS FIRST, VVV ASC NULLS LAST, 1;

ID           NULLS                          VVV                                     
------------ ------------------------------ ----------------------------------------
17                                          20                                      
2                                           20000                                   
12                                          20000                                   
4                                           40000                                   
14                                                                                  
19                                                                                  
1            CHR_AAAAAA                     10000                                   
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             
18           CHR_CCCCCC                     30                                      
13           CHR_CCCCCC                     30000                                   
3            CHR_CCCCCC                                                             
20           CHR_EEEEEE                     50                                      
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   

15 rows fetched.

SQL> SELECT "ID", "CHR_FIELD" NULLS, "VALUE" VVV from "TMP0000000254_ORDER_BY_NULLS" ORDER BY NULLS DESC NULLS FIRST, VVV ASC NULLS LAST, 1;

ID           NULLS                          VVV                                     
------------ ------------------------------ ----------------------------------------
17                                          20                                      
2                                           20000                                   
12                                          20000                                   
4                                           40000                                   
14                                                                                  
19                                                                                  
20           CHR_EEEEEE                     50                                      
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
18           CHR_CCCCCC                     30                                      
13           CHR_CCCCCC                     30000                                   
3            CHR_CCCCCC                                                             
1            CHR_AAAAAA                     10000                                   
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             

15 rows fetched.

SQL> 
SQL> SELECT "ID", "CHR_FIELD" NULLS, "VALUE" VVV from "TMP0000000254_ORDER_BY_NULLS" ORDER BY NULLS FIRST, VVV ASC NULLS LAST, 1;

CT-00601, [1:96]Sql syntax error: invalid word 'FIRST' found
SQL> 
SQL> -- winsort order by NULLS / 
SQL> SELECT ID, CHR_FIELD, VALUE, ROW_NUMBER() OVER (PARTITION BY -VALUE ORDER BY CHR_FIELD DESC NULLS LAST, ID) ROW_NUM from "TMP0000000254_ORDER_BY_NULLS";

ID           CHR_FIELD                      VALUE                                    ROW_NUM     
------------ ------------------------------ ---------------------------------------- ------------
5            CHR_EEEEEE                     50000                                    1           
15           CHR_EEEEEE                     50000                                    2           
4                                           40000                                    1           
13           CHR_CCCCCC                     30000                                    1           
2                                           20000                                    1           
12                                          20000                                    2           
1            CHR_AAAAAA                     10000                                    1           
20           CHR_EEEEEE                     50                                       1           
18           CHR_CCCCCC                     30                                       1           
17                                          20                                       1           
3            CHR_CCCCCC                                                              1           
11           CHR_AAAAAA                                                              2           
16           CHR_AAAAAA                                                              3           
14                                                                                   4           
19                                                                                   5           

15 rows fetched.

SQL> SELECT ID, CHR_FIELD, VALUE, SUM(VALUE) OVER (PARTITION BY CHR_FIELD ORDER BY VALUE NULLS FIRST, ID) SUM_VALUE from "TMP0000000254_ORDER_BY_NULLS";

ID           CHR_FIELD                      VALUE                                    SUM_VALUE                               
------------ ------------------------------ ---------------------------------------- ----------------------------------------
11           CHR_AAAAAA                                                                                                      
16           CHR_AAAAAA                                                                                                      
1            CHR_AAAAAA                     10000                                    10000                                   
3            CHR_CCCCCC                                                                                                      
18           CHR_CCCCCC                     30                                       30                                      
13           CHR_CCCCCC                     30000                                    30030                                   
20           CHR_EEEEEE                     50                                       50                                      
5            CHR_EEEEEE                     50000                                    50050                                   
15           CHR_EEEEEE                     50000                                    100050                                  
14                                                                                                                           
19                                                                                                                           
17                                          20                                       20                                      
2                                           20000                                    20020                                   
12                                          20000                                    40020                                   
4                                           40000                                    80020                                   

15 rows fetched.

SQL> SELECT ID, CHR_FIELD, VALUE, MAX(VALUE) OVER (PARTITION BY CHR_FIELD ORDER BY ID, VALUE DESC NULLS FIRST) SUM_VALUE from "TMP0000000254_ORDER_BY_NULLS";

ID           CHR_FIELD                      VALUE                                    SUM_VALUE                               
------------ ------------------------------ ---------------------------------------- ----------------------------------------
1            CHR_AAAAAA                     10000                                    10000                                   
11           CHR_AAAAAA                                                              10000                                   
16           CHR_AAAAAA                                                              10000                                   
3            CHR_CCCCCC                                                                                                      
13           CHR_CCCCCC                     30000                                    30000                                   
18           CHR_CCCCCC                     30                                       30000                                   
5            CHR_EEEEEE                     50000                                    50000                                   
15           CHR_EEEEEE                     50000                                    50000                                   
20           CHR_EEEEEE                     50                                       50000                                   
2                                           20000                                    20000                                   
4                                           40000                                    40000                                   
12                                          20000                                    40000                                   
14                                                                                   40000                                   
17                                          20                                       40000                                   
19                                                                                   40000                                   

15 rows fetched.

SQL> 
SQL> -- group by may eliminate the sorting
SQL> insert into "TMP0000000254_ORDER_BY_NULLS" values(23, 'CHR_XXXXXX', NULL);

1 rows affected.

SQL> insert into "TMP0000000254_ORDER_BY_NULLS" values(24, 'CHR_YYYYYY', 80020);

1 rows affected.

SQL> select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by CHR_FIELD nulls first;

CHR_FIELD                      SUM(VALUE)                              
------------------------------ ----------------------------------------
                               80020                                   
CHR_AAAAAA                     10000                                   
CHR_CCCCCC                     30030                                   
CHR_EEEEEE                     100050                                  
CHR_XXXXXX                                                             
CHR_YYYYYY                     80020                                   

6 rows fetched.

SQL> select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by CHR_FIELD DESC nulls first;

CHR_FIELD                      SUM(VALUE)                              
------------------------------ ----------------------------------------
                               80020                                   
CHR_YYYYYY                     80020                                   
CHR_XXXXXX                                                             
CHR_EEEEEE                     100050                                  
CHR_CCCCCC                     30030                                   
CHR_AAAAAA                     10000                                   

6 rows fetched.

SQL> select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by CHR_FIELD DESC nulls first, 2;

CHR_FIELD                      SUM(VALUE)                              
------------------------------ ----------------------------------------
                               80020                                   
CHR_YYYYYY                     80020                                   
CHR_XXXXXX                                                             
CHR_EEEEEE                     100050                                  
CHR_CCCCCC                     30030                                   
CHR_AAAAAA                     10000                                   

6 rows fetched.

SQL> select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by 2 ASC NULLS FIRST, CHR_FIELD DESC nulls LAST;

CHR_FIELD                      SUM(VALUE)                              
------------------------------ ----------------------------------------
CHR_XXXXXX                                                             
CHR_AAAAAA                     10000                                   
CHR_CCCCCC                     30030                                   
CHR_YYYYYY                     80020                                   
                               80020                                   
CHR_EEEEEE                     100050                                  

6 rows fetched.

SQL> select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by 2 ASC NULLS FIRST, CHR_FIELD DESC nulls first;

CHR_FIELD                      SUM(VALUE)                              
------------------------------ ----------------------------------------
CHR_XXXXXX                                                             
CHR_AAAAAA                     10000                                   
CHR_CCCCCC                     30030                                   
                               80020                                   
CHR_YYYYYY                     80020                                   
CHR_EEEEEE                     100050                                  

6 rows fetched.

SQL> 
SQL> select CHR_FIELD, id, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD, id order by CHR_FIELD DESC nulls first,3 nulls first, 2 nulls first;

CHR_FIELD                      ID           SUM(VALUE)                              
------------------------------ ------------ ----------------------------------------
                               14                                                   
                               19                                                   
                               17           20                                      
                               2            20000                                   
                               12           20000                                   
                               4            40000                                   
CHR_YYYYYY                     24           80020                                   
CHR_XXXXXX                     23                                                   
CHR_EEEEEE                     20           50                                      
CHR_EEEEEE                     5            50000                                   
CHR_EEEEEE                     15           50000                                   
CHR_CCCCCC                     3                                                    
CHR_CCCCCC                     18           30                                      
CHR_CCCCCC                     13           30000                                   
CHR_AAAAAA                     11                                                   
CHR_AAAAAA                     16                                                   
CHR_AAAAAA                     1            10000                                   

17 rows fetched.

SQL> select CHR_FIELD, id, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD, id order by CHR_FIELD DESC nulls last, id nulls first;

CHR_FIELD                      ID           SUM(VALUE)                              
------------------------------ ------------ ----------------------------------------
CHR_YYYYYY                     24           80020                                   
CHR_XXXXXX                     23                                                   
CHR_EEEEEE                     5            50000                                   
CHR_EEEEEE                     15           50000                                   
CHR_EEEEEE                     20           50                                      
CHR_CCCCCC                     3                                                    
CHR_CCCCCC                     13           30000                                   
CHR_CCCCCC                     18           30                                      
CHR_AAAAAA                     1            10000                                   
CHR_AAAAAA                     11                                                   
CHR_AAAAAA                     16                                                   
                               2            20000                                   
                               4            40000                                   
                               12           20000                                   
                               14                                                   
                               17           20                                      
                               19                                                   

17 rows fetched.

SQL> 
SQL> explain select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by CHR_FIELD nulls first;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                              |      |      |       |        |
| 1   |   SORT GROUP BY        |       |                              |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by CHR_FIELD nulls last;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                              |      |      |       |        |
| 1   |   SORT GROUP BY        |       |                              |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select CHR_FIELD, sum(value) from "TMP0000000254_ORDER_BY_NULLS" group by CHR_FIELD order by 2 nulls first;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name                         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY    |       |                              |      |      |       |        |
| 2   |     HASH GROUP BY        |       |                              |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
--------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> 
SQL> -- index scan may eliminate the sorting
SQL> create index idx_ORDER_BY_NULLS on "TMP0000000254_ORDER_BY_NULLS"(CHR_FIELD);

Succeed.

SQL> explain select CHR_FIELD from "TMP0000000254_ORDER_BY_NULLS" order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                         | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 2   |     INDEX FULL SCAN           | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
-------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select CHR_FIELD from "TMP0000000254_ORDER_BY_NULLS" order by 1 nulls last;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                         | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 2   |     INDEX FULL SCAN           | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
-------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select CHR_FIELD from "TMP0000000254_ORDER_BY_NULLS" order by 1 nulls first;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
---------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> 
SQL> explain select * from "TMP0000000254_ORDER_BY_NULLS" order by CHR_FIELD desc;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 2   |     INDEX FULL SCAN DESCENDING | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
--------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select * from "TMP0000000254_ORDER_BY_NULLS" order by CHR_FIELD desc nulls last;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 3   |       INDEX FULL SCAN DESCENDING | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
----------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select id, value from "TMP0000000254_ORDER_BY_NULLS" order by CHR_FIELD desc nulls first;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TMP0000000254_ORDER_BY_NULLS |      |      |       |        |
| 2   |     INDEX FULL SCAN DESCENDING | SYS   | IDX_ORDER_BY_NULLS           |      |      |       |        |
--------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> 
SQL> select CHR_FIELD from "TMP0000000254_ORDER_BY_NULLS" order by 1 desc nulls last;

CHR_FIELD                     
------------------------------
CHR_YYYYYY                    
CHR_XXXXXX                    
CHR_EEEEEE                    
CHR_EEEEEE                    
CHR_EEEEEE                    
CHR_CCCCCC                    
CHR_CCCCCC                    
CHR_CCCCCC                    
CHR_AAAAAA                    
CHR_AAAAAA                    
CHR_AAAAAA                    
                              
                              
                              
                              
                              
                              

17 rows fetched.

SQL> select * from "TMP0000000254_ORDER_BY_NULLS" order by CHR_FIELD asc nulls first, id;

ID           CHR_FIELD                      VALUE                                   
------------ ------------------------------ ----------------------------------------
2                                           20000                                   
4                                           40000                                   
12                                          20000                                   
14                                                                                  
17                                          20                                      
19                                                                                  
1            CHR_AAAAAA                     10000                                   
11           CHR_AAAAAA                                                             
16           CHR_AAAAAA                                                             
3            CHR_CCCCCC                                                             
13           CHR_CCCCCC                     30000                                   
18           CHR_CCCCCC                     30                                      
5            CHR_EEEEEE                     50000                                   
15           CHR_EEEEEE                     50000                                   
20           CHR_EEEEEE                     50                                      
23           CHR_XXXXXX                                                             
24           CHR_YYYYYY                     80020                                   

17 rows fetched.

SQL> 
SQL> 
SQL> --DTS2019020203833
SQL> DROP TABLE IF EXISTS t_type_004;

Succeed.

SQL> CREATE TABLE t_type_004(b BOOLEAN);

Succeed.

SQL> INSERT INTO t_type_004 VALUES(TRUE);

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES(FALSE);

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('TRUE');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('FALSE');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('true');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('false');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('T');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('F');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('t');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('f');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('1');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES('0');

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES(1);

1 rows affected.

SQL> INSERT INTO t_type_004 VALUES(0);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = '1' AND T.B = TRUE AND T.B = 't' AND B = 'T' AND B = 'true' AND B = 'TRUE' AND B = 1 AND b ORDER BY B;

B     
------
TRUE  
TRUE  
TRUE  
TRUE  
TRUE  
TRUE  
TRUE  

7 rows fetched.

SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = '0' ORDER BY B;

B     
------
FALSE 
FALSE 
FALSE 
FALSE 
FALSE 
FALSE 
FALSE 

7 rows fetched.

SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'LIMIT' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'ROWID' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'NULL' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'LEFT' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'JOIN' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'SELECT' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 'TRUE' or T.B = 'll' ORDER BY B;

CT-00601, Sql syntax error: invalid BOOLEAN text
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = X'02';

CT-00606, [1:40]Inconsistent datatypes, expected BOOLEAN - got BINARY
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = 0x02;

CT-00606, [1:40]Inconsistent datatypes, expected BOOLEAN - got BINARY
SQL> SELECT * FROM T_TYPE_004 T WHERE T.B = NULL;

B     
------

0 rows fetched.

SQL> DROP TABLE T_TYPE_004;

Succeed.

SQL> 
SQL> 
SQL> DROP TABLE IF EXISTS I_PHYINVLTP_test;

Succeed.

SQL> CREATE TABLE I_PHYINVLTP_test
  2 (
  3   id VARBINARY(16) NOT NULL,
  4   name VARCHAR(765 BYTE),
  5   neName VARCHAR(765 BYTE),
  6   PRIMARY KEY(id)
  7 );

Succeed.

SQL> CREATE INDEX IDX_PHYINVLTP_NENAME_1204_test ON I_PHYINVLTP_test(neName, id);

Succeed.

SQL> 
SQL> explain SELECT  name, neName,id ,rowid
  2 FROM I_PHYINVLTP_test I 
  3 WHERE (((((I.neName<'10004') 
  4 OR (I.neName IS NULL )) 
  5 OR ((I.neName='10004') 
  6 AND (I.id>UNHEX('11e969c29bd3ee40adf00050569e7b91')))))) 
  7 ORDER BY I.neName DESC, I.id ASC
  8 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_PHYINVLTP_TEST I             |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_PHYINVLTP_NENAME_1204_TEST |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: I.NENAME < '10004' OR I.NENAME IS NULL OR I.NENAME = '10004' AND I.ID > '11E969C29BD3EE40ADF00050569E7B91'

12 rows fetched.

SQL> 
SQL> explain SELECT  name, neName,id ,rowid
  2 FROM I_PHYINVLTP_test I 
  3 WHERE (((((I.neName<'10004') 
  4 OR (I.neName IS NULL )) 
  5 OR ((I.neName='10004') 
  6 AND (I.id>UNHEX('11e969c29bd3ee40adf00050569e7b91')))))) 
  7 ORDER BY I.neName ASC, I.id DESC
  8 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_PHYINVLTP_TEST I             |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_PHYINVLTP_NENAME_1204_TEST |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: I.NENAME < '10004' OR I.NENAME IS NULL OR I.NENAME = '10004' AND I.ID > '11E969C29BD3EE40ADF00050569E7B91'

12 rows fetched.

SQL> 
SQL> explain SELECT  name, neName,id ,rowid
  2 FROM I_PHYINVLTP_test I 
  3 WHERE (((((I.neName<'10004') 
  4 OR (I.neName IS NULL )) 
  5 OR ((I.neName='10004') 
  6 AND (I.id>UNHEX('11e969c29bd3ee40adf00050569e7b91')))))) 
  7 ORDER BY I.neName DESC, I.id DESC
  8 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                           | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                     |       |                                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID   | SYS   | I_PHYINVLTP_TEST I             |      |      |       |        |
| 3   |       INDEX RANGE SCAN DESCENDING | SYS   | IDX_PHYINVLTP_NENAME_1204_TEST |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: I.NENAME < '10004' OR I.NENAME IS NULL OR I.NENAME = '10004' AND I.ID > '11E969C29BD3EE40ADF00050569E7B91'

11 rows fetched.

SQL> 
SQL> explain SELECT  name, neName,id ,rowid
  2 FROM I_PHYINVLTP_test I 
  3 WHERE (((((I.neName<'10004') 
  4 OR (I.neName IS NULL )) 
  5 OR ((I.neName='10004') 
  6 AND (I.id>UNHEX('11e969c29bd3ee40adf00050569e7b91')))))) 
  7 ORDER BY I.neName, I.id 
  8 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_PHYINVLTP_TEST I             |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_PHYINVLTP_NENAME_1204_TEST |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: I.NENAME < '10004' OR I.NENAME IS NULL OR I.NENAME = '10004' AND I.ID > '11E969C29BD3EE40ADF00050569E7B91'

11 rows fetched.

SQL> 
SQL> explain SELECT  name, neName,id ,rowid
  2 FROM I_PHYINVLTP_test I 
  3 WHERE (((((I.neName<'10004') 
  4 OR (I.neName IS NULL )) 
  5 OR ((I.neName='10004') 
  6 AND (I.id>UNHEX('11e969c29bd3ee40adf00050569e7b91')))))) 
  7 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_PHYINVLTP_TEST I             |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_PHYINVLTP_NENAME_1204_TEST |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: I.NENAME < '10004' OR I.NENAME IS NULL OR I.NENAME = '10004' AND I.ID > '11E969C29BD3EE40ADF00050569E7B91'

11 rows fetched.

SQL> 
SQL> DROP TABLE I_PHYINVLTP_test;

Succeed.

SQL> 
SQL> drop table if exists ToClob_T1;

Succeed.

SQL> create table ToClob_T1(f_long long,f_clob clob);

Succeed.

SQL> insert into ToClob_T1 values('bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb',to_clob(LPAD(1,20000,'x')));

1 rows affected.

SQL> insert into ToClob_T1 values('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',to_clob(LPAD(1,20000,'a')));

1 rows affected.

SQL> select to_clob(f_long) from ToClob_T1 order by 1;

TO_CLOB(F_LONG)                                                 
----------------------------------------------------------------
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                         
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                         

2 rows fetched.

SQL> select f_long from ToClob_T1 order by f_clob desc;

F_LONG                                                          
----------------------------------------------------------------
bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb                         
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                         

2 rows fetched.

SQL> drop table ToClob_T1;

Succeed.

SQL> --DTS2019082311282
SQL> drop table if exists t_count_base_001;

Succeed.

SQL> create table t_count_base_001(id number,deptno number,name varchar2(20),sal number);

Succeed.

SQL> insert into t_count_base_001 values(1,1,'1aa',120);

1 rows affected.

SQL> insert into t_count_base_001 values(2,1,'2aa',300);

1 rows affected.

SQL> insert into t_count_base_001 values(3,1,'3aa',100);

1 rows affected.

SQL> insert into t_count_base_001 values(4,1,'4aa',99);

1 rows affected.

SQL> insert into t_count_base_001 values(5,1,'5aa',90);

1 rows affected.

SQL> insert into t_count_base_001 values(6,2,'6aa',87);

1 rows affected.

SQL> insert into t_count_base_001 values(7,2,'7aa',500);

1 rows affected.

SQL> insert into t_count_base_001 values(8,2,'8aa',200);

1 rows affected.

SQL> insert into t_count_base_001 values(9,2,'9aa',20);

1 rows affected.

SQL> insert into t_count_base_001 values(10,2,'10aa',30);

1 rows affected.

SQL> insert into t_count_base_001 values(null,2,'10aa',30);

1 rows affected.

SQL> insert into t_count_base_001 values(12,2,'10aa',null);

1 rows affected.

SQL> commit;

Succeed.

SQL> select distinct to_char(to_blob('a'))||array[1] c from t_count_base_001 t connect by nocycle prior id=1 order by abs(c);

CT-00636, Invalid number -- unexpected character
SQL> drop table if exists t_count_base_001;

Succeed.

SQL> 
SQL> drop table if exists t_sort_1;

Succeed.

SQL> drop table if exists t_sort_2;

Succeed.

SQL> drop table if exists t_sort_3;

Succeed.

SQL> drop table if exists t_sort_4;

Succeed.

SQL> create table t_sort_1(a int, b int, c int, d int);

Succeed.

SQL> create index idx_t_sort_1_1 on t_sort_1(a);

Succeed.

SQL> create table t_sort_2(a int, b int, c int, d int);

Succeed.

SQL> create index idx_t_sort_2_1 on t_sort_2(b);

Succeed.

SQL> create table t_sort_3(a int, b int, c int, d int);

Succeed.

SQL> create index idx_t_sort_3_1 on t_sort_3(c);

Succeed.

SQL> create table t_sort_4(a int, b int, c int, d int);

Succeed.

SQL> create index idx_t_sort_4_1 on t_sort_4(d);

Succeed.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.b = t2.b where t1.a >= 0 order by t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name           | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                |      |      |       |        |
| 1   |   QUERY SORT ORDER BY              |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_2 T2    |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | IDX_T_SORT_2_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A >= 0                                        
   6 - access: T1.B = T2.B                                      

15 rows fetched.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.c = t2.c order by t1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |             |      |      |       |        |
| 1   |   QUERY SORT ORDER BY    |       |             |      |      |       |        |
| 2   |     HASH JOIN(L)         |       |             |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_SORT_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_SORT_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.C = T2.C                                      

12 rows fetched.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.b = t2.b order by t1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_2 T2    |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_T_SORT_2_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.B = T2.B                                      

13 rows fetched.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.c = t2.c order by t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   HASH JOIN(L)                   |       |                |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | T_SORT_1 T1    |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_2 T2    |      |      |       |        |
| 4   |       INDEX FULL SCAN            | SYS   | IDX_T_SORT_2_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.C = T2.C                                      

12 rows fetched.

SQL> explain select * from t_sort_1 t1 left join t_sort_2 t2 on t1.c = t2.c order by t1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)             |       |                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL            | SYS   | T_SORT_2 T2    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.C = T2.C                                      

12 rows fetched.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.b = t2.b where t1.a >= 0 order by t1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_2 T2    |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | IDX_T_SORT_2_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A >= 0                                        
   5 - access: T1.B = T2.B                                      

14 rows fetched.

SQL> explain select * from t_sort_1 t1 join t_sort_2 t2 on t1.b = t2.b  join t_sort_3 t3 on t2.c = t3.c where t1.a = 100 order by t1.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name           | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                |      |      |       |        |
| 1   |   NESTED LOOPS                     |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |                |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_2 T2    |      |      |       |        |
| 6   |         INDEX RANGE SCAN           | SYS   | IDX_T_SORT_2_1 |      |      |       |        |
| 7   |     TABLE ACCESS BY INDEX ROWID    | SYS   | T_SORT_3 T3    |      |      |       |        |
| 8   |       INDEX RANGE SCAN             | SYS   | IDX_T_SORT_3_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = 100                                       
   6 - access: T1.B = T2.B                                      
   8 - access: T2.C = T3.C                                      

18 rows fetched.

SQL> explain select * from t_sort_1 t1 join ((t_sort_2 t2 join t_sort_3 t3 on t2.c = t3.c) left join t_sort_4 t4 on t3.b = t4.b) on t1.a = t4.a order by t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                  |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |                |      |      |       |        |
| 3   |       HASH JOIN(L)                     |       |                |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 5   |           TABLE ACCESS FULL            | SYS   | T_SORT_2 T2    |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_3 T3    |      |      |       |        |
| 7   |             INDEX RANGE SCAN           | SYS   | IDX_T_SORT_3_1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL              | SYS   | T_SORT_4 T4    |      |      |       |        |
| 9   |       TABLE ACCESS BY INDEX ROWID      | SYS   | T_SORT_1 T1    |      |      |       |        |
| 10  |         INDEX RANGE SCAN               | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T3.B = T4.B                                      
   7 - access: T2.C = T3.C                                      
   10 - access: T1.A = T4.A                                     

20 rows fetched.

SQL> explain select * from t_sort_1 t1 join ((t_sort_2 t2 join t_sort_3 t3 on t2.a = t3.a) left join t_sort_4 t4 on t3.b = t4.b) on t1.a = t4.a order by t3.c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                  |       |                |      |      |       |        |
| 2   |     HASH JOIN(L)                       |       |                |      |      |       |        |
| 3   |       HASH JOIN(L)                     |       |                |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 5   |           TABLE ACCESS FULL            | SYS   | T_SORT_4 T4    |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ROWID  | SYS   | T_SORT_1 T1    |      |      |       |        |
| 7   |             INDEX RANGE SCAN           | SYS   | IDX_T_SORT_1_1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL              | SYS   | T_SORT_3 T3    |      |      |       |        |
| 9   |       TABLE ACCESS FULL                | SYS   | T_SORT_2 T2    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T3.A = T2.A                                      
   3 - access: T4.B = T3.B                                      
   7 - access: T1.A = T4.A                                      

19 rows fetched.

SQL> drop table if exists t_sort_1;

Succeed.

SQL> drop table if exists t_sort_2;

Succeed.

SQL> drop table if exists t_sort_3;

Succeed.

SQL> drop table if exists t_sort_4;

Succeed.

SQL> 
SQL> drop table if exists t_orderby1;

Succeed.

SQL> drop table if exists t_orderby2;

Succeed.

SQL> create table t_orderby1(f1 int, f2 int, f3 int, f4 int);

Succeed.

SQL> create table t_orderby2(f1 int, f2 int, f3 int, f4 int);

Succeed.

SQL> insert into t_orderby1 values(1,2,3,4);

1 rows affected.

SQL> insert into t_orderby1 values(2,3,4,5);

1 rows affected.

SQL> insert into t_orderby1 values(3,4,5,6);

1 rows affected.

SQL> insert into t_orderby1 values(4,5,6,7);

1 rows affected.

SQL> insert into t_orderby1 values(3,4,1,2);

1 rows affected.

SQL> insert into t_orderby1 values(4,5,2,3);

1 rows affected.

SQL> insert into t_orderby1 values(5,6,3,4);

1 rows affected.

SQL> insert into t_orderby1 values(6,7,4,5);

1 rows affected.

SQL> insert into t_orderby2 values(1,2,3,4);

1 rows affected.

SQL> insert into t_orderby2 values(2,3,4,5);

1 rows affected.

SQL> insert into t_orderby2 values(3,4,5,6);

1 rows affected.

SQL> insert into t_orderby2 values(4,5,6,7);

1 rows affected.

SQL> insert into t_orderby2 values(3,4,1,2);

1 rows affected.

SQL> insert into t_orderby2 values(4,5,2,3);

1 rows affected.

SQL> insert into t_orderby2 values(5,6,3,4);

1 rows affected.

SQL> insert into t_orderby2 values(6,7,4,5);

1 rows affected.

SQL> 
SQL> explain select * from (select distinct f1,f2,f3,f4 from t_orderby1) order by f1,f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |            |      |      |       |        |
| 1   |   SUBSELECT                |       |            |      |      |       |        |
| 2   |     QUERY SORT ORDER BY    |       |            |      |      |       |        |
| 3   |       HASH DISTINCT        |       |            |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_ORDERBY1 |      |      |       |        |
----------------------------------------------------------------------------------------

9 rows fetched.

SQL> explain select * from (select distinct f1,f2,f3,f4 from t_orderby1) order by f3+f4;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |            |      |      |       |        |
| 1   |   SUBSELECT                |       |            |      |      |       |        |
| 2   |     QUERY SORT ORDER BY    |       |            |      |      |       |        |
| 3   |       HASH DISTINCT        |       |            |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_ORDERBY1 |      |      |       |        |
----------------------------------------------------------------------------------------

9 rows fetched.

SQL> explain select * from (select f1,f2,sum(f3) over(partition by f1 order by f4) winsort from t_orderby1) order by f1,f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |            |      |      |       |        |
| 1   |   SUBSELECT                |       |            |      |      |       |        |
| 2   |     QUERY SORT ORDER BY    |       |            |      |      |       |        |
| 3   |       WINDOW SORT          |       |            |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_ORDERBY1 |      |      |       |        |
----------------------------------------------------------------------------------------

9 rows fetched.

SQL> explain select * from (select distinct t1.f1 f1,t1.f2 f2,t1.f3 f3,t2.f1 f4,t2.f2 f5,t2.f3 f6 from t_orderby1 t1 join t_orderby2 t2 on t1.f1 = t2.f1) order by f2,f4,f6;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |               |      |      |       |        |
| 1   |   SUBSELECT                  |       |               |      |      |       |        |
| 2   |     QUERY SORT ORDER BY      |       |               |      |      |       |        |
| 3   |       HASH DISTINCT          |       |               |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |               |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_ORDERBY1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_ORDERBY2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.F1 = T2.F1                                    

14 rows fetched.

SQL> 
SQL> select * from (select distinct f1,f2,f3,f4 from t_orderby1) order by f1,f2;

F1           F2           F3           F4          
------------ ------------ ------------ ------------
1            2            3            4           
2            3            4            5           
3            4            5            6           
3            4            1            2           
4            5            6            7           
4            5            2            3           
5            6            3            4           
6            7            4            5           

8 rows fetched.

SQL> select * from (select distinct f1,f2,f3,f4 from t_orderby1) order by f3+f4;

F1           F2           F3           F4          
------------ ------------ ------------ ------------
3            4            1            2           
4            5            2            3           
1            2            3            4           
5            6            3            4           
2            3            4            5           
6            7            4            5           
3            4            5            6           
4            5            6            7           

8 rows fetched.

SQL> select * from (select f1,f2,sum(f3) over(partition by f1 order by f4) winsort from t_orderby1) order by f1,f2;

F1           F2           WINSORT             
------------ ------------ --------------------
1            2            3                   
2            3            4                   
3            4            1                   
3            4            6                   
4            5            2                   
4            5            8                   
5            6            3                   
6            7            4                   

8 rows fetched.

SQL> select * from (select distinct t1.f1 f1,t1.f2 f2,t1.f3 f3,t2.f1 f4,t2.f2 f5,t2.f3 f6 from t_orderby1 t1 join t_orderby2 t2 on t1.f1 = t2.f1) order by f2,f4,f6;

F1           F2           F3           F4           F5           F6          
------------ ------------ ------------ ------------ ------------ ------------
1            2            3            1            2            3           
2            3            4            2            3            4           
3            4            5            3            4            1           
3            4            1            3            4            1           
3            4            5            3            4            5           
3            4            1            3            4            5           
4            5            6            4            5            2           
4            5            2            4            5            2           
4            5            6            4            5            6           
4            5            2            4            5            6           
5            6            3            5            6            3           
6            7            4            6            7            4           

12 rows fetched.

SQL> 
SQL> drop table if exists t_orderby1;

Succeed.

SQL> drop table if exists t_orderby2;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "PBI_EDITION_OD";

Succeed.

SQL> CREATE TABLE "PBI_EDITION_OD"
  2 (
  3   "EDITION_ID" NUMBER(20) NOT NULL,
  4   "OFFERING_ID" NUMBER(20),
  5   "PARENT_ID" NUMBER(20),
  6   "NO" VARCHAR(45 BYTE) NOT NULL,
  7   "EDITION_CODE" VARCHAR(75 BYTE),
  8   "CATEGORY" VARCHAR(30 BYTE) NOT NULL,
  9   "STATUS" NUMBER(1) NOT NULL,
 10   "OFFERING_NAME" VARCHAR(768 BYTE),
 11   "ALIAS" VARCHAR(768 BYTE),
 12   "FOR_FINACE" NUMBER(1) NOT NULL,
 13   "LIFECYCLE_ID" VARCHAR(45 BYTE),
 14   "OLD_NO" VARCHAR(150 BYTE),
 15   "VERSION" VARCHAR(15 BYTE) NOT NULL,
 16   "CREATED_BY" VARCHAR(768 BYTE),
 17   "CREATION_DATE" DATE,
 18   "LAST_UPDATED_BY" VARCHAR(768 BYTE),
 19   "LAST_UPDATE_DATE" DATE,
 20   "DIFFICULTY_COEFFICIENT" VARCHAR(45 BYTE),
 21   "SPLIMIT" NUMBER(1),
 22   "SPNUM" NUMBER(5),
 23   "IFHISTORYCOA" NUMBER(1),
 24   "RESERVE11" VARCHAR(375 BYTE),
 25   "RESERVE12" VARCHAR(375 BYTE),
 26   "RESERVE13" VARCHAR(375 BYTE),
 27   "RESERVE14" VARCHAR(375 BYTE),
 28   "RESERVE15" VARCHAR(375 BYTE)
 29 );

Succeed.

SQL> DROP TABLE IF EXISTS "HWF_DD_ITEM";

Succeed.

SQL> CREATE TABLE "HWF_DD_ITEM"
  2 (
  3   "ITEM_ID" VARCHAR(75 BYTE) NOT NULL,
  4   "ITEM_NAME" VARCHAR(150 BYTE) NOT NULL,
  5   "ITEM_DESC" VARCHAR(750 BYTE),
  6   "ITEM_TIME" DATE,
  7   "NLS_LANG" VARCHAR(15 BYTE) NOT NULL,
  8   "CLASSIFY_ID" VARCHAR(75 BYTE) NOT NULL,
  9   "PARENT_ITEM_ID" VARCHAR(75 BYTE),
 10   "ITEM_STATUS" NUMBER(38) NOT NULL
 11 );

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "PBI_RND_EDITION";

Succeed.

SQL> CREATE TABLE "PBI_RND_EDITION"
  2 (
  3   "RND_EDITION_ID" NUMBER(20) NOT NULL,
  4   "EDITION_ID" NUMBER(20),
  5   "PARENT_ID" NUMBER(20),
  6   "NO" VARCHAR(45 BYTE) NOT NULL,
  7   "EDITION_CODE" VARCHAR(75 BYTE),
  8   "CATEGORY" VARCHAR(30 BYTE) NOT NULL,
  9   "STATUS" NUMBER(1) NOT NULL,
 10   "OFFERING_NAME" VARCHAR(768 BYTE),
 11   "ALIAS" VARCHAR(768 BYTE),
 12   "OLD_NO" VARCHAR(150 BYTE),
 13   "VERSION" VARCHAR(15 BYTE) NOT NULL,
 14   "CREATED_BY" VARCHAR(768 BYTE),
 15   "CREATION_DATE" DATE,
 16   "LAST_UPDATED_BY" VARCHAR(768 BYTE),
 17   "LAST_UPDATE_DATE" DATE,
 18   "SPLIMIT" NUMBER(1),
 19   "SPNUM" NUMBER(5),
 20   "RESERVE11" VARCHAR(375 BYTE),
 21   "RESERVE12" VARCHAR(375 BYTE),
 22   "RESERVE13" VARCHAR(375 BYTE),
 23   "RESERVE14" VARCHAR(375 BYTE),
 24   "RESERVE15" VARCHAR(375 BYTE)
 25 );

Succeed.

SQL> ALTER TABLE "PBI_RND_EDITION" ADD CONSTRAINT "PK_RND_EDITION_ID" PRIMARY KEY("RND_EDITION_ID");

Succeed.

SQL> explain SELECT *
  2   FROM (SELECT ROWNUM rn, t.*
  3           FROM (SELECT *
  4                   FROM (SELECT C.RND_EDITION_ID AS ENTITY_ID,
  5                                C.RND_EDITION_ID,
  6                                C.EDITION_ID,
  7                                (CASE
  8                                  WHEN (SELECT T.CATEGORY
  9                                          FROM PBI_EDITION_OD T
 10                                         WHERE T.EDITION_ID = C.EDITION_ID) =
 11                                       '402-00023814' THEN
 12                                   (SELECT T.PARENT_ID
 13                                      FROM PBI_EDITION_OD T
 14                                     WHERE T.EDITION_ID = C.EDITION_ID)
 15                                  ELSE
 16                                   C.EDITION_ID
 17                                END) AS PARENT_ID,
 18                                C.NO,
 19                                C.CATEGORY,
 20                                C.ALIAS,
 21                                C.EDITION_CODE,
 22                                C.ALIAS AS CN,
 23                                C.ALIAS AS EN,
 24                                (SELECT item_name
 25                                   FROM hwf_dd_item
 26                                  WHERE C.category = item_id) AS categoryName,
 27                                C.STATUS,
 28                                C.OFFERING_NAME,
 29                                C.OLD_NO AS VERSION,
 30                                C.SPLIMIT,
 31                                C.SPNUM,
 32                                C.RESERVE11,
 33                                C.RESERVE12,
 34                                C.RESERVE13,
 35                                C.RESERVE14,
 36                                C.RESERVE15,
 37                                C.CREATED_BY,
 38                                C.CREATION_DATE,
 39                                C.LAST_UPDATED_BY,
 40                                C.LAST_UPDATE_DATE AS last_update_date
 41                           FROM (SELECT RND_EDITION_ID,
 42                                        EDITION_ID,
 43                                        PARENT_ID,
 44                                        NO,
 45                                        EDITION_CODE,
 46                                        CATEGORY,
 47                                        STATUS,
 48                                        OFFERING_NAME,
 49                                        ALIAS,
 50                                        OLD_NO,
 51                                        VERSION,
 52                                        CREATED_BY,
 53                                        CREATION_DATE,
 54                                        LAST_UPDATED_BY,
 55                                        LAST_UPDATE_DATE,
 56                                        SPLIMIT,
 57                                        SPNUM,
 58                                        RESERVE11,
 59                                        RESERVE12,
 60                                        RESERVE13,
 61                                        RESERVE14,
 62                                        RESERVE15
 63                                   FROM PBI_RND_EDITION BL) C
 64                          WHERE 1 = 1
 65                            AND C.status = '1') C
 66                  WHERE 1 = 1
 67                  ORDER BY entity_id) t
 68          WHERE ROWNUM <= 10)
 69  WHERE rn >= 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                    |      |      |       |        |
| 1   |   SUBSELECT                            |       |                    |      |      |       |        |
| 2   |     ROWNUM FILTER                      |       |                    |      |      |       |        |
| 3   |       SUBSELECT                        |       | T                  |      |      |       |        |
| 4   |         TABLE ACCESS FULL              | SYS   | PBI_EDITION_OD T   |      |      |       |        |
| 5   |         TABLE ACCESS FULL              | SYS   | PBI_EDITION_OD T   |      |      |       |        |
| 6   |         TABLE ACCESS FULL              | SYS   | HWF_DD_ITEM        |      |      |       |        |
| 7   |         SUBSELECT                      |       | C                  |      |      |       |        |
| 8   |           TABLE ACCESS BY INDEX ROWID  | SYS   | PBI_RND_EDITION BL |      |      |       |        |
| 9   |             INDEX FULL SCAN            | SYS   | PK_RND_EDITION_ID  |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: RN >= 1                                          
   2 - filter: ROWNUM <= 10                                     
   4 - filter: T.EDITION_ID = C.EDITION_ID                      
   5 - filter: T.EDITION_ID = C.EDITION_ID                      
   6 - filter: ITEM_ID = C.CATEGORY                             
   8 - filter: BL.STATUS = 1                                    

22 rows fetched.

SQL> DROP TABLE IF EXISTS "PBI_EDITION_OD";

Succeed.

SQL> DROP TABLE IF EXISTS "HWF_DD_ITEM";

Succeed.

SQL> DROP TABLE IF EXISTS "PBI_RND_EDITION";

Succeed.

SQL> ---DTS2020022716448
SQL> DROP TABLE IF EXISTS T_ORDER_BY_PUSHODWN;

Succeed.

SQL> CREATE TABLE T_ORDER_BY_PUSHODWN(
  2 	I_INT INT,
  3 	V_VARCHAR VARCHAR(20),
  4 	BOOL BOOLEAN,
  5 	D_DECIMAL DECIMAL,
  6 	V_CHAR  CHAR(10),
  7 	B_BINARY BINARY(10),
  8 	D_DATETIME DATETIME,
  9 	T_INTERVAL interval day(7) to second,
 10 	ARRAY_LIST INT[]	
 11 );

Succeed.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(1,'AA',TRUE,12.3,'王五','101010','2020-01-01 17:18:18','-1234 0:0:0.0004','{1,2,3}');

1 rows affected.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(2,'BB',FALSE,12.4,'张天','010101','2021-01-01 17:18:18','-1234 0:0:0.0004','{1,2,3}');

1 rows affected.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(3,'CC',0,12.5,'张三','010101','2020-01-01 17:18:18','-1234 0:0:0.0004','{1,2}');

1 rows affected.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(4,'DD',1,12.4,'李四','010101','2021-01-01 17:18:18','-1234 0:0:0.0004','{1,2,3}');

1 rows affected.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(5,'AA',TRUE,1.3,'王五','101010','2020-01-01 17:18:18','-1234 0:0:0.0004','{1,2,3}');

1 rows affected.

SQL> INSERT INTO T_ORDER_BY_PUSHODWN VALUES(6,'DD',FALSE,12.40,'六六','101010','2021-01-01 17:18:18','-1234 0:0:0.0004','{1,2}');

1 rows affected.

SQL> commit;

Succeed.

SQL> explain select case when D_DECIMAL>2 then D_DECIMAL else I_INT+5 end,case when I_INT>2 then I_INT else I_INT+5 end from (select distinct I_INT,D_DECIMAL from T_ORDER_BY_PUSHODWN) order by case when D_DECIMAL>2 then D_DECIMAL else I_INT+5 end;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                     |      |      |       |        |
| 1   |   SUBSELECT                |       |                     |      |      |       |        |
| 2   |     QUERY SORT ORDER BY    |       |                     |      |      |       |        |
| 3   |       HASH DISTINCT        |       |                     |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_ORDER_BY_PUSHODWN |      |      |       |        |
-------------------------------------------------------------------------------------------------

9 rows fetched.

SQL> select case when D_DECIMAL>2 then D_DECIMAL else I_INT+5 end,case when I_INT>2 then I_INT else I_INT+5 end from (select distinct I_INT,D_DECIMAL from T_ORDER_BY_PUSHODWN) order by case when D_DECIMAL>2 then D_DECIMAL else I_INT+5 end;

CASE WHEN D_DECIMAL>2 THEN D_DECIMAL ELSE I_INT+5 END CASE WHEN I_INT>2 THEN I_INT ELSE I_INT+5 END
----------------------------------------------------- ---------------------------------------------
10                                                    5                                            
12.3                                                  6                                            
12.4                                                  7                                            
12.4                                                  4                                            
12.4                                                  6                                            
12.5                                                  3                                            

6 rows fetched.

SQL> explain select I_INT from (select I_INT, V_VARCHAR, D_DECIMAL FROM T_ORDER_BY_PUSHODWN connect by nocycle prior I_INT+1=I_INT) WHERE D_DECIMAL > 2 ORDER BY I_INT;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name                | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                     |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |                     |      |      |       |        |
| 2   |     SUBSELECT                |       |                     |      |      |       |        |
| 3   |       CONNECT BY MATERIALIZE |       |                     |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_ORDER_BY_PUSHODWN |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: D_DECIMAL > 2
   3 - access: PRIOR I_INT + 1 = I_INT

13 rows fetched.

SQL> explain select I_INT from (select I_INT, V_VARCHAR FROM T_ORDER_BY_PUSHODWN connect by nocycle prior I_INT+1=I_INT)  HAVING 1 =2  ORDER BY I_INT;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                     |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |                     |      |      |       |        |
| 2   |     HAVING                     |       |                     |      |      |       |        |
| 3   |       SUBSELECT                |       |                     |      |      |       |        |
| 4   |         CONNECT BY MATERIALIZE |       |                     |      |      |       |        |
| 5   |           TABLE ACCESS FULL    | SYS   | T_ORDER_BY_PUSHODWN |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: NULL IS NOT NULL
   4 - access: PRIOR I_INT + 1 = I_INT

14 rows fetched.

SQL> DROP TABLE IF EXISTS T_ORDER_BY_PUSHODWN;

Succeed.

SQL> 

SQL> --basic
SQL> drop table if exists t_subselect_rs_001;

Succeed.

SQL> create table t_subselect_rs_001(f1 int);

Succeed.

SQL> insert into t_subselect_rs_001 values(1),(2000);

2 rows affected.

SQL> commit;

Succeed.

SQL> select f1,(select dummy||sleep(f1) from dual) from t_subselect_rs_001 order by f1 limit 1;

F1           (SELECT DUMMY||SLEEP(F1) FROM DUAL)
------------ -----------------------------------
1            X

1 rows fetched.

SQL> drop table if exists t_subselect_rs_003;

Succeed.

SQL> create table t_subselect_rs_003(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10) not null,c_vchar2 varchar2(100),c_clob clob,
  4 c_long varchar(200),c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> insert into t_subselect_rs_003 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),
  2 lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-03-05 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));


1 rows affected.

SQL> insert into t_subselect_rs_003 values(-1,null,null,null,null,null,null,'M',null,null,null,null,null,null,null);

1 rows affected.

SQL> CREATE or replace procedure proc_insert(tname varchar,startall int,endall int) as
  2 sqlst varchar(500);
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5                 sqlst := 'insert into ' || tname ||' select id+'||i||',c_int+'||i||',c_real+'||i||',c_float+'||i||',c_decimal+'||i||',c_number+'||i||',c_char'||',c_vchar||'||i||',c_vchar2||'||i||',c_clob||'||i||',c_long||'||i||',c_blob'||',c_raw,ADD_MONTHS(c_date,'||i||'),ADD_MONTHS(c_timestamp,'||i||') from '||tname|| ' where id=1';
  6         execute immediate sqlst;
  7   END LOOP;
  8 END;
  9 /

Succeed.

SQL> call proc_insert('t_subselect_rs_003',1,66);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> drop table if exists t_subselect_rs_004;

Succeed.

SQL> drop table if exists t_subselect_rs_005;

Succeed.

SQL> drop table if exists t_subselect_rs_006;

Succeed.

SQL> create table t_subselect_rs_004(t4_f1 int, t4_f2 int, t4_f3 int);

Succeed.

SQL> create table t_subselect_rs_005(t5_f1 int, t5_f2 int, t5_f3 int);

Succeed.

SQL> create table t_subselect_rs_006(t6_f1 int, t6_f2 int, t6_f3 int);

Succeed.

SQL> CREATE or replace procedure proc_insert2(tname varchar,startall int,endall int) as
  2 sqlst varchar(500);
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5                 sqlst := 'insert into ' || tname ||' values('|| i ||',' || i || '+1,' || i||'+2)';
  6         execute immediate sqlst;
  7   END LOOP;
  8 END;
  9 /

Succeed.

SQL> call proc_insert2('t_subselect_rs_004',1,200);

PL/SQL procedure successfully completed.

SQL> call proc_insert2('t_subselect_rs_005',1,200);

PL/SQL procedure successfully completed.

SQL> call proc_insert2('t_subselect_rs_006',1,200);

PL/SQL procedure successfully completed.

SQL> create index idx_t4_002 on t_subselect_rs_004(t4_f2);

Succeed.

SQL> create index idx_t5_003 on t_subselect_rs_005(t5_f3);

Succeed.

SQL> create index idx_t6_002 on t_subselect_rs_006(t6_f2);

Succeed.

SQL> --mtrl datatype
SQL> drop table if exists t_subselect_rs_002;

Succeed.

SQL> CREATE TABLE  t_subselect_rs_002(
  2      COL_1 int,
  3      COL_2 integer,
  4      COL_3 bigint,
  5      COL_4 real,
  6      COL_5 double,
  7      COL_6 float,
  8      COL_7 decimal(12,6),
  9      COL_8 number,
 10      COL_9 numeric,
 11      COL_10 char(30),
 12      COL_11 varchar(30),
 13      COL_12 varchar2(30),
 14      COL_13 image,
 15      COL_14 date,
 16      COL_15 datetime,
 17      COL_16 timestamp,
 18      COL_17 timestamp with time zone,
 19      COL_18 timestamp with local time zone,
 20      COL_19 bool,
 21      COL_20 boolean,
 22      COL_21 interval year to month,
 23      COL_22 interval day to second,
 24      col_23 blob,
 25      col_24 clob
 26 );

Succeed.

SQL> begin
  2     for i in 1..10 loop
  3       insert into t_subselect_rs_002 values(
  4       i,
  5       i+1,
  6       i+2,
  7       i+3.1415926,
  8       i+445.255,
  9       3.1415926-i*2,
 10       98*0.99*i,
 11       99*1.01*i,
 12       -98*0.99*i,
 13       lpad('abc','10','@'),
 14       lpad('abc','10','b'),
 15       rpad('abc','10','e'),
 16       '1111111111',
 17       TIMESTAMPADD(SECOND,i,'2018-11-03 14:14:12'),
 18       TIMESTAMPADD(MINUTE,i,'2019-01-03 14:14:12'),
 19       to_timestamp('2019-01-03 14:58:54.000000','YYYY-MM-DD HH24:MI:SS.FFFFFF'),
 20       TIMESTAMPADD(HOUR,i,'2019-01-03 14:14:12'),
 21       TIMESTAMPADD(DAY,i,'2019-08-17 15:36:00'),
 22       true,
 23       false,
 24       (INTERVAL '99-02' YEAR TO MONTH),
 25       (INTERVAL '4 5:12:10.222' DAY TO SECOND(3)),
 26       lpad('123abc',50,'abc'),
 27       lpad('11100001',50,'1100')
 28       );
 29       commit;
 30     end loop;
 31 end;
 32 /

PL/SQL procedure successfully completed.

SQL> select (select COL_1||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_1||DUMMY FROM DUAL)
-------------------------------
1X
2X

2 rows fetched.

SQL> select (select COL_2||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_2||DUMMY FROM DUAL)
-------------------------------
2X
3X

2 rows fetched.

SQL> select (select COL_3||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_3||DUMMY FROM DUAL)
-------------------------------
3X
4X

2 rows fetched.

SQL> select (select COL_4||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_4||DUMMY FROM DUAL)
-------------------------------
4.1415926X
5.1415926X

2 rows fetched.

SQL> select (select COL_5||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_5||DUMMY FROM DUAL)
-------------------------------
446.255X
447.255X

2 rows fetched.

SQL> select (select COL_6||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_6||DUMMY FROM DUAL)
-------------------------------
1.1415926X
-0.8584074X

2 rows fetched.

SQL> select (select COL_7||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_7||DUMMY FROM DUAL)
----------------------------------------------------------------
97.02X
194.04X

2 rows fetched.

SQL> select (select COL_8||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_8||DUMMY FROM DUAL)
----------------------------------------------------------------
99.99X
199.98X

2 rows fetched.

SQL> select (select COL_9||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_9||DUMMY FROM DUAL)
----------------------------------------------------------------
-97.02X
-194.04X

2 rows fetched.

SQL> select (select COL_10||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_10||DUMMY FROM DUAL)
--------------------------------
@@@@@@@abc                    X
@@@@@@@abc                    X

2 rows fetched.

SQL> select (select COL_11||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_11||DUMMY FROM DUAL)
--------------------------------
bbbbbbbabcX
bbbbbbbabcX

2 rows fetched.

SQL> select (select COL_12||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_12||DUMMY FROM DUAL)
--------------------------------
abceeeeeeeX
abceeeeeeeX

2 rows fetched.

SQL> select (select COL_13 from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_13 FROM DUAL)
----------------------------------------------------------------
1111111111
1111111111

2 rows fetched.

SQL> select (select COL_14||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_14||DUMMY FROM DUAL)
-------------------------------------------------
2018-11-03 14:14:13X
2018-11-03 14:14:14X

2 rows fetched.

SQL> select (select COL_15||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_15||DUMMY FROM DUAL)
-------------------------------------------------
2019-01-03 14:15:12X
2019-01-03 14:16:12X

2 rows fetched.

SQL> select (select COL_16||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_16||DUMMY FROM DUAL)
-------------------------------------------------
2019-01-03 14:58:54.000000X
2019-01-03 14:58:54.000000X

2 rows fetched.

SQL> select (select COL_17||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_17||DUMMY FROM DUAL)
-------------------------------------------------
2019-01-03 15:14:12.000000 +08:00X
2019-01-03 16:14:12.000000 +08:00X

2 rows fetched.

SQL> select (select COL_18||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_18||DUMMY FROM DUAL)
-------------------------------------------------
2019-08-18 15:36:00.000000X
2019-08-19 15:36:00.000000X

2 rows fetched.

SQL> select (select COL_19||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_19||DUMMY FROM DUAL)
--------------------------------
TRUEX
TRUEX

2 rows fetched.

SQL> select (select COL_20||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_20||DUMMY FROM DUAL)
--------------------------------
FALSEX
FALSEX

2 rows fetched.

SQL> select (select COL_21||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_21||DUMMY FROM DUAL)
--------------------------------
+99-02X
+99-02X

2 rows fetched.

SQL> select (select COL_22||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_22||DUMMY FROM DUAL)
--------------------------------
+04 05:12:10.222000X
+04 05:12:10.222000X

2 rows fetched.

SQL> select (select COL_23 from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_23 FROM DUAL)
----------------------------------------------------------------
ABCABCABCABCABCABCABCABCABCABCABCABCABCABCAB123ABC
ABCABCABCABCABCABCABCABCABCABCABCABCABCABCAB123ABC

2 rows fetched.

SQL> select (select COL_24||dummy from dual) from t_subselect_rs_002 order by COL_1 limit 2;

(SELECT COL_24||DUMMY FROM DUAL)
----------------------------------------------------------------
11001100110011001100110011001100110011001111100001X
11001100110011001100110011001100110011001111100001X

2 rows fetched.

SQL> --rowid
SQL> select (select t6_f1 from t_subselect_rs_005 where t5_f1 < t6.rowid limit 1) from t_subselect_rs_006 t6 order by t6_f1 limit 2;

(SELECT T6_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6.ROWID LIM
----------------------------------------------------------------
1
2

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6.rowid limit 1) from t_subselect_rs_006 t6 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6.ROWID LIM
----------------------------------------------------------------
1
1

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6.rowid and t5_f1 = t6.t6_f1) from t_subselect_rs_006 t6 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6.ROWID AND
----------------------------------------------------------------
1
2

2 rows fetched.

SQL> --group by + aggr
SQL> select (select t6_f1 from dual) from t_subselect_rs_006 group by t6_f1 order by 1 limit 2;

(SELECT T6_F1 FROM DUAL)
------------------------
1
2

2 rows fetched.

SQL> select t6_f1,(select t6_f2||t6_f1||dummy from dual) from t_subselect_rs_006 group by t6_f1,t6_f2 order by 1 limit 6;

T6_F1        (SELECT T6_F2||T6_F1||DUMMY FROM DUAL)
------------ --------------------------------------
1            21X
2            32X
3            43X
4            54X
5            65X
6            76X

6 rows fetched.

SQL> select t6_f1,GROUP_CONCAT(t6_f2),(select t6_f1 from dual) from t_subselect_rs_006 group by t6_f1 order by 1 limit 6;

T6_F1        GROUP_CONCAT(T6_F2)                                              (SELECT T6_F1 FROM DUAL)
------------ ---------------------------------------------------------------- ------------------------
1            2                                                                1
2            3                                                                2
3            4                                                                3
4            5                                                                4
5            6                                                                5
6            7                                                                6

6 rows fetched.

SQL> select t6_f1,(select GROUP_CONCAT(dummy)||t6_f1||dummy from dual) from t_subselect_rs_006 group by t6_f1,t6_f2 order by t6_f1 limit 6;

CT-00609, Expression not in group list
SQL> select GROUP_CONCAT(t6_f2),(select GROUP_CONCAT(t6_f2)||t6_f1||dummy from dual) from t_subselect_rs_006 group by t6_f1,t6_f2 order by t6_f1 limit 6;

CT-00609, Expression not in group list
SQL> select (select median(t4_f1) from dual) from t_subselect_rs_004 order by t4_f2 limit 6;

(SELECT MEDIAN(T4_F1) FROM DUAL)
----------------------------------------
1
2
3
4
5
6

6 rows fetched.

SQL> select (select median(avg(t4_f1)) from dual) from t_subselect_rs_004 order by t4_f2 limit 6;

CT-01317, [1:23]Unexpected aggregation 'AVG'
SQL> --order by
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6.rowid order by t5_f1 desc limit 1) from t_subselect_rs_006 t6 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6.ROWID ORD
----------------------------------------------------------------
200
200

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6.rowid order by t5_f1 asc limit 1) from t_subselect_rs_006 t6 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6.ROWID ORD
----------------------------------------------------------------
1
1

2 rows fetched.

SQL> --limit
SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5  order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
6
7
8
9
10
11

10 rows fetched.

SQL> --join
SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
6
7
8
9
10
11

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 > t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
5
6
6
6
7
7

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 or t4_f2=t6_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 > t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 OR T4_F2
----------------------------------------------------------------
2
3
2
2
3
2
3
4
2
3

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 or t4_f2=t6_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 inner join t_subselect_rs_003 t3 on
  2 t5.t5_f1!=t3.c_int order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 OR T4_F2
----------------------------------------------------------------
2
2
2
2
2
2
2
2
2
2

10 rows fetched.

SQL> --connect by
SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from (select * from t_subselect_rs_005) t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 start with
  2 t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
6
7
8
9
10
11

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from (select * from t_subselect_rs_005) t5 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 start with
  2 t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
3
4
5
6
7
8
9
10
11

9 rows fetched.

SQL> select /*+rule*/ (select sys_connect_by_path(t4_f2||t5_f3,'/') from t_subselect_rs_004 start with t4_f2=t5_f3 connect by prior t4_f2 + 1 = t4_f2 limit 1) from (select * from t_subselect_rs_005) t5
  2 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 start with t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 10;

(SELECT SYS_CONNECT_BY_PATH(T4_F2||T5_F3,'/') FROM T_SUBSELECT_R
----------------------------------------------------------------
/44
/55
/66
/77
/88
/99
/1010
/1111
/1212

9 rows fetched.

SQL> select /*+rule*/ (select sys_connect_by_path(t4_f2||t5_f3,'/') from t_subselect_rs_004 start with t4_f2=t5_f3 connect by prior t4_f2 + 1 = t4_f2 limit 1) from (select * from t_subselect_rs_005) t5
  2 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2  order by t5.t5_f1 limit 10;

(SELECT SYS_CONNECT_BY_PATH(T4_F2||T5_F3,'/') FROM T_SUBSELECT_R
----------------------------------------------------------------
/44
/55
/66
/77
/88
/99
/1010
/1111
/1212
/1313

10 rows fetched.

SQL> select /*+rule*/ (select t4_f2 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1),sys_connect_by_path(t5_f3,'/') from (select * from t_subselect_rs_005) t5 inner join t_subselect_rs_006 t6
  2 on t5.t5_f1 = t6.t6_f2 start with t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 10;

(SELECT T4_F2 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1) SYS_CONNECT_BY_PATH(T5_F3,'/')
---------------------------------------------------------------- ----------------------------------------------------------------
4                                                                /12/11/10/9/8/7/6/5/4
5                                                                /12/11/10/9/8/7/6/5
6                                                                /12/11/10/9/8/7/6
7                                                                /12/11/10/9/8/7
8                                                                /12/11/10/9/8
9                                                                /12/11/10/9
10                                                               /12/11/10
11                                                               /12/11
12                                                               /12

9 rows fetched.

SQL> select /*+rule*/ (select sys_connect_by_path(t4_f2||t5_f3,'/') from t_subselect_rs_004 start with t4_f2=t5_f3 connect by prior t4_f2 + 1 = t4_f2 limit 1) from (select * from t_subselect_rs_005) t5
  2 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 start with t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order siblings by t5.t5_f1 limit 10;

(SELECT SYS_CONNECT_BY_PATH(T4_F2||T5_F3,'/') FROM T_SUBSELECT_R
----------------------------------------------------------------
/1212
/1111
/1010
/99
/88
/77
/66
/55
/44

9 rows fetched.

SQL> select /*+rule*/ (select t4_f2 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1),sys_connect_by_path(t5_f3,'/') from (select * from t_subselect_rs_005) t5 inner join t_subselect_rs_006 t6
  2 on t5.t5_f1 = t6.t6_f2 start with t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order siblings by t5.t5_f1 limit 10;

(SELECT T4_F2 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1) SYS_CONNECT_BY_PATH(T5_F3,'/')
---------------------------------------------------------------- ----------------------------------------------------------------
12                                                               /12
11                                                               /12/11
10                                                               /12/11/10
9                                                                /12/11/10/9
8                                                                /12/11/10/9/8
7                                                                /12/11/10/9/8/7
6                                                                /12/11/10/9/8/7/6
5                                                                /12/11/10/9/8/7/6/5
4                                                                /12/11/10/9/8/7/6/5/4

9 rows fetched.

SQL> --array
SQL> select (select sys_connect_by_path(c_char, '/') from t_subselect_rs_003 t3 start with t3.id = t5.t5_f1 connect by prior id+1=id limit 1) from t_subselect_rs_005 t5 order by t5_f1 limit 10;

(SELECT SYS_CONNECT_BY_PATH(C_CHAR, '/') FROM T_SUBSELECT_RS_003
----------------------------------------------------------------
/abc123
/abc123
/abc123
/abc123
/abc123
/abc123
/abc123
/abc123
/abc123
/abc123

10 rows fetched.

SQL> select (select array_length(array_agg(sys_connect_by_path(c_char, '/'))) from t_subselect_rs_003 t3 start with t3.id = t5.t5_f1 connect by prior id+1=id group by c_char limit 1) from
  2 t_subselect_rs_005 t5 order by t5_f1 limit 10;

(SELECT ARRAY_LENGTH(ARRAY_AGG(SYS_CONNECT_BY_PATH(C_CHAR, '/'))
----------------------------------------------------------------
67
66
65
64
63
62
61
60
59
58

10 rows fetched.

SQL> select (select array_length(array_agg(sys_connect_by_path(t5.t5_f1, '/'))) from t_subselect_rs_003 t3 start with t3.id = t5.t5_f1 connect by prior id+1=id group by c_char limit 1) from
  2 t_subselect_rs_005 t5 order by t5_f1 limit 10;

(SELECT ARRAY_LENGTH(ARRAY_AGG(SYS_CONNECT_BY_PATH(T5.T5_F1, '/'
----------------------------------------------------------------
67
66
65
64
63
62
61
60
59
58

10 rows fetched.

SQL> --rs subselect + order by const
SQL> select (select c_int from t_subselect_rs_003 where c_int!=t4_f1 order by 1 limit 1) from t_subselect_rs_004 order by t4_f1 limit 10;

(SELECT C_INT FROM T_SUBSELECT_RS_003 WHERE C_INT!=T4_F1 ORDER B
----------------------------------------------------------------
1000
1000
1000
1000
1000
1000
1000
1000
1000
1000

10 rows fetched.

SQL> select (select c_char from t_subselect_rs_003 where c_int!=t4_f1 order by 1 limit 1) from t_subselect_rs_004 order by t4_f1 limit 10;

(SELECT C_CHAR FROM T_SUBSELECT_RS_003 WHERE C_INT!=T4_F1 ORDER
----------------------------------------------------------------
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123

10 rows fetched.

SQL> select (select c_char from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1) from t_subselect_rs_004 order by 1 limit 10;

(SELECT C_CHAR FROM T_SUBSELECT_RS_003 WHERE ID=T4_F1 ORDER BY 1
----------------------------------------------------------------
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123

10 rows fetched.

SQL> select (select c_char from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1) from t_subselect_rs_004 group by t4_f1 order by 1 limit 10;

(SELECT C_CHAR FROM T_SUBSELECT_RS_003 WHERE ID=T4_F1 ORDER BY 1
----------------------------------------------------------------
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123

10 rows fetched.

SQL> --select sort
SQL> select (select c_char||id from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1) from t_subselect_rs_004 union all select (select c_char from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1)
  2 from t_subselect_rs_004 order by 1 limit 10;

(SELECT C_CHAR||ID FROM T_SUBSELECT_RS_003 WHERE ID=T4_F1 ORDER
----------------------------------------------------------------
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123

10 rows fetched.

SQL> select (select c_char||id from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1) from t_subselect_rs_004 union all select (select c_char from t_subselect_rs_003 where id=t4_f1 order by 1 limit 1)
  2 from t_subselect_rs_004 order by 1 limit 10;

(SELECT C_CHAR||ID FROM T_SUBSELECT_RS_003 WHERE ID=T4_F1 ORDER
----------------------------------------------------------------
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123
abc123

10 rows fetched.

SQL> --where
SQL> select (select t4_f1 from t_subselect_rs_004 where t4_f2=a.t5_f3 limit 1) from (select (select t5_f3 from t_subselect_rs_005 where t5_f3 = t6_f2 limit 1)t5_f3,t6_f2 from
  2 (select t6_f2,t6_f3 from t_subselect_rs_006) where t6_f2 = 66 order by t6_f3 desc)a;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=A.T5_F3 LIMIT
----------------------------------------------------------------
65

1 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
6
7
8
9
10
11

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 > t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
5
6
6
6
7
7

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 > t6.t6_f2 order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3
4
5
5
6
6
6
7
7

10 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 inner join t_subselect_rs_003 t3 on
  2 t5.t5_f1!=t3.c_int order by t5.t5_f1 limit 10;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
2
2
2
2
2
2
2
2
2

10 rows fetched.

SQL> --explain
SQL> explain select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from (select * from t_subselect_rs_005) t5 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2
  2 start with t5.t5_f1 = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name                  | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                       |      |      |       |        |
| 1   |   QUERY LIMIT                         |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID       | SYS   | T_SUBSELECT_RS_004    |      |      |       |        |
| 3   |       INDEX RANGE SCAN                | SYS   | IDX_T4_002            |      |      |       |        |
| 4   |   QUERY LIMIT                         |       |                       |      |      |       |        |
| 5   |     QUERY SORT ORDER BY ROWNUM        |       |                       |      |      |       |        |
| 6   |       CONNECT BY MATERIALIZE          |       |                       |      |      |       |        |
| 7   |         NESTED LOOPS                  |       |                       |      |      |       |        |
| 8   |           SUBSELECT                   |       | T5                    |      |      |       |        |
| 9   |             TABLE ACCESS FULL         | SYS   | T_SUBSELECT_RS_005    |      |      |       |        |
| 10  |           TABLE ACCESS BY INDEX ONLY  | SYS   | T_SUBSELECT_RS_006 T6 |      |      |       |        |
| 11  |             INDEX RANGE SCAN          | SYS   | IDX_T6_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T4_F2 = T5_F3                                    
   6 - access: PRIOR T5.T5_F1 = T5.T5_F1 + 1                    
       filter: T5.T5_F1 = 10                                    
   11 - access: T5.T5_F1 = T6.T6_F2                             

22 rows fetched.

SQL> explain select /*+use_hash*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from (select * from t_subselect_rs_005) t5 inner join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2
  2 order by t5.t5_f1 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name                  | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |                       |      |      |       |        |
| 1   |   QUERY LIMIT                       |       |                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID     | SYS   | T_SUBSELECT_RS_004    |      |      |       |        |
| 3   |       INDEX RANGE SCAN              | SYS   | IDX_T4_002            |      |      |       |        |
| 4   |   QUERY LIMIT                       |       |                       |      |      |       |        |
| 5   |     QUERY SORT ORDER BY ROWNUM      |       |                       |      |      |       |        |
| 6   |       NESTED LOOPS                  |       |                       |      |      |       |        |
| 7   |         SUBSELECT                   |       | T5                    |      |      |       |        |
| 8   |           TABLE ACCESS FULL         | SYS   | T_SUBSELECT_RS_005    |      |      |       |        |
| 9   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_SUBSELECT_RS_006 T6 |      |      |       |        |
| 10  |           INDEX RANGE SCAN          | SYS   | IDX_T6_002            |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T4_F2 = T5_F3                                    
   10 - access: T5.T5_F1 = T6.T6_F2                             

19 rows fetched.

SQL> --winsort
SQL> select (select sum(t4_f1) over (partition by t4_f2 order by t4_f3) from t_subselect_rs_004 where t4_f1 = t5_f1 limit 1) from t_subselect_rs_005 order by t5_f1 limit 10;

(SELECT SUM(T4_F1) OVER (PARTITION BY T4_F2 ORDER BY T4_F3) FROM
----------------------------------------------------------------
1
2
3
4
5
6
7
8
9
10

10 rows fetched.

SQL> select (select t4_f1 from t_subselect_rs_004 where t4_f1 = t5_f1 limit 1),sum(t5_f1) over (partition by t5_f2 order by t5_f3) from t_subselect_rs_005 order by t5_f1 limit 2;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F1 = T5_F1 LIMIT  SUM(T5_F1) OVER (PARTITION BY T5_F2 ORDER BY T5_F3)
---------------------------------------------------------------- ---------------------------------------------------
1                                                                1
2                                                                2

2 rows fetched.

SQL> --winsort + within group
SQL> select listagg(t4_f1,dummy) within group (order by t4_f2) over (partition by t4_f2),(select t5_f1 from t_subselect_rs_005 where t5_f1=t4_f1 limit 1) from t_subselect_rs_004,dual limit 2;

LISTAGG(T4_F1,DUMMY) WITHIN GROUP (ORDER BY T4_F2) OVER (PARTITI (SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1=T4_F1 LIMIT 1)
---------------------------------------------------------------- ----------------------------------------------------------------
1                                                                1
2                                                                2

2 rows fetched.

SQL> select listagg(t4_f1,dummy) within group (order by t4_f2) over (partition by t4_f2),(select listagg(t4_f1,dummy) within group (order by t4_f2) over (partition by t4_f2) from t_subselect_rs_005
  2 where t5_f1=t4_f1 limit 1) from t_subselect_rs_004,dual limit 2;

LISTAGG(T4_F1,DUMMY) WITHIN GROUP (ORDER BY T4_F2) OVER (PARTITI (SELECT LISTAGG(T4_F1,DUMMY) WITHIN GROUP (ORDER BY T4_F2) OVER
---------------------------------------------------------------- ----------------------------------------------------------------
1                                                                1
2                                                                2

2 rows fetched.

SQL> --case
SQL> select (select case when t4_f1 > t5_f1 then t4_f1-t5_f1 else t5_f1-t4_f1 end from t_subselect_rs_004 where t4_f1 = 66) from t_subselect_rs_005 order by t5_f1 limit 10;

(SELECT CASE WHEN T4_F1 > T5_F1 THEN T4_F1-T5_F1 ELSE T5_F1-T4_F
----------------------------------------------------------------
65
64
63
62
61
60
59
58
57
56

10 rows fetched.

SQL> select (select case when t4_f1 > t5_f1 then t4_f1-t5_f1 else t5_f1-t4_f1 end from t_subselect_rs_004 where t4_f1 = 66),sum(t5_f1) over (partition by t5_f2 order by t5_f3) from t_subselect_rs_005
  2 where case when t5_f1 + t5_f2 > t5_f3 then 1 else 0 end > 0 order by t5_f1 limit 10;

(SELECT CASE WHEN T4_F1 > T5_F1 THEN T4_F1-T5_F1 ELSE T5_F1-T4_F SUM(T5_F1) OVER (PARTITION BY T5_F2 ORDER BY T5_F3)
---------------------------------------------------------------- ---------------------------------------------------
64                                                               2
63                                                               3
62                                                               4
61                                                               5
60                                                               6
59                                                               7
58                                                               8
57                                                               9
56                                                               10
55                                                               11

10 rows fetched.

SQL> select sum(t5_f1) over (partition by t5_f2 order by case when t5_f1 + t5_f2 > t5_f3 then 1 else 0 end) from t_subselect_rs_005 order by t5_f1 limit 10;

SUM(T5_F1) OVER (PARTITION BY T5_F2 ORDER BY CASE WHEN T5_F1 + T
----------------------------------------------------------------
1
2
3
4
5
6
7
8
9
10

10 rows fetched.

SQL> select (select sum(t4_f1) over (partition by t4_f2 order by case when t5_f1 + t5_f2 > t5_f3 then 1 else 0 end) from t_subselect_rs_004 where t4_f1 = t5_f1 limit 1) from t_subselect_rs_005
  2 order by t5_f1 limit 10;

(SELECT SUM(T4_F1) OVER (PARTITION BY T4_F2 ORDER BY CASE WHEN T
----------------------------------------------------------------
1
2
3
4
5
6
7
8
9
10

10 rows fetched.

SQL> select (select sum(t4_f1) over (partition by t4_f2 order by case when t5_f1 then t5_f1 else t4_f1 end) from t_subselect_rs_004 where t4_f1 = t5_f1 limit 1) from t_subselect_rs_005 order by t5_f1 limit 10;

(SELECT SUM(T4_F1) OVER (PARTITION BY T4_F2 ORDER BY CASE WHEN T
----------------------------------------------------------------
1
2
3
4
5
6
7
8
9
10

10 rows fetched.

SQL> select (select case when t4_f1 > t5_f1 then t4_f1-t5_f1 else t5_f1-t4_f1 end from t_subselect_rs_004 where t4_f1 = 66),sum(t5_f1) over (partition by t5_f2 order by t5_f3) from t_subselect_rs_005
  2 order by case when t5_f1 then t5_f2 else  t5_f3 end  limit 10;

(SELECT CASE WHEN T4_F1 > T5_F1 THEN T4_F1-T5_F1 ELSE T5_F1-T4_F SUM(T5_F1) OVER (PARTITION BY T5_F2 ORDER BY T5_F3)
---------------------------------------------------------------- ---------------------------------------------------
65                                                               1
64                                                               2
63                                                               3
62                                                               4
61                                                               5
60                                                               6
59                                                               7
58                                                               8
57                                                               9
56                                                               10

10 rows fetched.

SQL> select case (t6_f1) when (66) then ('six') when (100) then ('hundred') else ('others') end as aaa from t_subselect_rs_006 order by aaa limit 10;

AAA
-------
hundred
others
others
others
others
others
others
others
others
others

10 rows fetched.

SQL> --others
SQL> DROP TABLE IF EXISTS t_subselect_rs_007;

Succeed.

SQL> CREATE TABLE t_subselect_rs_007(F_INT51 INT, F_INT52 INT, F_CHAR51 varCHAR(20));

Succeed.

SQL> INSERT INTO t_subselect_rs_007 VALUES(1,2,'abc');

1 rows affected.

SQL> INSERT INTO t_subselect_rs_007 VALUES(2,3,'dec');

1 rows affected.

SQL> INSERT INTO t_subselect_rs_007 VALUES(3,4,'hij');

1 rows affected.

SQL> INSERT INTO t_subselect_rs_007 VALUES(4,5,'qwe');

1 rows affected.

SQL> INSERT INTO t_subselect_rs_007 VALUES(null,6,'asd');

1 rows affected.

SQL> CREATE INDEX FUNC_INDEX_INT_T_INDEX_5 ON t_subselect_rs_007(TO_CHAR(F_INT51)) ONLINE;

CT-00130, Operation create index online is not supported on  cluster database

SQL> CREATE INDEX FUNC_INDEX_CHAR_INDEX_5 ON t_subselect_rs_007(UPPER(F_CHAR51) )ONLINE;

CT-00130, Operation create index online is not supported on  cluster database

SQL> select /*+rule*/ (select f_int51||a.f_char51 from t_subselect_rs_007 where to_char(a.f_char51) = TO_CHAR(F_CHAR51) limit 1) from t_subselect_rs_007 a
  2 where upper(F_CHAR51)='QWE' order by f_int51 limit 2;

(SELECT F_INT51||A.F_CHAR51 FROM T_SUBSELECT_RS_007 WHERE TO_CHA
----------------------------------------------------------------
4qwe

1 rows fetched.

SQL> explain select /*+rule*/ (select f_int51||a.f_char51 from t_subselect_rs_007 where to_char(a.f_char51) = TO_CHAR(F_CHAR51) limit 1) from t_subselect_rs_007 a
  2 where upper(F_CHAR51)='QWE' order by f_int51 limit 2;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                      |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |                      |      |      |       |        |
| 2   |     TABLE ACCESS FULL          | SYS   | T_SUBSELECT_RS_007   |      |      |       |        |
| 3   |   QUERY LIMIT                  |       |                      |      |      |       |        |
| 4   |     QUERY SORT ORDER BY ROWNUM |       |                      |      |      |       |        |
| 5   |       TABLE ACCESS FULL        | SYS   | T_SUBSELECT_RS_007 A |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: TO_CHAR(A.F_CHAR51) = TO_CHAR(F_CHAR51)
   5 - filter: UPPER(F_CHAR51) = 'QWE'

14 rows fetched.

SQL> --distinct
SQL> select distinct t4_f1,(select c_int from t_subselect_rs_003 where c_int!=t4_f1 order by 1 limit 1) from t_subselect_rs_004 order by 1 limit 2;

T4_F1        (SELECT C_INT FROM T_SUBSELECT_RS_003 WHERE C_INT!=T4_F1 ORDER B
------------ ----------------------------------------------------------------
1            1000
2            1000

2 rows fetched.

SQL> --having
SQL> select (select t5_f1 from t_subselect_rs_005 having t6_f1 > 1 limit 1) from t_subselect_rs_006 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 HAVING T6_F1 > 1 LIMIT 1)
---------------------------------------------------------------

1

2 rows fetched.

SQL> select (select t6_f1 from t_subselect_rs_005 limit 1) from t_subselect_rs_006 group by t6_f1 having t6_f1 > 1 order by t6_f1 limit 2;

(SELECT T6_F1 FROM T_SUBSELECT_RS_005 LIMIT 1)
----------------------------------------------
2
3

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 having t6_f1 > 1 limit 1) from t_subselect_rs_006 group by t6_f1 having t6_f1 > 6 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 HAVING T6_F1 > 1 LIMIT 1)
---------------------------------------------------------------
1
1

2 rows fetched.

SQL> --pivot+unpivot
SQL> select (select t5_f3 from t_subselect_rs_005 pivot (avg(t5_f1) for t5_f2 in(1,2)) where t5_f3 = t6_f3 limit 1) from t_subselect_rs_006 order by t6_f1 limit 2;

(SELECT T5_F3 FROM T_SUBSELECT_RS_005 PIVOT (AVG(T5_F1) FOR T5_F
----------------------------------------------------------------
3
4

2 rows fetched.

SQL> select (select t5_f3 from t_subselect_rs_005 where t5_f3 = t6_f3 limit 1) from t_subselect_rs_006 pivot (avg(t6_f2) for t6_f2 in(2,3)) order by t6_f1 limit 2;

(SELECT T5_F3 FROM T_SUBSELECT_RS_005 WHERE T5_F3 = T6_F3 LIMIT
----------------------------------------------------------------
3
4

2 rows fetched.

SQL> select (select t5_f3 from t_subselect_rs_005 pivot (avg(t5_f1) for t5_f2 in(1,2)) where t5_f3 = t6_f3 limit 1) from t_subselect_rs_006 pivot (avg(t6_f2) for t6_f2 in(2,3)) order by t6_f1 limit 2;

(SELECT T5_F3 FROM T_SUBSELECT_RS_005 PIVOT (AVG(T5_F1) FOR T5_F
----------------------------------------------------------------
3
4

2 rows fetched.

SQL> select (select aaa||t6_f1 from t_subselect_rs_005 unpivot (aaa for bbb in(t5_f1,t5_f2,t5_f3)) limit 1) from t_subselect_rs_006 order by t6_f1 limit 2;

(SELECT AAA||T6_F1 FROM T_SUBSELECT_RS_005 UNPIVOT (AAA FOR BBB
----------------------------------------------------------------
11
12

2 rows fetched.

SQL> select (select t5_f1 + t6_f2 from t_subselect_rs_005 limit 1) from t_subselect_rs_006 unpivot (aaa for bbb in(t6_f1)) order by bbb limit 2;

(SELECT T5_F1 + T6_F2 FROM T_SUBSELECT_RS_005 LIMIT 1)
------------------------------------------------------
3
4

2 rows fetched.

SQL> --subselect
SQL> select (select * from (select t5_f1 from t_subselect_rs_005) t5 where t5.t5_f1 = t6_f1) from t_subselect_rs_006 order by t6_f1 limit 2;

(SELECT * FROM (SELECT T5_F1 FROM T_SUBSELECT_RS_005) T5 WHERE T
----------------------------------------------------------------
1
2

2 rows fetched.

SQL> select (select * from (select t5_f1 from t_subselect_rs_005) t5 where t5.t5_f1 = t6_f1) from t_subselect_rs_006 where t6_f1 = 10 order by t6_f1 limit 2;

(SELECT * FROM (SELECT T5_F1 FROM T_SUBSELECT_RS_005) T5 WHERE T
----------------------------------------------------------------
10

1 rows fetched.

SQL> select (select * from (select t5_f1 from t_subselect_rs_005) t5 where t5.t5_f1 = t6_f1) from t_subselect_rs_006 where t6_f1 > 10 order by t6_f1 limit 2;

(SELECT * FROM (SELECT T5_F1 FROM T_SUBSELECT_RS_005) T5 WHERE T
----------------------------------------------------------------
11
12

2 rows fetched.

SQL> select * from (select (select * from (select t5_f1 from t_subselect_rs_005) t5 where t5.t5_f1 = t6_f1) from t_subselect_rs_006 order by t6_f1) limit 2;

(SELECT * FROM (SELECT T5_F1 FROM T_SUBSELECT_RS_005) T5 WHERE T
----------------------------------------------------------------
1
2

2 rows fetched.

SQL> --transfom
SQL> --distinct column eliminate
SQL> select distinct t6_f1,aaa from (select distinct t6_f1, (select t5_f1 from t_subselect_rs_005 where t5_f1 = t6_f1) aaa from t_subselect_rs_006 order by 1) limit 2;

T6_F1        AAA
------------ ------------
1            1
2            2

2 rows fetched.

SQL> select distinct t6_f1,aaa from (select distinct t6_f1, (select t5_f1 from t_subselect_rs_005 where t5_f1 > t6_f1 order by t5_f1 desc limit 1) aaa from t_subselect_rs_006 order by t6_f1 desc) limit 2;

T6_F1        AAA
------------ ------------
1            200
2            200

2 rows fetched.

SQL> select distinct t6_f1,aaa,rownum from (select distinct t6_f1, (select t5_f1 from t_subselect_rs_005 where t5_f1 > t6_f1  limit 1) aaa from t_subselect_rs_006 order by t6_f1%7 desc, t6_f1) limit 10;

T6_F1        AAA          ROWNUM
------------ ------------ ------------
6            7            1
13           14           2
20           21           3           
27           28           4           
34           35           5           
41           42           6
48           49           7
55           56           8
62           63           9
69           70           10

10 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 > t6_f1  limit 1) aaa from (select distinct t6_f1 from (select distinct t6_f1 from t_subselect_rs_006 )) t6 left join t_subselect_rs_004 t4 on t6.t6_f1 = t4.t4_f1  order by t6_f1%7 desc limit 2;

AAA
------------
7
14

2 rows fetched.

SQL> --project column eliminate
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6_f1 limit 1) from (select t6_f1,t6_f2 from t_subselect_rs_006) t6 left join t_subselect_rs_004 t4 on t6.t6_f1 = t4.t4_f1 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6_F1 LIMIT
----------------------------------------------------------------

1

2 rows fetched.

SQL> --sub-select table eliminate
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6_f1 limit 1) from (select * from (select * from t_subselect_rs_006)) t6 left join t_subselect_rs_004 t4 on t6.t6_f1 = t4.t4_f1 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6_F1 LIMIT
----------------------------------------------------------------

1

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 < t6_f1 limit 1) from (select * from (select /*+use_nl*/ * from t_subselect_rs_006,t_subselect_rs_001)) t6 left join t_subselect_rs_004 t4 on t6.t6_f1 = t4.t4_f1 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 < T6_F1 LIMIT
----------------------------------------------------------------



2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1 <= t6_f1 limit 1) from (select * from (select /*+use_nl*/ * from t_subselect_rs_006,t_subselect_rs_001)) t6 left join t_subselect_rs_004 t4 on t6.t6_f1 = t4.t4_f1 order by t6_f1 limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1 <= T6_F1 LIMIT
----------------------------------------------------------------
1
1

2 rows fetched.

SQL> --order by push down
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from (select * from t_subselect_rs_006 order by t6_f1 desc) order by t6_f2 asc limit 10;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F1 LIMIT 1)
----------------------------------------------------------------

1
1
1
1
1
1
1
1
1

10 rows fetched.

SQL> explain select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from (select * from t_subselect_rs_006 order by t6_f1 desc) order by t6_f2 asc limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                    |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS FULL              | SYS   | T_SUBSELECT_RS_005 |      |      |       |        |
| 3   |   QUERY LIMIT                      |       |                    |      |      |       |        |
| 4   |     SUBSELECT                      |       |                    |      |      |       |        |
| 5   |       TABLE ACCESS BY INDEX ROWID  | SYS   | T_SUBSELECT_RS_006 |      |      |       |        |
| 6   |         INDEX FULL SCAN            | SYS   | IDX_T6_002         |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T5_F1 < T6_F1                                    

14 rows fetched.

SQL> alter system set _OPTIM_ORDER_BY_PLACEMENT=false;

Succeed.

SQL> explain select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from (select * from t_subselect_rs_006 order by t6_f1 desc) order by t6_f2 asc limit 10   ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS FULL          | SYS   | T_SUBSELECT_RS_005 |      |      |       |        |
| 3   |   QUERY LIMIT                  |       |                    |      |      |       |        |
| 4   |     QUERY SORT ORDER BY ROWNUM |       |                    |      |      |       |        |
| 5   |       SUBSELECT                |       |                    |      |      |       |        |
| 6   |         TABLE ACCESS FULL      | SYS   | T_SUBSELECT_RS_006 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T5_F1 < T6_F1                                    

14 rows fetched.

SQL> alter system set _OPTIM_ORDER_BY_PLACEMENT=true;

Succeed.

SQL> --transform in to exist
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from t_subselect_rs_006 where t6_f1 in (select t4_f1 from t_subselect_rs_004) order by t6_f2 asc limit 10;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F1 LIMIT 1)
----------------------------------------------------------------

1
1
1
1
1
1
1
1
1

10 rows fetched.

SQL> --sub-select optimizer
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from t_subselect_rs_006 where t6_f1 = (select max(t4_f1) from t_subselect_rs_004 ) order by t6_f2 asc;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F1 LIMIT 1)
----------------------------------------------------------------
1

1 rows fetched.

SQL> SELECT * FROM t_subselect_rs_004 T4 WHERE EXISTS( SELECT t6.t6_f1, t5.t5_f2 FROM t_subselect_rs_006 t6, t_subselect_rs_005 t5
  2 WHERE t6.t6_f2 = t5.t5_f1 AND t5.t5_f2 = t4.t4_f1 AND t6.t6_f3 < (SELECT 0.2 * sum(t6.t6_f3) FROM t_subselect_rs_006 t6 WHERE t6.t6_f2 = t5.t5_f1)) limit 2;

T4_F1        T4_F2        T4_F3
------------ ------------ ------------

0 rows fetched.

SQL> --variant sub-select optimizer/cannot
SQL>  select (select t4_f1+t5_f1 from t_subselect_rs_004 where t4_f1 = t5_f1) from (SELECT t6.t6_f1, t6.t6_f2,t5_f1,t5.t5_f2
  2              FROM t_subselect_rs_006 t6, t_subselect_rs_005 t5
  3             WHERE t6.t6_f1 = t5.t5_f1 AND t6.t6_f3 > (SELECT 0.2 * sum(t6.t6_f3) FROM t_subselect_rs_006 t6 WHERE t6.t6_f1 = t5.t5_f1)) inner join t_subselect_rs_004 order by t5_f1 limit 2;

(SELECT T4_F1+T5_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F1 = T5_F1)
----------------------------------------------------------------
2
2

2 rows fetched.

SQL> --cartesian join optimizer
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from (select max(t6_f1) t6_f1 from t_subselect_rs_006,t_subselect_rs_004 group by t6_f1) t6
  2 left join t_subselect_rs_004 t4 on t6.t6_f1=t4.t4_f1 order by t6_f1 asc limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F1 LIMIT 1)
----------------------------------------------------------------

1

2 rows fetched.

SQL> --eliminate outer join+
SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f1 limit 1) from (select max(t6_f1) t6_f1 from t_subselect_rs_006,t_subselect_rs_004 group by t6_f1) t6
  2 left join t_subselect_rs_004 t4 on t6.t6_f1=t4.t4_f1 order by t6_f1 asc limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F1 LIMIT 1)
----------------------------------------------------------------

1

2 rows fetched.

SQL> select (select t5_f1 from t_subselect_rs_005 where t5_f1<t6_f2 limit 1) from t_subselect_rs_006 t6 left join t_subselect_rs_004 t4 on t6.t6_f2=t4.t4_f1 order by t6_f2 asc limit 2;

(SELECT T5_F1 FROM T_SUBSELECT_RS_005 WHERE T5_F1<T6_F2 LIMIT 1)
----------------------------------------------------------------
1
1

2 rows fetched.

SQL> --query condition optimizer
SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2 start with
  2 (select t5_f1 from t_subselect_rs_005 where t5_f1=t6_f2) = 10 connect by prior t5.t5_f1 = t5.t5_f1 + 1 order by t5.t5_f1 limit 2;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3

2 rows fetched.

SQL> --predicate push down
SQL> select /*+rule*/ (select t4_f1 from (select t4_f1 + t4_f2 t4_f1 from t_subselect_rs_004) where t4_f1=t5_f3 limit 1) from t_subselect_rs_005 t5 left join t_subselect_rs_006 t6 on t5.t5_f1 = t6.t6_f2
  2 where t6.t6_f2 < 66 and t5_f3 =15 order by t5.t5_f1 limit 2;

(SELECT T4_F1 FROM (SELECT T4_F1 + T4_F2 T4_F1 FROM T_SUBSELECT_
----------------------------------------------------------------
15

1 rows fetched.

SQL> select max(t4_f1) over (partition by t4_f3 order by t4_f2) ,(select t5_f1+max(t5_f1) from (select t5_f1+t5_f2 t5_f1 from t_subselect_rs_005 where t5_f1 = t4_f1) group by t5_f1 limit 1) from t_subselect_rs_004   limit 1;

MAX(T4_F1) OVER (PARTITION BY T4_F3 ORDER BY T4_F2) (SELECT T5_F1+MAX(T5_F1) FROM (SELECT T5_F1+T5_F2 T5_F1 FROM T_S
--------------------------------------------------- ----------------------------------------------------------------
1                                                   6

1 rows fetched.

SQL> --sort group optimizer/cannot in one query
SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f3 limit 1) from (select max(t5_f3) t5_f3 from t_subselect_rs_005 group by t5_f1 order by t5_f1) t5 order by t5.t5_f3 limit 2;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F3 LIMIT 1)
----------------------------------------------------------------
2
3

2 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f2 limit 1),rum from (select avg(t5_f2) t5_f2,rownum rum from t_subselect_rs_005
  2 group by t5_f1,rownum order by t5_f1,rownum) t5 inner join t_subselect_rs_006 order by t5.t5_f2 limit 1;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F2 LIMIT 1) RUM
---------------------------------------------------------------- ------------
1                                                                1

1 rows fetched.

SQL> --cube group optimizer
SQL> select (select max(t5_f2) t5_f2 from t_subselect_rs_005 where t5_f1 <t6_f1 group by cube( t5_f1,t5_f2)  limit 1 offset 1) from t_subselect_rs_006 order by t6_f1 limit 1;

(SELECT MAX(T5_F2) T5_F2 FROM T_SUBSELECT_RS_005 WHERE T5_F1 <T6
----------------------------------------------------------------


1 rows fetched.

SQL> select /*+rule*/ (select t4_f1 from t_subselect_rs_004 where t4_f2=t5_f2 limit 1) from (select max(t5_f2) t5_f2 from t_subselect_rs_005 group by cube( t5_f1,t5_f2)) t5 inner join t_subselect_rs_006 order by t5.t5_f2 limit 2;

(SELECT T4_F1 FROM T_SUBSELECT_RS_004 WHERE T4_F2=T5_F2 LIMIT 1)
----------------------------------------------------------------
1
1

2 rows fetched.

SQL> drop table t_subselect_rs_001;

Succeed.

SQL> drop table t_subselect_rs_002;

Succeed.

SQL> drop table t_subselect_rs_003;

Succeed.

SQL> drop table t_subselect_rs_004;

Succeed.

SQL> drop table t_subselect_rs_005;

Succeed.

SQL> drop table t_subselect_rs_006;

Succeed.

SQL> DROP TABLE t_subselect_rs_007;

Succeed.

SQL> 
SQL> --DTS2020030202338
SQL> DROP TABLE IF EXISTS T_CONNECT_BASE_001;

Succeed.

SQL> CREATE TABLE T_CONNECT_BASE_001(
  2        EMP_ID NUMBER(18),
  3        LEAD_ID NUMBER(18),
  4        EMP_NAME VARCHAR2(200),
  5        SALARY NUMBER(10,2),
  6        DEPT_NO VARCHAR2(8)
  7 );

Succeed.

SQL> 
SQL> EXPLAIN SELECT C[1] FROM (SELECT ARRAY[SYS_CONNECT_BY_PATH(EMP_NAME,'/'),EMP_NAME] C FROM T_CONNECT_BASE_001 START WITH EMP_ID=1 CONNECT BY PRIOR EMP_ID = LEAD_ID) ORDER BY 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |                    |      |      |       |        |
| 2   |     SUBSELECT                |       |                    |      |      |       |        |
| 3   |       CONNECT BY MATERIALIZE |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_CONNECT_BASE_001 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: PRIOR EMP_ID = LEAD_ID                           
       filter: EMP_ID = 1                                       

13 rows fetched.

SQL> EXPLAIN SELECT C[1] FROM (SELECT ARRAY[SYS_CONNECT_BY_PATH(EMP_NAME,'/'),EMP_NAME] C FROM T_CONNECT_BASE_001 START WITH EMP_ID=1 CONNECT BY PRIOR EMP_ID = LEAD_ID) ORDER BY C[1];

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |                    |      |      |       |        |
| 2   |     SUBSELECT                |       |                    |      |      |       |        |
| 3   |       CONNECT BY MATERIALIZE |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL    | SYS   | T_CONNECT_BASE_001 |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: PRIOR EMP_ID = LEAD_ID                           
       filter: EMP_ID = 1                                       

13 rows fetched.

SQL> DROP TABLE IF EXISTS T_CONNECT_BASE_001;

Succeed.

SQL>
SQL> drop table if exists t_sort_limit;

Succeed.

SQL> create table t_sort_limit(a int, b int, c varchar(20));

Succeed.

SQL> commit;

Succeed.

SQL>
SQL> explain select * from t_sort_limit order by b limit 1000;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |              |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | T_SORT_LIMIT |      |      |       |        |
----------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select * from t_sort_limit order by b limit 1001;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |              |      |      |       |        |
| 1   |   QUERY LIMIT            |       |              |      |      |       |        |
| 2   |     QUERY SORT ORDER BY  |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_SORT_LIMIT |      |      |       |        |
----------------------------------------------------------------------------------------

8 rows fetched.

SQL> alter system set _query_topn_threshold = 0;

Succeed.

SQL> explain select * from t_sort_limit order by b limit 1000;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |              |      |      |       |        |
| 1   |   QUERY LIMIT            |       |              |      |      |       |        |
| 2   |     QUERY SORT ORDER BY  |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_SORT_LIMIT |      |      |       |        |
----------------------------------------------------------------------------------------

8 rows fetched.

SQL> alter system set _query_topn_threshold = 10000;

Succeed.

SQL> explain select * from t_sort_limit order by b limit 10000;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |              |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | T_SORT_LIMIT |      |      |       |        |
----------------------------------------------------------------------------------------------

8 rows fetched.

SQL> alter system set _query_topn_threshold = 10001;

CT-00210, The value of parameter "_QUERY_TOPN_THRESHOLD" is too large, at most 10000
SQL> alter system set _query_topn_threshold = 1000;

Succeed.

SQL> drop table if exists t_sort_limit;

Succeed.

SQL>
SQL> DROP TABLE IF EXISTS CONTEXT_DATA;

Succeed.

SQL> CREATE TABLE CONTEXT_DATA
  2 (
  3   OBJECT_NAME VARCHAR(64 BYTE) NOT NULL,
  4   BE_ID NUMBER(10) NOT NULL,
  5   PARTITION_ID NUMBER(8) NOT NULL,
  6   DATA_CONTENT CLOB,
  7   STATUS VARCHAR(1 BYTE),
  8   CLOB_ID NUMBER(20),
  9   TENANT_ID NUMBER(20),
 10   HIS_DATE DATE,
 11   C_EX_FIELD4 VARCHAR(255 BYTE),
 12   C_EX_FIELD5 VARCHAR(255 BYTE)
 13 );

Succeed.

SQL> INSERT INTO CONTEXT_DATA values('CreateOrderFlowInfoXMLVO',101,1,null,'0',31108,999999,null,null,null);

1 rows affected.

SQL> INSERT INTO CONTEXT_DATA values('Subscription_490000001000014108',101,2,null,'0',35299,999999,null,null,null);

1 rows affected.

SQL> INSERT INTO CONTEXT_DATA values('CreateOrderFlowInfoXMLVO',101,1,null,'0',113004,999999,null,null,null);

1 rows affected.

SQL> INSERT INTO CONTEXT_DATA values('CreateOrderRequestXMLVO',101,1,null,'0',111009,999999,null,null,null);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL>
SQL> SELECT
  2   REF_0.OBJECT_NAME AS C0,
  3   REF_0.BE_ID AS C1,
  4   REF_0.CLOB_ID AS C2,
  5   REF_0.STATUS AS C3,
  6   REF_0.C_EX_FIELD4 AS C4,
  7   REF_0.DATA_CONTENT AS C5
  8 FROM
  9   CONTEXT_DATA AS REF_0
 10 ORDER BY
 11  REF_0.TENANT_ID DESC NULLS LAST,
 12  REF_0.TENANT_ID DESC,
 13  REF_0.C_EX_FIELD5 DESC NULLS FIRST,
 14  REF_0.DATA_CONTENT DESC NULLS FIRST,
 15  REF_0.OBJECT_NAME DESC NULLS FIRST,
 16  REF_0.STATUS DESC NULLS FIRST,
 17  REF_0.PARTITION_ID DESC NULLS LAST,
 18  REF_0.TENANT_ID ASC,
 19  REF_0.STATUS ASC NULLS LAST,
 20  REF_0.STATUS ASC,
 21  REF_0.HIS_DATE DESC NULLS LAST
 22 LIMIT 1, 1;

C0                                                               C1                                       C2                                       C3 C4                                                               C5

---------------------------------------------------------------- ---------------------------------------- ---------------------------------------- -- ---------------------------------------------------------------- ----------------------------------------------------------------
CreateOrderRequestXMLVO                                          101                                      111009                                   0


1 rows fetched.

SQL> DROP TABLE CONTEXT_DATA;

Succeed.

SQL> 
SQL> drop table if exists t_sort_lnnvl_alias;

Succeed.

SQL> create table t_sort_lnnvl_alias(id int, c_int int);

Succeed.

SQL> select id, c_int as c1 from t_sort_lnnvl_alias order by lnnvl(c1);

ID           C1          
------------ ------------

0 rows fetched.

SQL> drop table t_sort_lnnvl_alias;

Succeed.

SQL>                                                                                                       
SQL> drop table if exists j1;                                                                              
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> drop table if exists j2;                                                                              
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> create table j1(a int, b int);                                                                        
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> create table j2(a int, b int);                                                                        
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> insert into j1 values(1,2),(2,3),(3,3),(4,3);                                                         
                                                                                                           
4 rows affected.                                                                                           
                                                                                                           
SQL> insert into j2 values(1,2),(2,2),(3,2),(4,3);                                                         
                                                                                                           
4 rows affected.                                                                                           
                                                                                                           
SQL> commit;                                                                                               
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> create index j1i on j1(a);                                                                            
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> select count(a) from j1 where a in (select max(a) from j2 group by b order by abs(b));                
                                                                                                           
COUNT(A)                                                                                                   
--------------------                                                                                       
2                                                                                                          
                                                                                                           
1 rows fetched.                                                                                            
                                                                                                           
SQL> select count(a) from j1 where a in (select max(a) from j2 group by b order by abs(b) limit 1);        
                                                                                                           
COUNT(A)                                                                                                   
--------------------                                                                                       
1                                                                                                          
                                                                                                           
1 rows fetched.                                                                                            
                                                                                                           
SQL> select a from j1 where a in (select min(b) from j2 group by a order by a limit 2) ;

A
------------
2

1 rows fetched.                                                                                          

SQL> select * from j1 where rowid in (select rowid from j1 connect by nocycle prior a = b order by rowid limit 3);

A            B
------------ ------------
1            2

1 rows fetched.
                                                                                                          
SQL> drop table j1;                                                                                        
                                                                                                           
Succeed.                                                                                                   
                                                                                                           
SQL> drop table j2;                                                                                        
                                                                                                           
Succeed.                                                                                                   

SQL> 
SQL> DROP TABLE  if exists  merge_test_vchar_big;

Succeed.

SQL> create table merge_test_vchar_big
  2 (
  3   emp_id VARCHAR2(8000)
  4 );

Succeed.

SQL> 
SQL> DECLARE
  2 vchar_big VARCHAR2(8000) := DBE_RANDOM.GET_STRING('l', 8000);
  3 begin
  4 for i in 0 .. 63 loop
  5   insert into merge_test_vchar_big(emp_id) values(DBE_LOB.SUBSTR(vchar_big, 8000 - i, 1));
  6 end loop; 
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> select MOD(LENGTH(emp_id),7) from merge_test_vchar_big order by emp_id;

MOD(LENGTH(EMP_ID),7)                   
----------------------------------------
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       
0                                       
1                                       
2                                       
3                                       
4                                       
5                                       
6                                       

64 rows fetched.

SQL> DROP TABLE merge_test_vchar_big;
Succeed.

SQL> 
SQL> -- order siblings by select node cannot be pushed down
SQL> drop table if exists connect_push_down_t1;

Succeed.

SQL> drop table if exists connect_push_down_t2;

Succeed.

SQL> create table connect_push_down_t1(c1 int, c2 int);

Succeed.

SQL> create table connect_push_down_t2(c1 int, c2 int);

Succeed.

SQL> 
SQL> explain
  2 select
  3 	(select c1 from connect_push_down_t1 limit 1) as c0
  4 from
  5 	(
  6 	select
  7 		cast(ref_0.c1 as number(20, 0)) as c0,
  8 		cast('273047 12:16:7' as interval day to second(6)) as c1,
  9 		cast('957064 21:48:39' as interval day to second) as c3,
 10 		cast(ref_0.c1 as number(20, 0)) as c4
 11 	from
 12 		connect_push_down_t2 as ref_0
 13 	) as subq_0
 14 where
 15 	(select c2 from connect_push_down_t2 limit 1) = subq_0.c0
 16 connect by
 17 	subq_0.c4 = prior subq_0.c0
 18 order siblings by 
 19     (select c2 from connect_push_down_t1 limit 1), 1, 1 desc;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   FILTER                         |       |                            |      |      |       |        |
| 2   |     QUERY SORT SIBLINGS ORDER BY |       |                            |      |      |       |        |
| 3   |       QUERY LIMIT                |       |                            |      |      |       |        |
| 4   |         TABLE ACCESS FULL        | SYS   | CONNECT_PUSH_DOWN_T1       |      |      |       |        |
| 5   |       CONNECT BY MATERIALIZE     |       |                            |      |      |       |        |
| 6   |         SUBSELECT                |       | SUBQ_0                     |      |      |       |        |
| 7   |           TABLE ACCESS FULL      | SYS   | CONNECT_PUSH_DOWN_T2 REF_0 |      |      |       |        |
| 8   |   QUERY LIMIT                    |       |                            |      |      |       |        |
| 9   |     TABLE ACCESS FULL            | SYS   | CONNECT_PUSH_DOWN_T2       |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: (SELECT C2 FROM CONNECT_PUSH_DOWN_T2 LIMIT 1) = SUBQ_0.C0
   5 - access: PRIOR SUBQ_0.C0 = SUBQ_0.C4                      

18 rows fetched.

SQL> 
SQL> drop table connect_push_down_t1;

Succeed.

SQL> drop table connect_push_down_t2;
Succeed.

SQL> 
SQL> drop table if exists nested_aggr_t;

Succeed.

SQL> create table nested_aggr_t(col_1 int, col_2 int);

Succeed.

SQL> insert into nested_aggr_t values(1,1);

1 rows affected.

SQL> insert into nested_aggr_t values(2,2);

1 rows affected.

SQL> 
SQL> select col_1, group_concat(col_2) c2 from nested_aggr_t group by col_1 order by group_concat(c2);

CT-01317, [1:94]Unexpected aggregation 'GROUP_CONCAT'
SQL> select col_1, cume_dist(1) within group (order by col_1 desc) c2 from nested_aggr_t group by col_1 order by cume_dist(1) within group (order by c2 desc);

CT-00601, [1:145]Sql syntax error: invalid column name 'C2'
SQL> select sum(col_1) over() c1 from nested_aggr_t order by sum(c1) over();

CT-01316, [1:65]Unexpected windows sort analytic function
SQL> drop table nested_aggr_t;
Succeed.




