

SQL> DROP TABLE IF EXISTS T_UPDATE_1;

Succeed.

SQL> CREATE TABLE T_UPDATE_1 (F_INT1 INT, F_INT2 INT, F_CHAR CHAR(16), F_DATE DATE);

Succeed.

SQL> INSERT INTO T_UPDATE_1 VALUES(1,11,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO T_UPDATE_1 VALUES(2,22,'B','2017-12-12 16:08:00');

1 rows affected.

SQL> INSERT INTO T_UPDATE_1 VALUES(1,11,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO T_UPDATE_1 VALUES(3,33,'C','2017-12-13 15:08:20');

1 rows affected.

SQL> INSERT INTO T_UPDATE_1 VALUES(2,22,'B','2017-12-12 16:08:00');

1 rows affected.

SQL> DROP TABLE IF EXISTS T_UPDATE_2;

Succeed.

SQL> CREATE TABLE T_UPDATE_2 (F_INT1 INT, F_INT2 INT, F_CHAR CHAR(16), F_DATE DATE);

Succeed.

SQL> INSERT INTO T_UPDATE_2 VALUES(2,22,'C','2017-12-12 16:08:00');

1 rows affected.

SQL> INSERT INTO T_UPDATE_2 VALUES(1,11,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO T_UPDATE_2 VALUES(2,22,'C','2017-12-12 16:08:00');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> SELECT * FROM T_UPDATE_1;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
1            11           A                2017-12-11 14:08:00   
2            22           B                2017-12-12 16:08:00   
1            11           A                2017-12-11 14:08:00   
3            33           C                2017-12-13 15:08:20   
2            22           B                2017-12-12 16:08:00   

5 rows fetched.

SQL> SELECT * FROM T_UPDATE_2;

F_INT1       F_INT2       F_CHAR           F_DATE                
------------ ------------ ---------------- ----------------------
2            22           C                2017-12-12 16:08:00   
1            11           A                2017-12-11 14:08:00   
2            22           C                2017-12-12 16:08:00   

3 rows fetched.

SQL> UPDATE T_UPDATE_1 SET F_INT1=11, F_INT2=(SELECT F_INT2 FROM T_UPDATE_2);

CT-00915, More than one return value of SELECT INTO, EXECUTE IMMEDIATE, or a cursor was assigned to a common variable.
SQL> UPDATE T_UPDATE_1 SET F_INT1=11, F_INT2=(SELECT 111 FROM DUAL) WHERE F_INT2=11 AND F_INT1=1;

2 rows affected.

SQL> COMMIT;

Succeed.

SQL> SELECT F_INT1, F_INT2 FROM T_UPDATE_1;

F_INT1       F_INT2      
------------ ------------
11           111         
2            22          
11           111         
3            33          
2            22          

5 rows fetched.

SQL> UPDATE T_UPDATE_1 SET F_INT1=22, F_INT2=(SELECT F_INT2 FROM T_UPDATE_2 WHERE F_INT2=22 GROUP BY F_INT2) WHERE F_INT2=22 AND F_INT1=2;

2 rows affected.

SQL> COMMIT;

Succeed.

SQL> SELECT F_INT1, F_INT2 FROM T_UPDATE_1;

F_INT1       F_INT2      
------------ ------------
11           111         
22           22          
11           111         
3            33          
22           22          

5 rows fetched.

SQL> UPDATE T_UPDATE_1 SET F_INT1=(SELECT 33 FROM DUAL), F_INT2=(SELECT 333 FROM DUAL) WHERE F_INT1=3 AND F_INT2=(SELECT 33 FROM DUAL);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> SELECT F_INT1, F_INT2 FROM T_UPDATE_1;

F_INT1       F_INT2      
------------ ------------
11           111         
22           22          
11           111         
33           333         
22           22          

5 rows fetched.

SQL> UPDATE T_UPDATE_1 SET F_INT1=(SELECT 4 FROM DUAL), F_INT2=(SELECT 44 FROM DUAL);

5 rows affected.

SQL> COMMIT;

Succeed.

SQL> SELECT F_INT1, F_INT2 FROM T_UPDATE_1;

F_INT1       F_INT2      
------------ ------------
4            44          
4            44          
4            44          
4            44          
4            44          

5 rows fetched.

SQL> 
SQL> update t_update_1 set f_int1=1, f_int2=2 , f_int1=1;

CT-00604, Duplicate column name F_INT1
SQL> 
SQL> --multi update error
SQL> DROP VIEW IF EXISTS TEST_V1;

Succeed.

SQL> CREATE VIEW TEST_V1 AS SELECT * FROM T_UPDATE_1;

Succeed.

SQL> UPDATE TEST_V1 SET F_INT1=10;

CT-00601, [1:8]Sql syntax error: view operation UPDATE must based on instead of trigger but current view has no trigger
SQL> UPDATE T_UPDATE_1 T1 JOIN (SELECT * FROM T_UPDATE_2) T2 ON T1.F_INT1=T2.F_INT1 SET T2.F_INT1=100;

CT-00130, Operation update is not supported on view, func, join table, json table, subqueries or system table
SQL> UPDATE T_UPDATE_1 T1 FULL JOIN T_UPDATE_2 T2 ON T1.F_INT1=T2.F_INT1 SET T1.F_INT1=100;

CT-00601, Sql syntax error: multi delete/update not support full join
SQL> DROP VIEW  TEST_V1;

Succeed.

SQL> DROP TABLE T_UPDATE_1;

Succeed.

SQL> DROP TABLE T_UPDATE_2;

Succeed.

SQL> 
SQL> --DTS2018020906949
SQL> DROP TABLE IF EXISTS table_multi_mix;

Succeed.

SQL> CREATE TABLE table_multi_mix(C_INTEGER INTEGER, C_BIGINT BIGINT, C_DOUBLE DOUBLE, C_NUMBER NUMBER, C_CHAR CHAR(63), C_VARCHAR VARCHAR(99), C_TIMESTAMP TIMESTAMP, C_TEXT TEXT null, C_BOOL BOOL)
  2 partition by range (C_TIMESTAMP)
  3 (partition p1 values less than (to_timestamp('1989-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p2 values less than (to_timestamp('1990-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p3 values less than (to_timestamp('1991-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  4  partition p4 values less than (to_timestamp('1992-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p5 values less than (to_timestamp('1993-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p6 values less than (to_timestamp('1994-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  5  partition p7 values less than (to_timestamp('1995-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p8 values less than (to_timestamp('1996-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p9 values less than (to_timestamp('1997-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  6 partition p10 values less than (to_timestamp('1998-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p11 values less than (to_timestamp('1999-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p12 values less than (to_timestamp('2000-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  7 partition p13 values less than (to_timestamp('2001-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p14 values less than (to_timestamp('2002-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p15 values less than (to_timestamp('2003-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  8 partition p16 values less than (to_timestamp('2004-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p17 values less than (to_timestamp('2005-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p18 values less than (to_timestamp('2006-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
  9 partition p19 values less than (to_timestamp('2007-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p20 values less than (to_timestamp('2008-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p21 values less than (to_timestamp('2009-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 10 partition p22 values less than (to_timestamp('2010-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p23 values less than (to_timestamp('2011-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p24 values less than (to_timestamp('2012-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 11 partition p25 values less than (to_timestamp('2013-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p26 values less than (to_timestamp('2014-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p27 values less than (to_timestamp('2015-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 12 partition p28 values less than (to_timestamp('2016-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p29 values less than (to_timestamp('2017-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p30 values less than (to_timestamp('2018-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 13 partition p31 values less than (to_timestamp('2019-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p32 values less than (to_timestamp('2020-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p33 values less than (to_timestamp('2021-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 14 partition p34 values less than (to_timestamp('2022-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p35 values less than (to_timestamp('2023-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p36 values less than (to_timestamp('2024-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 15 partition p37 values less than (to_timestamp('2025-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p38 values less than (to_timestamp('2026-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),partition p39 values less than (to_timestamp('2027-12-12 00:00:00', 'yyyy-mm-dd hh24:mi:ss')),
 16 partition p40 values less than (maxvalue));

Succeed.

SQL> 
SQL> UPDATE table_multi_mix SET C_NUMBER = C_DOUBLE WHERE (((NULL - (C_NUMBER / (-902408775334363136 / (6 + 1)))) / 736559104) in (-1720647680)) and (C_TIMESTAMP between to_timestamp('2005-07-06 18:49:04', 'yyyy-mm-dd hh24:mi:ss') and C_TIMESTAMP);

0 rows affected.

SQL> DROP TABLE IF EXISTS table_multi_mix;

Succeed.

SQL> 
SQL> --DTS2018041703844
SQL> DROP TABLE IF EXISTS T_UPDATE_ROLLBACK_1;

Succeed.

SQL> CREATE TABLE T_UPDATE_ROLLBACK_1 (COL1 VARCHAR(64), COL2 VARCHAR(64), COL3 VARCHAR(64), COL4 VARCHAR(64), COL5 VARCHAR(64), COL6 VARCHAR(64), COL7 VARCHAR(64), COL8 VARCHAR(64), COL9 VARCHAR(64), COL10 VARCHAR(64), COL11 VARCHAR(64), COL12 VARCHAR(64));

Succeed.

SQL> INSERT INTO T_UPDATE_ROLLBACK_1 VALUES ('QWERTYUIOPASDFGHJKLZXCVBNM', 'QWERTYUIOPASDFGHJKLZXCVBNM', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'QWERTYUIOPASDFG', NULL);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE T_UPDATE_ROLLBACK_1 ADD COL13 VARCHAR(24);

Succeed.

SQL> UPDATE T_UPDATE_ROLLBACK_1 SET COL11 = NULL, COL12 = 'ZXCVBNMASDFGH';

1 rows affected.

SQL> ROLLBACK;

Succeed.

SQL> 
SQL> ----------------------------------------------------------------------
SQL> ----- [CASE BLOCK BEGIN]: SUPPORT MULTI SET -----
SQL> drop table if exists t;

Succeed.

SQL> create table t (c1 int, c2 int, c3 int, c4 int default 10 + 1, c5 varchar(32), c6 varchar(32), c7 varchar(32));

Succeed.

SQL> insert into t(c1, c2, c3) values (1, 2, 3);

1 rows affected.

SQL> 
SQL> drop table if exists t1;

Succeed.

SQL> create table t1 (c1 int, c2 int, c3 int, c5 varchar(32), c6 varchar(32), c7 varchar(32));

Succeed.

SQL> insert into t1 values (11, 12, 13, 'a', 'b', 'c');

1 rows affected.

SQL> insert into t1 values (21, 22, 23, 'a', 'b', 'c');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> -- Subquery returns single row: Oracle/PG support
SQL> update t set (c1, c2, c3) = (select c1, c2, c3 from t1 where c1 = 21);

1 rows affected.

SQL> update t set (c5, c6, c7) = (select c5, c6, c7 from t1 where c1 = 21);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
21           22           23           11           a                                b                                c                               

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> update t set (c1, c2) = (select c1 + t.c1, c2 + t.c2 from t1 where c1 = 21), (c3, c5) = (select c3 + t.c3, c5 from t1 where c1 = 21), (c6, c7) = (select c6, c7 from t1 where c1 = 21);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
22           24           26           11           a                                b                                c                               

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> insert into t1(c1, c2, c3, c5, c6, c7) values (1, 502, 503, 'x', 'y', 'z');

1 rows affected.

SQL> update sys.t 
  2 set 
  3     (c1, c2) = (SELECT a.c1, a.c2    from sys.t1 a where a.c1 = sys.t.c1),
  4     (c3, c5) = (select c3 + t.c3, c5 from sys.t1 a where a.c1 = sys.t.c1),
  5     (c6, c7) = (select c6, c7        from sys.t1 a where a.c1 = sys.t.c1)
  6 where 
  7     exists (select 1                 from sys.t1 a where a.c1 = sys.t.c1);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
1            502          506          11           x                                y                                z                               

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> insert into t1(c1, c2, c3, c5, c6, c7) values (1, 502, 503, 'x', 'y', 'z');

1 rows affected.

SQL> update t 
  2 set 
  3     (c1, c2) = (SELECT a.c1, a.c2    from t1 a where a.c1 = t.c1),
  4     (c3, c5) = (select c3 + t.c3, c5 from t1 a where a.c1 = t.c1),
  5     (c6, c7) = (select c6, c7        from t1 a where a.c1 = t.c1)
  6 where 
  7     exists (select 1                 from t1 a where a.c1 = t.c1);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
1            502          506          11           x                                y                                z                               

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> -- Subquery returns more than one row: Oracle/PG not support
SQL> update t set (c1, c2, c3) = (select c1, c2, c3 from t1);

CT-00915, More than one return value of SELECT INTO, EXECUTE IMMEDIATE, or a cursor was assigned to a common variable.
SQL> rollback;

Succeed.

SQL> 
SQL> -- Subquery returns no row: Oracle/PG support, columns will set to NULL
SQL> update t set (c1, c2, c3) = (select c1, c2, c3 from t1 where c1 > 100);

1 rows affected.

SQL> select count(1) from t where c1 is null and c2 is null and c3 is null;

COUNT(1)            
--------------------
1                   

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> -- Subquery returns single row with NULL: Oracle/PG support, columns will set to NULL
SQL> update t set (c1, c2, c3) = (select NULL, NULL, NULL from t1 where c1 = 2);

1 rows affected.

SQL> select count(1) from t where c1 is null and c2 is null and c3 is null;

COUNT(1)            
--------------------
1                   

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> -- Non-subquery: Oracle not support, PG support
SQL> update t set (c1, c2, c3) = (4, 4, 4);

CT-00601, [1:31]Sql syntax error: the word "," is not correct
SQL> update t set (c1, c2) = (1);

CT-00601, [1:26]Sql syntax error: UPDATE ... SET expression must be a subquery
SQL> 
SQL> -- Set list mis-matched
SQL> update t set c1 = (select c1, c2 from t1 where c1 = 21);

CT-00601, [1:20]Sql syntax error: too many columns
SQL> update t set (c1, c2) = (select c1 from t1 where c1 = 21);

CT-00601, [1:25]Sql syntax error: too many columns
SQL> update t set (c1, c2) = (select c1, 1, 1 from t1 where c1 = 21);

CT-00601, [1:25]Sql syntax error: too many columns
SQL> 
SQL> -- Duplicate column
SQL> update t set c1 = 1, (c1) = (select c1 from t1 where c1 = 21);

CT-00604, Duplicate column name C1
SQL> update t set (c1) = (select c1 from t1 where c1 = 21), c1 = 1;

CT-00604, Duplicate column name C1
SQL> update t set (c1, c2) = (select c1, c2 from t1 where c1 = 21), (c3, c1) = (select c1, c2 from t1 where c1 = 21);

CT-00604, Duplicate column name C1
SQL> 
SQL> -- Wrong syntax
SQL> update t set c1, c2 = select 1, 2 from t1;

CT-00601, [1:16]Sql syntax error: = expected
SQL> update t set (c1, c2) = select 1, 2 from t1;

CT-00601, [1:25]Sql syntax error: invalid expression
SQL> update t set (c1, c2) = 1;

CT-00601, [1:25]Sql syntax error: UPDATE ... SET expression must be a subquery
SQL> 
SQL> -- Column type mis-matched
SQL> update t set c1 = (select to_date('2018-06-30', 'yyyy-mm-dd') from t1);

CT-00606, Inconsistent datatypes, expected BINARY_INTEGER - got DATE
SQL> update t set (c1, c2) = (select 1, to_date('2018-06-30', 'yyyy-mm-dd') from t1 limit 1);

CT-00606, Inconsistent datatypes, expected BINARY_INTEGER - got DATE
SQL> rollback;

Succeed.

SQL> 
SQL> -- merge into 
SQL> merge into t new using t1 old on (old.c1 = 11) 
  2 when matched then update set new.c1 = old.c1 where new.c1 = 1;

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
11           2            3            11                                                                                                             

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> merge into t new using t1 old on (old.c1 = 11) 
  2 when matched then 
  3     update set (new.c1, new.c2) = (select 100 + old.c1, 200 + old.c1), 
  4                (new.c3, new.c5)         = (select c3 + old.c3, c5 from t1 where c1 = 21), 
  5                (new.c6, new.c7)         = (select c6, c7 from t1 where c1 = 21)
  6     where new.c1 = 1; 

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
111          211          36           11           a                                b                                c                               

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> merge into t new using t1 old on (old.c1 = 11) 
  2 when matched then 
  3     update set (new.c1, new.c2) = (select 100 + old.c1, 200 + old.c1)
  4     where new.c1 = 1; 

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
111          211          3            11                                                                                                             

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> -- Check normal update syntax
SQL> update t set c1 = 101, c2 = 102, c3 = 103;

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
101          102          103          11                                                                                                             

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> update t set c1 = (select c1 from t1 where c1 = 21);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
21           2            3            11                                                                                                             

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> update t set (c1) = (select c1 from t1 where c1 = 21);

1 rows affected.

SQL> select * from t;

C1           C2           C3           C4           C5                               C6                               C7                              
------------ ------------ ------------ ------------ -------------------------------- -------------------------------- --------------------------------
21           2            3            11                                                                                                             

1 rows fetched.

SQL> rollback;

Succeed.

SQL> 
SQL> update t set c1 = default;

CT-01316, [1:19]Unexpected 'DEFAULT' found
SQL> rollback;

Succeed.

SQL> 
SQL> update t1 set ("T1"."C1", c2, c3) = (select 1, 2, 3 from t1 limit 1);

2 rows affected.

SQL> rollback;

Succeed.

SQL> 
SQL> update t1 set "T1"."C1" = (select 1 from t1 limit 1);

2 rows affected.

SQL> rollback;

Succeed.

SQL> 
SQL> -- cleanup
SQL> drop table t;

Succeed.

SQL> drop table t1;

Succeed.

SQL> commit;

Succeed.

SQL> ----- [CASE BLOCK END]: SUPPORT MULTI SET -----
SQL> ----------------------------------------------------------------------
SQL> --------------------MULTI UPDATE-----------------------------
SQL> DROP TABLE IF EXISTS T1;

Succeed.

SQL> DROP TABLE IF EXISTS T2;

Succeed.

SQL> DROP TABLE IF EXISTS T3;

Succeed.

SQL> CREATE TABLE T1(F_INT1 INT, F_VARCHAR1 VARCHAR(32));

Succeed.

SQL> CREATE TABLE T2(F_INT1 INT, F_VARCHAR1 VARCHAR(32));

Succeed.

SQL> CREATE TABLE T3(F_INT1 INT, F_VARCHAR1 VARCHAR(32));

Succeed.

SQL> 
SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (4, 'T2_VALUE_4');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (5, 'T2_VALUE_5');

1 rows affected.

SQL> UPDATE T1 JOIN T2 ON T1.F_INT1=T2.F_INT1 SET T1.F_VARCHAR1 = T1.F_VARCHAR1 || 'UPDATED';

4 rows affected.

SQL> UPDATE T1 JOIN T2 ON T1.F_INT1=T2.F_INT1 SET T2.F_VARCHAR1 = T2.F_VARCHAR1 || 'UPDATED';

5 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
1            T1_VALUE_1UPDATED               
1            T1_VALUE_1UPDATED               
2            T1_VALUE_2UPDATED               
3            T1_VALUE_3UPDATED               

4 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
1            T2_VALUE_1UPDATED               
1            T2_VALUE_1UPDATED               
2            T2_VALUE_2UPDATED               
2            T2_VALUE_2UPDATED               
3            T2_VALUE_3UPDATED               
4            T2_VALUE_4                      
5            T2_VALUE_5                      

7 rows fetched.

SQL> UPDATE T1 TT1 JOIN T2 TT2 ON TT1.F_INT1=TT2.F_INT1 SET TT1.F_INT1 = TT1.F_INT1*10, TT2.F_INT1=TT2.F_INT1*100;

9 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
10           T1_VALUE_1UPDATED               
10           T1_VALUE_1UPDATED               
20           T1_VALUE_2UPDATED               
30           T1_VALUE_3UPDATED               

4 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
100          T2_VALUE_1UPDATED               
100          T2_VALUE_1UPDATED               
200          T2_VALUE_2UPDATED               
200          T2_VALUE_2UPDATED               
300          T2_VALUE_3UPDATED               
4            T2_VALUE_4                      
5            T2_VALUE_5                      

7 rows fetched.

SQL> 
SQL> DELETE FROM T1;

4 rows affected.

SQL> DELETE FROM T2;

7 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (4, 'T2_VALUE_4');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (5, 'T2_VALUE_5');

1 rows affected.

SQL> 
SQL> UPDATE T1 JOIN (SELECT * FROM T2 WHERE F_INT1=2) TT2 ON T1.F_INT1=TT2.F_INT1 SET T1.F_VARCHAR1 = T1.F_VARCHAR1 || 'UPDATED';

1 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
1            T1_VALUE_1                      
1            T1_VALUE_1                      
2            T1_VALUE_2UPDATED               
3            T1_VALUE_3                      

4 rows fetched.

SQL> 
SQL> DELETE FROM T1;

4 rows affected.

SQL> DELETE FROM T2;

7 rows affected.

SQL> DELETE FROM T3;

0 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (4, 'T2_VALUE_4');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (5, 'T2_VALUE_5');

1 rows affected.

SQL> 
SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (1, 'T3_VALUE_1');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (2, 'T3_VALUE_2');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (2, 'T3_VALUE_2');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (3, 'T3_VALUE_3');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (4, 'T3_VALUE_4');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (5, 'T3_VALUE_5');

1 rows affected.

SQL> INSERT INTO T3 (F_INT1, F_VARCHAR1) VALUES (6, 'T3_VALUE_6');

1 rows affected.

SQL> UPDATE T1 JOIN T2 ON T1.F_INT1=T2.F_INT1,T3 SET T1.F_INT1=T1.F_INT1*10,T2.F_INT1=T2.F_INT1*100 WHERE T2.F_INT1=T3.F_INT1;

8 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
10           T1_VALUE_1                      
20           T1_VALUE_2                      
30           T1_VALUE_3                      

3 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
100          T2_VALUE_1                      
100          T2_VALUE_1                      
200          T2_VALUE_2                      
200          T2_VALUE_2                      
300          T2_VALUE_3                      
4            T2_VALUE_4                      
5            T2_VALUE_5                      

7 rows fetched.

SQL> 
SQL> DELETE FROM T1;

3 rows affected.

SQL> DELETE FROM T2;

7 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> UPDATE T1,T2 LEFT JOIN T3 ON T2.F_INT1=T3.F_INT1 SET T1.F_INT1=50,T2.F_INT1=60 WHERE T1.F_INT1=T2.F_INT1;

8 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
50           T1_VALUE_1                      
50           T1_VALUE_2                      
50           T1_VALUE_3                      

3 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
60           T2_VALUE_1                      
60           T2_VALUE_1                      
60           T2_VALUE_2                      
60           T2_VALUE_2                      
60           T2_VALUE_3                      

5 rows fetched.

SQL> 
SQL> DELETE FROM T1;

3 rows affected.

SQL> DELETE FROM T2;

5 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> UPDATE T1,T2 RIGHT JOIN T3 ON T2.F_INT1=T3.F_INT1 SET T1.F_INT1=50,T2.F_INT1=60 WHERE T1.F_INT1=T2.F_INT1;

8 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
50           T1_VALUE_1                      
50           T1_VALUE_2                      
50           T1_VALUE_3                      

3 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
60           T2_VALUE_1                      
60           T2_VALUE_1                      
60           T2_VALUE_2                      
60           T2_VALUE_2                      
60           T2_VALUE_3                      

5 rows fetched.

SQL> 
SQL> DELETE FROM T1;

3 rows affected.

SQL> DELETE FROM T2;

5 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> UPDATE T1 LEFT JOIN T2 ON T1.F_INT1=T2.F_INT1 RIGHT JOIN T3 ON T2.F_INT1=T3.F_INT1 SET T1.F_INT1=50,T2.F_INT1=60;

8 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
50           T1_VALUE_1                      
50           T1_VALUE_2                      
50           T1_VALUE_3                      

3 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
60           T2_VALUE_1                      
60           T2_VALUE_1                      
60           T2_VALUE_2                      
60           T2_VALUE_2                      
60           T2_VALUE_3                      

5 rows fetched.

SQL> 
SQL> DELETE FROM T1;

3 rows affected.

SQL> DELETE FROM T2;

5 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (1, 'T1_VALUE_1');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (2, 'T1_VALUE_2');

1 rows affected.

SQL> INSERT INTO T1 (F_INT1, F_VARCHAR1) VALUES (3, 'T1_VALUE_3');

1 rows affected.

SQL> 
SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (1, 'T2_VALUE_1');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (2, 'T2_VALUE_2');

1 rows affected.

SQL> INSERT INTO T2 (F_INT1, F_VARCHAR1) VALUES (3, 'T2_VALUE_3');

1 rows affected.

SQL> UPDATE T1 LEFT JOIN T2 ON T1.F_INT1=T2.F_INT1 RIGHT JOIN T3 ON T2.F_INT1=T3.F_INT1 SET T1.F_INT1=50,T2.F_INT1=60 WHERE T1.F_INT1=2;

3 rows affected.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T1;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
1            T1_VALUE_1                      
50           T1_VALUE_2                      
3            T1_VALUE_3                      

3 rows fetched.

SQL> SELECT F_INT1, F_VARCHAR1 FROM T2;

F_INT1       F_VARCHAR1                      
------------ --------------------------------
1            T2_VALUE_1                      
1            T2_VALUE_1                      
60           T2_VALUE_2                      
60           T2_VALUE_2                      
3            T2_VALUE_3                      

5 rows fetched.

SQL> DROP TABLE IF EXISTS T1;

Succeed.

SQL> DROP TABLE IF EXISTS T2;

Succeed.

SQL> DROP TABLE IF EXISTS T3;

Succeed.

SQL> --DTS2018073105767
SQL> DROP TABLE IF EXISTS ALL_DATATYPE_TBL;

Succeed.

SQL> CREATE TABLE ALL_DATATYPE_TBL( C_INTEGER INTEGER, C_VARCHAR VARCHAR(50) ); 

Succeed.

SQL> INSERT INTO ALL_DATATYPE_TBL VALUES(1,'AAAAA');

1 rows affected.

SQL> UPDATE ALL_DATATYPE_TBL T1 SET (C_INTEGER, C_VARCHAR) = (SELECT C_INTEGER C1, C_VARCHAR C2 FROM ALL_DATATYPE_TBL UNION SELECT C_INTEGER C1, C_VARCHAR C2 FROM ALL_DATATYPE_TBL WHERE T1.C_INTEGER = C_INTEGER);

1 rows affected.

SQL> SELECT * FROM ALL_DATATYPE_TBL;

C_INTEGER    C_VARCHAR                                         
------------ --------------------------------------------------
1            AAAAA                                             

1 rows fetched.

SQL> DROP TABLE IF EXISTS ALL_DATATYPE_TBL;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS ABC;

Succeed.

SQL> DROP TABLE IF EXISTS EFG;

Succeed.

SQL> CREATE GLOBAL TEMPORARY TABLE ABC(A INT);

Succeed.

SQL> CREATE TABLE EFG(B INT);

Succeed.

SQL> INSERT INTO EFG VALUES(1);

1 rows affected.

SQL> INSERT INTO EFG VALUES(1);

1 rows affected.

SQL> INSERT INTO ABC VALUES(1);

1 rows affected.

SQL> UPDATE EFG, ABC SET ABC.A=2 WHERE ABC.A=EFG.B;

CT-00130, [1:13]Operation multi update is not supported on temp table
SQL> DELETE ABC FROM ABC JOIN EFG ON ABC.A=EFG.B;

CT-00130, [1:17]Operation multi delete is not supported on temp table
SQL> DROP TABLE IF EXISTS ABC;

Succeed.

SQL> DROP TABLE IF EXISTS EFG;

Succeed.

SQL> 
SQL> --
SQL> create table t_D_BTSAUTODLDACTINFO_B8
  2 (
  3     SAVEPOINTID       NUMBER(10,0) NOT NULL ,                                      
  4     OPERTYPE          NUMBER(3,0)  NOT NULL,                                      
  5     PLANID            NUMBER(10,0) NOT NULL,                                    
  6     CMENEID           NUMBER(10,0) NOT NULL ,                                  
  7     BTSID             NUMBER(10,0) NOT NULL,                                     
  8     ADLDACT           NUMBER(3,0),                                                     
  9     AUTOTYPE          NUMBER(3,0) ,                                                    
 10     ADVER1            VARCHAR(77) ,                                                    
 11     ADVER2            VARCHAR(77) ,                                                    
 12     PV                VARCHAR(75) ,                                                    
 13     ADMODE            NUMBER(3,0) ,                                                    
 14     STTYPE            NUMBER(3,0) ,                                                    
 15     MAINVER           NUMBER(10,0) ,                                                   
 16     SUBVER            NUMBER(10,0) ,                                                   
 17     PATCHNO           NUMBER(10,0) ,                                                   
 18     MONTH             NUMBER(3,0)  ,                                                   
 19     DAY               NUMBER(3,0)  ,                                                   
 20     VVER              NUMBER(10,0) ,                                                   
 21     RVER              NUMBER(10,0) ,                                                   
 22     CVER              NUMBER(3,0)  ,                                                   
 23     PATCHNO1          NUMBER(10,0) ,                                                   
 24     AUTOACTIVEVERSION NUMBER(3,0)  ,                                                   
 25     LOGUPTID          VARCHAR(383) ,                                                   
 26     NBI_RECID         NUMBER(10,0) ,                                                   
 27     ISGENMML          NUMBER(3,0)                                                   
 28 );

Succeed.

SQL> 
SQL> create table t_P_BTSAUTODLDACTINFO_B8
  2 (
  3 PLANID             NUMBER(10,0)  NOT NULL,                                          
  4 CMENEID            NUMBER(10,0)  NOT NULL,                                             
  5 BTSID              NUMBER(10,0)  NOT NULL,                                         
  6 ADLDACT            NUMBER(3,0),
  7 AUTOTYPE           NUMBER(3,0),
  8 ADVER1             VARCHAR(77),
  9 ADVER2             VARCHAR(77),
 10 PV                 VARCHAR(75),
 11 ADMODE             NUMBER(3,0),
 12 STTYPE             NUMBER(3,0),
 13 MAINVER            NUMBER(10,0),
 14 SUBVER             NUMBER(10,0),
 15 PATCHNO            NUMBER(10,0),
 16 MONTH              NUMBER(3,0),
 17 DAY                NUMBER(3,0),
 18 VVER               NUMBER(10,0),
 19 RVER               NUMBER(10,0),
 20 CVER               NUMBER(3,0) ,
 21 PATCHNO1           NUMBER(10,0),
 22 AUTOACTIVEVERSION  NUMBER(3,0)
 23 );

Succeed.

SQL> 
SQL> merge into t_P_BTSAUTODLDACTINFO_B8 
  2 using ( select B.rowid as row_id, A.PlanID as field0, 
  3 A.CMENEID as field1, A.ADLDACT as field2, A.AUTOTYPE as field3, A.ADVER1 as field4, A.ADVER2 as field5, A.PV as field6, A.ADMODE as field7, A.STTYPE as field8, A.MAINVER as field9, A.SUBVER as field10, 
  4 A.PATCHNO as field11, A.MONTH as field12, A.DAY as field13, A.VVER as field14, A.RVER as field15, A.CVER as field16, A.PATCHNO1 as field17, A.AUTOACTIVEVERSION as field18 from t_D_BTSAUTODLDACTINFO_B8 A, t_P_BTSAUTODLDACTINFO_B8 B 
  5 where A.PlanID = 1 and A.OperType = 4 and A.PlanID = B.PlanID
  6      and A.CMENEID = B.CMENEID and A.BTSID = B.BTSID) src 
  7 on(t_P_BTSAUTODLDACTINFO_B8.rowid = src.row_id) 
  8 when matched then update set 
  9 PlanID = src.field0, 
 10 CMENEID = src.field1, ADLDACT = src.field2, AUTOTYPE = src.field3, ADVER1 = src.field4, ADVER2 = src.field5, PV = src.field6, ADMODE = src.field7, STTYPE = src.field8, MAINVER = src.field9, SUBVER = src.field10, 
 11 PATCHNO = src.field11, MONTH = src.field12, DAY = src.field13, VVER = src.field14, RVER = src.field15, CVER = src.field16, PATCHNO1 = src.field17, AUTOACTIVEVERSION = src.field18;

0 rows affected.

SQL> 
SQL> drop table t_D_BTSAUTODLDACTINFO_B8;

Succeed.

SQL> drop table t_P_BTSAUTODLDACTINFO_B8;

Succeed.

SQL> 
SQL> create table test_update_reserved (month NUMBER(3,0), day NUMBER(3,0));

Succeed.

SQL> insert into test_update_reserved values (1, 2);

1 rows affected.

SQL> update test_update_reserved set day = 3 where month = 1;

1 rows affected.

SQL> drop table test_update_reserved;

Succeed.

SQL> 
SQL> drop table if exists update_hash_partition_table_009_2;

Succeed.

SQL> create table update_hash_partition_table_009_2(C_ID int,
  2 C_D_ID bigint,
  3 C_W_ID tinyint unsigned NOT NULL,
  4 C_FIRST VARCHAR(64) NOT NULL,
  5 C_MIDDLE CHAR(2),
  6 C_LAST VARCHAR(64),
  7 C_STREET_1 VARCHAR(20) NOT NULL,
  8 C_STREET_2 VARCHAR(20),
  9 C_CITY VARCHAR(20) NOT NULL,
 10 C_STATE CHAR(2) NOT NULL,
 11 C_ZIP CHAR(9) NOT NULL,
 12 C_PHONE CHAR(16) NOT NULL,
 13 C_SINCE TIMESTAMP,
 14 C_CREDIT CHAR(2) NOT NULL,
 15 C_CREDIT_LIM NUMERIC(12,2),
 16 C_DISCOUNT NUMERIC(4,4),
 17 C_BALANCE NUMERIC(12,2),
 18 C_YTD_PAYMENT REAL NOT NULL,
 19 C_PAYMENT_CNT NUMBER NOT NULL,
 20 C_DELIVERY_CNT BOOL NOT NULL,
 21 C_END DATE NOT NULL,
 22 C_VCHAR VARCHAR(1000),
 23 C_VARCHAR1 VARCHAR2(3000),
 24 C_VARCHAR2 VARCHAR2(3000),
 25 C_VARCHAR3 VARCHAR2(3000),
 26 C_VARCHAR4 VARCHAR2(3000),
 27 C_DATA LONG,
 28 C_TEXT BLOB,
 29 C_CLOB CLOB,
 30 C_VARCHAR5 VARCHAR2(100 BYTE) DEFAULT LPAD('AA',30,'BB'),
 31 C_FLOAT FLOAT DEFAULT 0.001,
 32 C_DOUBLE DOUBLE DEFAULT 1.001,
 33 C_DECIMAL DECIMAL DEFAULT 1.001,
 34 C_BINARY BINARY(100) DEFAULT LPAD('101',30,'201'),
 35 C_VARBINARY VARBINARY(100) DEFAULT LPAD('101',30,'201'),
 36 C_BOOLEAN BOOLEAN DEFAULT TRUE,
 37 C_LONG LONG DEFAULT LPAD('AA',100,'BB'),
 38 C_RAW RAW(100) DEFAULT LPAD('101',50,'201'),
 39 C_IMAGE IMAGE DEFAULT LPAD('101',50,'201'))
 40 partition by hash(c_d_id,c_last)
 41 (
 42 partition part_1,
 43 partition part_2,
 44 partition part_3,
 45 partition part_4,
 46 partition part_5,
 47 partition part_6,
 48 partition part_7,
 49 partition part_8
 50 );

Succeed.

SQL> INSERT INTO update_hash_partition_table_009_2 ("C_ID","C_D_ID","C_W_ID","C_FIRST","C_MIDDLE","C_LAST","C_STREET_1","C_STREET_2","C_CITY","C_STATE","C_ZIP","C_PHONE","C_SINCE","C_CREDIT","C_CREDIT_LIM","C_DISCOUNT","C_BALANCE","C_YTD_PAYMENT","C_PAYMENT_CNT","C_DELIVERY_CNT","C_END","C_VCHAR","C_VARCHAR1","C_VARCHAR2","C_VARCHAR3","C_VARCHAR4","C_DATA","C_TEXT","C_CLOB","C_VARCHAR5","C_FLOAT","C_DOUBLE","C_DECIMAL","C_BINARY","C_VARBINARY","C_BOOLEAN","C_LONG","C_RAW","C_IMAGE") values
  2   (180,106,180,'AAiscmvls','OE','106AA106106ddBA106RBAR106','bkili0fcxcle0','pmbwo0vhvpaj0','dyf0rya0','uq','48000    ','94002050        ','2018-06-29 10:51:47.000000','GC',50000,.4361,-10,10,1,TRUE,'2018-06-29 10:51:47','varchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarchar1ERTDPvarcvarachar11234D','varchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarchar2EROPHFFvarc1234WEDRvarchar2','varchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchar3ERTSFvarchvarchar321345','ABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghABfgCDefghA1234ESDFT','yxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfgdsgtcjxrbxxbmyxcfsbfacwjdafgjyjhfpyxcpmnutcjxrbxxbm','lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lob125lcobCLOr','76873890157687389015768738901576873890157687389015768738901576873890157687389015768738901576873890157687389015768738901576873890157687389015768738901576873890157687389015768124324543256546324554354325','clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clob12345clclobCLOBer','BBBBBBBBBBBBBBBBBBBBBBBBBBBBAA',0.001,1.001,1.001,0x323031323031323031323031323031323031323031323031323031313031,0x323031323031323031323031323031323031323031323031323031313031,TRUE,'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAA','20120120120120120120120120120120120120120120120101',X'3230313230313230313230313230313230313230313230313230313230313230313230313230313230313230313230313031');

1 rows affected.

SQL> update update_hash_partition_table_009_2 set (c_d_id,c_last,c_clob,c_data)=(select 106, '106AA106106ddBA106RBAR106', lpad('clobCLOBer',3000,'clob12345'), lpad('cobCLOr',200,'lob125') from dual) 
  2 where c_id = 180;

1 rows affected.

SQL> update update_hash_partition_table_009_2 set (c_d_id,c_last,c_clob,c_data)=(select 107, '106AA106106ddBA106RBAR108', lpad('clobCLOBer',3000,'clob12345'), lpad('cobCLOr',2000,'lob125') from dual),
  2 (C_CREDIT_LIM,C_VARCHAR1,C_VARCHAR2,C_VARCHAR3)=(select 108, '106AA106106ddBA106RBAR108', lpad('clobCLOBer',3000,'clob12345'), lpad('cobCLOr',2000,'lob125') from dual)
  3 where c_id = 180;

1 rows affected.

SQL> drop table update_hash_partition_table_009_2;
Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS test_null;

Succeed.

SQL> create table test_null (i int, b varchar(30), c int);

Succeed.

SQL> declare
  2 i integer;
  3 begin
  4 FOR i IN 1..500 LOOP
  5 insert into test_null values(i,'aa',i);
  6 END LOOP;
  7 END;
  8 /

PL/SQL procedure successfully completed.

SQL> update test_null set i=null,b=null,c=null;

500 rows affected.

SQL> 
SQL> declare
  2 i integer;
  3 begin
  4 FOR i IN 1..400 LOOP
  5 insert into test_null values(i,'aa',i);
  6 END LOOP;
  7 END;
  8 /

PL/SQL procedure successfully completed.

SQL> update test_null set i=null,b='bb',c=6;

900 rows affected.

SQL> rollback;

Succeed.

SQL> update test_null set i=null,b='bb',c=6;

0 rows affected.

SQL> commit;

Succeed.

SQL> DROP TABLE IF EXISTS test_null;
Succeed.




