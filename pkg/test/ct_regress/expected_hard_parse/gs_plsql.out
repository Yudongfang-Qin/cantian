

SQL> --
SQL> -- gs_plsql
SQL> -- testing procedure
SQL> --
SQL> conn / as sysdba

connected.

SQL> drop user if exists zyd1 cascade;

Succeed.

SQL> create user zyd1 identified by Cantian_234;

Succeed.

SQL> grant dba to zyd1;

Succeed.

SQL> conn zyd1/Cantian_234@127.0.0.1:1611

connected.

SQL> exec DBE_UTIL.COMPILE_SCHEMA('sys');

CT-00932, [1:2] PL/SQL(ZYD1.ANONYMOUS BLOCK) terminated with execute errors
[1:2] PL/SQL(DBE_UTIL.COMPILE_SCHEMA) terminated with execute errors
[1:2] CT-01012, Cannot recompile SYS objects, only itself

SQL> conn / as sysdba

connected.

SQL> select object_type,owner,object_name,status from DB_OBJECTS where OBJECT_NAME = 'AUD$CLEAN_AUD_LOG';

OBJECT_TYPE        OWNER                                                            OBJECT_NAME                                                      STATUS 
------------------ ---------------------------------------------------------------- ---------------------------------------------------------------- -------
PROCEDURE          SYS                                                              AUD$CLEAN_AUD_LOG                                                VALID  

1 rows fetched.

SQL> drop user if exists zyd1 cascade;

Succeed.

SQL> conn / as sysdba

connected.

SQL> create user compile_user identified by Cantian_234;

Succeed.

SQL> create user compile_user1 identified by Cantian_234;

Succeed.

SQL> grant create session to compile_user;

Succeed.

SQL> grant create session to compile_user1;

Succeed.

SQL> create table compile_user.t1(id int,name varchar(20));

Succeed.

SQL> create table compile_user1.t1(id int,name varchar(20));

Succeed.

SQL> grant select any table to compile_user;

Succeed.

SQL> grant select any table to compile_user1;

Succeed.

SQL> grant dba to compile_user;

Succeed.

SQL> grant dba to compile_user1;

Succeed.

SQL> conn compile_user1/Cantian_234@127.0.0.1:1611

connected.

SQL> create view view_t1 as select * from t1;

Succeed.

SQL> create synonym syn_view_t1 for view_t1;

Succeed.

SQL> conn compile_user/Cantian_234@127.0.0.1:1611

connected.

SQL> exec DBE_UTIL.COMPILE_SCHEMA('compile_user1');

PL/SQL procedure successfully completed.

SQL> SELECT object_type,owner,object_name,status FROM DB_objects WHERE status = 'INVALID' and owner = 'COMPILE_USER1';

OBJECT_TYPE        OWNER                                                            OBJECT_NAME                                                      STATUS 
------------------ ---------------------------------------------------------------- ---------------------------------------------------------------- -------

0 rows fetched.

SQL> conn compile_user1/Cantian_234@127.0.0.1:1611

connected.

SQL> drop table  t1 cascade constraints;

Succeed.

SQL> conn compile_user/Cantian_234@127.0.0.1:1611

connected.

SQL> exec DBE_UTIL.COMPILE_SCHEMA('compile_user1');

PL/SQL procedure successfully completed.

SQL> SELECT object_type,owner,object_name,status FROM DB_objects WHERE status = 'INVALID' and owner = 'COMPILE_USER1';

OBJECT_TYPE        OWNER                                                            OBJECT_NAME                                                      STATUS 
------------------ ---------------------------------------------------------------- ---------------------------------------------------------------- -------
VIEW               COMPILE_USER1                                                    VIEW_T1                                                          INVALID
SYNONYM            COMPILE_USER1                                                    SYN_VIEW_T1                                                      INVALID

2 rows fetched.

SQL> conn / as sysdba

connected.

SQL> drop user compile_user cascade;

Succeed.

SQL> drop user compile_user1 cascade;

Succeed.

SQL> set serveroutput on;

ON
SQL> DROP USER IF EXISTS gs_plsql1 cascade;

Succeed.

SQL> create user gs_plsql1 identified by Whf00174302;

Succeed.

SQL> grant dba to gs_plsql1;

Succeed.

SQL> DROP USER IF EXISTS gs_plsql cascade;

Succeed.

SQL> create user gs_plsql identified by Whf00174302;

Succeed.

SQL> grant dba to gs_plsql;

Succeed.

SQL> conn gs_plsql/Whf00174302@127.0.0.1:1611

connected.

SQL> 
SQL> --BEGIN: timestamp
SQL> create or replace procedure testProcWithAllTypeInputOut(datetime_type IN datetime,timestamp_type IN TIMESTAMP)
  2 as
  3 SWC_Current_1 SYS_REFCURSOR;
  4 begin
  5     open SWC_Current_1 for select datetime_type as datetime1,timestamp_type as timestamp_type1 from dual;
  6     dbe_sql.return_cursor(SWC_Current_1);
  7 commit;
  8 end;
  9 /

Succeed.

SQL> call testProcWithAllTypeInputOut('2012-12-05 19:00:00', '2012-12-05 19:00:00');

PL/SQL procedure successfully completed.

ResultSet #1

DATETIME1              TIMESTAMP_TYPE1                 
---------------------- --------------------------------
2012-12-05 19:00:00    2012-12-05 19:00:00.000000      

1 rows fetched.


SQL> drop procedure testProcWithAllTypeInputOut;

Succeed.

SQL> --END: timestamp
SQL> 
SQL> --BEGIN: test serveroutput
SQL> DROP TABLE IF EXISTS PLSQL_T_PROC_1;

Succeed.

SQL> CREATE TABLE PLSQL_T_PROC_1 (F_INT1 INT);

Succeed.

SQL> CREATE OR REPLACE FUNCTION PLSQL_Zenith_Test_Sysdate return varchar2
  2 IS
  3  cunt int := 0;
  4  Begin
  5  select count(*) into cunt from dual;
  6  dbe_output.print_line(cunt);
  7  IF SQL % FOUND
  8   then
  9  return cunt;
 10  end if;
 11  End PLSQL_Zenith_Test_Sysdate;
 12 /

Succeed.

SQL> 
SQL> --select
SQL> select PLSQL_Zenith_Test_Sysdate() from dual;

PLSQL_ZENITH_TEST_SYSDATE()                                     
----------------------------------------------------------------
1                                                               

1 rows fetched.

1

SQL> --insert/delete/update
SQL> insert into PLSQL_T_PROC_1(f_int1) values(PLSQL_Zenith_Test_Sysdate());

1

1 rows affected.

SQL> update PLSQL_T_PROC_1 set f_int1=PLSQL_Zenith_Test_Sysdate() where f_int1=PLSQL_Zenith_Test_Sysdate();

1
1

1 rows affected.

SQL> delete from PLSQL_T_PROC_1 where f_int1=PLSQL_Zenith_Test_Sysdate();

1

1 rows affected.

SQL> drop table PLSQL_T_PROC_1;

Succeed.

SQL> 
SQL> --END: test serveroutput
SQL> 
SQL> --BEGIN: TEST OUT PARAM
SQL> CREATE OR REPLACE PROCEDURE PLSQL_Zenith_Test_004(param1 out varchar2)
  2 IS
  3     tmp varchar2(20) :='12345678';
  4 begin
  5  param1:=param1||tmp;
  6 end PLSQL_Zenith_Test_004;
  7 /

Succeed.

SQL> 
SQL> Declare
  2     v_char1 char(9) :='A';
  3 begin
  4     PLSQL_Zenith_Test_004(v_char1);
  5     dbe_output.print_line('OUT PUT RESULT:'||v_char1);
  6 end;
  7 /

OUT PUT RESULT:12345678 

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE PLSQL_Zenith_Test_004(param1 out varchar2)
  2 IS
  3     tmp varchar2(20) :='12345678';
  4 begin
  5     dbe_output.print_line('OUT PUT RESULT:'||param1);
  6 end PLSQL_Zenith_Test_004;
  7 /

Succeed.

SQL> 
SQL> 
SQL> Declare
  2     v_char1 char(9) :='A';
  3 begin
  4     PLSQL_Zenith_Test_004(v_char1);
  5     dbe_output.print_line('OUT PUT RESULT:'||v_char1);
  6 end;
  7 /

OUT PUT RESULT:
OUT PUT RESULT:

PL/SQL procedure successfully completed.

SQL> 
SQL> --END: TEST OUT PARAM
SQL> 
SQL> --BEGIN:TEST ERROR, not allow to appear column
SQL> begin
  2 dbe_output.print_line("-------------------");
  3 end;
  4 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:23] PLC-00601 Sql syntax error: invalid column name '-------------------'

SQL> --END
SQL> 
SQL> --BEGIN: TEST SQL%ROWCOUNT
SQL> DROP TABLE IF EXISTS PLSQL_T_PROC_1;

Succeed.

SQL> DROP TABLE IF EXISTS PLSQL_T_PROC_2;

Succeed.

SQL> CREATE TABLE PLSQL_T_PROC_1 (F_INT1 INT, F_INT2 INT);

Succeed.

SQL> CREATE TABLE PLSQL_T_PROC_2 (F_INT1 INT, F_INT2 INT);

Succeed.

SQL> 
SQL> DECLARE
  2 A INT;
  3 B INT;
  4 BEGIN
  5 	INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(12);
  6 	INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(12);
  7 	A := SQL%ROWCOUNT;
  8 	EXECUTE IMMEDIATE 'DELETE FROM PLSQL_T_PROC_1';
  9 	B := SQL%ROWCOUNT;
 10 	INSERT INTO PLSQL_T_PROC_2(F_INT1,F_INT2) VALUES(A,B);
 11 END;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> SELECT * FROM PLSQL_T_PROC_1;

F_INT1       F_INT2      
------------ ------------

0 rows fetched.

SQL> SELECT * FROM PLSQL_T_PROC_2;

F_INT1       F_INT2      
------------ ------------
1            2           

1 rows fetched.

SQL> 
SQL> 
SQL> DELETE FROM PLSQL_T_PROC_1;

0 rows affected.

SQL> DELETE FROM PLSQL_T_PROC_2;

1 rows affected.

SQL> 
SQL> DECLARE
  2 A INT;
  3 B INT;
  4 BEGIN
  5 	EXECUTE IMMEDIATE 'INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(12)';
  6 	A := SQL%ROWCOUNT;
  7 	INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(12);
  8 	DELETE FROM PLSQL_T_PROC_1;
  9 	B := SQL%ROWCOUNT;
 10 	INSERT INTO PLSQL_T_PROC_2(F_INT1,F_INT2) VALUES(A,B);
 11 END;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> SELECT * FROM PLSQL_T_PROC_1;

F_INT1       F_INT2      
------------ ------------

0 rows fetched.

SQL> SELECT * FROM PLSQL_T_PROC_2;

F_INT1       F_INT2      
------------ ------------
1            2           

1 rows fetched.

SQL> 
SQL> 
SQL> DELETE FROM PLSQL_T_PROC_1;

0 rows affected.

SQL> DELETE FROM PLSQL_T_PROC_2;

1 rows affected.

SQL> 
SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(1);

1 rows affected.

SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(2);

1 rows affected.

SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(3);

1 rows affected.

SQL> 
SQL> DECLARE
  2 A INT;
  3 B INT;
  4 BEGIN
  5 	UPDATE PLSQL_T_PROC_1 SET F_INT1 = 2 WHERE F_INT1 = 1;
  6 	A := SQL%ROWCOUNT;
  7 	EXECUTE IMMEDIATE 'UPDATE PLSQL_T_PROC_1 SET F_INT1 = 3 WHERE F_INT1 = 2';
  8 	B := SQL%ROWCOUNT;
  9 	INSERT INTO PLSQL_T_PROC_2(F_INT1,F_INT2) VALUES(A,B);
 10 END;
 11 /

PL/SQL procedure successfully completed.

SQL> 
SQL> SELECT * FROM PLSQL_T_PROC_1;

F_INT1       F_INT2      
------------ ------------
3                        
3                        
3                        

3 rows fetched.

SQL> SELECT * FROM PLSQL_T_PROC_2;

F_INT1       F_INT2      
------------ ------------
1            2           

1 rows fetched.

SQL> 
SQL> 
SQL> DELETE FROM PLSQL_T_PROC_1;

3 rows affected.

SQL> DELETE FROM PLSQL_T_PROC_2;

1 rows affected.

SQL> 
SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(1);

1 rows affected.

SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(2);

1 rows affected.

SQL> INSERT INTO PLSQL_T_PROC_1(F_INT1) VALUES(3);

1 rows affected.

SQL> 
SQL> DECLARE
  2 A INT;
  3 B INT;
  4 BEGIN
  5 	MERGE INTO PLSQL_T_PROC_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_INT1 = 2;
  6 	A := SQL%ROWCOUNT;
  7 	EXECUTE IMMEDIATE 'MERGE INTO PLSQL_T_PROC_1 USING DUAL ON (1=0) WHEN NOT MATCHED THEN INSERT (F_INT1) VALUES(1)';
  8 	B := SQL%ROWCOUNT;
  9 	INSERT INTO PLSQL_T_PROC_2(F_INT1,F_INT2) VALUES(A,B);
 10 END;
 11 /

PL/SQL procedure successfully completed.

SQL> 
SQL> SELECT * FROM PLSQL_T_PROC_1;

F_INT1       F_INT2      
------------ ------------
2                        
2                        
2                        
1                        

4 rows fetched.

SQL> SELECT * FROM PLSQL_T_PROC_2;

F_INT1       F_INT2      
------------ ------------
3            1           

1 rows fetched.

SQL> COMMIT;

Succeed.

SQL> --EDN: TEST SQL%ROWCOUNT
SQL> 
SQL> --BEGIN:TEST Case sensitivity
SQL> drop table if exists "plsql_t1";

Succeed.

SQL> create table "plsql_t1" ("f1" int, "f2" int);

Succeed.

SQL> insert into "plsql_t1" values(1,2);

1 rows affected.

SQL> insert into "plsql_t1" values(2,3);

1 rows affected.

SQL> insert into "plsql_t1" values(3,4);

1 rows affected.

SQL> declare
  2 a int;
  3 Begin
  4 select "f1" into a from "plsql_t1" order by "f1" limit 1;
  5 dbe_output.print_line(a);
  6 select max("f1") into a from "plsql_t1";
  7 dbe_output.print_line(a);
  8 select "f1" into a from "plsql_t1" where "f1" = 2;
  9 dbe_output.print_line(a);
 10 End;
 11 /

1
3
2

PL/SQL procedure successfully completed.

SQL> --END:Case sensitivity 
SQL> 
SQL> --test 'bool var = cond'
SQL> declare
  2    v_bool boolean;
  3 begin
  4   v_bool:=(1+2+3+4+5=3*5);
  5 	if(v_bool)
  6 	then
  7      dbe_output.print_line('The condition is true');
  8   end if;
  9 end;
 10 /

The condition is true

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> declare
  2 v_sal int;
  3 begin
  4 v_sal := 1;
  5 v_sal := v_sal + 1;
  6 dbe_output.print_line('value1:'||v_sal);
  7 if v_sal < 2 then
  8    dbe_output.print_line('value2:'||v_sal);
  9 elsif v_sal = 2 then
 10    if v_sal != 2 then
 11      dbe_output.print_line('value3:'||v_sal);
 12    else
 13      dbe_output.print_line('value3x:'||v_sal);
 14    end if;
 15 elsif v_sal = 4 then
 16    dbe_output.print_line('value4:'||v_sal);
 17 else
 18    dbe_output.print_line('value5:'||v_sal);
 19 end if;
 20 dbe_output.print_line('value6:'||(v_sal+2));
 21 end;
 22 /

value1:2
value3x:2
value6:4

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v_sal int;
  3 begin
  4 v_sal := 1;
  5 case v_sal
  6 when v_sal+1 then
  7   v_sal := v_sal + 1;
  8   dbe_output.print_line('value1:'||v_sal);
  9 when v_sal+2 then
 10   v_sal := v_sal + 3;
 11   dbe_output.print_line('value1X:'||v_sal);  
 12 else
 13   v_sal := v_sal + 2;
 14   dbe_output.print_line('value2:'||v_sal);
 15 end case;
 16 end;
 17 /

value2:3

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 x NUMBER;
  3 BEGIN
  4 x := 0;
  5 LOOP
  6   dbe_output.print_line ('Inside loop: x = ' || x);
  7   x := x + 1;
  8   IF x > 3 THEN
  9      dbe_output.print_line(' BEGIN EXIT ');
 10      EXIT WHEN x > 4;
 11      dbe_output.print_line(' AFTER EXIT ');
 12   END IF;
 13 END LOOP;
 14 dbe_output.print_line(' After loop: x = ' || x);
 15 END;
 16 /

Inside loop: x = 0
Inside loop: x = 1
Inside loop: x = 2
Inside loop: x = 3
 BEGIN EXIT 
 AFTER EXIT 
Inside loop: x = 4
 BEGIN EXIT 
 After loop: x = 5

PL/SQL procedure successfully completed.

SQL> 
SQL> <<main>>
  2 DECLARE
  3 x NUMBER;
  4 BEGIN
  5 x := 0;
  6 goto outer_loop;
  7 x := 100;
  8 <<outer_loop>>
  9 LOOP
 10 dbe_output.print_line(' outer in ');
 11 <<inner_loop>>
 12 LOOP
 13   dbe_output.print_line ('Inside loop: x = ' || x);
 14   x := x + 1;
 15   IF x > 3 THEN
 16      dbe_output.print_line(' BEGIN EXIT ');
 17      EXIT inner_loop WHEN x > 4;
 18      dbe_output.print_line(' AFTER EXIT ');
 19   else
 20      continue inner_loop when x > 1;
 21   END IF;
 22   dbe_output.print_line(' after continue ');
 23     END LOOP; 
 24   dbe_output.print_line(' outer_loop ');
 25   EXIT outer_loop;
 26 END LOOP;
 27 dbe_output.print_line(' After loop: x = ' || x);
 28 if x < 6 then
 29 goto inner_loop;
 30 end if;
 31 END;
 32 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[29:1] PLC-00916 PL/SQL:syntax error(INNER_LOOP is an invalid label(not in equal ctl_block))

SQL> 
SQL> DECLARE
  2 x NUMBER;
  3 BEGIN
  4 x := 0;
  5 while x <= 1 LOOP
  6 dbe_output.print_line ('here:' || x);
  7 x := x + 1;
  8 END LOOP;
  9 END;
 10 /

here:0
here:1

PL/SQL procedure successfully completed.

SQL> 
SQL> Declare
  2 x bool;
  3 BEGIN
  4 x := FALSE;
  5 FOR i IN x..3 LOOP
  6 if i > 2 then
  7 dbe_output.print_line ('here:' || i);
  8 else
  9 dbe_output.print_line ('there:' || i);
 10 end if;
 11 END LOOP;
 12 dbe_output.print_line ('x:' || x);
 13 END;
 14 /

CT-00932, [5:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[5:1] CT-00916, PL/SQL:syntax error(unsupport range type in for statement.)

SQL> 
SQL> Declare
  2 x bool;
  3 BEGIN
  4 x := FALSE;
  5 FOR i IN 1..3 LOOP
  6 dbe_output.print_line ('here:' || i);
  7 END LOOP;
  8 dbe_output.print_line ('x:' || x);
  9 END;
 10 /

here:1
here:2
here:3
x:FALSE

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists test;

Succeed.

SQL> create table test(a1 int);

Succeed.

SQL> insert into test values(10);

1 rows affected.

SQL> 
SQL> declare
  2 a int;
  3 begin
  4 a := 1;
  5 update test set a1 = a1 + 11 where a = 1;
  6 delete from test where a1 = 1;
  7 select * into a from test limit 1;
  8 commit;
  9 dbe_output.print_line ('result is:' || a);
 10 end;
 11 /

result is:21

PL/SQL procedure successfully completed.

SQL> 
SQL> select * from test order by a1;

A1          
------------
21          

1 rows fetched.

SQL> 
SQL> declare
  2 a int;
  3 begin
  4 a := 1;
  5 MERGE INTO test USING DUAL ON (a1 = 2) WHEN NOT MATCHED THEN INSERT (a1) VALUES(2);
  6 commit;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select * from test;

A1          
------------
21          
2           

2 rows fetched.

SQL> 
SQL> --test stack
SQL> drop table if exists plsql_Utils_CheckPoint;

Succeed.

SQL> create table plsql_Utils_CheckPoint(
  2 PlanID number(10, 0) not null ,
  3 Tag varchar2(150) not null
  4 );

Succeed.

SQL> 
SQL> create or replace procedure plsql_sp_LockFor (
  2 v_PlanID in number ,
  3 v_Tag in varchar2 )
  4 as
  5 v_flag number(10, 0);
  6 loop_num int := 0;
  7 begin
  8 insert into plsql_Utils_CheckPoint
  9 select v_PlanID, v_Tag from dual where not exists ( select 1 from plsql_Utils_CheckPoint where PlanID = v_PlanID and Tag = v_Tag ) ;
 10 commit;
 11 v_flag := 1;
 12 while (loop_num < 10000)
 13 loop
 14  begin
 15 	 begin
 16 		 select count( 1 ) into v_flag from plsql_Utils_CheckPoint where PlanID = v_PlanID and Tag = v_Tag;
 17 		 exception
 18 		 when no_data_found then
 19 		 null;
 20 	 end;
 21 	 begin loop_num := loop_num + 1; end;
 22  end;
 23 end loop;
 24 dbe_output.print_line ('loop number: ' || loop_num);
 25 end;
 26 /

Succeed.

SQL> 
SQL> insert into plsql_Utils_CheckPoint values (32, 'tag_jfj');

1 rows affected.

SQL> call plsql_sp_LockFor(32, 'tag_jfj');

loop number: 10000

PL/SQL procedure successfully completed.

SQL> --test stack
SQL> 
SQL> --test case-when expr
SQL> --add 2018/07/09
SQL> drop table if exists plsql_tab_test_case_when;

Succeed.

SQL> create table plsql_tab_test_case_when
  2 (
  3 id number,
  4 score number
  5 );

Succeed.

SQL> 
SQL> insert into plsql_tab_test_case_when values(1,1);

1 rows affected.

SQL> insert into plsql_tab_test_case_when values(2,2);

1 rows affected.

SQL> insert into plsql_tab_test_case_when values(3,3);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select id , case score when 1 then 1 else 0 end  from plsql_tab_test_case_when order by id;

ID                                       CASE SCORE WHEN 1 THEN 1 ELSE 0 END
---------------------------------------- -----------------------------------
1                                        1                                  
2                                        0                                  
3                                        0                                  

3 rows fetched.

SQL> select id , case score when 1 then 1 end  from plsql_tab_test_case_when order by id;

ID                                       CASE SCORE WHEN 1 THEN 1 END
---------------------------------------- ----------------------------
1                                        1                           
2                                                                    
3                                                                    

3 rows fetched.

SQL> 
SQL> insert into plsql_tab_test_case_when values(4,null);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select id , case score when 1 then 1 when null then 2 end  from plsql_tab_test_case_when order by id;

ID                                       CASE SCORE WHEN 1 THEN 1 WHEN NULL THEN 2 END
---------------------------------------- ---------------------------------------------
1                                        1                                            
2                                                                                     
3                                                                                     
4                                                                                     

4 rows fetched.

SQL> 
SQL> 
SQL> DECLARE
  2     grade CHAR(1) := 'B';
  3     appraisal VARCHAR2(20);
  4 BEGIN     
  5     appraisal := CASE grade
  6             WHEN 'A' THEN  'Excellent'
  7             WHEN 'B' THEN  'Very Good'
  8             WHEN 'C' THEN  'Good'
  9             WHEN 'D' THEN  'Fair'
 10             WHEN 'F' THEN  'Poor'
 11             ELSE 'No such grade'
 12         END ;
 13     dbe_output.print_line(appraisal);
 14 END;
 15 /

Very Good

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2     grade CHAR(1) := 'E';
  3     appraisal VARCHAR2(20);
  4 BEGIN
  5     appraisal := CASE
  6             WHEN grade = 'A' THEN  'Excellent'
  7             WHEN grade = 'B' THEN  'Very Good'
  8             WHEN grade = 'C' THEN  'Good'
  9             WHEN grade = 'D' THEN  'Fair'
 10             WHEN grade = 'F' THEN  'Poor'
 11             ELSE 'No such grade'
 12         END ;
 13     dbe_output.print_line(appraisal);
 14 END;
 15 /

No such grade

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2     grade CHAR(1) := 'B';
  3     appraisal VARCHAR2(20);
  4 BEGIN    
  5         CASE grade
  6             WHEN 'A' THEN appraisal := 'Excellent';
  7             WHEN 'B' THEN appraisal := 'Very Good';
  8             WHEN 'B' THEN appraisal := 'Good';
  9             WHEN 'D' THEN appraisal := 'Fair';
 10             WHEN 'F' THEN appraisal := 'Poor';
 11             ELSE appraisal := 'No such grade';
 12         END CASE;
 13     dbe_output.print_line(appraisal);
 14 END;
 15 /

Very Good

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2     grade CHAR(1) := 'B';
  3     appraisal VARCHAR2(20);
  4 BEGIN    
  5         CASE 
  6             WHEN grade = 'A' THEN appraisal := 'Excellent';
  7             WHEN grade = 'B' THEN appraisal := 'Very Good';
  8             WHEN grade = 'C' THEN appraisal := 'Good';
  9             WHEN grade = 'D' THEN appraisal := 'Fair';
 10             WHEN grade = 'F' THEN appraisal := 'Poor';
 11             ELSE appraisal := 'No such grade';
 12         END CASE;
 13     dbe_output.print_line(appraisal);
 14 END;
 15 /

Very Good

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2     grade CHAR(1) := 'B';
  3     appraisal VARCHAR2(20);
  4 BEGIN    
  5         CASE grade
  6             WHEN 'A' THEN appraisal := 'Excellent';            
  7             WHEN 'C' THEN appraisal := 'Good';
  8             WHEN 'D' THEN appraisal := 'Fair';
  9             WHEN 'F' THEN appraisal := 'Poor';            
 10         END CASE;
 11     dbe_output.print_line(appraisal);
 12 END;
 13 /

CT-00932, [9:13] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[9:13] CT-00902, The declaration of CASE was not found when the CASE statement was executed.

SQL> 
SQL> --test for cursor
SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test(a int, b bigint, c char(10), d varchar(20), e bool);

Succeed.

SQL> insert into plsql_test (a, b) values(1,200);

1 rows affected.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 a1 := 1;
  5 update plsql_test set a = a + 11 where a = 1;
  6 delete from plsql_test where a = a1;
  7 select a as a1 into a1 from plsql_test;
  8 dbe_output.print_line('result is ' || a1);
  9 commit;
 10 end;
 11 /

result is 12

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 a1 := 1;
  5 insert into plsql_test (a, b) values(2,201);
  6 select a into a1 from plsql_test;
  7 dbe_output.print_line('result is ' || a1);
  8 commit;
  9 end;
 10 /

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:1] CT-00915, More than one return value of SELECT INTO, EXECUTE IMMEDIATE, or a cursor was assigned to a common variable.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 a1 := 1;
  5 select a into a1 from plsql_test limit 1;
  6 dbe_output.print_line('result is ' || a1);
  7 commit;
  8 end;
  9 /

result is 12

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 a1 := 1;
  5 delete from plsql_test;
  6 select a into a1 from plsql_test;
  7 dbe_output.print_line('result is ' || a1);
  8 commit;
  9 end;
 10 /

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:1] CT-00906, In PL/SQL, running SELECT INTO or EXECUTE IMMEDIATE INTO to grant values to variables had no data found.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 a1 := 1;
  5 insert into plsql_test (a, b) values(2,201);
  6 select * into a1 from plsql_test;
  7 dbe_output.print_line('result is ' || a1);
  8 commit;
  9 end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[6:1] PLC-00926 PL/SQL: Return types of Result Set variables or query do not match

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 b int;
  3 cursor c1(xx int default 10) is select a from plsql_test where a = xx;
  4 begin
  5 open c1(20);
  6 FETCH c1 into b;
  7 dbe_output.print_line('result is:' || b);
  8 FETCH c1 into b;
  9 dbe_output.print_line('result is:' || b);
 10 close c1;
 11 end;
 12 /

result is:
result is:

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> declare
  2 b1 int;
  3 cursor c1 is select a from plsql_test;
  4 begin
  5 delete from plsql_test;
  6 insert into plsql_test (a, b) values(1,100);
  7 insert into plsql_test (a, b) values(2,100);
  8 insert into plsql_test (a, b) values(2,201);
  9 open c1;
 10 FETCH c1 into b1;
 11 dbe_output.print_line('result is:' || b1);
 12 FETCH c1 into b1;
 13 dbe_output.print_line('result is:' || b1);
 14 FETCH c1 into b1;
 15 dbe_output.print_line('result is:' || b1);
 16 FETCH c1 into b1;
 17 dbe_output.print_line('result is:' || b1);
 18 close c1;
 19 end;
 20 /

result is:1
result is:2
result is:2
result is:2

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> declare
  2 b int;
  3 cursor c1(xx int default 10) is select a from plsql_test where a = xx;
  4 begin
  5 delete from plsql_test;
  6 open c1;
  7 FETCH c1 into b;
  8 dbe_output.print_line('result is:' || b);
  9 FETCH c1 into b;
 10 dbe_output.print_line('result is:' || b);
 11 close c1;
 12 end;
 13 /

result is:
result is:

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 b int;
  3 c1 sys_refcursor;
  4 begin
  5 delete from plsql_test;
  6 open c1 for select a from plsql_test;
  7 FETCH c1 into b;
  8 dbe_output.print_line('result is:' || b);
  9 FETCH c1 into b;
 10 dbe_output.print_line('result is:' || b);
 11 close c1;
 12 end;
 13 /

result is:
result is:

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> declare
  2 b int;
  3 c1 sys_refcursor;
  4 begin
  5 delete from plsql_test;
  6 open c1;
  7 FETCH c1 into b;
  8 dbe_output.print_line('result is:' || b);
  9 FETCH c1 into b;
 10 dbe_output.print_line('result is:' || b);
 11 close c1;
 12 end;
 13 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[6:8] PLC-00601 Sql syntax error: FOR expected

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> declare
  2 b int;
  3 c1 sys_refcursor;
  4 begin
  5 delete from plsql_test;
  6 insert into plsql_test (a) values(100);
  7 insert into plsql_test (a) values(101);
  8 open c1 for select a from plsql_test;
  9 FETCH c1 into b;
 10 dbe_output.print_line('result is:' || b);
 11 FETCH c1 into b;
 12 dbe_output.print_line('result is:' || b);
 13 close c1;
 14 end;
 15 /

result is:100
result is:101

PL/SQL procedure successfully completed.

SQL> 
SQL> select * from plsql_test;

A            B                    C          D                    E     
------------ -------------------- ---------- -------------------- ------
100                                                                     
101                                                                     

2 rows fetched.

SQL> delete from plsql_test;

2 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> --BEGIN:TEST
SQL> drop table if exists plsql_t1;

Succeed.

SQL> create table plsql_t1 (f1 int, f2 varchar(100));

Succeed.

SQL> insert into plsql_t1 values (1, 'a'), (2, 'b'), (3, 'c');

3 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create or replace procedure plsql_p1()
  2 as
  3 a int := 10;
  4 c4 SYS_REFCURSOR;
  5 begin
  6 open c4 for select * from plsql_t1 where f1 < a order by f1;
  7 dbe_sql.return_cursor(c4);
  8 end;
  9 /

Succeed.

SQL> 
SQL> call plsql_p1();

PL/SQL procedure successfully completed.

ResultSet #1

F1           F2                                                              
------------ ----------------------------------------------------------------
1            a                                                               
2            b                                                               
3            c                                                               

3 rows fetched.


SQL> drop table plsql_t1;

Succeed.

SQL> call plsql_p1();

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00944 PL/SQL(GS_PLSQL.PLSQL_P1) terminated with compiling errors
[6:27] PLC-00843 The table or view GS_PLSQL.PLSQL_T1 does not exist.


SQL> create table plsql_t1 (f1 int, f2 varchar(100));

Succeed.

SQL> call plsql_p1();

PL/SQL procedure successfully completed.

ResultSet #1

F1           F2                                                              
------------ ----------------------------------------------------------------

0 rows fetched.


SQL> --END
SQL> 
SQL> --test exec/execute procedure
SQL> --2018/6/16
SQL> drop table if exists plsql_test_pro_t1;

Succeed.

SQL> create table plsql_test_pro_t1(f1 int, f2 varchar2(20));

Succeed.

SQL> 
SQL> drop function if exists plsql_test_p1;

Succeed.

SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1(a int, b varchar2)
  2 as
  3 c int := 1;
  4 d int := 2;
  5 begin
  6   insert into plsql_test_pro_t1 values(a,b);
  7   commit;
  8 end;
  9 /

Succeed.

SQL> 
SQL> --expect success
SQL> exec plsql_test_p1(100,'sss');

PL/SQL procedure successfully completed.

SQL> execute plsql_test_p1(101,'sss'); 

PL/SQL procedure successfully completed.

SQL> call plsql_test_p1(101,'sss'); 

PL/SQL procedure successfully completed.

SQL> 
SQL> select f1, f2 from plsql_test_pro_t1 order by f1, f2;

F1           F2                  
------------ --------------------
100          sss                 
101          sss                 
101          sss                 

3 rows fetched.

SQL> 
SQL> --expect error
SQL> exec plsql_test_noexist_p1(100,'sss');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.PLSQL_TEST_NOEXIST_P1 does not exist

SQL> execute plsql_test_noexist_p1(101,'sss'); 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.PLSQL_TEST_NOEXIST_P1 does not exist

SQL> call plsql_test_noexist_p1(101,'sss'); 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.PLSQL_TEST_NOEXIST_P1 does not exist

SQL> call plsql_test_noexist_p1(101,'sss') abc; 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:35] PLC-00954 ';' or ':=' expected but abc found

SQL> call plsql_test_noexist_p1(101,'sss') abc(); 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:35] PLC-00954 ';' or ':=' expected but abc found

SQL> 
SQL> --unsupport without brackets when procedure has no arguments.
SQL> --create success
SQL> create or replace procedure plsql_test_p2
  2 as
  3 begin
  4   insert into plsql_test_pro_t1 values(1,'a');
  5   commit;
  6 end;
  7 /

Succeed.

SQL> --expect succ
SQL> exec plsql_test_p2;

PL/SQL procedure successfully completed.

SQL> execute plsql_test_p2;

PL/SQL procedure successfully completed.

SQL> call plsql_test_p2;

PL/SQL procedure successfully completed.

SQL> --expect success
SQL> exec plsql_test_p2();

PL/SQL procedure successfully completed.

SQL> execute plsql_test_p2();

PL/SQL procedure successfully completed.

SQL> call plsql_test_p2();

PL/SQL procedure successfully completed.

SQL> 
SQL> select f1, f2 from plsql_test_pro_t1 order by f1, f2;

F1           F2                  
------------ --------------------
1            a                   
1            a                   
1            a                   
1            a                   
1            a                   
1            a                   
100          sss                 
101          sss                 
101          sss                 

9 rows fetched.

SQL> 
SQL> drop table if exists plsql_test_pro_t1;

Succeed.

SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> drop procedure if exists plsql_test_p2;

Succeed.

SQL> 
SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  5 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
  6 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
  7 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
  8 end;
  9 /

SQL%ISOPEN :FALSE
SQL%FOUND :
SQL%NOTFOUND :
SQL%ROWCOUNT :

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 delete from plsql_test;
  5 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  6 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
  7 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
  8 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
  9 dbe_output.print_line('%ROWCOUNT :' || SQL%xxxx);
 10 end;
 11 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[9:40] PLC-00601 Sql syntax error: invalid column name 'SQL'

SQL> 
SQL> begin
  2 delete from plsql_test;
  3 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  4 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
  5 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
  6 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
  7 end;
  8 /

SQL%ISOPEN :FALSE
SQL%FOUND :FALSE
SQL%NOTFOUND :TRUE
SQL%ROWCOUNT :0

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a1 int;
  3 begin
  4 delete from plsql_test;
  5 insert into plsql_test (a) values (1);
  6 select a into a1 from plsql_test;
  7 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  8 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
  9 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 10 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 11 end;
 12 /

SQL%ISOPEN :FALSE
SQL%FOUND :TRUE
SQL%NOTFOUND :FALSE
SQL%ROWCOUNT :1

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 cursor a1 is select a from plsql_test;
  3 begin
  4 dbe_output.print_line('%ISOPEN :' || a1%ISOPEN);
  5 dbe_output.print_line('%FOUND :' || a1%FOUND);
  6 end;
  7 /

%ISOPEN :FALSE
CT-00932, [5:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[5:1] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00905, The cursor was invalid.

SQL> declare
  2 cursor a1 is select a from plsql_test;
  3 begin
  4 dbe_output.print_line('%ISOPEN :' || a1%ISOPEN);
  5 dbe_output.print_line('%NOTFOUND :' || a1%NOTFOUND);
  6 end;
  7 /

%ISOPEN :FALSE
CT-00932, [5:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[5:1] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00905, The cursor was invalid.

SQL> declare
  2 cursor a1 is select a from plsql_test;
  3 begin
  4 dbe_output.print_line('%ISOPEN :' || a1%ISOPEN);
  5 dbe_output.print_line('%ROWCOUNT :' || a1%ROWCOUNT);
  6 end;
  7 /

%ISOPEN :FALSE
CT-00932, [5:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[5:1] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00905, The cursor was invalid.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> delete from plsql_test;

1 rows affected.

SQL> declare
  2 cursor a1 is select a from plsql_test;
  3 begin
  4 open a1;
  5 dbe_output.print_line('%ISOPEN :' || a1%ISOPEN);
  6 dbe_output.print_line('%FOUND :' || a1%FOUND);
  7 dbe_output.print_line('%NOTFOUND :' || a1%NOTFOUND);
  8 dbe_output.print_line('%ROWCOUNT :' || a1%ROWCOUNT);
  9 close a1;
 10 end;
 11 /

%ISOPEN :TRUE
%FOUND :
%NOTFOUND :
%ROWCOUNT :

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 b int;
  3 cursor a1 is select a from plsql_test;
  4 begin
  5 open a1;
  6 fetch a1 into b;
  7 dbe_output.print_line('%OPEN :' || a1%ISOPEN);
  8 dbe_output.print_line('%FOUND :' || a1%FOUND);
  9 dbe_output.print_line('%NOTFOUND :' || a1%NOTFOUND);
 10 dbe_output.print_line('%ROWCOUNT :' || a1%ROWCOUNT);
 11 close a1;
 12 end;
 13 /

%OPEN :TRUE
%FOUND :FALSE
%NOTFOUND :TRUE
%ROWCOUNT :0

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 b int;
  3 cursor a1 is select a from plsql_test;
  4 begin
  5 open a1;
  6 fetch a1 into b;
  7 dbe_output.print_line('%OPEN :' || a1%ISOPEN);
  8 dbe_output.print_line('%FOUND :' || a1%FOUND);
  9 dbe_output.print_line('%NOTFOUND :' || a1%NOTFOUND);
 10 dbe_output.print_line('%ROWCOUNT :' || a1%ROWCOUNT);
 11 dbe_output.print_line('%ROWCOUNT :' || a1%xxxx);
 12 end;
 13 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[11:40] PLC-00601 Sql syntax error: unexpected cursor type

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --record.
SQL> 
SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 type yyy is record (
  7   a xxx
  8 );
  9 ab yyy;
 10 abc xxx;
 11 begin
 12 delete from plsql_test;
 13 insert into plsql_test (a,b) values(1,100);
 14 select a,b into ab from plsql_test;
 15 dbe_output.print_line('result is ' || ab.a.a);
 16 dbe_output.print_line('result is ' || ab.a.b);
 17 end;
 18 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[14:1] PLC-00926 PL/SQL: Return types of Result Set variables or query do not match

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 type yyy is record (
  7   a xxx
  8 );
  9 ab yyy;
 10 abc xxx;
 11 begin
 12 delete from plsql_test;
 13 insert into plsql_test (a,b) values(1,100);
 14 select a,b into abc from plsql_test;
 15 dbe_output.print_line('result is ' || abc.a);
 16 dbe_output.print_line('result is ' || abc.b);
 17 select a,b into ab.a from plsql_test;
 18 dbe_output.print_line('result is ' || ab.a.a);
 19 dbe_output.print_line('result is ' || ab.a.b);
 20 end;
 21 /

result is 1
result is 100
result is 1
result is 100

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 type yyy is record (
  7   a xxx
  8 );
  9 ab yyy;
 10 abc xxx;
 11 cursor c1 is select a,b from plsql_test order by a;
 12 begin
 13 delete from plsql_test;
 14 insert into plsql_test (a,b) values(1,100);
 15 insert into plsql_test (a,b) values(2,101);
 16 open c1;
 17 fetch c1 into abc;
 18 dbe_output.print_line('result is ' || abc.a);
 19 dbe_output.print_line('result is ' || abc.b);
 20 close c1;
 21 end;
 22 /

result is 1
result is 100

PL/SQL procedure successfully completed.

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 type yyy is record (
  7   a xxx
  8 );
  9 ab yyy;
 10 abc xxx;
 11 cursor c1 is select a,b from plsql_test order by a;
 12 begin
 13 delete from plsql_test;
 14 insert into plsql_test (a,b) values(1,100);
 15 insert into plsql_test (a,b) values(2,101);
 16 open c1;
 17 fetch c1 into ab;
 18 dbe_output.print_line('result is ' || ab.a.a);
 19 dbe_output.print_line('result is ' || ab.a.b);
 20 close c1;
 21 end;
 22 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[17:1] PLC-00926 PL/SQL: Return types of Result Set variables or query do not match

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 type yyy is record (
  7   a xxx
  8 );
  9 ab yyy;
 10 cursor c1 is select a from plsql_test order by a;
 11 begin
 12 open c1;
 13 fetch c1 into ab.a.a;
 14 dbe_output.print_line('result is ' || ab.a.a);
 15 dbe_output.print_line('result is ' || ab.a.b);
 16 close c1;
 17 end;
 18 /

result is 1
result is 

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 ab xxx;
  7 abc ab%type;
  8 begin
  9 delete from plsql_test;
 10 insert into plsql_test (a,b) values(1,100);
 11 select a,b into abc from plsql_test order by a;
 12 dbe_output.print_line('result is ' || abc.a);
 13 dbe_output.print_line('result is ' || abc.b);
 14 end;
 15 /

result is 1
result is 100

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 ab xxx;
  7 abc ab.a%type;
  8 begin
  9 delete from plsql_test;
 10 insert into plsql_test (a,b) values(1,100);
 11 select a into abc from plsql_test;
 12 dbe_output.print_line('result is ' || abc);
 13 end;
 14 /

result is 1

PL/SQL procedure successfully completed.

SQL> --expect error
SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 cursor a1 is select a,b from plsql_test order by a;
  7 abc a1%type;
  8 ab  xxx;
  9 begin
 10 open abc;
 11 fetch abc into ab;
 12 dbe_output.print_line('result is ' || ab.a);
 13 dbe_output.print_line('result is ' || ab.b);
 14 close abc;
 15 end;
 16 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[7:5] PLC-00941 'GS_PLSQL.a1'.TYPE was not a variable, column, or attribute.

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 cursor a1 is select a,b from plsql_test order by a;
  7 abc a1%type;
  8 ab  xxx;
  9 begin
 10 open abc;
 11 fetch abc into ab;
 12 dbe_output.print_line('result is ' || ab.a);
 13 dbe_output.print_line('result is ' || ab.b);
 14 close abc;
 15 end;
 16 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[7:5] PLC-00941 'GS_PLSQL.a1'.TYPE was not a variable, column, or attribute.

SQL> declare
  2 type xxx is record (
  3   a int,
  4   b int
  5 );
  6 cursor c1 is select * from plsql_test order by a;
  7 c2 sys_refcursor;
  8 abc xxx;
  9 begin
 10 open c2 for select a from plsql_test order by a;
 11 close c2;
 12 open c2 for select a,b from plsql_test order by a;
 13 fetch c2 into abc;
 14 close c2;
 15 dbe_output.print_line('result is ' || abc.a);
 16 dbe_output.print_line('result is ' || abc.b);
 17 end;
 18 /

result is 1
result is 100

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 abc plsql_test.a%type;
  3 c2 sys_refcursor;
  4 begin
  5 open c2 for select a from plsql_test order by a;
  6 fetch c2 into abc;
  7 close c2;
  8 dbe_output.print_line('result is ' || abc);
  9 end;
 10 /

result is 1

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> DECLARE
  2 CURSOR c1 IS
  3 select a,b from plsql_test order by a;
  4 BEGIN
  5 delete from plsql_test;
  6 insert into plsql_test(a,b) values(1,100);
  7 insert into plsql_test(a,b) values(1,100);
  8 FOR item IN c1
  9 LOOP
 10 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
 11 dbe_output.print_line('CURSOR%ISOPEN   is ' || c1%ISOPEN);
 12 dbe_output.print_line('CURSOR%FOUND    is ' || c1%FOUND);
 13 dbe_output.print_line('CURSOR%NOTFOUND is ' || c1%NOTFOUND);
 14 dbe_output.print_line('CURSOR%ROWCOUNT is ' || c1%ROWCOUNT);
 15 END LOOP;
 16 dbe_output.print_line('after for loop');
 17 dbe_output.print_line('CURSOR%ISOPEN   is ' || c1%ISOPEN);
 18 END;
 19 /

A = 1,B = 100
CURSOR%ISOPEN   is TRUE
CURSOR%FOUND    is TRUE
CURSOR%NOTFOUND is FALSE
CURSOR%ROWCOUNT is 1
A = 1,B = 100
CURSOR%ISOPEN   is TRUE
CURSOR%FOUND    is TRUE
CURSOR%NOTFOUND is FALSE
CURSOR%ROWCOUNT is 2
after for loop
CURSOR%ISOPEN   is FALSE

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 CURSOR c1 IS
  3 select a,b from plsql_test order by a;
  4 BEGIN
  5 delete from plsql_test;
  6 insert into plsql_test(a,b) values(1,100);
  7 insert into plsql_test(a,b) values(1,100);
  8 FOR item IN c1
  9 LOOP
 10 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
 11 END LOOP;
 12 dbe_output.print_line('after for loop');
 13 dbe_output.print_line('CURSOR%ISOPEN   is ' || c1%ISOPEN);
 14 dbe_output.print_line('CURSOR%FOUND    is ' || c1%FOUND);
 15 END;
 16 /

A = 1,B = 100
A = 1,B = 100
after for loop
CURSOR%ISOPEN   is FALSE
CT-00932, [14:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[14:1] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00905, The cursor was invalid.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> DECLARE
  2 CURSOR c1 IS
  3 select a,b from plsql_test order by a;
  4 BEGIN
  5 delete from plsql_test;
  6 FOR item IN c1
  7 LOOP
  8 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
  9 END LOOP;
 10 END;
 11 /

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> DECLARE
  2 CURSOR c1 IS
  3 select a,b from plsql_test order by a;
  4 BEGIN
  5 open c1;
  6 close c1;
  7 delete from plsql_test;
  8 insert into plsql_test(a,b) values(1,100);
  9 insert into plsql_test(a,b) values(2,101);
 10 insert into plsql_test(a,b) values(3,99);
 11 FOR item IN c1
 12 LOOP
 13 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
 14 END LOOP;
 15 END;
 16 /

A = 1,B = 100
A = 2,B = 101
A = 3,B = 99

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> DECLARE
  2 CURSOR c1 IS
  3 select a,b from plsql_test order by a;
  4 BEGIN
  5 open c1;
  6 open c1;
  7 exception
  8 when CURSOR_ALREADY_OPEN then
  9 dbe_output.print_line('exception CURSOR_ALREADY_OPEN');
 10 close c1;
 11 END;
 12 /

exception CURSOR_ALREADY_OPEN

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> DECLARE
  2 c1 sys_refcursor;
  3 BEGIN
  4 open c1 for select a,b from plsql_test order by a;
  5 open c1 for select a,b from plsql_test order by b;
  6 exception
  7 when CURSOR_ALREADY_OPEN then
  8 dbe_output.print_line('exception CURSOR_ALREADY_OPEN');
  9 close c1;
 10 END;
 11 /

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> --BEGIN: plsql_test '=>'
SQL> DROP TABLE IF EXISTS plsql_T_PL_1;

Succeed.

SQL> CREATE TABLE plsql_T_PL_1 (F_INT1 INT, F_INT2 INT, F_CHAR VARCHAR(16));

Succeed.

SQL> DROP procedure IF EXISTS plsql_p1;

Succeed.

SQL> CREATE procedure plsql_p1(a int , b varchar2, c int)
  2 AUTHID CURRENT_USER
  3 as
  4 d int := 1;
  5 Begin
  6 Insert into plsql_T_PL_1( f_int1, f_char,f_int2)  values(a,b,c);
  7 Commit;
  8 End;
  9 /

Succeed.

SQL> 
SQL> begin 
  2 	plsql_p1(1,'ww1',1);
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> SELECT * FROM plsql_T_PL_1 ORDER BY 1,2,3;

F_INT1       F_INT2       F_CHAR          
------------ ------------ ----------------
1            1            ww1             

1 rows fetched.

SQL> 
SQL> begin
  2 	plsql_p1(1,'ww1',c => 2); 
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> SELECT * FROM plsql_T_PL_1 ORDER BY 1,2,3;

F_INT1       F_INT2       F_CHAR          
------------ ------------ ----------------
1            1            ww1             
1            2            ww1             

2 rows fetched.

SQL> 
SQL> begin
  2 	plsql_p1(1,c => 2,b => 'ww2');
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> SELECT * FROM plsql_T_PL_1 ORDER BY 1,2,3;

F_INT1       F_INT2       F_CHAR          
------------ ------------ ----------------
1            1            ww1             
1            2            ww1             
1            2            ww2             

3 rows fetched.

SQL> 
SQL> begin
  2 	plsql_p1(1,b => 'ww3',c => 2);
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> SELECT * FROM plsql_T_PL_1 ORDER BY 1,2,3;

F_INT1       F_INT2       F_CHAR          
------------ ------------ ----------------
1            1            ww1             
1            2            ww1             
1            2            ww2             
1            2            ww3             

4 rows fetched.

SQL> 
SQL> begin
  2 	plsql_p1(a => 1,b => 'ww4',c => 2);
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> SELECT * FROM plsql_T_PL_1 ORDER BY 1,2,3;

F_INT1       F_INT2       F_CHAR          
------------ ------------ ----------------
1            1            ww1             
1            2            ww1             
1            2            ww2             
1            2            ww3             
1            2            ww4             

5 rows fetched.

SQL> 
SQL> --error
SQL> begin
  2 	plsql_p1(a => 1,b => 'ww4', 2);
  3 end;
  4 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:30] PLC-00601 Sql syntax error:  '=>' expected

SQL> 
SQL> --error
SQL> begin
  2 	plsql_p1(a => 1,b => 'ww4', a => 2, c => 2);
  3 end;
  4 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:16] PLC-00948 Duplicate argument A in PLSQL_P1

SQL> 
SQL> --error
SQL> begin
  2 	plsql_p1(a => 1,b => 'ww4', b => 'a',c => 2);
  3 end;
  4 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:23] PLC-00948 Duplicate argument B in PLSQL_P1

SQL> --END: plsql_test '=>'
SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_Zenith_Test_003(param1 in varchar2,param2 in varchar2)
  2 IS
  3 begin
  4 dbe_output.print_line('Hello Zenith:'||param1||','||param2);
  5 end plsql_Zenith_Test_003;
  6 /

Succeed.

SQL> 
SQL> call plsql_Zenith_Test_003(to_char(to_date('2018-01-07','YYYY-MM-DD'),'DDD'),UPPER('Zenith$'));

Hello Zenith:007,ZENITH$

PL/SQL procedure successfully completed.

SQL> call plsql_Zenith_Test_003(param2=>UPPER('Zenith$'),param1=>to_char(to_date('2018-01-07','YYYY-MM-DD'),'DDD'));

Hello Zenith:007,ZENITH$

PL/SQL procedure successfully completed.

SQL> call plsql_Zenith_Test_003(param2=>(select case when 1=1 then 'True' else 'False' end from dual),param1=>'Case when Sub');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:40] PLC-01316 Unexpected SUBSELECT

SQL> 
SQL> --test create procedure/function can end with object name
SQL> --2018/6/20
SQL> create or replace procedure plsql_ztest_p1(a int, b varchar2)
  2 as
  3 c int;
  4 begin
  5   c := a;
  6 end plsql_ztest_p1;
  7 /

Succeed.

SQL> 
SQL> drop procedure plsql_ztest_p1;

Succeed.

SQL> 
SQL> create or replace procedure plsql_ztest_p2(a int, b varchar2)
  2 as
  3 c int;
  4 begin
  5   c := a;
  6 end;
  7 /

Succeed.

SQL> 
SQL> drop procedure plsql_ztest_p2;

Succeed.

SQL> 
SQL> create or replace procedure plsql_ztest_p3(a int, b varchar2)
  2 as
  3 c int;
  4 begin
  5   c := a;
  6 end plsql_ztest_p34;
  7 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_ZTEST_P3) terminated with compiling errors
[6:5] PLC-00920 Undefined symbol PLSQL_ZTEST_P34


SQL> 
SQL> create or replace procedure plsql_ztest_p4(a int, b varchar2)
  2 as
  3 c int;
  4 begin
  5   c := a;
  6 end plsql_ztest_p4 /
  7 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_ZTEST_P4) terminated with compiling errors
[6:5] PLC-00954 ';' expected but plsql_ztest_p4 found


SQL> 
SQL> drop procedure if exists plsql_ztest_p1;

Succeed.

SQL> drop procedure if exists plsql_ztest_p2;

Succeed.

SQL> drop procedure if exists plsql_ztest_p3;

Succeed.

SQL> drop procedure if exists plsql_ztest_p4;

Succeed.

SQL> 
SQL> create or replace function plsql_ztest_f1(a int, b varchar2)
  2 return int
  3 as
  4 c int;
  5 begin
  6   c := a;
  7   return c;
  8 end plsql_ztest_f1;
  9 /

Succeed.

SQL> 
SQL> create or replace function plsql_ztest_f2(a int, b varchar2)
  2 return int
  3 as
  4 c int;
  5 begin
  6   c := a;
  7   return c;
  8 end;
  9 /

Succeed.

SQL> 
SQL> exec plsql_ztest_f1(1,'1');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.PLSQL_ZTEST_F1 does not exist

SQL> exec plsql_ztest_f2(1,'1');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.PLSQL_ZTEST_F2 does not exist

SQL> exec ztest_f3(1,'1');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.ZTEST_F3 does not exist

SQL> 
SQL> drop function if exists plsql_ztest_f1;

Succeed.

SQL> drop function if exists plsql_ztest_f2;

Succeed.

SQL> 
SQL> 
SQL> 
SQL> --test variable default value can be set to another variable in declares.
SQL> --2018/6/22
SQL> declare
  2 a int := 1+2;
  3 b int := a+1;
  4 c int;
  5 begin
  6  c := b+3;
  7  dbe_output.print_line(a);
  8  dbe_output.print_line(b);
  9  dbe_output.print_line(c);
 10  a := 10;
 11  dbe_output.print_line(a);
 12  dbe_output.print_line(b);
 13  dbe_output.print_line(c);
 14 end; 
 15 /

3
4
7
10
4
7

PL/SQL procedure successfully completed.

SQL> 
SQL> --test cloud sop.
SQL> drop table plsql_tab;

CT-00843, The table or view GS_PLSQL.PLSQL_TAB does not exist.
SQL> create table plsql_tab(tname varchar(200));

Succeed.

SQL> insert into plsql_tab values('donghaijun');

1 rows affected.

SQL> drop procedure if exists plsql_Setting_Drop_Entity;

Succeed.

SQL> create or replace procedure plsql_Setting_Drop_Entity(v_type IN varchar2,v_name IN varchar2)
  2 as
  3         v_cnt number;
  4         sqlstr varchar2(200);
  5 begin
  6         if v_type='table' then
  7                 select count(*) into v_cnt from plsql_tab
  8                         where upper(tname)=upper(v_name);
  9                 dbe_output.print_line('count is ' || v_cnt);
 10         else 
 11                 dbe_output.print_line('no data found');
 12         end if;
 13 end;
 14 /

Succeed.

SQL> 
SQL> declare
  2 v_type varchar2(200);
  3 v_name varchar2(200);
  4 begin
  5 v_type := 'table';
  6 v_name := 'donghaijun';
  7 plsql_Setting_Drop_Entity(v_type,v_name);
  8 end;
  9 /              

count is 1

PL/SQL procedure successfully completed.

SQL> declare
  2 v_type varchar2(200);
  3 v_name varchar2(200);
  4 begin
  5 v_type := 'table';
  6 v_name := 'DONGHAIJUN';
  7 plsql_Setting_Drop_Entity(v_type,v_name);
  8 end;
  9 /

count is 1

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v_type varchar2(200);
  3 v_name varchar2(200);
  4 begin
  5 v_type := 'table1';
  6 v_name := 'DONGHAIJUN';
  7 plsql_Setting_Drop_Entity(v_type,v_name);
  8 end;
  9 /

no data found

PL/SQL procedure successfully completed.

SQL> insert into plsql_tab values('donghaijun');

1 rows affected.

SQL> execute plsql_Setting_Drop_Entity('table1','DONGHAIJUN');

no data found

PL/SQL procedure successfully completed.

SQL> execute plsql_Setting_Drop_Entity('table','donghaijun');

count is 2

PL/SQL procedure successfully completed.

SQL> execute plsql_Setting_Drop_Entity('table','DONGHAIJUN');

count is 2

PL/SQL procedure successfully completed.

SQL> drop table plsql_tab;

Succeed.

SQL> 
SQL> --call procedure
SQL> drop table if exists plsql_test_pro_t1;

Succeed.

SQL> create table plsql_test_pro_t1(f1 int, f2 varchar2(20));

Succeed.

SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1(a int, b varchar2, f_out1 out int, f_out2 out int, f_out3 OUT sys_refcursor)
  2 as
  3 c int := 1;
  4 d int := 2;
  5 begin
  6   delete from plsql_test_pro_t1;
  7   insert into plsql_test_pro_t1 values(a,b);
  8   select f1 into f_out1 from plsql_test_pro_t1;
  9   f_out2 := 22;
 10   open f_out3 for select f1,f2 from plsql_test_pro_t1;
 11   commit;
 12 end;
 13 /

Succeed.

SQL> 
SQL> declare
  2 a int := 1;
  3 b varchar2(10) := 'abcd';
  4 c int;
  5 d int;
  6 f sys_refcursor;
  7 type xxx is record (
  8   a int,
  9   b varchar2(10)
 10 );
 11 item xxx;
 12 begin
 13 plsql_test_p1(a,b,c,d,f);
 14 dbe_output.print_line('c is ' || c);
 15 dbe_output.print_line('d is ' || d);
 16 fetch f into item;
 17 dbe_output.print_line('item.a is ' || item.a);
 18 dbe_output.print_line('item.b is ' || item.b);
 19 close f;
 20 end;
 21 /

c is 1
d is 22
item.a is 1
item.b is abcd

PL/SQL procedure successfully completed.

SQL> drop table plsql_test_pro_t1;

Succeed.

SQL> drop procedure plsql_test_p1;

Succeed.

SQL> 
SQL> drop table if exists t1;

Succeed.

SQL> create table t1 
  2 (  
  3     f_int1           integer default 0 not null,  
  4     f_int2           integer,  
  5     f_int3           integer, 
  6     f_bigint1        bigint,  
  7     f_bigint2        bigint,  
  8     f_bigint3        bigint,  
  9     f_bool1          integer,  
 10     f_bool2          integer,  
 11     f_num1           number(38, 0),  
 12     f_num2           number(38, 0),  
 13     f_dec1           DECIMAL(38, 0), 
 14     f_dec2           DECIMAL(38, 0),  
 15     f_num10          number(38, 10),  
 16     f_dec10          decimal(38, 10),      
 17     f_float          float,  
 18     f_double         double,  
 19     f_real           real,  
 20     f_char1          char(128),  
 21     f_char2          char(128),  
 22     f_varchar1       varchar(512),  
 23     f_varchar2       varchar2(512),  
 24     f_date1          date,  
 25     f_date2          date,  
 26     f_time           date, 
 27     f_timestamp      timestamp
 28 );

Succeed.

SQL> insert into t1 values (1,2,3,
  2  555555555555, 555555555556, 555555555557, 
  3  true, false, 
  4  1234567890.1234567890, 1234567890.1234567891, 1234567890.1234567892,
  5  1234567890.1234567893, 1234567890.1234567894, 1234567890.1234567895,
  6  1.234, 1.235, 1.236,
  7  'wanghaifeng', 'wanghaifeng1', 'wanghaifeng2', 'wanghaifeng3', 
  8  '2018-06-25 22:55:00', '2018-06-25 22:55:01',
  9  '2018-06-25 22:55:02', '2018-06-25 22:55:03');

1 rows affected.

SQL>  commit;

Succeed.

SQL> 
SQL> declare
  2 type xxx is record (
  3     f_int1           integer,  
  4     f_int2           integer,  
  5     f_int3           integer, 
  6     f_bigint1        bigint,  
  7     f_bigint2        bigint,  
  8     f_bigint3        bigint,  
  9     f_bool1          integer,  
 10     f_bool2          integer,  
 11     f_num1           number(38, 0),     
 12     f_num2           number(38, 0),     
 13     f_dec1           DECIMAL(38, 0),    
 14     f_dec2           DECIMAL(38, 0),    
 15     f_num10          number(38, 10),    
 16     f_dec10          decimal(38, 10),   
 17     f_float          float,  
 18     f_double         double,  
 19     f_real           real,  
 20     f_char1          char(128),  
 21     f_char2          char(128),  
 22     f_varchar1       varchar(512),  
 23     f_varchar2       varchar2(512),  
 24     f_date1          date,  
 25     f_date2          date,  
 26     f_time           date, 
 27     f_timestamp      timestamp
 28 );
 29 f_int1           integer;
 30 f_int2           integer;  
 31 f_int3           integer; 
 32 f_bigint1        bigint; 
 33 f_bigint2        bigint;  
 34 f_bigint3        bigint;  
 35 f_bool1          integer;  
 36 f_bool2          integer;  
 37 f_num1           number(38, 0);
 38 f_num2           number(38, 0);     
 39 f_dec1           DECIMAL(38, 0);    
 40 f_dec2           DECIMAL(38, 0);    
 41 f_num10          number(38, 10);    
 42 f_dec10          decimal(38, 10);   
 43 f_float          float;
 44 f_double         double;  
 45 f_real           real; 
 46 f_char1          char(128);
 47 f_char2          char(128);  
 48 f_varchar1       varchar(512);
 49 f_varchar2       varchar2(512);  
 50 f_date1          date; 
 51 f_date2          date;  
 52 f_time           date; 
 53 f_timestamp      timestamp;
 54 item xxx;
 55 begin
 56 select * into item from t1;
 57 dbe_output.print_line('item.f_int1      is ' || item.f_int1     );
 58 dbe_output.print_line('item.f_int2      is ' || item.f_int2     );
 59 dbe_output.print_line('item.f_int3      is ' || item.f_int3     );
 60 dbe_output.print_line('item.f_bigint1   is ' || item.f_bigint1  );
 61 dbe_output.print_line('item.f_bigint2   is ' || item.f_bigint2  );
 62 dbe_output.print_line('item.f_bigint3   is ' || item.f_bigint3  );
 63 dbe_output.print_line('item.f_bool1     is ' || item.f_bool1    );
 64 dbe_output.print_line('item.f_bool2     is ' || item.f_bool2    );
 65 dbe_output.print_line('item.f_num1      is ' || item.f_num1     );
 66 dbe_output.print_line('item.f_num2      is ' || item.f_num2     );
 67 dbe_output.print_line('item.f_dec1      is ' || item.f_dec1     );
 68 dbe_output.print_line('item.f_dec2      is ' || item.f_dec2     );
 69 dbe_output.print_line('item.f_num10     is ' || item.f_num10    );
 70 dbe_output.print_line('item.f_dec10     is ' || item.f_dec10    );
 71 dbe_output.print_line('item.f_float     is ' || item.f_float    );
 72 dbe_output.print_line('item.f_double    is ' || item.f_double   );
 73 dbe_output.print_line('item.f_real      is ' || item.f_real     );
 74 dbe_output.print_line('item.f_char1     is ' || item.f_char1    );
 75 dbe_output.print_line('item.f_char2     is ' || item.f_char2    );
 76 dbe_output.print_line('item.f_varchar1  is ' || item.f_varchar1 );
 77 dbe_output.print_line('item.f_varchar2  is ' || item.f_varchar2 );
 78 dbe_output.print_line('item.f_date1     is ' || item.f_date1    );
 79 dbe_output.print_line('item.f_date2     is ' || item.f_date2    );
 80 dbe_output.print_line('item.f_time      is ' || item.f_time     );
 81 dbe_output.print_line('item.f_timestamp is ' || item.f_timestamp);
 82 select * into f_int1,f_int2,f_int3,f_bigint1,f_bigint2,f_bigint3,f_bool1,f_bool2,f_num1,f_num2,f_dec1,f_dec2,f_num10,f_dec10,f_float,f_double,f_real,f_char1,f_char2,f_varchar1,f_varchar2,f_date1,f_date2,f_time,f_timestamp from t1;
 83 dbe_output.print_line('f_int1      is ' || f_int1     );
 84 dbe_output.print_line('f_int2      is ' || f_int2     );
 85 dbe_output.print_line('f_int3      is ' || f_int3     );
 86 dbe_output.print_line('f_bigint1   is ' || f_bigint1  );
 87 dbe_output.print_line('f_bigint2   is ' || f_bigint2  );
 88 dbe_output.print_line('f_bigint3   is ' || f_bigint3  );
 89 dbe_output.print_line('f_bool1     is ' || f_bool1    );
 90 dbe_output.print_line('f_bool2     is ' || f_bool2    );
 91 dbe_output.print_line('f_num1      is ' || f_num1     );
 92 dbe_output.print_line('f_num2      is ' || f_num2     );
 93 dbe_output.print_line('f_dec1      is ' || f_dec1     );
 94 dbe_output.print_line('f_dec2      is ' || f_dec2     );
 95 dbe_output.print_line('f_num10     is ' || f_num10    );
 96 dbe_output.print_line('f_dec10     is ' || f_dec10    );
 97 dbe_output.print_line('f_float     is ' || f_float    );
 98 dbe_output.print_line('f_double    is ' || f_double   );
 99 dbe_output.print_line('f_real      is ' || f_real     );
100 dbe_output.print_line('f_char1     is ' || f_char1    );
101 dbe_output.print_line('f_char2     is ' || f_char2    );
102 dbe_output.print_line('f_varchar1  is ' || f_varchar1 );
103 dbe_output.print_line('f_varchar2  is ' || f_varchar2 );
104 dbe_output.print_line('f_date1     is ' || f_date1    );
105 dbe_output.print_line('f_date2     is ' || f_date2    );
106 dbe_output.print_line('f_time      is ' || f_time     );
107 dbe_output.print_line('f_timestamp is ' || f_timestamp);
108 end;
109 /

item.f_int1      is 1
item.f_int2      is 2
item.f_int3      is 3
item.f_bigint1   is 555555555555
item.f_bigint2   is 555555555556
item.f_bigint3   is 555555555557
item.f_bool1     is 1
item.f_bool2     is 0
item.f_num1      is 1234567890
item.f_num2      is 1234567890
item.f_dec1      is 1234567890
item.f_dec2      is 1234567890
item.f_num10     is 1234567890.1234567894
item.f_dec10     is 1234567890.1234567895
item.f_float     is 1.234
item.f_double    is 1.235
item.f_real      is 1.236
item.f_char1     is wanghaifeng                                                                                                                     
item.f_char2     is wanghaifeng1                                                                                                                    
item.f_varchar1  is wanghaifeng2
item.f_varchar2  is wanghaifeng3
item.f_date1     is 2018-06-25 22:55:00
item.f_date2     is 2018-06-25 22:55:01
item.f_time      is 2018-06-25 22:55:02
item.f_timestamp is 2018-06-25 22:55:03.000000
f_int1      is 1
f_int2      is 2
f_int3      is 3
f_bigint1   is 555555555555
f_bigint2   is 555555555556
f_bigint3   is 555555555557
f_bool1     is 1
f_bool2     is 0
f_num1      is 1234567890
f_num2      is 1234567890
f_dec1      is 1234567890
f_dec2      is 1234567890
f_num10     is 1234567890.1234567894
f_dec10     is 1234567890.1234567895
f_float     is 1.234
f_double    is 1.235
f_real      is 1.236
f_char1     is wanghaifeng                                                                                                                     
f_char2     is wanghaifeng1                                                                                                                    
f_varchar1  is wanghaifeng2
f_varchar2  is wanghaifeng3
f_date1     is 2018-06-25 22:55:00
f_date2     is 2018-06-25 22:55:01
f_time      is 2018-06-25 22:55:02
f_timestamp is 2018-06-25 22:55:03.000000

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> declare
  2 f_int1           integer;
  3 f_int2           integer;  
  4 f_int3           integer; 
  5 f_bigint1        bigint; 
  6 f_bigint2        bigint;  
  7 f_bigint3        bigint;  
  8 f_bool1          integer;  
  9 f_bool2          integer;  
 10 f_num1           number(38, 0);
 11 f_num2           number(38, 0);     
 12 f_dec1           DECIMAL(38, 0);    
 13 f_dec2           DECIMAL(38, 0);    
 14 f_num10          number(38, 10);    
 15 f_dec10          decimal(38, 10);   
 16 f_float          float;
 17 f_double         double;  
 18 f_real           real; 
 19 f_char1          char(128);
 20 f_char2          char(128);  
 21 f_varchar1       varchar(512);
 22 f_varchar2       varchar2(512);  
 23 f_date1          date; 
 24 f_date2          date;  
 25 f_time           date; 
 26 f_timestamp      timestamp;
 27 begin
 28 dbe_output.print_line('BEGIN:');
 29 insert into t1 values (1,2,3,
 30  555555555555, 555555555556, 555555555557, 
 31  true, false, 
 32  1234567890.1234567890, 1234567890.1234567891, 1234567890.1234567892,
 33  1234567890.1234567893, 1234567890.1234567894, 1234567890.1234567895,
 34  1.234, 1.235, 1.236,
 35  'wanghaifeng', 'wanghaifeng1', 'wanghaifeng2', 'wanghaifeng3', 
 36  '2018-06-25 22:55:00', '2018-06-25 22:55:01',
 37  '2018-06-25 22:55:02', '2018-06-25 22:55:03');
 38 select * into f_int1,f_int2,f_int3,f_bigint1,f_bigint2,f_bigint3,f_bool1,f_bool2,f_num1,f_num2,f_dec1,f_dec2,f_num10,f_dec10,f_float,f_double,f_real,f_char1,f_char2,f_varchar1,f_varchar2,f_date1,f_date2,f_time,f_timestamp from t1;
 39 dbe_output.print_line('f_int1      is ' || f_int1     );
 40 dbe_output.print_line('f_int2      is ' || f_int2     );
 41 dbe_output.print_line('f_int3      is ' || f_int3     );
 42 dbe_output.print_line('f_bigint1   is ' || f_bigint1  );
 43 dbe_output.print_line('f_bigint2   is ' || f_bigint2  );
 44 dbe_output.print_line('f_bigint3   is ' || f_bigint3  );
 45 dbe_output.print_line('f_bool1     is ' || f_bool1    );
 46 dbe_output.print_line('f_bool2     is ' || f_bool2    );
 47 dbe_output.print_line('f_num1      is ' || f_num1     );
 48 dbe_output.print_line('f_num2      is ' || f_num2     );
 49 dbe_output.print_line('f_dec1      is ' || f_dec1     );
 50 dbe_output.print_line('f_dec2      is ' || f_dec2     );
 51 dbe_output.print_line('f_num10     is ' || f_num10    );
 52 dbe_output.print_line('f_dec10     is ' || f_dec10    );
 53 dbe_output.print_line('f_float     is ' || f_float    );
 54 dbe_output.print_line('f_double    is ' || f_double   );
 55 dbe_output.print_line('f_real      is ' || f_real     );
 56 dbe_output.print_line('f_char1     is ' || f_char1    );
 57 dbe_output.print_line('f_char2     is ' || f_char2    );
 58 dbe_output.print_line('f_varchar1  is ' || f_varchar1 );
 59 dbe_output.print_line('f_varchar2  is ' || f_varchar2 );
 60 dbe_output.print_line('f_date1     is ' || f_date1    );
 61 dbe_output.print_line('f_date2     is ' || f_date2    );
 62 dbe_output.print_line('f_time      is ' || f_time     );
 63 dbe_output.print_line('f_timestamp is ' || f_timestamp);
 64 end;
 65 /

BEGIN:
CT-00932, [38:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[38:1] CT-00915, More than one return value of SELECT INTO, EXECUTE IMMEDIATE, or a cursor was assigned to a common variable.

SQL> 
SQL> BEGIN
  2 delete from plsql_test;
  3 insert into plsql_test(a,b) values(1,100);
  4 insert into plsql_test(a,b) values(2,101);
  5 FOR item IN (select a,b from plsql_test order by a)
  6 LOOP
  7 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
  8 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  9 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
 10 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 11 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 12 END LOOP;
 13 dbe_output.print_line('after for loop');
 14 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
 15 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
 16 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 17 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 18 END;
 19 /

A = 1,B = 100
SQL%ISOPEN :FALSE
SQL%FOUND :TRUE
SQL%NOTFOUND :FALSE
SQL%ROWCOUNT :1
A = 2,B = 101
SQL%ISOPEN :FALSE
SQL%FOUND :TRUE
SQL%NOTFOUND :FALSE
SQL%ROWCOUNT :1
after for loop
SQL%ISOPEN :FALSE
SQL%FOUND :FALSE
SQL%NOTFOUND :TRUE
SQL%ROWCOUNT :0

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> DECLARE
  2 xxx int := 0;
  3 BEGIN
  4 delete from plsql_test;
  5 insert into plsql_test(a,b) values(1,100);
  6 insert into plsql_test(a,b) values(2,101);
  7 FOR item IN (select a,b from plsql_test order by a)
  8 LOOP
  9 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
 10 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
 11 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
 12 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 13 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 14 xxx := xxx / 0;
 15 END LOOP;
 16 dbe_output.print_line('after for loop');
 17 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
 18 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
 19 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 20 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 21 END;
 22 /

A = 1,B = 100
SQL%ISOPEN :FALSE
SQL%FOUND :TRUE
SQL%NOTFOUND :FALSE
SQL%ROWCOUNT :1
CT-00932, [14:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[14:12] CT-00637, The divisor was zero

SQL> 
SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test(a int, b bigint, c char(10), d varchar(20), e bool);

Succeed.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> BEGIN
  2 delete from plsql_test;
  3 FOR item IN (select a,b from plsql_test order by a)
  4 LOOP
  5 dbe_output.print_line('A = ' || item.a || ',B = ' || item.b);
  6 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
  7 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
  8 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
  9 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 10 END LOOP;
 11 dbe_output.print_line('after for loop');
 12 dbe_output.print_line('SQL%ISOPEN :' || SQL%ISOPEN);
 13 dbe_output.print_line('SQL%FOUND :' || SQL%FOUND);
 14 dbe_output.print_line('SQL%NOTFOUND :' || SQL%NOTFOUND);
 15 dbe_output.print_line('SQL%ROWCOUNT :' || SQL%ROWCOUNT);
 16 END;
 17 /

after for loop
SQL%ISOPEN :FALSE
SQL%FOUND :FALSE
SQL%NOTFOUND :TRUE
SQL%ROWCOUNT :0

PL/SQL procedure successfully completed.

SQL> 
SQL> drop procedure if exists p_upgradecron
  2 /

Succeed.

SQL> drop table if exists CRON_FIRED_TRIGGERS;

Succeed.

SQL> drop table if exists SCHED_TIME;

Succeed.

SQL> create table CRON_FIRED_TRIGGERS(a int);

Succeed.

SQL> create table SCHED_TIME(a int);

Succeed.

SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> grant select on SYS.SYS_COLUMNS to gs_plsql;

Succeed.

SQL> grant select on SYS.SYS_TABLES to gs_plsql;

Succeed.

SQL> conn gs_plsql/Whf00174302@127.0.0.1:1611

connected.

SQL> CREATE OR REPLACE PROCEDURE p_upgradecron()
  2 as
  3     v_count int;
  4 begin 
  5     SELECT COUNT(1) into v_count FROM SYS.SYS_COLUMNS WHERE (USER#, table#) IN (SELECT USER#, ID FROM SYS.SYS_TABLES WHERE NAME='CRON_FIRED_TRIGGERS') AND NAME='SCHED_TIME';
  6     if v_count = 0 then 
  7         EXECUTE IMMEDIATE 'alter table CRON_FIRED_TRIGGERS add SCHED_TIME bigint not null default 0';
  8         dbe_output.print_line('alter table');
  9     else
 10     	dbe_output.print_line('v_count is ' || v_count);
 11     end if;
 12 end;
 13 /

Succeed.

SQL> call p_upgradecron()
  2 /

alter table

PL/SQL procedure successfully completed.

SQL> drop procedure if exists p_upgradecron
  2 /

Succeed.

SQL> 
SQL> create or replace procedure plsql_ztest_p1(a int)
  2 as
  3 c int;
  4 begin
  5   select a into c from dual;
  6   dbe_output.print_line(c);
  7   dbe_output.print_line(a);
  8 end plsql_ztest_p1;
  9 /

Succeed.

SQL> 
SQL> exec plsql_ztest_p1(1);

1
1

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> drop procedure plsql_ztest_p1;

Succeed.

SQL> create or replace procedure ztest_p5
  2 as
  3 c int := 1;
  4 begin
  5   dbe_output.print_line(c);
  6 end ztest_p5;
  7 /

Succeed.

SQL> 
SQL> exec ztest_p5;

1

PL/SQL procedure successfully completed.

SQL> exec ztest_p5();

1

PL/SQL procedure successfully completed.

SQL> execute ztest_p5;

1

PL/SQL procedure successfully completed.

SQL> execute ztest_p5();

1

PL/SQL procedure successfully completed.

SQL> call ztest_p5;

1

PL/SQL procedure successfully completed.

SQL> call ztest_p5();

1

PL/SQL procedure successfully completed.

SQL> 
SQL> drop procedure ztest_p5;

Succeed.

SQL> 
SQL> set serveroutput off;

OFF
SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --test select into
SQL> --2018/6/26
SQL> set serveroutput on;

ON
SQL> drop table if exists plsql_test_pl_t1;

Succeed.

SQL> create table plsql_test_pl_t1(a int, b int,c int, d varchar2(32));

Succeed.

SQL> insert into plsql_test_pl_t1 values(4,3,4,'321');

1 rows affected.

SQL> insert into plsql_test_pl_t1 values(-2,3,4,'1111111111');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> drop SEQUENCE if exists seq_test_1;

Succeed.

SQL> CREATE  SEQUENCE seq_test_1  INCREMENT BY 1 START WITH 1 MAXVALUE 10000000000 MINVALUE 1 NOCYCLE CACHE 20 ORDER;

Succeed.

SQL> 
SQL> create or replace procedure plsql_ztest_p2(f int)
  2 as
  3 c int;
  4 begin
  5   select count(*) into c from plsql_test_pl_t1;
  6   dbe_output.print_line(c);
  7   dbe_output.print_line(f);
  8 end plsql_ztest_p2;
  9 /

Succeed.

SQL> 
SQL> exec plsql_ztest_p2(2);

2
2

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace procedure plsql_ztest_p3(f int)
  2 as
  3 c int;
  4 begin
  5   select a into c from plsql_test_pl_t1 where a=-2;
  6   dbe_output.print_line(c);
  7   dbe_output.print_line(f);
  8 end plsql_ztest_p3;
  9 /

Succeed.

SQL> 
SQL> exec plsql_ztest_p3(3);

-2
3

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace procedure plsql_ztest_p4(a int)
  2 as
  3 c int;
  4 begin
  5   select seq_test_1.nextval into c from dual;
  6   dbe_output.print_line(c);
  7   dbe_output.print_line(a);
  8 end plsql_ztest_p4;
  9 /

Succeed.

SQL> 
SQL> exec plsql_ztest_p4(4);

1
4

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table plsql_test_pl_t1;

Succeed.

SQL> drop SEQUENCE seq_test_1;

Succeed.

SQL> drop procedure plsql_ztest_p2;

Succeed.

SQL> drop procedure plsql_ztest_p3;

Succeed.

SQL> drop procedure plsql_ztest_p4;

Succeed.

SQL> 
SQL> drop procedure if exists Pro_ColumnOper;

Succeed.

SQL> CREATE PROCEDURE Pro_ColumnOper(TableName VARCHAR,ColumnName VARCHAR,CType INT,SqlStr VARCHAR)
  2 AS
  3    Rows1 INT;
  4    SQL1 VARCHAR(4000);
  5 BEGIN
  6 Rows1 := 0;
  7 
  8 IF (CType=1 AND Rows1<=0) THEN
  9 	SqlStr := 'ALTER table ' || plsql_tableName || ' ADD COLUMN ' || ColumnName || ' ' || SqlStr;
 10 ELSIF (CType=2 AND Rows1>0)  THEN
 11 	SqlStr := '1';      
 12 END IF;
 13 dbe_output.print_line(SqlStr);
 14 END;
 15 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PRO_COLUMNOPER) terminated with compiling errors
[9:2] PLC-00950 The expression SQLSTR was used as the assignment target (left operand of the assignment statement).
[11:2] PLC-00950 The expression SQLSTR was used as the assignment target (left operand of the assignment statement).


SQL> call Pro_ColumnOper('test','check',1,'int default 0 not null');

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00944 PL/SQL(GS_PLSQL.PRO_COLUMNOPER) terminated with compiling errors
[9:2] PLC-00950 The expression SQLSTR was used as the assignment target (left operand of the assignment statement).
[11:2] PLC-00950 The expression SQLSTR was used as the assignment target (left operand of the assignment statement).


SQL> 
SQL> -----call func() and column-list support expr-list
SQL> DROP table IF EXISTS storage_deadlock_tbl_001_1;

Succeed.

SQL> CREATE table storage_deadlock_tbl_001_1(i int);

Succeed.

SQL> insert into storage_deadlock_tbl_001_1 values(0);

1 rows affected.

SQL> DROP table IF EXISTS strg_wait_lk_range_tbl_001_1;

Succeed.

SQL> CREATE table strg_wait_lk_range_tbl_001_1(i int);

Succeed.

SQL> insert into strg_wait_lk_range_tbl_001_1 values(0);

1 rows affected.

SQL> DROP table IF EXISTS nebula_storage_tbl_000;

Succeed.

SQL> create table nebula_storage_tbl_000(c_id int,
  2 c_d_id int NOT NULL,
  3 c_w_id int NOT NULL,
  4 c_first varchar(16) NOT NULL,
  5 c_middle char(2),
  6 c_last varchar(16) NOT NULL,
  7 c_street_1 varchar(20) NOT NULL,
  8 c_street_2 varchar(20),
  9 c_city varchar(20) NOT NULL,
 10 c_state char(2) NOT NULL,
 11 c_zip char(9) NOT NULL,
 12 c_phone char(16) NOT NULL,
 13 c_since timestamp,
 14 c_credit char(2) NOT NULL,
 15 c_credit_lim numeric(12,2),
 16 c_discount numeric(4,4),
 17 c_balance numeric(12,2),
 18 c_ytd_payment real NOT NULL,
 19 c_payment_cnt number NOT NULL,
 20 c_delivery_cnt bool NOT NULL,
 21 c_end date NOT NULL,
 22 c_vchar varchar(1000),
 23 c_data clob,
 24 c_text blob,
 25 primary key (c_id,c_d_id,c_w_id));

Succeed.

SQL> select c_id from nebula_storage_tbl_000;

C_ID        
------------

0 rows fetched.

SQL> 
SQL> drop procedure if exists strg_wait_lk_range_proc_001;

Succeed.

SQL> create or replace procedure strg_wait_lk_range_proc_001(a int) is
  2   b int := 0;
  3 begin
  4   while (a - b != 0) loop
  5   	select i into b from strg_wait_lk_range_tbl_001_1;
  6   	dbe_output.print_line(b);
  7   	a := a - 1;   	
  8   end loop;
  9 end;
 10 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.STRG_WAIT_LK_RANGE_PROC_001) terminated with compiling errors
[7:4] PLC-00950 The expression A was used as the assignment target (left operand of the assignment statement).
[10:1] PLC-00954 more text expected but EOF found


SQL> call strg_wait_lk_range_proc_001(1);

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00944 PL/SQL(GS_PLSQL.STRG_WAIT_LK_RANGE_PROC_001) terminated with compiling errors
[7:4] PLC-00950 The expression A was used as the assignment target (left operand of the assignment statement).
[10:1] PLC-00954 more text expected but EOF found


SQL> drop procedure if exists nebula_storage_func_000;

Succeed.

SQL> CREATE or replace procedure nebula_storage_func_000(startnum int,endall int)
  2 as
  3 i int :=1;
  4 j varchar(10);
  5 BEGIN
  6   FOR i IN startnum..endall LOOP
  7     select cast(i as varchar(10)) into j from dual;    
  8     insert into nebula_storage_tbl_000 select i,i,i,'is'||j||'cmRDs'||j,'OE','BAR'||j||'Bar'||j,'bkili'||j||'fcrRGF'||j,'pmbwo'||j||'vhSDGj'||j,'dyf'||j||'rDa'||j,'uq','4801'||j,'940'||j||'215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,1,sysdate,lpad('QVLDETANRBRBURBMfhlhfrcllgfSMNTECC348493214893542NPFZCSfjlufvCDSF',650,'QVLDETANRBRBURBMfhlhfrcllgfSMNTECC348493214893542NPFZCSfjlufvCDSF')||j,lpad('QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF',630,'QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF')||j,'1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323' from dual;
  9   END LOOP;
 10 END;
 11 /

Succeed.

SQL> call nebula_storage_func_000(1,2);

PL/SQL procedure successfully completed.

SQL> select c_id from nebula_storage_tbl_000;

C_ID        
------------
1           
2           

2 rows fetched.

SQL> 
SQL> create user plsql_omcdb identified by Root1234;

Succeed.

SQL> create or replace procedure plsql_omcdb.proc_create_iad_index as
  2   strSQL varchar2(1000);
  3 begin
  4   strSQL := 'create index idx_t1_c1 on t1(c1)';
  5   EXECUTE IMMEDIATE strSQL;
  6 end plsql_omcdb.proc_create_iad_index;
  7 /

Succeed.

SQL> drop procedure if exists plsql_omcdb.proc_create_iad_index;

Succeed.

SQL> drop user plsql_omcdb cascade;

Succeed.

SQL> 
SQL> declare
  2   v_int int;
  3 begin
  4     select -2147483647.7898765 into v_int from dual;
  5    dbe_output.print_line('result: '||v_int);
  6 end;
  7 /

result: -2147483648

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2   v_sysdate number(12,2);
  3 begin
  4     select 123456.7898765 into v_sysdate from dual;
  5    dbe_output.print_line('result: '||v_sysdate);
  6 end;
  7 /

result: 123456.79

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2   v_int int;
  3 begin
  4     select -2147483647.7898765 into v_int from dual;
  5    dbe_output.print_line('result: '||v_int);
  6 end;
  7 /

result: -2147483648

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> declare
  2   v_int int;
  3 begin
  4     select 2147483647.7898765 into v_int from dual;
  5    dbe_output.print_line('result: '||v_int);
  6 end;
  7 /

CT-00932, [4:5] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[4:5] CT-00659, INTEGER out of range

SQL> 
SQL> declare
  2   v_real real;
  3 begin
  4     select 7.7898765+1 into v_real from dual;
  5    dbe_output.print_line('result: '||v_real);
  6 end;
  7 /

result: 8.7898765

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2   v_real real;
  3 begin
  4     select 9223372036854775808.7898765 into v_real from dual;
  5    dbe_output.print_line('result: '||v_real);
  6 end;
  7 /

result: 9.22337203685478e+18

PL/SQL procedure successfully completed.

SQL> 
SQL> --BUG?? bigint overflow to minus
SQL> declare
  2    v_real real;
  3    v_bigint bigint;
  4 begin
  5     v_real:=9223372036854775800.7898765;
  6     select v_real into v_bigint from dual;
  7    dbe_output.print_line('result: '||v_bigint);
  8 end;
  9 /

CT-00932, [6:5] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:5] CT-00659, BIGINT out of range

SQL> 
SQL> --BUG?? overflow
SQL> declare
  2    v_real real;
  3    v_number number(12,3);
  4 begin
  5     v_real:=9.999999999999999999999999999999999e+127;
  6     select v_real into v_number from dual;
  7    dbe_output.print_line('result: '||v_number);
  8 end;
  9 /

CT-00932, [6:5] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:5] CT-01319, High-Precision numeric overflow

SQL> delete from plsql_test;

0 rows affected.

SQL> begin
  2 insert into plsql_test (a) values(1),(2),(3),(4);
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> select * from plsql_test order by 1 desc;

A            B                    C          D                    E     
------------ -------------------- ---------- -------------------- ------
4                                                                       
3                                                                       
2                                                                       
1                                                                       

4 rows fetched.

SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test (a varchar(100));

Succeed.

SQL> insert into plsql_test values('1');

1 rows affected.

SQL> select * from plsql_test;

A                                                               
----------------------------------------------------------------
1                                                               

1 rows fetched.

SQL> declare
  2 like_str varchar(120) := '1%';
  3 begin
  4 delete from plsql_test where a like like_str;
  5 end;
  6 /

PL/SQL procedure successfully completed.

SQL> select * from plsql_test;

A                                                               
----------------------------------------------------------------

0 rows fetched.

SQL> 
SQL> drop table if exists t_casewhen;

Succeed.

SQL> create table t_casewhen(id int,year int,month int,day int);

Succeed.

SQL> insert into t_casewhen values (1,2018,6,30);

1 rows affected.

SQL> declare
  2     v_int int;
  3 begin
  4     select (select case id when 1 then '1530331200' end from t_casewhen) into v_int from dual;
  5     dbe_output.print_line('result: '||v_int);
  6 end;
  7 /

result: 1530331200

PL/SQL procedure successfully completed.

SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1(a int, b varchar2)
  2 as
  3 c int := a;
  4 d int := c;
  5 begin
  6   dbe_output.print_line('a is ' || a || ',b is ' || b || ',c is ' || c || ',d is ' || d);
  7 end;
  8 /

Succeed.

SQL> call plsql_test_p1(1,'123');

a is 1,b is 123,c is 1,d is 1

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace procedure plsql_test_p1(a int := 3, b varchar2 := 'abcd')
  2 as
  3 c int := a;
  4 d int := c;
  5 begin
  6   dbe_output.print_line('a is ' || a || ',b is ' || b || ',c is ' || c || ',d is ' || d);
  7 end;
  8 /

Succeed.

SQL> call plsql_test_p1();

a is 3,b is abcd,c is 3,d is 3

PL/SQL procedure successfully completed.

SQL> call plsql_test_p1(1);

a is 1,b is abcd,c is 1,d is 1

PL/SQL procedure successfully completed.

SQL> call plsql_test_p1(2,'ccc');

a is 2,b is ccc,c is 2,d is 2

PL/SQL procedure successfully completed.

SQL> call plsql_test_p1(b =>'ccc');

a is 3,b is ccc,c is 3,d is 3

PL/SQL procedure successfully completed.

SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> declare
  2 a int := 1;
  3 b int := a;
  4 begin
  5   dbe_output.print_line('a is ' || a || ',b is ' || b);
  6 end;
  7 /

a is 1,b is 1

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists t_casewhen;

Succeed.

SQL> drop table if exists plsql_test;

Succeed.

SQL> DROP table IF EXISTS storage_deadlock_tbl_001_1;

Succeed.

SQL> DROP table IF EXISTS strg_wait_lk_range_tbl_001_1;

Succeed.

SQL> DROP table IF EXISTS nebula_storage_tbl_000;

Succeed.

SQL> drop SEQUENCE if exists seq_test_1;

Succeed.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> 
SQL> --test use input argument as default value
SQL> 
SQL> create or replace procedure gs_plsql1.plsql_test_pl_proc1(a int)
  2 as
  3 c int := 2+1;
  4 d int :=a;
  5 begin
  6   c := a;
  7   
  8   dbe_output.print_line(d);
  9   dbe_output.print_line(c);
 10 end;
 11 /

Succeed.

SQL> 
SQL> exec gs_plsql1.plsql_test_pl_proc1(0);

0
0

PL/SQL procedure successfully completed.

SQL> exec gs_plsql1.plsql_test_pl_proc1(0);

0
0

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --BEGIN: plsql_test create proc -> drop user -> create proc
SQL> CREATE USER plsql_ww identified by Cantian_234;

Succeed.

SQL> GRANT dba to plsql_ww;

Succeed.

SQL> CREATE table plsql_ww.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> CREATE table plsql_ww.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> CREATE OR REPLACE TRIGGER plsql_ww.TRIG_BEFORE_STMT BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON plsql_ww.T_TRIG_1
  2 BEGIN
  3   INSERT INTO plsql_ww.T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
  4 END;
  5 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_ww.p1(a int)
  2 AS
  3 x int;
  4 BEGIN
  5 	x := 10;
  6 	a := a + x;
  7 	dbe_output.print_line(a);
  8 END;
  9 /

Succeed.
Warning:
PL/SQL(PLSQL_WW.P1) terminated with compiling errors
[6:2] PLC-00950 The expression A was used as the assignment target (left operand of the assignment statement).


SQL> 
SQL> DROP USER plsql_ww cascade;

Succeed.

SQL> CREATE USER plsql_ww identified by Cantian_234;

Succeed.

SQL> GRANT dba to plsql_ww;

Succeed.

SQL> CREATE table plsql_ww.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> CREATE table plsql_ww.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

Succeed.

SQL> CREATE OR REPLACE TRIGGER plsql_ww.TRIG_BEFORE_STMT BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON plsql_ww.T_TRIG_1
  2 BEGIN
  3   INSERT INTO plsql_ww.T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
  4 END;
  5 /

Succeed.

SQL> 
SQL> INSERT INTO plsql_ww.T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');

1 rows affected.

SQL> INSERT INTO plsql_ww.T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');

1 rows affected.

SQL> INSERT INTO plsql_ww.T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');

1 rows affected.

SQL> INSERT INTO plsql_ww.T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');

1 rows affected.

SQL> SELECT * FROM plsql_ww.T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
1            2            A                2017-12-11 14:08:00   
1            3            A                2017-12-11 14:18:00   
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

4 rows fetched.

SQL> SELECT * FROM plsql_ww.T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   

4 rows fetched.

SQL> 
SQL> UPDATE plsql_ww.T_TRIG_1 SET F_INT1 = 10,F_CHAR1='TRIG' WHERE F_INT1 = 1;

2 rows affected.

SQL> SELECT * FROM plsql_ww.T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   
10           2            TRIG             2017-12-11 14:08:00   
10           3            TRIG             2017-12-11 14:18:00   

4 rows fetched.

SQL> SELECT * FROM plsql_ww.T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   

5 rows fetched.

SQL> 
SQL> DELETE FROM plsql_ww.T_TRIG_1 WHERE F_INT1 = 10;

2 rows affected.

SQL> SELECT * FROM plsql_ww.T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
2            3            B                2017-12-11 16:08:00   
3            4            C                2017-12-12 16:08:00   

2 rows fetched.

SQL> SELECT * FROM plsql_ww.T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   

6 rows fetched.

SQL> 
SQL> UPDATE plsql_ww.T_TRIG_1 SET F_INT2 = 5;

2 rows affected.

SQL> SELECT * FROM plsql_ww.T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
2            5            B                2017-12-11 16:08:00   
3            5            C                2017-12-12 16:08:00   

2 rows fetched.

SQL> SELECT * FROM plsql_ww.T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

F_INT1       F_INT2       F_CHAR1          F_DATE                
------------ ------------ ---------------- ----------------------
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   
4            2            A                2017-12-11 14:08:00   

6 rows fetched.

SQL> 
SQL> COMMIT;

Succeed.

SQL> 
SQL> drop table if exists T_TRIG_1;

Succeed.

SQL> drop table if exists T_TRIG_2;

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_ww.p1(a int)
  2 AS
  3 x int;
  4 BEGIN
  5 	x := 10;
  6 	a := a + x;
  7 	dbe_output.print_line(a);
  8 END;
  9 /

Succeed.
Warning:
PL/SQL(PLSQL_WW.P1) terminated with compiling errors
[6:2] PLC-00950 The expression A was used as the assignment target (left operand of the assignment statement).


SQL> 
SQL> begin
  2 	plsql_ww.p1(1);
  3 end;
  4 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:2] PLC-00944 PL/SQL(PLSQL_WW.P1) terminated with compiling errors
[6:2] PLC-00950 The expression A was used as the assignment target (left operand of the assignment statement).


SQL> 
SQL> --END: plsql_test create proc -> drop user -> create proc
SQL> 
SQL> declare 
  2     v_time varchar2(113) ;
  3 	a int :=600;
  4 begin
  5     begin
  6         select 'TIMETAG='  into v_time from dual where rownum <= 1;
  7     exception
  8         when no_data_found then                                                                                                                                                                         
  9             null;
 10         when others then
 11     			dbe_output.print_line(a||SQL_ERR_CODE||'==='||SQL_ERR_MSG);  
 12     end;
 13     dbe_output.print_line(a||v_time);
 14 exception
 15     when no_data_found then                                                                                                                                                                         
 16         null;   
 17         when others then
 18     dbe_output.print_line(a||SQL_ERR_CODE||'******'||SQL_ERR_MSG);     
 19 end;
 20 /

600TIMETAG=

PL/SQL procedure successfully completed.

SQL> 
SQL> --test for-loop DTS2018070301650
SQL> --begin
SQL> --expect compile success and run success
SQL> create or replace procedure bubble_sort
  2 as
  3     v_order number;
  4 begin
  5     v_order:=10;
  6     v_order:= v_order + 0.1;
  7     for i in v_order-5..v_order-1+0.5
  8     loop
  9         dbe_output.print_line(i);
 10     end loop;
 11 end;
 12 /

Succeed.

SQL> 
SQL> exec bubble_sort;

5
6
7
8
9
10

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect compile success and run success
SQL> create or replace procedure bubble_sort
  2 as
  3     v_order number;
  4 begin
  5     v_order:=10;
  6     v_order:= v_order + 0.5;
  7     for i in v_order-5..v_order-1+0.5
  8     loop
  9         dbe_output.print_line(i);
 10     end loop;
 11 end;
 12 /

Succeed.

SQL> 
SQL> exec bubble_sort;

6
7
8
9
10

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect compile success and run error
SQL> create or replace procedure bubble_sort
  2 as
  3     v_order varchar2(10) := 'abc';
  4 begin
  5     for i in v_order-5..v_order-1
  6     loop
  7         dbe_output.print_line(i);
  8     end loop;
  9 end;
 10 /

Succeed.

SQL> 
SQL> exec bubble_sort;

CT-00932, [1:2] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[4:5] PL/SQL(GS_PLSQL.BUBBLE_SORT) terminated with execute errors
[4:21] CT-00636, Invalid number -- unexpected character

SQL> --end plsql_test for-loop DTS2018070301650
SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1(result_cur sys_refcursor)
  2 	as
  3 		strSQL varchar2(1000);
  4 	begin
  5 		strSQL := 'select * from t_not_exists order by f1, f2';
  6 		dbe_output.print_line(strSQL);
  7 		OPEN result_cur for strSQL;
  8 	end plsql_test_p1;
  9 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[7:8] PLC-00990 IN cursor RESULT_CUR cannot be OPEN again


SQL> 
SQL> --param only allowed in dml or anonymous block or call
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1
  2 as
  3 	v_refcur SYS_REFCURSOR;   
  4 	SWV_tbl_DeviceTab__var0 NUMBER(10,0);
  5 begin
  6 	select count(*) INTO SWV_tbl_DeviceTab__var0 from dual;   
  7 	if SWV_tbl_DeviceTab__var0 <> :p1 
  8 	then      
  9 		open v_refcur for select 1 from dual;      
 10 		dbe_output.return_result(v_refcur);      
 11 		RETURN;   
 12 	else      
 13 		open v_refcur for select 0 from dual;      
 14 		dbe_output.return_result(v_refcur);   
 15 	end if;  
 16 	
 17 	RETURN;
 18 end;
 19 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[7:32] PLC-00601 Sql syntax error: param only allowed in dml or anonymous block or call
[10:3] PLC-00828 procedure DBE_OUTPUT.RETURN_RESULT does not exist
[12:2] PLC-00955 Unexpected ELSE found
[14:3] PLC-00828 procedure DBE_OUTPUT.RETURN_RESULT does not exist
[15:6] PLC-00920 Undefined symbol IF


SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1
  2 as
  3 	v_refcur SYS_REFCURSOR;   
  4 begin
  5 	open v_refcur for select 1 from dual where 1=:p1;   
  6 end;
  7 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[5:47] PLC-00945 Param only allowed in dml or anonymous block or call


SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace procedure plsql_test_p1
  2 as
  3 	SWV_tbl_DeviceTab__var0 NUMBER(10,0);
  4 begin
  5 	select count(*) INTO SWV_tbl_DeviceTab__var0 from dual where 1=:p1;   
  6 	RETURN;
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[5:65] PLC-00945 Param only allowed in dml or anonymous block or call


SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace function plsql_test_p1(a int, b varchar2)
  2 return int
  3 as
  4 c int;
  5 begin
  6   c := :p1;
  7   return c;
  8 end plsql_test_p1;
  9 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[6:8] PLC-00601 Sql syntax error: param only allowed in dml or anonymous block or call


SQL> 
SQL> drop procedure if exists plsql_test_p1;

Succeed.

SQL> create or replace function plsql_test_p1(a int, b varchar2)
  2 return int
  3 as
  4 c int;
  5 begin
  6   c := a;
  7   select 1 into c from dual where 1=:p1;
  8   return c;
  9 end plsql_test_p1;
 10 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_P1) terminated with compiling errors
[7:37] PLC-00945 Param only allowed in dml or anonymous block or call


SQL> 
SQL> CREATE OR REPLACE TRIGGER plsql_ww.TRIG_BEFORE_STMT BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON plsql_ww.T_TRIG_1
  2 BEGIN
  3   INSERT INTO plsql_ww.T_TRIG_2 VALUES(4,2,'A',:p1);
  4 END;
  5 /

Succeed.
Warning:
PL/SQL(PLSQL_WW.TRIG_BEFORE_STMT) terminated with compiling errors
[3:48] PLC-00945 Param only allowed in dml or anonymous block or call


SQL> DROP USER plsql_ww cascade;

Succeed.

SQL> --test create procedure with quotes
SQL> --add 2018/7/9
SQL> --begin
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE "Zenith_Test_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end Zenith_Test_001;
  6 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.Zenith_Test_001) terminated with compiling errors
[5:5] PLC-00920 Undefined symbol ZENITH_TEST_001


SQL> 
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE gs_plsql1."Zenith_Test_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end gs_plsql1."ZENITH_TEST_001";
  6 /

Succeed.
Warning:
PL/SQL(GS_PLSQL1.Zenith_Test_001) terminated with compiling errors
[5:5] PLC-00920 Undefined symbol GS_PLSQL1


SQL> 
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE "Zenith_Test_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end "ZENITH_TEST_001";
  6 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.Zenith_Test_001) terminated with compiling errors
[5:5] PLC-00920 Undefined symbol ZENITH_TEST_001


SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE gs_plsql1."Zenith_Test_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end "Zenith_Test_001";
  6 /

Succeed.

SQL> 
SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE gs_plsql1."ZENITH_TEST_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end "ZENITH_TEST_001";
  6 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE "ZENITH_TEST_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end "ZENITH_TEST_001";
  6 /

Succeed.

SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE "Zenith_Test_001"
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end;
  6 /

Succeed.

SQL> 
SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE "Zenith_Test_002"(a number)
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith'||a);
  5 end "Zenith_Test_002";
  6 /

Succeed.

SQL> 
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE 'Zenith_Test_001'
  2 AS
  3 Begin
  4     dbe_output.print_line('Hello Zenith');
  5 end;
  6 /

CT-00601, [1:29]Sql syntax error: invalid variant/object name was found
SQL> 
SQL> exec Zenith_Test_001;

Hello Zenith

PL/SQL procedure successfully completed.

SQL> exec "Zenith_Test_001";

Hello Zenith

PL/SQL procedure successfully completed.

SQL> exec gs_plsql1."Zenith_Test_001";

Hello Zenith

PL/SQL procedure successfully completed.

SQL> exec "Zenith_Test_002"(1);

Hello Zenith1

PL/SQL procedure successfully completed.

SQL> exec Zenith_Test_002(1);

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00828 procedure GS_PLSQL.ZENITH_TEST_002 does not exist

SQL> 
SQL> drop procedure Zenith_Test_001;

Succeed.

SQL> drop procedure "Zenith_Test_001";

Succeed.

SQL> drop procedure "Zenith_Test_002";

Succeed.

SQL> drop procedure gs_plsql1."ZENITH_TEST_001";

Succeed.

SQL> drop PROCEDURE gs_plsql1."Zenith_Test_001";

Succeed.

SQL> 
SQL> --end plsql_test create procedure with quotes
SQL> drop table if exists plsql_emp_test;

Succeed.

SQL> create table plsql_emp_test(empno number,ename varchar2(100),job varchar2(100), sal number);

Succeed.

SQL> insert into plsql_emp_test values(1,'wanghaifeng','doctor1',10000);

1 rows affected.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE syscur(sys_cur OUT SYS_REFCURSOR) 
  2 IS 
  3 C1 SYS_REFCURSOR; 
  4 BEGIN 
  5 OPEN C1 FOR
  6     SELECT empno,ename FROM plsql_emp_test  where empno=1 ORDER BY empno; 
  7 sys_cur := C1; 
  8 END; 
  9 /

Succeed.

SQL> 
SQL> DECLARE
  2   cv SYS_REFCURSOR;
  3   v_sal   plsql_emp_test.sal%type;
  4   v_sal_mul     plsql_emp_test.sal%type;
  5   factor   integer :=2;
  6 BEGIN
  7     open cv for
  8           select sal,sal*factor from plsql_emp_test where job like '%1' and sal < 13000 order by sal;
  9     loop
 10     fetch cv into v_sal,v_sal_mul;
 11     exit when cv%notfound;
 12     dbe_output.print_line('factor ='||factor||';');
 13     dbe_output.print_line('sal ='||v_sal||';');
 14     dbe_output.print_line('sal_mul ='||v_sal_mul||';');
 15     factor :=factor+1;
 16 
 17   END LOOP;
 18   close cv;
 19 end;
 20 /

factor =2;
sal =10000;
sal_mul =20000;

PL/SQL procedure successfully completed.

SQL> --test the max length of char and varchar is 32767
SQL> --2018/7/13
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect error
SQL> declare
  2 v_type1 varchar2(32768);
  3 begin
  4 v_type1 := 'staticbool32plccompiletriggervariant1plcompiler';
  5   dbe_output.print_line(v_type1);
  6 end;
  7 / 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:18] PLC-00601 Sql syntax error: size value must between 1 and 32767

SQL> 
SQL> --expect error
SQL> declare
  2 v_type1 char(32767);
  3 begin
  4 v_type1 := 'staticbool32plccompiletriggervariant1plcompiler';
  5   dbe_output.print_line(v_type1);
  6 end;
  7 / 

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:14] PLC-00601 Sql syntax error: size value must between 1 and 8000

SQL> 
SQL> --expect success
SQL> declare
  2 v_type1 varchar2(32767);
  3 begin
  4 v_type1 := 'staticbool32plccompiletriggervariant1plcompiler';
  5   dbe_output.print_line(v_type1);
  6 end;
  7 / 

staticbool32plccompiletriggervariant1plcompiler

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> declare
  2 v_type1 varchar2(32767);
  3 v_type2 varchar2(32767);
  4 begin
  5 v_type1 := 'stat';
  6 v_type2 := v_type1 || 'sta';
  7   dbe_output.print_line(substr(v_type2, 1,2));
  8 end;
  9 / 

st

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> declare
  2 v_type1 varchar2(32767);
  3 v_type2 varchar2(32767);
  4 begin
  5 v_type1 := 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CM
  6 SNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canon
  7 lyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACH
  8 ROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclchar
  9 param[GSNA';
 10 v_type2 := v_type1 || 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CM
 11 SNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canon
 12 lyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACH
 13 ROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclchar
 14 param[GSNA';
 15   dbe_output.print_line(substr(v_type2, 1,20));
 16 end;
 17 / 

staticbool32plccompi

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect error
SQL> declare
  2 a varchar2(32766);
  3 b integer;
  4 begin
  5 a := '123454545423542525525325435354325433535254325435432543535553552354352552';
  6 select cast(a as integer) into b from dual;
  7   dbe_output.print_line(b-3);
  8 end;
  9 / 

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:8] PL/SQL(PUBLIC.CAST) terminated with execute errors
[6:8] CT-00659, INTEGER out of range

SQL> 
SQL> --expect error
SQL> declare
  2 a varchar2(32767);
  3 b integer;
  4 begin
  5 a := '123a';
  6 select cast(a as integer) into b from dual;
  7   dbe_output.print_line(b-3);
  8 end;
  9 / 

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:8] PL/SQL(PUBLIC.CAST) terminated with execute errors
[6:8] CT-00636, Invalid number -- unexpected character

SQL> 
SQL> --expect success: convert bigvarchar to bigint
SQL> declare
  2 a varchar2(32766);
  3 b integer;
  4 c real;
  5 d decimal;
  6 e date;
  7 f datetime;
  8 g number(20,3);
  9 begin
 10 a := '12345';
 11 select cast(a as bigint) into b from dual;
 12 a := '1231233413.123';
 13 select cast(a as real) into c from dual;
 14 a := '1231233413.123123213E100';
 15 select cast(a as decimal) into d from dual;
 16 a := '2017-08-11';
 17 select to_date(a, 'YYYY-MM-DD') into e from dual;
 18 a := '2017-08-11 23:11:20';
 19 select to_date(a, 'YYYY-MM-DD HH24:MI:SS') into f from dual;
 20 
 21   dbe_output.print_line(b-3);
 22   dbe_output.print_line(c);
 23   dbe_output.print_line(d);
 24   dbe_output.print_line(e);
 25   dbe_output.print_line(f);
 26 end;
 27 / 

12342
1231233413.123
1.231233413123123213000000000000000E+109
2017-08-11 00:00:00
2017-08-11 23:11:20

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> declare
  2 a varchar2(32766);
  3 b integer;
  4 c varchar2(5);
  5 begin
  6 a := '12345';
  7 c := '12345';
  8 if a=c then
  9   dbe_output.print_line(a);
 10   end if;
 11 end;
 12 / 

12345

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> declare
  2 a varchar2(32766);
  3 b integer;
  4 c varchar2(5);
  5 begin
  6 a := '12345';
  7 c := a;
  8   dbe_output.print_line(c);
  9 end;
 10 / 

12345

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> --result is :1234512345600
SQL> declare
  2 a varchar2(32766);
  3 b integer;
  4 c varchar2(5);
  5 begin
  6 a := '12345';
  7 c := a;
  8 b := 00600;
  9   dbe_output.print_line(c||a||b);
 10 end;
 11 / 

1234512345600

PL/SQL procedure successfully completed.

SQL> 
SQL> create table plsql_test_varchar32k
  2 (
  3 a varchar2(32767)
  4 );

CT-00601, [3:12]Sql syntax error: size value must between 1 and 8000
SQL> 
SQL> --expect success
SQL> declare
  2 v_type1 varchar2(32767);
  3 v_type2 varchar2(32767);
  4 v_type3 varchar2(32767);
  5 a  integer;
  6 begin
  7 v_type1 := 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CM
  8 SNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canon
  9 lyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACH
 10 ROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclchar
 11 param[GSNA';
 12 v_type2 := v_type1 || 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CM
 13 SNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canon
 14 lyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACH
 15 ROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclchar
 16 param[GSNA';
 17   dbe_output.print_line(substr(v_type2, 1,20));
 18   v_type3 := 'select count(*) from dual';
 19   execute immediate v_type3 into a;
 20   dbe_output.print_line(a);
 21 end;
 22 / 

staticbool32plccompi
1

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> drop table if exists plsql_tab_1023_col;

Succeed.

SQL> declare
  2     v_sql varchar2(32767);
  3 begin
  4     v_sql:='create table plsql_tab_1023_col(';
  5  for i in 1..999
  6  loop
  7      v_sql:=v_sql||'col_'||to_char(i)||' int,';
  8  end loop;
  9  v_sql:=v_sql||'col_1000 int)';
 10  execute immediate v_sql;
 11 end;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success, string length is 16384
SQL> declare
  2 v_type1 varchar2(32767);
  3 a  integer;
  4 begin
  5 v_type1 := 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1
  6 CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111ne
  7 w1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharpara
  8 m[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFORE
  9 EACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1dec
 10 l111void1CMSNPRINTFS1paramSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32p
 11 lccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAstaticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcom
 12 pilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111TRIGBEFOREEA
 13 CHROW111PLCE';
 14   dbe_output.print_line(substr(v_type1, 1,20));
 15 end;
 16 / 

staticbool32plccompi

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success, string length is 16385
SQL> declare
  2 v_type1 varchar2(32767);
  3 a  integer;
  4 begin
  5 v_type1 := 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1
  6 CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111ne
  7 w1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharpara
  8 m[GSNAMEBUFFERSIZE]=101if1CMPLCONEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFORE
  9 EACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1dec
 10 l111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32p
 11 lccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAstaticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcom
 12 pilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111TRIGBEFOREEA
 13 CHROW111PLCEa';
 14   dbe_output.print_line(substr(v_type1, 1,20));
 15 end;
 16 /

staticbool32plccompi

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --expect success, string length is 16384
SQL> declare
  2 v_type1 varchar2(32767) := 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1
  3 CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111ne
  4 w1or11old1canonlyappearinrowtriggr11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharpara
  5 m[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFORE
  6 EACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1dec
  7 l111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32p
  8 lccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAstaticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcom
  9 pilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111TRIGBEFOREEA
 10 CHROW111PLCE';
 11 a  integer;
 12 begin
 13   dbe_output.print_line(substr(v_type1, 1,20));
 14 end;
 15 / 

staticbool32plccompi

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect error, string length is 16385
SQL> declare
  2 v_type1 varchar2(32767):= 'staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1
  3 CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111ne
  4 w1or11old1canonlyappearinrowtrigger1returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharpara
  5 m[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFORE
  6 EACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1dec
  7 l111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32p
  8 lccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAstaticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcom
  9 pilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111new1or11old1canonlyappearinrowtrigger11returnGSFALSE1PLCCALL1plcgettriggerdecl1compiler0wordPLVVAR1decl111void1CMSNPRINTFS1paramGSNAMEBUFFERSIZEGSNAMEBUFFERSIZE111d1d1declvidblockdeclvidid1cmconcatstr1sqlparam1returnGSTRUE1staticbool32plccompiletriggervariant1plcompilertcompilertexttsqlwordtword11plvdecltdeclcharparam[GSNAMEBUFFERSIZE]=101if1CMPLCONTEXTtype=SQLTYPECREATETRIG1compilerproctrigtype=TRIGAFTEREACHROW11compilerproctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111proctrigtype=TRIGBEFOREEACHROW111PLCERROR1wordlocERRPLSYNTAXERROR111TRIGBEFOREEA
 10 CHROW111PLCEa';
 11 a  integer;
 12 begin
 13   dbe_output.print_line(substr(v_type1, 1,20));
 14 end;
 15 /

staticbool32plccompi

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> select count(*) from plsql_tab_1023_col;

COUNT(*)            
--------------------
0                   

1 rows fetched.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --end plsql_test the max length of char and varchar is 32767
SQL> 
SQL> DECLARE
  2   cv SYS_REFCURSOR;
  3   v_empno  plsql_emp_test.empno%TYPE;
  4   v_ename     plsql_emp_test.ename%TYPE;
  5   v_sal    plsql_emp_test.sal%TYPE;
  6   query_2 VARCHAR2(200) :=
  7     'select * from plsql_emp_test order by 1,2,3';
  8   v_emp_test plsql_emp_test%ROWTYPE;
  9 BEGIN
 10   syscur(cv);
 11   LOOP
 12     FETCH cv INTO v_empno, v_ename;
 13     EXIT WHEN cv%NOTFOUND;
 14     -- dbe_output.print_line('v_empno is :'||v_empno||'---->'||'v_ename is :'||v_ename);
 15 	dbe_output.print_line(rpad(v_empno,25,' ')||v_ename);
 16   END LOOP;
 17  
 18   dbe_output.print_line( '-------------------------------------' );
 19   CLOSE cv;
 20 END;
 21 /

1                        wanghaifeng
-------------------------------------

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> drop table if exists plsql_emp_test;

Succeed.

SQL> drop procedure if exists syscur;

Succeed.

SQL> 
SQL> 
SQL> --test:in parameter can not use as left assiagnment target
SQL> --add 2018/07/17
SQL> --begin
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE plsql_test_in_para (
  2   t_column char,
  3   t_name   VARCHAR2
  4 ) 
  5 IS
  6   temp VARCHAR2(30);
  7 BEGIN
  8 	t_column := t_column ||'--';
  9 	dbe_output.print_line(t_column||t_name);
 10  
 11 EXCEPTION
 12   WHEN NO_DATA_FOUND THEN
 13     dbe_output.print_line ('No Data found for SELECT on ');
 14   WHEN OTHERS THEN
 15     dbe_output.print_line ('Unexpected error');
 16     RAISE;
 17 END;
 18 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_TEST_IN_PARA) terminated with compiling errors
[8:2] PLC-00950 The expression T_COLUMN was used as the assignment target (left operand of the assignment statement).


SQL> 
SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE plsql_test_in_para (
  2   t_column in char,
  3   t_name  in out VARCHAR2,
  4   result out varchar2
  5 ) 
  6 IS
  7   temp VARCHAR2(30);
  8 BEGIN
  9 	t_name := t_name ||t_column ||'--';
 10 	result := t_name;
 11 	dbe_output.print_line(t_column||t_name);
 12  
 13 EXCEPTION
 14   WHEN NO_DATA_FOUND THEN
 15     dbe_output.print_line ('No Data found for SELECT on ');
 16   WHEN OTHERS THEN
 17     dbe_output.print_line ('Unexpected error');
 18     RAISE;
 19 END;
 20 /

Succeed.

SQL> 
SQL> DECLARE
  2   a    varchar2(20):='aaa';
  3   b    varchar2(20):='bbb';
  4   c    varchar2(20);
  5 BEGIN
  6   plsql_test_in_para(a, b, c);
  7   dbe_output.print_line( 'a:'||a||'  b:'||b||'   c:'||c );
  8 END;
  9 /

aaabbbaaa--
a:aaa  b:bbbaaa--   c:bbbaaa--

PL/SQL procedure successfully completed.

SQL> --end plsql_test:in parameter can not use as left assiagnment target
SQL> 
SQL> --test cursor open and deal with the eof:DTS2018071706609
SQL> --add 2018/07/18
SQL> --begin
SQL> drop table if exists pl_emp;

Succeed.

SQL> create table pl_emp(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into pl_emp values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10000),(123,'zhangsan3','doctor3',10000);

3 rows affected.

SQL> insert into pl_emp values(1,'zhansi','doctor1',10000),(2,'lisiabc','doctor2',10000),(123,'zhangwu123','doctor3',10000);

3 rows affected.

SQL> insert into pl_emp values(10,'abc','worker',9000);

1 rows affected.

SQL> insert into pl_emp values(716,'ZHANGSAN','leader',20000);

1 rows affected.

SQL> insert into pl_emp values(715,'SYS','leader',20001);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> --expect print 'sys' user info.
SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> grant select on sys.SYS_USERS to gs_plsql;

Succeed.

SQL> conn gs_plsql/Whf00174302@127.0.0.1:1611

connected.

SQL> declare
  2 cursor mycursor is (select * from pl_emp,sys.SYS_USERS where pl_emp.ename=sys.SYS_USERS.NAME and pl_emp.ename like '%S%' and pl_emp.sal > 9000 order by empno);
  3 begin
  4 for a in mycursor
  5 loop
  6 dbe_output.print_line('a is emp:'||a.ENAME||'SYS_USERS name is: '||a.name);
  7 dbe_output.print_line(mycursor%rowcount);
  8 end loop;
  9 end;
 10 /

a is emp:SYSSYS_USERS name is: SYS
1

PL/SQL procedure successfully completed.

SQL> --end
SQL> 
SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test(a int, b int);

Succeed.

SQL> declare
  2 type tcur is ref cursor;
  3 cursor_k tcur;
  4 rec plsql_test%rowtype;
  5 begin
  6 open cursor_k for (select * from plsql_test);
  7 fetch cursor_k into rec;
  8 close cursor_k;
  9 end;
 10 /

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type tcur is ref cursor return plsql_test%rowtype;
  3 cursor_k tcur;
  4 rec plsql_test%rowtype;
  5 begin
  6 open cursor_k for select * from plsql_test;
  7 fetch cursor_k into rec;
  8 close cursor_k;
  9 end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:25] PLC-00958 Unsupported feature

SQL> drop table if exists plsql_emp;

Succeed.

SQL> create table plsql_emp(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_emp values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10000),(123,'zhangsan3','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(1,'zhansi','doctor1',10000),(2,'lisiabc','doctor2',10000),(123,'zhangwu123','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(10,'abc','worker',9000);

1 rows affected.

SQL> insert into plsql_emp values(716,'ZHANGSAN','leader',20000);

1 rows affected.

SQL> commit;

Succeed.

SQL> declare
  2 cursor mycursor is select * from plsql_emp where empno != 123 and sal=10000;
  3 begin
  4 close mycursor;
  5 end;
  6 /

CT-00932, [4:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[4:1] CT-00905, The cursor was invalid.

SQL> 
SQL> create or  replace procedure procedure2(a int) is
  2 cursor mycursor is select * from plsql_emp where empno != 123 and sal=10000;
  3 b plsql_emp%rowtype;
  4 mysyscur  sys_refcursor;
  5 strSQL1 varchar(1000);
  6 strSQL2 varchar(1000);
  7 begin
  8 strSQL1 := 'select * from plsql_emp  where  sal <> 10000';
  9 strSQL2 := '';
 10  if a <= 10 then
 11    for i in mycursor
 12    loop
 13     dbe_output.print_line(i.ename||' is not 10000');
 14    end loop;
 15  elsif a >10  then
 16   open mysyscur for  strSQL1;
 17   fetch mysyscur into  b; 
 18   dbe_output.print_line(b.ename||' a > 10 and a < 100');
 19   close mycursor;
 20  else
 21   open mysyscur for strSQL2;
 22   dbe_output.print_line('else a > 10 and a < 100');
 23  end if;
 24  exception
 25    when others then
 26    dbe_output.print_line('close mysyscur');
 27    close mysyscur;   
 28 end;
 29 /

Succeed.

SQL> call procedure2(10);

zhangsan is not 10000
zhangsan2 is not 10000
zhansi is not 10000
lisiabc is not 10000

PL/SQL procedure successfully completed.

SQL> exec procedure2(11);

abc a > 10 and a < 100
close mysyscur

PL/SQL procedure successfully completed.

SQL> declare
  2 type vll is record(
  3 s char(13),
  4 b int);
  5 ab vll.s%type;
  6 begin
  7  ab := '10';
  8 dbe_output.print_line(ab || 'xx');
  9  end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[5:4] PLC-00941 'VLL.S'.TYPE was not a variable, column, or attribute.

SQL> 
SQL> declare
  2 type vll is record(
  3 s char(13),
  4 b int);
  5 ab vll%rowtype;
  6 begin
  7  ab := '10';
  8 dbe_output.print_line(ab || 'xx');
  9  end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[5:4] PLC-00942 With ROWTYPE attribute, 'VLL' must name a table, cursor or cursor-variable

SQL> 
SQL> drop table plsql_emp;

Succeed.

SQL> create table plsql_emp(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_emp values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10000),(123,'zhangsan3','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(1,'zhansi','doctor1',10000),(2,'lisiabc','doctor2',10000),(123,'zhangwu123','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(10,'abc','worker',9000);

1 rows affected.

SQL> insert into plsql_emp values(716,'ZHANGSAN','leader',20000);

1 rows affected.

SQL> commit;

Succeed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 cursor mycursor  is select * from plsql_emp where  ename like '%ZHANGSAN%' and sal > 9000 ;
  3 c mycursor%rowtype;
  4 begin
  5 for a  in  mycursor
  6 loop
  7 open mycursor;
  8 --fetch mycursor into c;
  9 dbe_output.print_line('a is emp:'||c.ENAME||'SYS_USERS name is: '||c.job);
 10 dbe_output.print_line(mycursor%rowcount);
 11 --close mycursor;
 12 end loop;
 13 end;
 14 /

CT-00932, [7:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[7:1] CT-00904, Cursor is already opened

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 cursor mycursor  is select * from plsql_emp where  ename like '%ZHANGSAN%' and sal > 9000 ;
  3 c mycursor%rowtype;
  4 begin
  5 for a  in  mycursor
  6 loop
  7 --open mycursor;
  8 --fetch mycursor into c;
  9 dbe_output.print_line('a is emp:'||c.ENAME||'SYS_USERS name is: '||c.job);
 10 dbe_output.print_line(mycursor%rowcount);
 11 close mycursor;
 12 end loop;
 13 end;
 14 /

a is emp:SYS_USERS name is: 
1
CT-00932, [11:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[11:1] CT-00905, The cursor was invalid.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 cursor mycursor  is select * from plsql_emp where  ename like '%ZHANGSAN%' and sal > 9000 ;
  3 c mycursor%rowtype;
  4 begin
  5 for a  in  mycursor
  6 loop
  7 fetch mycursor into c;
  8 dbe_output.print_line('a is emp:'||c.ENAME||'SYS_USERS name is: '||c.job);
  9 dbe_output.print_line(mycursor%rowcount);
 10 end loop;
 11 end;
 12 /

CT-00932, [7:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[7:1] CT-00905, The cursor was invalid.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                            

1 rows fetched.

SQL> drop table if exists plsql_emp;

Succeed.

SQL> create table plsql_emp(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_emp values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10000),(123,'zhangsan3','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(1,'zhansi','doctor1',10000),(2,'lisiabc','doctor2',10000),(123,'zhangwu123','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(10,'abc','worker',9000);

1 rows affected.

SQL> declare
  2 cursor mycursor  is select sum(sal) he from plsql_emp where ename like '%zhangsan%' and sal > 9000 ;
  3 begin
  4 for a  in  mycursor
  5 loop
  6 dbe_output.print_line('a is emp:'||a.he);
  7 dbe_output.print_line(mycursor%rowcount);
  8 end loop;
  9 end;
 10 /

a is emp:30000
1

PL/SQL procedure successfully completed.

SQL> declare
  2 cursor mycursor  is select ename||' '||job as ejob ,sal*10 as exp_sal from plsql_emp order by ename DESC,exp_sal asc;
  3 begin
  4 for a  in  mycursor
  5 loop
  6 dbe_output.print_line('a is ejob:'||a.ejob||'exp_sal:'||a.exp_sal);
  7 dbe_output.print_line(mycursor%rowcount);
  8 end loop;
  9 end;
 10 /

a is ejob:zhansi doctor1exp_sal:100000
1
a is ejob:zhangwu123 doctor3exp_sal:100000
2
a is ejob:zhangsan3 doctor3exp_sal:100000
3
a is ejob:zhangsan2 doctor2exp_sal:100000
4
a is ejob:zhangsan doctor1exp_sal:100000
5
a is ejob:lisiabc doctor2exp_sal:100000
6
a is ejob:abc workerexp_sal:90000
7

PL/SQL procedure successfully completed.

SQL> drop table if exists plsql_emp;

Succeed.

SQL> 
SQL> --test unsupport column size at parameter
SQL> --add 2018/07/19
SQL> --begin
SQL> --expect error
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in CHAR(10),
  3   t_name   in VARCHAR2(10)
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:19] PLC-00954 ',' expected but 10 found


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in CHAR,
  3   t_name   in VARCHAR2,
  4   t_num    in number(10),
  5   t_dec    in decimal(10,5)
  6 ) 
  7 IS
  8   temp1 VARCHAR2(10);
  9 BEGIN
 10   temp1 := t_column; 
 11     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 12 END;
 13 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[4:21] PLC-00954 ',' expected but 10 found


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in CHAR,
  3   t_name   in VARCHAR2,
  4   t_num    in number,
  5   t_dec    in decimal,
  6   t_bin    in binary(100),
  7   t_vbin   in varbinary(100)
  8 ) 
  9 IS
 10   temp1 VARCHAR2(10);
 11   temp2 binary(100);
 12   temp3 varbinary(100);
 13 BEGIN
 14   temp1 := t_column; 
 15     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 16 END;
 17 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[6:21] PLC-00954 ',' expected but 100 found


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in interval,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:23] PLC-00601 Sql syntax error: YEAR or DAY expected


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in interval year,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:28] PLC-00601 Sql syntax error: 'TO MONTH' expected


SQL> 
SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in interval day to second(2),
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:37] PLC-00954 ',' expected but 2 found


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in timestamp(2),
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:24] PLC-00954 ',' expected but 2 found


SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in timestamp with time,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.PLSQL_SELECT_ITEM) terminated with compiling errors
[2:34] PLC-00601 Sql syntax error: 'TIME ZONE' expected


SQL> 
SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in timestamp with time zone,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in clob,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(100);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.

SQL> 
SQL> exec plsql_select_item(null, null);

No Data found for SELECT on 

PL/SQL procedure successfully completed.

SQL> 
SQL> -- TODO
SQL> exec plsql_select_item('WHF nihao!', null);

No Data found for SELECT on WHF nihao!

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in int signed,
  3   t_name   in VARCHAR2
  4 ) 
  5 IS
  6   temp1 VARCHAR2(10);
  7 BEGIN
  8   temp1 := t_column; 
  9     dbe_output.print_line ('No Data found for SELECT on ' || temp1);
 10 END;
 11 /

Succeed.

SQL> 
SQL> exec plsql_select_item('200.512', null);

No Data found for SELECT on 201

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2   t_column in CHAR,
  3   t_name   in VARCHAR2,
  4   t_num    in number,
  5   t_dec    in decimal,
  6   t_bin    in binary
  7 ) 
  8 IS
  9   temp1 VARCHAR2(20);
 10   temp2 binary(100);
 11   temp3 varbinary(100);
 12 BEGIN
 13 	temp1 := t_column; 
 14 	dbe_output.print_line ('data:' || temp1||'-');
 15 	dbe_output.print_line ('data:' || t_column||'-');
 16 	dbe_output.print_line ('data:' || t_name||'-');
 17 	dbe_output.print_line ('data:' || t_num||'-');
 18 	dbe_output.print_line ('data:' || t_dec||'-');
 19 	dbe_output.print_line ('data:' || t_bin||'-');
 20 END;
 21 /

Succeed.

SQL> exec plsql_select_item('abc','111111111111',1.32452, 0.333,hex2bin('0x112233'));

data:abc-
data:abc-
data:111111111111-
data:1.32452-
data:.333-
data:"3-

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --expect error
SQL> declare
  2   v_ename varchar2;
  3   n_value int;
  4 begin
  5   n_value := 1;
  6      DBE_STATS.PURGE_STATS(sysdate);  
  7 end;
  8 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:19] PLC-00601 Sql syntax error: the column size must be specified

SQL> 
SQL> --expect error:DTS2018071601849
SQL> drop table if exists plsql_emp;

Succeed.

SQL> create table plsql_emp(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_emp values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10000),(123,'zhangsan3','doctor3',10000);

3 rows affected.

SQL> insert into plsql_emp values(1,'zhansi','doctor1',10000),(2,'lisiabc','doctor2',10000),(123,'zhangwu123','doctor3',10000);

3 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> declare
  2 cursor mycursor(job_real varchar2 default 'doctor1',max_sal number default 9000) is  select ename from plsql_emp where job=job_real and sal> max_sal  order by sal;
  3 c_empno varchar2(20);
  4 a1 varchar2(20);
  5 b1 number;
  6 begin
  7 a1 := 'doctor1';
  8 b1 := 2000;
  9 open mycursor(a1,b1);
 10 fetch mycursor into c_empno;
 11 dbe_output.print_line('doctor2 c_empno is emp:'||c_empno);
 12 dbe_output.print_line(mycursor%rowcount);
 13 a1 := 'doctor2';
 14 b1 := 2100;
 15 fetch mycursor into c_empno;
 16 dbe_output.print_line('doctor2 c_empno is emp:'||c_empno);
 17 dbe_output.print_line(mycursor%rowcount);
 18 close mycursor;
 19 open mycursor(a1,b1);
 20 fetch mycursor into c_empno;
 21 dbe_output.print_line('doctor2 c_empno is emp:'||c_empno);
 22 dbe_output.print_line(mycursor%rowcount);
 23 close mycursor;
 24 end;
 25 /

doctor2 c_empno is emp:zhangsan
1
doctor2 c_empno is emp:zhansi
2
doctor2 c_empno is emp:zhangsan2
1

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 cursor mycursor(job_real varchar2 default 'doctor1',max_sal number default 9000) is  select ename from plsql_emp where job=job_real and sal> max_sal  order by sal;
  3 c_empno varchar2;
  4 begin
  5 open mycursor;
  6 fetch mycursor into c_empno;
  7 if  mycursor%found  then 
  8 dbe_output.print_line('c_empno is emp:'||c_empno);
  9 dbe_output.print_line(mycursor%rowcount);
 10 end if;
 11 close mycursor;
 12 open mycursor('doctor2',8000);
 13 fetch mycursor into c_empno;
 14 dbe_output.print_line('doctor2 c_empno is emp:'||c_empno);
 15 dbe_output.print_line(mycursor%rowcount);
 16 close mycursor;
 17 end;
 18 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[3:17] PLC-00601 Sql syntax error: the column size must be specified

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2    cursor cv(v_empno int,v_job varchar2) is select * from plsql_emp where empno=v_empno and job =v_job;
  3 BEGIN
  4         for i in cv(1,'doctor1')
  5         loop
  6         dbe_output.print_line('ename ='||i.ename);
  7         end loop;
  8 end;
  9 /

ename =zhangsan
ename =zhansi

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace function syscur_028(v_num int) return sys_refcursor
  2 is
  3         cv1 SYS_REFCURSOR;
  4         v_empno NUMBER(10,0);
  5 begin
  6         select count(*) INTO v_empno from plsql_emp;
  7         if v_empno <> v_num then
  8                 open cv1 for select 1 from dual;
  9         else
 10                 open cv1 for select 0 from dual;
 11         end if;
 12         RETURN cv1;
 13 end;
 14 /

Succeed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> declare
  2 cv sys_refcursor;
  3 v_empno plsql_emp.empno%type;
  4 begin
  5 cv :=syscur_028(10);
  6 loop
  7 fetch cv into v_empno;
  8 exit when cv%notfound;
  9 dbe_output.print_line('v_empno is '|| v_empno);
 10 end loop;
 11 close cv;
 12 end;
 13 /

v_empno is 1

PL/SQL procedure successfully completed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> create user plsql_nebula identified by Cantian_234;

Succeed.

SQL> create table plsql_nebula.plsql_syscur_026(c_since timestamp,c_end date);

Succeed.

SQL> insert into plsql_nebula.plsql_syscur_026 values(to_timestamp('2018-07-17 18:57:42.00','yyyy-mm-dd hh24:mi:ss.ff3'),to_date('2018-07-17 18:57:42','yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into plsql_nebula.plsql_syscur_026 values(to_timestamp('2018-07-16 18:57:42.00','yyyy-mm-dd hh24:mi:ss.ff3'),to_date('2018-07-16 18:57:42','yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> declare
  2 cv sys_refcursor;
  3 --since   timestamp;
  4 --ccend   date;
  5 since plsql_nebula.plsql_syscur_026.c_since%type;
  6 ccend plsql_nebula.plsql_syscur_026.c_since%type;
  7 c_syscur_026 plsql_nebula.plsql_syscur_026%rowtype;
  8 begin
  9 open cv for select distinct c_since,c_end from plsql_nebula.plsql_syscur_026 group by c_since,c_end order by 1,2;
 10 loop
 11 fetch cv into since,ccend;
 12 exit when cv%notfound;
 13 dbe_output.print_line('since_timestamp is ' || since||'---->'||'date_end is '|| ccend);
 14 end loop;
 15 close cv;
 16 open cv for select * from plsql_nebula.plsql_syscur_026 order by c_since,c_end;
 17 loop
 18 fetch cv into c_syscur_026;
 19 exit when cv%notfound;
 20 dbe_output.print_line('c_syscur_since_timestamp is ' || c_syscur_026.c_since||'---->'||'c_syscur_date_end is '|| c_syscur_026.c_end);
 21 end loop;
 22 close cv;
 23 end;
 24 /

since_timestamp is 2018-07-16 18:57:42.000000---->date_end is 2018-07-16 18:57:42.000000
since_timestamp is 2018-07-17 18:57:42.000000---->date_end is 2018-07-17 18:57:42.000000
c_syscur_since_timestamp is 2018-07-16 18:57:42.000000---->c_syscur_date_end is 2018-07-16 18:57:42
c_syscur_since_timestamp is 2018-07-17 18:57:42.000000---->c_syscur_date_end is 2018-07-17 18:57:42

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2    v_emp_test     plsql_emp%ROWTYPE;
  3    cursor cv is SELECT * FROM plsql_emp where empno=1 for update;
  4    BEGIN
  5    OPEN cv;
  6    FETCH cv INTO v_emp_test;
  7    while cv%FOUND LOOP
  8        update plsql_emp set sal=sal+1000 where current of cv;
  9        dbe_output.print_line(rpad(v_emp_test.empno,15,' ')||rpad(v_emp_test.ename,15,' ')||v_emp_test.sal);
 10        FETCH cv INTO v_emp_test;       
 11    END LOOP;   
 12    dbe_output.print_line( '-------------------------------------' );
 13    CLOSE cv;
 14 END;
 15 /

1              zhangsan       10000
1              zhansi         10000
-------------------------------------

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2    v_emp_test     plsql_emp%ROWTYPE;
  3    cursor cv is SELECT * FROM plsql_emp where empno=1 for update;
  4    BEGIN
  5    OPEN cv;
  6    FETCH cv INTO v_emp_test;
  7    while cv%FOUND LOOP
  8        delete from plsql_emp where current of cv;
  9        dbe_output.print_line(rpad(v_emp_test.empno,15,' ')||rpad(v_emp_test.ename,15,' ')||v_emp_test.sal);
 10        FETCH cv INTO v_emp_test;       
 11    END LOOP;   
 12    dbe_output.print_line( '-------------------------------------' );
 13    CLOSE cv;
 14 END;
 15 /

1              zhangsan       11000
1              zhansi         11000
-------------------------------------

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2    v_emp_test     plsql_emp%ROWTYPE;
  3    cursor cv is SELECT * FROM plsql_emp where empno=1 for update;
  4    BEGIN
  5    --OPEN cv;
  6    --FETCH cv INTO v_emp_test;
  7    --while cv%FOUND LOOP
  8        update plsql_emp set sal=sal+1000 where current of cv;
  9        dbe_output.print_line(rpad(v_emp_test.empno,15,' ')||rpad(v_emp_test.ename,15,' ')||v_emp_test.sal);
 10        --FETCH cv INTO v_emp_test;       
 11    --END LOOP;   
 12    dbe_output.print_line( '-------------------------------------' );
 13    CLOSE cv;
 14 END;
 15 /

CT-00932, [8:8] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[8:8] CT-00905, The cursor was invalid.

SQL> 
SQL> 
SQL> DECLARE
  2    v_emp_test     plsql_emp%ROWTYPE;
  3    cursor cv is SELECT * FROM plsql_emp where empno=1 for update;
  4    BEGIN
  5    OPEN cv;
  6    --FETCH cv INTO v_emp_test;
  7    --while cv%FOUND LOOP
  8        update plsql_emp set sal=sal+1000 where current of cv;
  9        dbe_output.print_line(rpad(v_emp_test.empno,15,' ')||rpad(v_emp_test.ename,15,' ')||v_emp_test.sal);
 10        --FETCH cv INTO v_emp_test;       
 11    --END LOOP;   
 12    dbe_output.print_line( '-------------------------------------' );
 13    CLOSE cv;
 14 exception
 15    when others then
 16    close cv;
 17 END;
 18 /

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists plsql_nebula.plsql_syscur_026;

Succeed.

SQL> drop user plsql_nebula cascade;

Succeed.

SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --end
SQL> 
SQL> --TEST: exit in procedure
SQL> create or replace procedure P_TEST_RETURN_EXIT is
  2 i number:=1;
  3 j number:=1;
  4 begin
  5 
  6 for i in 1..20 loop
  7 
  8 dbe_output.print_line('output='||i);
  9 if (i>10) then 
 10 EXIT;
 11 end if;
 12 
 13 end loop;
 14 
 15 for j in 1..20 loop
 16 
 17 dbe_output.print_line('output='||j);
 18 end loop;
 19 
 20 
 21 end P_TEST_RETURN_EXIT;
 22 /

Succeed.

SQL> 
SQL> exec P_TEST_RETURN_EXIT;

output=1
output=2
output=3
output=4
output=5
output=6
output=7
output=8
output=9
output=10
output=11
output=1
output=2
output=3
output=4
output=5
output=6
output=7
output=8
output=9
output=10
output=11
output=12
output=13
output=14
output=15
output=16
output=17
output=18
output=19
output=20

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace procedure P_TEST_RETURN_EXIT is
  2 
  3 i number:=1;
  4 j number:=1;
  5 begin
  6 
  7 for i in 1..20 loop
  8 dbe_output.print_line('output='||i);
  9 if (i>10) then 
 10 RETURN;
 11 end if;
 12 end loop;
 13 
 14 for j in 1..20 loop
 15 dbe_output.print_line('output='||j);
 16 end loop;
 17 
 18 end P_TEST_RETURN_EXIT;
 19 /

Succeed.

SQL> 
SQL> exec P_TEST_RETURN_EXIT;

output=1
output=2
output=3
output=4
output=5
output=6
output=7
output=8
output=9
output=10
output=11

PL/SQL procedure successfully completed.

SQL> 
SQL> --test return
SQL> declare 
  2     v_time varchar2(113) ;
  3     a      int := 1;
  4 begin
  5     begin
  6         select 'TIMETAG=' into v_time from dual where rownum <= 1;
  7         a := a/0;
  8     exception
  9         when no_data_found then                                                                                                                                                                         
 10             null;
 11     when others then
 12 	    dbe_output.print_line('will return immediate');
 13             return;
 14     end;
 15     dbe_output.print_line(v_time);
 16     dbe_output.print_line('**********');
 17     a := a/0;
 18 exception
 19     when no_data_found then                                                                                                                                                                         
 20         null;   
 21         when others then
 22     dbe_output.print_line(a||SQL_ERR_CODE||'******'||SQL_ERR_MSG);     
 23 end;
 24 /

will return immediate

PL/SQL procedure successfully completed.

SQL> 
SQL> --test recursive block
SQL> declare 
  2     v_time varchar2(113) ;
  3     a      int := 1;
  4     
  5 begin
  6     a := 9;
  7     v_time := 'aaaa';
  8     begin
  9         a := 10;
 10         v_time := v_time||'bbbb';
 11         a := a/0;
 12     exception
 13         when no_data_found then                                                                                                                                                                         
 14             null;
 15     end;
 16     dbe_output.print_line(a);
 17     dbe_output.print_line('****************');
 18     a := a/0;
 19 exception
 20     when no_data_found then                                                                                                                                                                         
 21         null;   
 22         when others then
 23     dbe_output.print_line(SQL_ERR_CODE||'******'||SQL_ERR_MSG||'---'||a);     
 24     dbe_output.print_line(SQL_ERR_CODE||'******'||SQL_ERR_MSG||'---'||v_time);  
 25 end;
 26 /

637******The divisor was zero---10
637******The divisor was zero---aaaabbbb

PL/SQL procedure successfully completed.

SQL> 
SQL> --end plsql_test: exit in procedure
SQL> 
SQL> --test exit in for-loop
SQL> create or replace procedure P_TEST_RETURN_EXIT is
  2 
  3 i number:=1;
  4 j number:=2;
  5 begin
  6 
  7 for i in 1..5 loop
  8 
  9 dbe_output.print_line('output i='||i);
 10 if (i>3) then
 11 EXIT;
 12 end if;
 13 
 14 end loop;
 15 
 16 for j in 1..5 loop
 17 
 18 dbe_output.print_line('output j='||j);
 19 end loop;
 20 
 21 end P_TEST_RETURN_EXIT;
 22 /

Succeed.

SQL> 
SQL> --expect 1,2,3,4,1,2,3,4,5
SQL> exec P_TEST_RETURN_EXIT;

output i=1
output i=2
output i=3
output i=4
output j=1
output j=2
output j=3
output j=4
output j=5

PL/SQL procedure successfully completed.

SQL> 
SQL> --test exit in loop
SQL> --expect 1
SQL> DECLARE
  2 x number;
  3 BEGIN
  4 x:=0;
  5 LOOP
  6 x:=x+1;
  7 
  8 EXIT WHEN x<3;
  9 dbe_output.print_line('inner:x='||x);
 10 END LOOP;
 11 dbe_output.print_line('outer:x='||x);
 12 END;
 13 /

outer:x=1

PL/SQL procedure successfully completed.

SQL> 
SQL> --test exit in while
SQL> --expect 1,2,2,3,4,5,6
SQL> DECLARE
  2 x number;
  3 BEGIN
  4 x:=0;
  5 WHILE x<3 LOOP
  6 x:=x+1;
  7 dbe_output.print_line('inner:x='||x);
  8 EXIT WHEN x=2;
  9 END LOOP;
 10 dbe_output.print_line('outer:x='||x);
 11 WHILE x<6 LOOP
 12 x:=x+1;
 13 dbe_output.print_line('inner:x='||x);
 14 END LOOP;
 15 END;
 16 /

inner:x=1
inner:x=2
outer:x=2
inner:x=3
inner:x=4
inner:x=5
inner:x=6

PL/SQL procedure successfully completed.

SQL> 
SQL> --empty body
SQL> begin
  2 end;
  3 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:1] PLC-00954 lines expected but END found

SQL> 
SQL> begin
  2 null;
  3 begin
  4 end;
  5 end;
  6 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[3:1] PLC-00954 lines expected but END found
[6:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> begin
  2   loop
  3   end loop;
  4 end;
  5 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:3] PLC-00954 lines expected but END LOOP found
[5:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> begin
  2   for i in 0..1 loop  
  3   end loop;
  4 end;
  5 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:3] PLC-00954 lines expected but END LOOP found
[5:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> begin
  2   while true loop  
  3   end loop;
  4 end;
  5 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:3] PLC-00954 lines expected but END LOOP found
[5:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> drop table if exists plsql_test;

Succeed.

SQL> drop table if exists t2;

Succeed.

SQL> create table plsql_test(f_int1 int, f_varchar1 varchar(10));

Succeed.

SQL> insert into plsql_test values(1,'value1');

1 rows affected.

SQL> insert into plsql_test values(2,'value2');

1 rows affected.

SQL> insert into plsql_test values(1,'value1_1');

1 rows affected.

SQL> insert into plsql_test values(4,'value4');

1 rows affected.

SQL> insert into plsql_test values(5,'value5');

1 rows affected.

SQL> create table t2(f_int1 int, f_varchar1 varchar(20));

Succeed.

SQL> 
SQL> declare
  2 cursor cv(v_empno int) is select f_int1, f_varchar1 from plsql_test where f_int1=v_empno;
  3 begin
  4 for i in cv(1)
  5 loop
  6 dbe_output.print_line(i.f_int1 || ',' || i.f_varchar1);
  7 insert into t2(f_int1, f_varchar1) values(i.f_int1,i.f_varchar1);
  8 end loop;
  9 end;
 10 /

1,value1
1,value1_1

PL/SQL procedure successfully completed.

SQL> drop table if exists plsql_test;

Succeed.

SQL> drop table if exists t2;

Succeed.

SQL> 
SQL> -----------------
SQL> --begin
SQL> --drop table if exists plsql_tab_1023_col;
SQL> --create table plsql_tab_1023_col(col_1 int);
SQL> --declare
SQL> --    v_sql varchar2(100);
SQL> --begin
SQL> --	for i in 2..1023
SQL> --	loop
SQL> --	    v_sql:='alter table plsql_tab_1023_col add column col_'||to_char(i)||' int';
SQL> --		execute immediate v_sql;
SQL> --	end loop;
SQL> --end;
SQL> --/
SQL> --
SQL> --insert into plsql_tab_1023_col(col_1,col_128,col_256,col_512,col_768,col_1023) values (1,128,256,512,768,1023);
SQL> --
SQL> --CREATE OR REPLACE PROCEDURE plsql_open_v_1023col (emp_cv  OUT sys_refcursor) IS
SQL> --  BEGIN
SQL> --    OPEN emp_cv FOR SELECT * FROM plsql_tab_1023_col;
SQL> --  END;
SQL> --/
SQL> --
SQL> --CREATE OR REPLACE  PROCEDURE plsql_fecth_v_1023col is 
SQL> --type mycurtp  is  ref  cursor;
SQL> --cur1 mycurtp;
SQL> --rec1 plsql_tab_1023_col%ROWTYPE;
SQL> --begin
SQL> --plsql_open_v_1023col(cur1);
SQL> --loop 
SQL> --fetch cur1 into rec1;
SQL> --exit when cur1%notfound;
SQL> --dbe_output.print_line(rec1.col_1||rec1.col_128||rec1.col_256||rec1.col_512||rec1.col_768||rec1.col_1023);
SQL> --end loop;
SQL> --close cur1;
SQL> --end;
SQL> --/
SQL> --call plsql_fecth_v_1023col();
SQL> --drop table if exists plsql_tab_1023_col;
SQL> --drop PROCEDURE plsql_open_v_1023col;
SQL> --drop PROCEDURE plsql_fecth_v_1023col;
SQL> --end
SQL> 
SQL> drop table if exists plsql_employees;

Succeed.

SQL> create table plsql_employees(employeesno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_employees values(1,'zhangsan','doctor1',10000);

1 rows affected.

SQL> insert into plsql_employees values(2,'zhangsan2','doctor2',10010);

1 rows affected.

SQL> insert into plsql_employees values(123,'zhangsan3','doctor3',10020);

1 rows affected.

SQL> alter table plsql_employees add  hiretime datetime;

Succeed.

SQL> 
SQL> create or replace  procedure plsql_test_outp1  is 
  2 type mycurtp is  ref cursor;
  3 cursorv1  mycurtp;
  4 sys_cur1  sys_refcursor;
  5 type  XXX is record(
  6 a varchar2(100),
  7 b number(10,1),
  8 c number(11,1)
  9 );
 10 var1 XXX;
 11 begin
 12 sys_cur1 := cursorv1;
 13 open  cursorv1 for  select ename as name, sal, sal*2 ep_sal from plsql_employees where ename like 'zhangsan%' ;
 14 loop
 15 fetch cursorv1 into var1;
 16 if cursorv1%notfound then  exit;
 17 end if;
 18 dbe_output.print_line('LINENO: '||cursorv1%rowcount||' +'||var1.a||'+'||var1.b||'+'||var1.c);
 19 end loop;
 20 end;
 21 /

Succeed.

SQL> 
SQL> call plsql_test_outp1();

LINENO: 1 +zhangsan+10000+20000
LINENO: 2 +zhangsan2+10010+20020
LINENO: 3 +zhangsan3+10020+20040

PL/SQL procedure successfully completed.

SQL> --test when keyword is used in procedure
SQL> --expect success
SQL> CREATE OR REPLACE PROCEDURE plsql_select_item (
  2 t_column in VARCHAR2,
  3 t_name in VARCHAR2
  4 )
  5 IS
  6 temp VARCHAR2(30);
  7 BEGIN
  8 temp := t_column;
  9 dbe_output.print_line ('No Data found for SELECT on ' || temp || t_name);
 10 END;
 11 /

Succeed.

SQL> 
SQL> exec plsql_select_item('111', '222');

No Data found for SELECT on 111222

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace  PROCEDURE  plsql_test_DROP_PROCEDURE_021ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ()
  2        as
  3        begin
  4            dbe_output.print_line('This is a procedure');
  5        END ;
  6        /

CT-00601, Sql syntax error: object is too long or varaint name
SQL> call plsql_test_DROP_PROCEDURE_021ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ();

CT-00601, Sql syntax error: object is too long or varaint name
SQL> call plsql_test_DROP_PROCEDURE_021ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNO;

CT-00601, Sql syntax error: object is too long or varaint name
SQL> call plsql_test_DROP_PROCEDURE_021ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOP;

CT-00601, Sql syntax error: object is too long or varaint name
SQL> DROP PROCEDURE plsql_test_DROP_PROCEDURE_021ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ;

CT-00601, Sql syntax error: object is too long or varaint name
SQL> 
SQL> create or replace view sysobjects as
  2 select object_name as name, object_name as id, CREATED as crdate, owner,
  3 case object_type when 'TABLE' then 'U'
  4                  when 'VIEW' then 'V'
  5                  when 'TRIGGER' then 'TR'
  6                  when 'PROCEDURE' then 'P'
  7                  else 'D' end as type
  8 from all_objects where instr(',SEQUENCE,PROCEDURE,TRIGGER,TABLE,VIEW,FUNCTION,',','||object_type||',')>0;

Succeed.

SQL> 
SQL> create or replace view sysindexes as
  2     select index_name as name, table_name as id, owner
  3     from all_indexes
  4 /

Succeed.

SQL> 
SQL> declare
  2     v_Temp_1 NUMBER(10, 0);
  3     v_Temp_2 varchar2(8000);
  4 begin
  5     select  count( a.id ) into v_Temp_1 from sysindexes a, sysobjects b where (UPPER(a.id) = UPPER(b.id) and UPPER(b.name) = UPPER('tmp_P_ANTENNAINFO_FOR_RAN')) AND UPPER(b.OWNER) = UPPER(user) AND UPPER(a.OWNER) = UPPER(user);
  6     if  (( v_Temp_1 ) > 1 ) then
  7         /*
  8 		drop index IDX_tmp_P_ANT_RAN;
  9 		*/
 10         v_Temp_2 := 'drop index IDX_tmp_P_ANT_RAN ON plsql_test';
 11         execute immediate v_Temp_2;
 12     end if;
 13 end; 
 14 /

PL/SQL procedure successfully completed.

SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test(a int);

Succeed.

SQL> declare
  2 a int;
  3 test int;
  4 begin
  5 a := 2;
  6 delete from plsql_test; 
  7 insert into plsql_test(a) values(1);
  8 update plsql_test set a = a;
  9 insert into plsql_test(a) values(1);
 10 end;
 11 /

PL/SQL procedure successfully completed.

SQL> select * from plsql_test order by a;

A           
------------
1           
2           

2 rows fetched.

SQL> drop table if exists plsql_test;

Succeed.

SQL> drop view sysobjects;

Succeed.

SQL> drop view sysindexes;

Succeed.

SQL> 
SQL> 
SQL> --test char size can not set
SQL> --begin
SQL> declare
  2     a char := '1';
  3   BEGIN
  4        CASE a
  5          WHEN '1' THEN
  6            dbe_output.print_line('1');
  7          WHEN '2' THEN
  8            dbe_output.print_line('2');
  9          WHEN '3' THEN
 10            dbe_output.print_line('a');
 11        END CASE;
 12 EXCEPTION
 13   WHEN OTHERS THEN    
 14     null;
 15 END;
 16 /

1

PL/SQL procedure successfully completed.

SQL> --end
SQL> 
SQL> --test drop procedure
SQL>  DROP PROCEDURE IF EXISTS Pro_IndexCopy
  2  /

Succeed.

SQL> 
SQL> CREATE PROCEDURE Pro_IndexCopy(ParentTableName VARCHAR,TableName VARCHAR)
  2 AS
  3     SqlStr VARCHAR(4000);
  4     IndexName VARCHAR(4000);
  5     columnName VARCHAR(4000);
  6     CURSOR curindex IS
  7     SELECT COLUMNS FROM USER_INDEXES WHERE table_name=UPPER(ParentTableName) AND IS_PRIMARY='N';
  8 BEGIN
  9     for cindex in curindex loop
 10         dbe_output.print_line(cindex.COLUMNS||',');
 11         IndexName:=CONCAT('idx_', tableName, '_', REPLACE(cindex.COLUMNS, ',', '_'));
 12         IF (LENGTH(IndexName) > 64) THEN
 13             IndexName:=SUBSTR(IndexName, -64);
 14         END IF;
 15         columnName:=REPLACE(cindex.COLUMNS, ',', '`,`');
 16         SqlStr := CONCAT('CREATE INDEX IF NOT EXISTS ',IndexName, ' ON ' , tableName, '(`',columnName,'`)');
 17         EXECUTE IMMEDIATE SqlStr;
 18     end loop;
 19 END;
 20 /

Succeed.

SQL> 
SQL> drop procedure Pro_IndexCopy';

CT-00601, [1:29]Sql syntax error: text is not completed
SQL> drop procedure Pro_IndexCopy'';

CT-00601, [1:29]Sql syntax error: expected end but '' found
SQL> drop procedure Pro_IndexCopy ''''''''''''';

CT-00601, [1:30]Sql syntax error: text is not completed
SQL> drop procedure Pro_IndexCopy'''''''''';

CT-00601, [1:29]Sql syntax error: expected end but '''''''''' found
SQL> drop procedure Pro_IndexCopy();

CT-00601, [1:29]Sql syntax error: expected end but  found
SQL> drop procedure if exists Pro_IndexCopy';

CT-00601, [1:39]Sql syntax error: text is not completed
SQL> drop procedure if exists Pro_IndexCopy'';

CT-00601, [1:39]Sql syntax error: expected end but '' found
SQL> drop procedure if exists Pro_IndexCopy ''''''''''''';

CT-00601, [1:40]Sql syntax error: text is not completed
SQL> drop procedure if exists Pro_IndexCopy'''''''''';

CT-00601, [1:39]Sql syntax error: expected end but '''''''''' found
SQL> drop procedure if exists Pro_IndexCopy();

CT-00601, [1:39]Sql syntax error: expected end but  found
SQL> drop procedure Pro_IndexCopy;

Succeed.

SQL> 
SQL> drop procedure if exists plsql_test_drop
  2 /

Succeed.

SQL> create procedure plsql_test_drop()
  2 as
  3     aa int;
  4 begin
  5     select count(*) into aa from all_tables;
  6 end;
  7 /

Succeed.

SQL> drop procedure plsql_test_drop';

CT-00601, [1:31]Sql syntax error: text is not completed
SQL> drop procedure plsql_test_drop'';

CT-00601, [1:31]Sql syntax error: expected end but '' found
SQL> drop procedure plsql_test_drop ''''''''''''';

CT-00601, [1:32]Sql syntax error: text is not completed
SQL> drop procedure plsql_test_drop'''''''''';

CT-00601, [1:31]Sql syntax error: expected end but '''''''''' found
SQL> drop procedure plsql_test_drop();

CT-00601, [1:31]Sql syntax error: expected end but  found
SQL> drop procedure plsql_test_drop;

Succeed.

SQL> 
SQL> 
SQL> --test sysrefcursor be opened more than once
SQL> --begin
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> ----------open more than once
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 1 from dual;
  5 open a for select 2 from dual;
  6 end;
  7 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> ----------open more than once, then return someone 1
SQL> --expect 2
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 1 from dual;
  5 open a for select 2 from dual;
  6 dbe_sql.return_cursor(a);
  7 end;
  8 /

PL/SQL procedure successfully completed.

ResultSet #1

2           
------------
2           

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect output:1000
SQL> declare
  2 b sys_refcursor;
  3 a sys_refcursor;
  4 c int;
  5 begin
  6 open b for select 2000 from dual;
  7 a := b;
  8 open b for select 1000 from dual;
  9 
 10 fetch a into c;
 11 dbe_output.print_line(c);
 12 close a;
 13 end;
 14 /

1000

PL/SQL procedure successfully completed.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect output:3000, 2000
SQL> declare
  2 b sys_refcursor;
  3 a sys_refcursor;
  4 c int;
  5 begin
  6 open b for select 2000 from dual;
  7 dbe_sql.return_cursor(b);
  8 a := b;
  9 open b for select 1000 from dual;
 10 open b for select 3000 from dual;
 11 fetch a into c;
 12 dbe_output.print_line(c);
 13 end;
 14 /

3000

PL/SQL procedure successfully completed.

ResultSet #1

2000        
------------
2000        

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect output:1000, 2000
SQL> declare
  2 b sys_refcursor;
  3 c int;
  4 begin
  5 open b for select 2000 from dual;
  6 dbe_sql.return_cursor(b);
  7 open b for select 1000 from dual;
  8 fetch b into c;
  9 dbe_output.print_line(c);
 10 end;
 11 /

1000

PL/SQL procedure successfully completed.

ResultSet #1

2000        
------------
2000        

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect invalid cursor
SQL> declare
  2 b sys_refcursor;
  3 a sys_refcursor;
  4 c int;
  5 begin
  6 open b for select 2000 from dual;
  7 dbe_sql.return_cursor(b);
  8 a := b;
  9 fetch a into c;
 10 dbe_output.print_line(c);
 11 end;
 12 /

CT-00932, [9:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[9:1] CT-00905, The cursor was invalid.

SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> create or replace procedure a_ret(b OUT sys_refcursor)
  2 is
  3 begin
  4 open b for select 2000 from dual;
  5 dbe_sql.return_cursor(b);
  6 open b for select 1000 from dual;
  7 end;
  8 /

Succeed.

SQL> 
SQL> --expect 2000, 1000
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 a_ret(a);
  5 dbe_sql.return_cursor(a);
  6 end;
  7 /

PL/SQL procedure successfully completed.

ResultSet #1

2000        
------------
2000        

1 rows fetched.


ResultSet #2

1000        
------------
1000        

1 rows fetched.


SQL> 
SQL> ----------open more than once, then return someone 2
SQL> create or replace procedure a_ret1(b OUT sys_refcursor)
  2 is
  3 a sys_refcursor;
  4 begin
  5 open a for select 2 from dual;
  6 dbe_sql.return_cursor(a);
  7 open a for select 1 from dual;
  8 b := a;
  9 end;
 10 /

Succeed.

SQL> 
SQL> ----------
SQL> create or replace procedure a_ret2(b OUT sys_refcursor)
  2 is
  3 a sys_refcursor;
  4 begin
  5 open a for select 2 from dual;
  6 dbe_sql.return_cursor(a);
  7 b := a;
  8 end;
  9 /

Succeed.

SQL> 
SQL> ----------
SQL> create or replace procedure a_ret3(b OUT sys_refcursor)
  2 is
  3 a sys_refcursor;
  4 begin
  5 open a for select 3 from dual;
  6 dbe_sql.return_cursor(a);
  7 a_ret1(a);
  8 dbe_sql.return_cursor(a);
  9 b := a;
 10 end;
 11 /

Succeed.

SQL> 
SQL> ----------call by procedure
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect 2000,1000
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 a_ret(a);
  6 dbe_sql.return_cursor(a);
  7 open a for select 11 from dual;
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

2000        
------------
2000        

1 rows fetched.


ResultSet #2

1000        
------------
1000        

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect 2,1
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 a_ret1(a);
  6 dbe_sql.return_cursor(a);
  7 open a for select 11 from dual;
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

2           
------------
2           

1 rows fetched.


ResultSet #2

1           
------------
1           

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect error
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 a_ret2(a);
  6 dbe_sql.return_cursor(a);
  7 end;
  8 /

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:1] PL/SQL(DBE_SQL.RETURN_CURSOR) terminated with execute errors
[6:23] CT-00905, The cursor was invalid.

SQL> 
SQL> --expect 2,11
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 a_ret2(a);
  6 open a for select 11 from dual;
  7 dbe_sql.return_cursor(a);
  8 open a for select 12 from dual;
  9 end;
 10 /

PL/SQL procedure successfully completed.

ResultSet #1

2           
------------
2           

1 rows fetched.


ResultSet #2

11          
------------
11          

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> --expect 3,2,1
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 a_ret3(a);
  6 end;
  7 /

PL/SQL procedure successfully completed.

ResultSet #1

3           
------------
3           

1 rows fetched.


ResultSet #2

2           
------------
2           

1 rows fetched.


ResultSet #3

1           
------------
1           

1 rows fetched.


SQL> 
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> create or replace procedure ret_null(b OUT sys_refcursor)
  2 is
  3 a int;
  4 begin
  5 a := 1;
  6 end;
  7 /

Succeed.

SQL> 
SQL> --expect 10
SQL> declare
  2 a sys_refcursor;
  3 begin
  4 open a for select 10 from dual;
  5 ret_null(a);
  6 dbe_sql.return_cursor(a);
  7 open a for select 11 from dual;
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

10          
------------
10          

1 rows fetched.


SQL> --end
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> 
SQL> --test cursor is setval recursive
SQL> --begin
SQL> --expect 10,11,12,13
SQL> declare
  2 a sys_refcursor;
  3 b sys_refcursor;
  4 c sys_refcursor;
  5 begin
  6 open a for select 10 from dual;
  7 b := a;
  8 c := b;
  9 a := c;
 10 dbe_sql.return_cursor(a);
 11 open a for select 11 from dual;
 12 dbe_sql.return_cursor(b);
 13 open b for select 12 from dual;
 14 dbe_sql.return_cursor(a);
 15 open b for select 13 from dual;
 16 dbe_sql.return_cursor(c);
 17 end;
 18 /

PL/SQL procedure successfully completed.

ResultSet #1

10          
------------
10          

1 rows fetched.


ResultSet #2

11          
------------
11          

1 rows fetched.


ResultSet #3

12          
------------
12          

1 rows fetched.


ResultSet #4

13          
------------
13          

1 rows fetched.


SQL> 
SQL> --expect a,d,a,ad,b,b
SQL> declare
  2 a sys_refcursor;
  3 b sys_refcursor;
  4 c sys_refcursor;
  5 d sys_refcursor;
  6 e sys_refcursor;
  7 f sys_refcursor;
  8 begin
  9 open a for select 'a' from dual;
 10 b := a;
 11 c := b;
 12 e := a;
 13 a := c;
 14 
 15 dbe_sql.return_cursor(a);
 16 open a for select 'a' from dual;
 17 open d for select 'd' from dual;
 18 a := d;
 19 dbe_sql.return_cursor(a);
 20 open d for select 'ad' from dual;
 21 dbe_sql.return_cursor(b);
 22 open b for select 'b' from dual;
 23 dbe_sql.return_cursor(a);
 24 open b for select 'b' from dual;
 25 dbe_sql.return_cursor(c);
 26 open b for select 'b' from dual;
 27 dbe_sql.return_cursor(e);
 28 open f for select 'f' from dual;
 29 b:= f;
 30 dbe_sql.return_cursor(b);
 31 end;
 32 /

PL/SQL procedure successfully completed.

ResultSet #1

'A'
---
a  

1 rows fetched.


ResultSet #2

'D'
---
d  

1 rows fetched.


ResultSet #3

'A'
---
a  

1 rows fetched.


ResultSet #4

'AD'
----
ad  

1 rows fetched.


ResultSet #5

'B'
---
b  

1 rows fetched.


ResultSet #6

'B'
---
b  

1 rows fetched.


ResultSet #7

'F'
---
f  

1 rows fetched.


SQL> --end
SQL> select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid;

STMT_ID      SQL_TEXT                                                         STATUS                                                          
------------ ---------------------------------------------------------------- ----------------------------------------------------------------
0            select stmt_id,sql_text,status from sys.v$open_cursor open_cur, sys.v$me me where open_cur.session_id = me.sid STMT_STATUS_EXECUTING                                           

1 rows fetched.

SQL> ------Declare error    OK
SQL> declare
  2   a xxxx;
  3 begin
  4   null;
  5 end;
  6 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[2:5] PLC-00601 Sql syntax error: datatype expected, but got 'xxxx'

SQL> -------blank or comment line
SQL> declare
  2   a int;
  3 begin
  4   a := 1;
  5   null  
  6 end;
  7 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[6:1] PLC-00601 Sql syntax error: ; expected
[7:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> declare
  2   a int;
  3 begin
  4   a := 1;
  5   /*do nothing*/
  6   null
  7 end;
  8 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[7:1] PLC-00601 Sql syntax error: ; expected
[8:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> declare
  2   --do nothing
  3   a int;
  4 begin
  5   --do nothing
  6   a := 1;
  7   --do nothing
  8   null  
  9 end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[9:1] PLC-00601 Sql syntax error: ; expected
[10:1] PLC-00954 more text expected but EOF found

SQL> ------sql error
SQL> declare
  2   a int;
  3 begin 
  4   select 1 into a from dual;
  5   select 1 from dual;  
  6 end;
  7 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[5:3] PLC-00916 PL/SQL:syntax error(an INTO clause is expected in this SELECT statement)

SQL> 
SQL> declare
  2   a int;
  3 begin 
  4   select 1 into a from dualx;  
  5 end;
  6 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[4:17] PLC-00843 The table or view GS_PLSQL.DUALX does not exist.

SQL> ------dynamic sql error
SQL> declare
  2   a int;
  3   sqlstr varchar(20);
  4 begin 
  5   select 1 into a from dual;
  6   sqlstr := 'select 1 from dualx';
  7   execute immediate sqlstr;
  8 end;
  9 /

CT-00932, [7:3] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[1:15] CT-00843, The table or view GS_PLSQL.DUALX does not exist.

SQL> 
SQL> ------exec compile error procedure
SQL> create or replace procedure xxx_c 
  2 as
  3   a int;
  4   sqlstr varchar(20);
  5 begin 
  6   select 1 into a from dual;
  7   sqlstr := 'select 1 from dualx';
  8   execute immediate sqlstr;
  9 end;
 10 /

Succeed.

SQL> 
SQL> exec xxx_c();

CT-00932, [1:2] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[7:3] PL/SQL(GS_PLSQL.XXX_C) terminated with execute errors
[1:15] CT-00843, The table or view GS_PLSQL.DUALX does not exist.

SQL> ------anonymous block call compile error procedure
SQL> create or replace procedure xxx_c as
  2   a int;
  3   sqlstr varchar(20);
  4 begin 
  5   select 1 into a from dual;
  6   sqlstr := 'select 1 from dualx';
  7   execute immediate sqlstr;
  8 end;
  9 /

Succeed.

SQL> 
SQL> declare
  2 sqlstr varchar(100);
  3 begin
  4 null;
  5 null;
  6 null;
  7 xxx_c();
  8 null;
  9 sqlstr := 'select 1 from dualx';
 10 execute immediate sqlstr;
 11 end;
 12 /

CT-00932, [7:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[7:3] PL/SQL(GS_PLSQL.XXX_C) terminated with execute errors
[1:15] CT-00843, The table or view GS_PLSQL.DUALX does not exist.

SQL> ------anonymous block call compile error procedure
SQL> create or replace procedure xxx_c as
  2   a int;
  3   sqlstr varchar(20);
  4 begin 
  5   select 1 into a from dual;
  6   sqlstr := 'select 1 from dual';
  7   execute immediate sqlstr;
  8 end;
  9 /

Succeed.

SQL> 
SQL> declare
  2 sqlstr varchar(100);
  3 begin
  4 null;
  5 null;
  6 null;
  7 xxx_c();
  8 null;
  9 sqlstr := 'select 1 from dualx';
 10 execute immediate sqlstr;
 11 end;
 12 /

CT-00932, [10:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[1:15] CT-00843, The table or view GS_PLSQL.DUALX does not exist.

SQL> -------procedure call procedure with compiler error
SQL> create or replace procedure xxx_c as
  2   a sys_refcursor;
  3   sqlstr varchar(20);
  4 begin
  5   null;
  6   open a for insert select 1 from dual;
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.XXX_C) terminated with compiling errors
[6:14] PLC-00601 Sql syntax error: invalid expression


SQL> 
SQL> create or replace procedure xxx_h as
  2   a sys_refcursor;
  3   sqlstr varchar(20);
  4 begin 
  5   open a for insert into plsql_test select 1 from dual;
  6   xxx_c();
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(GS_PLSQL.XXX_H) terminated with compiling errors
[5:14] PLC-00601 Sql syntax error: invalid expression
[6:3] PLC-00944 PL/SQL(GS_PLSQL.XXX_C) terminated with compiling errors
[6:14] PLC-00601 Sql syntax error: invalid expression



SQL> call xxx_h;

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[1:2] PLC-00944 PL/SQL(GS_PLSQL.XXX_H) terminated with compiling errors
[5:14] PLC-00601 Sql syntax error: invalid expression
[6:3] PLC-00944 PL/SQL(GS_PLSQL.XXX_C) terminated with compiling errors
[6:14] PLC-00601 Sql syntax error: invalid expression



SQL> --------procedure call procedure with execute error
SQL> create or replace procedure xxx_c as
  2   a sys_refcursor;
  3   sqlstr varchar(100) := 'insert select 1 from dual';
  4 begin 
  5   open a for sqlstr;
  6 end;
  7 /

Succeed.

SQL> 
SQL> create or replace procedure xxx_h as
  2   a sys_refcursor;
  3   sqlstr varchar(100) := 'insert into plsql_test values(1)';
  4 begin 
  5   null;  
  6   open a for sqlstr;
  7   xxx_c();
  8 end;
  9 /

Succeed.

SQL> 
SQL> call xxx_h();

CT-00932, [1:2] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:3] PL/SQL(GS_PLSQL.XXX_H) terminated with execute errors
[6:3] CT-00922, PL/SQL: illegal line(sys_refcursor must open a legal SELECT statement)

SQL> --------procedure call procedure with execute error
SQL> create or replace procedure xxx_h as
  2   a sys_refcursor;
  3   sqlstr varchar(100) := 'insert into plsql_test values(1)';
  4 begin 
  5   null;  
  6   xxx_c();
  7   open a for sqlstr;
  8 end;
  9 /

Succeed.

SQL> 
SQL> call xxx_h();

CT-00932, [1:2] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:3] PL/SQL(GS_PLSQL.XXX_H) terminated with execute errors
[5:3] PL/SQL(GS_PLSQL.XXX_C) terminated with execute errors
[5:3] CT-00922, PL/SQL: illegal line(sys_refcursor must open a legal SELECT statement)

SQL> 
SQL> declare
  2 begin
  3 null;
  4 xxx_h();
  5 end;
  6 /

CT-00932, [4:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:3] PL/SQL(GS_PLSQL.XXX_H) terminated with execute errors
[5:3] PL/SQL(GS_PLSQL.XXX_C) terminated with execute errors
[5:3] CT-00922, PL/SQL: illegal line(sys_refcursor must open a legal SELECT statement)

SQL> 
SQL> --begin:test alter password
SQL> DROP USER IF EXISTS plsql_test_USER_1 cascade;

Succeed.

SQL> CREATE USER plsql_test_USER_1 IDENTIFIED BY plsql_test_USER_12;

Succeed.

SQL> CREATE or replace procedure plsql_test_PROC_PASSWORD
  2 is
  3 BEGIN
  4 execute immediate 'ALTER USER plsql_test_USER_1 IDENTIFIED BY plsql_test_USER_12';
  5 END;
  6 /

Succeed.

SQL> 
SQL> call plsql_test_PROC_PASSWORD();

PL/SQL procedure successfully completed.

SQL> call plsql_test_PROC_PASSWORD();

PL/SQL procedure successfully completed.

SQL> 
SQL> DROP USER plsql_test_USER_1;

Succeed.

SQL> --end:test:alter password
SQL> 
SQL> --DTS2020030625889
SQL> drop table if exists REF_DTS2020030625889_01;

Succeed.

SQL> drop table if exists REF_DTS2020030625889_02;

Succeed.

SQL> create table REF_DTS2020030625889_01(id int primary key,sn number (10,0),sal number(10,2),name varchar(100),text varchar(100) ,c_time date,m_time datetime);


Succeed.

SQL> create table REF_DTS2020030625889_02(id int ,sn number (10,0),sal number(10,2),name varchar(100),text varchar(100) default 'test',c_time date,m_time datetime);

Succeed.

SQL> insert into REF_DTS2020030625889_01 values(1,0.11,90000.50,'test','lob',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_01 values(5,0.11,90000.50,'jane','',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_01 values(6,123.11,90000.50,'test','lob',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_01 values(2,123.11,80000.50,'test','lob',to_date('2019-01-08'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_01 values(10,123.11,90000.50,'test','lob',to_date('2019-01-09'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_01 values(101,156262811.11,90000.50,'test','lob',to_date('2019-01-09'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_02 values(1,123.11,90000.50,'test','lob',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_02 values(5,123.11,90000.50,'jane','lob',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_02 values(21,10001.11,90000.50,'test','lob',to_date('2019-01-07'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> insert into REF_DTS2020030625889_02 values(10,123.11,90000.50,'test','lob',to_date('2019-01-09'),to_date('2019-01-07 14:44:50'));

1 rows affected.

SQL> create or replace procedure REF_CURSOR_JOIN_005(v_sn in number,v_sal in number) is
  2 v_id int;
  3 v_name varchar(100);
  4 v_text varchar(100) ;
  5 v_c_time date;
  6 v_m_time datetime;
  7 cursor3 sys_refcursor;
  8 str3 varchar(4000) := 'select t1.id ,(select t2.name from REF_DTS2020030625889_02 t2 where t2.name = t1.name limit 1) t2_name,t1.c_time  from
  9 REF_DTS2020030625889_01 t1 left join REF_DTS2020030625889_02  t2 on t1.id = t2.id and t2.sn = 90000.50 order by id ,c_time';
 10 begin
 11   open cursor3 for str3 ;
 12   loop
 13   fetch cursor3 into v_id,v_name,v_c_time;
 14     exit when cursor3%notfound;
 15     dbe_output.print_line(v_id||' '||v_name||' '||v_c_time );
 16    end loop;
 17 end;
 18 /

Succeed.

SQL> call  REF_CURSOR_JOIN_005(0,90000.50);

1 test 2019-01-07 00:00:00
2 test 2019-01-08 00:00:00
5 jane 2019-01-07 00:00:00
6 test 2019-01-07 00:00:00
10 test 2019-01-09 00:00:00
101 test 2019-01-09 00:00:00

PL/SQL procedure successfully completed.

SQL>
SQL> create or replace function REF_CURSOR_JOIN_006(v_sn in number,v_sal in number) return int is
  2 v_id int;
  3 v_name varchar(100);
  4 v_text varchar(100) ;
  5 v_c_time date;
  6 v_m_time datetime;
  7 cursor3 sys_refcursor;
  8 str3 varchar(4000) := 'select t1.id ,(select t2.name from REF_DTS2020030625889_02 t2 where t2.name = t1.name limit 1) t2_name,t1.c_time  from
  9 REF_DTS2020030625889_01 t1 left join REF_DTS2020030625889_02  t2 on t1.id = t2.id and t2.sn = 90000.50 order by id ,c_time';
 10 begin
 11   open cursor3 for str3 ;
 12   loop
 13   fetch cursor3 into v_id,v_name,v_c_time;
 14     exit when cursor3%notfound;
 15     dbe_output.print_line(v_id||' '||v_name||' '||v_c_time );
 16    end loop;
 17    return 1;
 18 end;
 19 /

Succeed.

SQL> select REF_CURSOR_JOIN_006(0,90000.50) from dual;

REF_CURSOR_JOIN_006(0,90000.50)
-------------------------------
1

1 rows fetched.

1 test 2019-01-07 00:00:00
2 test 2019-01-08 00:00:00
5 jane 2019-01-07 00:00:00
6 test 2019-01-07 00:00:00
10 test 2019-01-09 00:00:00
101 test 2019-01-09 00:00:00

SQL> create or replace function REF_CURSOR_JOIN_007(v_sn in number,v_sal in number) return varchar is
  2 v_id int;
  3 v_name varchar(100);
  4 v_text varchar(100) ;
  5 v_c_time date;
  6 v_m_time datetime;
  7 cursor3 sys_refcursor;
  8 v_name2 varchar(4000) := '';
  9 begin
 10    for item in (select t1.id id,(select t2.name from REF_DTS2020030625889_02 t2 where t2.name = t1.name limit 1) t2_name,t1.c_time  from
 11 REF_DTS2020030625889_01 t1 left join REF_DTS2020030625889_02  t2 on t1.id = t2.id and t2.sn = 90000.50 order by id ,c_time)
 12    loop
 13        v_name2:=v_name2||item.t2_name;
 14    end loop;
 15    return v_name2;
 16 end;
 17 /

Succeed.

SQL> select REF_CURSOR_JOIN_007(0,90000.50) from dual;

REF_CURSOR_JOIN_007(0,90000.50)
----------------------------------------------------------------
testtestjanetesttesttest

1 rows fetched.

SQL> drop table REF_DTS2020030625889_01;

Succeed.

SQL> drop table REF_DTS2020030625889_02;

Succeed.

SQL> ------------------------------
SQL> --test fetch unopen cursor :DTS2018081702495
SQL> --begin
SQL> drop table plsql_employees;

Succeed.

SQL> create table plsql_employees(employeesno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_employees values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10010),(123,'zhangsan3','doctor3',10020);

3 rows affected.

SQL> alter table plsql_employees add  hiretime datetime;

Succeed.

SQL> commit;

Succeed.

SQL> 
SQL> --test refcursor
SQL> create or replace  function plsql_test_outf1()   return sys_refcursor is
  2 type mycurtp is  ref cursor;
  3 cursorv1  mycurtp;
  4 sys_cur1  sys_refcursor;
  5 type  XXX is record(
  6 a varchar2(100),
  7 b number(10,1),
  8 c number(11,1)
  9 );
 10 var1 XXX;
 11 begin
 12 sys_cur1 := cursorv1;
 13 open  cursorv1 for  select ename as name, sal, sal*2 ep_sal from plsql_employees where ename like 'zhangsan%' ;
 14 loop
 15 fetch sys_cur1 into var1;
 16 if sys_cur1%notfound then  exit;
 17 end if;
 18 dbe_output.print_line(sys_cur1%rowcount||':'||var1.a||'+'||var1.b||'+'||var1.c);
 19 end loop;
 20 end;
 21 /

Succeed.

SQL> --expect error
SQL> select plsql_test_outf1();

CT-00932, [15:1] PL/SQL(GS_PLSQL.PLSQL_TEST_OUTF1) terminated with execute errors
[15:1] CT-00905, The cursor was invalid.

SQL> 
SQL> --end
SQL> CREATE OR REPLACE PROCEDURE proc_2(a int) AS
  2   rc1 sys_refcursor;
  3 BEGIN
  4   OPEN rc1 FOR SELECT 1 FROM dual where 1 > a;
  5   dbe_sql.return_cursor(rc1);
  6 END;
  7 / 

Succeed.

SQL> 
SQL> --expect success
SQL> exec proc_2(0);

PL/SQL procedure successfully completed.

ResultSet #1

1           
------------
1           

1 rows fetched.


SQL> 
SQL> 
SQL> 
SQL> --test the variant name is dq_string
SQL> --begin
SQL> --exepect 0
SQL> declare
  2 "a" number;
  3 a number;
  4 begin
  5 "a" := 1;
  6 a := "a";
  7 dbe_output.print_line(a-"a");
  8 end;
  9 /

0

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect null
SQL> declare
  2 "a" number;
  3 a number;
  4 begin
  5 "a" := 1;
  6 a := a;
  7 dbe_output.print_line(a-"a");
  8 end;
  9 /



PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists plsql_test;

Succeed.

SQL> create table plsql_test(a int, b int);

Succeed.

SQL> insert into plsql_test values(10, 100);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> declare
  2 b int;
  3 cursor c1("xx" int default 10) is select a from plsql_test where a = "xx";
  4 begin
  5 open c1(20);
  6 FETCH c1 into b;
  7 dbe_output.print_line('result is:' || b);
  8 FETCH c1 into b;
  9 dbe_output.print_line('result is:' || b);
 10 close c1;
 11 end;
 12 /

result is:
result is:

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE p_test_dq("a" in number, "b" out varchar) AS
  2     a     number := 0;
  3   BEGIN
  4     IF "a" < a THEN
  5       "b" := 'negative number';
  6     ELSIF "a" = a THEN
  7       "b" := 'zero';
  8     ELSE
  9       "b" := 'positive number';
 10     END IF;
 11 END p_test_dq;
 12 /

Succeed.

SQL> 
SQL> --expect:positive number
SQL> declare
  2 b varchar2(256);
  3 v_sql varchar2(256);
  4 begin
  5 v_sql:='begin p_test_dq(:v1,:v2); end;';
  6 execute immediate v_sql using in 1,out b;
  7 dbe_output.print_line(b);
  8 end;
  9 /

positive number

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect:negative number
SQL> declare
  2 b varchar2(256);
  3 v_sql varchar2(256);
  4 begin
  5 v_sql:='begin p_test_dq(:v1,:v2); end;';
  6 execute immediate v_sql using -1,out b;
  7 dbe_output.print_line(b);
  8 end;
  9 /

negative number

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE "p_test_dq"("a" in number, "b" out varchar) AS
  2     a     number := 0;
  3   BEGIN
  4     IF "a" < a THEN
  5       "b" := 'negative number1';
  6     ELSIF "a" = a THEN
  7       "b" := 'zero1';
  8     ELSE
  9       "b" := 'positive number1';
 10     END IF;
 11 END "p_test_dq";
 12 /

Succeed.

SQL> 
SQL> --expect:positive number1
SQL> declare
  2 b varchar2(256);
  3 v_sql varchar2(256);
  4 begin
  5 v_sql:='begin "p_test_dq"(:v1,:v2); end;';
  6 execute immediate v_sql using in 1,out b;
  7 dbe_output.print_line(b);
  8 end;
  9 /

positive number1

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect:positive number1
SQL> declare
  2 b varchar2(256);
  3 v_sql varchar2(256);
  4 begin
  5 v_sql:='declare "d" number :=0; e varchar2(256); begin "p_test_dq"("d",e); dbe_output.print_line(e);end;';
  6 execute immediate v_sql;
  7 dbe_output.print_line('outer:'||b);
  8 end;
  9 /

zero1
outer:

PL/SQL procedure successfully completed.

SQL> --end
SQL> 
SQL> --test label with dq string
SQL> --begin
SQL> --expect success
SQL> DECLARE
  2   p  VARCHAR2(30);
  3   n  INTEGER := 37;
  4 BEGIN
  5     IF n = 37 THEN 
  6       p := ' is a prime number';
  7       GOTO "print_now";
  8     END IF;
  9 
 10   p := ' is not a prime number';
 11  
 12   <<"print_now">>
 13   dbe_output.print_line(TO_CHAR(n) || p);
 14 END;
 15 /

37 is a prime number

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect success
SQL> DECLARE
  2   p  VARCHAR2(30);
  3   n  INTEGER := 36;
  4 BEGIN
  5     IF n = 37 THEN 
  6       p := ' is a prime number';
  7       GOTO "print_now";
  8     END IF;
  9 
 10   p := ' is not a prime number';
 11  
 12   <<"print_now">>
 13   dbe_output.print_line(TO_CHAR(n) || p);
 14 END;
 15 /

36 is not a prime number

PL/SQL procedure successfully completed.

SQL> 
SQL> --expect error
SQL> DECLARE
  2   p  VARCHAR2(30);
  3   n  INTEGER := 37;
  4 BEGIN
  5     IF n = 37 THEN 
  6       p := ' is a prime number';
  7       GOTO print_now;
  8     END IF;
  9 
 10   p := ' is not a prime number';
 11  
 12   <<"print_now">>
 13   dbe_output.print_line(TO_CHAR(n) || p);
 14 END;
 15 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[7:7] PLC-00916 PL/SQL:syntax error(PRINT_NOW is an invalid label)

SQL> 
SQL> --end
SQL> 
SQL> ---------------DTS2018082204388
SQL> drop table if exists hash_tbl_002;

Succeed.

SQL> create table hash_tbl_002(c_id int,c_d_id number(10,4)) partition by hash(c_id) partitions 8;

Succeed.

SQL> declare
  2 pname varchar2(20);
  3 count_num int;
  4 cursor mycursor is select name from SYS_TABLE_PARTS where table# in (select ID from SYS_TABLES where name=upper('hash_tbl_002')) order by name;
  5 begin
  6    open mycursor;
  7    fetch mycursor into pname;
  8    while mycursor%found loop
  9    --dbe_output.print_line('part_name' ||' is '||pname);
 10    select count(*) into count_num from hash_tbl_002 partition(pname);
 11    --dbe_output.print_line(pname ||' is '||count_num);
 12    fetch mycursor into pname;
 13    end loop;
 14    close mycursor;
 15 end;
 16 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[6:21] PLC-00843 The table or view GS_PLSQL.SYS_TABLE_PARTS does not exist.

SQL> create or replace function DBA_ARGUMENTS_003_f1(parm1 in varchar2,parm2 in varchar,parm3 out varchar2) return char
  2 IS
  3 timestamp_para char(100);
  4 begin
  5      timestamp_para :=to_char(to_timestamp(parm1,'YYYY-MM-DD HH:MI:SS.ff6'));
  6      return timestamp_para;
  7 end;
  8 /

Succeed.

SQL> select data_type,data_length,data_precision,data_scale from user_arguments where object_name = 'DBA_ARGUMENTS_003_F1' order by sequence;

DATA_TYPE                                                        DATA_LENGTH  DATA_PRECISION DATA_SCALE  
---------------------------------------------------------------- ------------ -------------- ------------
CHAR                                                             8000                                    
VARCHAR                                                          32767                                   
VARCHAR                                                          32767                                   
VARCHAR                                                          32767                                   

4 rows fetched.

SQL> 
SQL> create or replace  function DBA_ARGUMENTS_003_f1(number1 in out number ) return number
  2 IS
  3 number2 number(10,2);
  4 number3 number(9,3);
  5 begin
  6      number3 := 123456.789;
  7   number2 := number1;
  8   number1 := number3;
  9   return number1;
 10 end;
 11 /

Succeed.

SQL> select data_type,data_length,data_precision,data_scale from user_arguments where object_name = 'DBA_ARGUMENTS_003_F1' order by sequence;

DATA_TYPE                                                        DATA_LENGTH  DATA_PRECISION DATA_SCALE  
---------------------------------------------------------------- ------------ -------------- ------------
NUMBER                                                           24                                      
NUMBER                                                           24                                      

2 rows fetched.

SQL> 
SQL> 
SQL> --test cursor
SQL> drop table if exists plsql_employees;

Succeed.

SQL> create table plsql_employees(employeesno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> insert into plsql_employees values(1,'zhangsan','doctor1',10000),(2,'zhangsan2','doctor2',10010),(123,'zhangsan3','doctor3',10020);

3 rows affected.

SQL> commit;

Succeed.

SQL> alter table plsql_employees add  hiretime datetime;

Succeed.

SQL> 
SQL> create or replace procedure plsql_test_out   is
  2 type mycurtp is  ref cursor;
  3 cursorv1  mycurtp;
  4 sys_cur1  sys_refcursor;
  5 type  XXX is record(
  6 a varchar2(100),
  7 b number(10,1),
  8 c number(11,1)
  9 );
 10 var1 XXX;
 11 begin
 12 open  sys_cur1 for  select ename as name, sal, sal*2 ep_sal from plsql_employees where ename like 'zhangsan%' ;
 13 cursorv1 := sys_cur1;
 14 loop
 15 fetch cursorv1 into var1;
 16 exit when cursorv1%notfound;
 17 dbe_output.print_line('1'||cursorv1%rowcount||'2 +'||var1.a||'+'||var1.b||'+'||var1.c);
 18 end loop;
 19 close cursorv1;
 20 end;
 21 /

Succeed.

SQL> 
SQL> --expect success
SQL> exec plsql_test_out;

112 +zhangsan+10000+20000
122 +zhangsan2+10010+20020
132 +zhangsan3+10020+20040

PL/SQL procedure successfully completed.

SQL> 
SQL> --support clob
SQL> declare
  2 a clob;
  3 begin
  4 a := '123456';
  5 dbe_output.print_line(a);
  6 end;
  7 /

123456

PL/SQL procedure successfully completed.

SQL> 
SQL> drop function if exists pl_func_test;

Succeed.

SQL> drop procedure if exists pl_func_test;

Succeed.

SQL> create or replace function pl_func_test() return clob
  2 as
  3 l_a clob;
  4 begin
  5 l_a := '123456';
  6 dbe_output.print_line(l_a);
  7 return l_a;
  8 end;
  9 /

Succeed.

SQL> 
SQL> select pl_func_test();

PL_FUNC_TEST()                                                  
----------------------------------------------------------------
123456                                                          

1 rows fetched.

123456

SQL> 
SQL> create or replace procedure pl_proc_test(a out clob)
  2 as
  3 begin
  4 a := '123456';
  5 end;
  6 /

Succeed.

SQL> 
SQL> declare
  2 a1 clob;
  3 begin
  4 pl_proc_test(a1);
  5 dbe_output.print_line(a1);
  6 end;
  7 /

123456

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace function pl_func_test1() return clob
  2 as
  3 l_a clob;
  4 begin
  5 pl_proc_test(l_a);
  6 return l_a;
  7 end;
  8 /

Succeed.

SQL> 
SQL> declare
  2 l_a clob;
  3 m_a clob;
  4 a int;
  5 begin
  6 l_a := '123456';
  7 m_a := DBE_LOB.substr(l_a, 32767);
  8 dbe_output.print_line(m_a);
  9 a := DBE_LOB.get_length(m_a);
 10 dbe_output.print_line(a);
 11 
 12 m_a := DBE_LOB.substr(l_a, 3);
 13 dbe_output.print_line(m_a);
 14 a := DBE_LOB.get_length(m_a);
 15 dbe_output.print_line(a);
 16 
 17 m_a := DBE_LOB.substr(l_a, 3, 4);
 18 dbe_output.print_line(m_a);
 19 a := DBE_LOB.get_length(m_a);
 20 dbe_output.print_line(a);
 21 end;
 22 /

123456
6
123
3
456
3

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a varchar(32767);
  3 begin
  4 a := '123456';
  5 dbe_output.print_line(a);
  6 end;
  7 /

123456

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a clob;
  3 b1 clob;
  4 begin
  5 select pl_func_test1() into a from dual;
  6 pl_func_test(b1);
  7 dbe_output.print_line(a);
  8 dbe_output.print_line(b1);
  9 end;
 10 /

CT-00944, PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with compiling errors
[6:1] PLC-00828 procedure GS_PLSQL.PL_FUNC_TEST does not exist

SQL> 
SQL> drop table hh;

CT-00843, The table or view GS_PLSQL.HH does not exist.
SQL> create table hh (a int);

Succeed.

SQL> insert into hh values(0);

1 rows affected.

SQL> declare
  2 begin
  3 insert into hh values(1);
  4 execute immediate 'drop table hh';
  5 execute immediate 'create table hh (a int)';
  6 insert into hh values('adsf');
  7 end;
  8 /

CT-00932, [6:1] PL/SQL(GS_PLSQL.ANONYMOUS BLOCK) terminated with execute errors
[6:1] CT-00636, Invalid number -- unexpected character

SQL> 
SQL> select * from hh;

A           
------------

0 rows fetched.

SQL> 
SQL> drop table if exists plsql_table_test;

Succeed.

SQL> create table plsql_table_test(t_a clob);

Succeed.

SQL> 
SQL> declare
  2 a clob;
  3 cnt int;
  4 begin
  5 select count(*) into cnt from plsql_table_test;
  6 dbe_output.print_line(cnt);
  7 pl_proc_test(a);
  8 insert into plsql_table_test values(a);
  9 insert into plsql_table_test values(pl_func_test1());
 10 select count(*) into cnt from plsql_table_test;
 11 dbe_output.print_line(cnt);
 12 end;
 13 /

0
2

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace function pl_func_test1(a in clob) return clob
  2 as
  3 c int;
  4 begin
  5 select count(1) into c from plsql_table_test;
  6 return a;
  7 end;
  8 /

Succeed.

SQL> declare
  2 a clob := '1234';
  3 b1 clob;
  4 begin
  5 select pl_func_test1(a) into b1 from dual;
  6 dbe_output.print_line(a);
  7 dbe_output.print_line(b1);
  8 end;
  9 /

1234
1234

PL/SQL procedure successfully completed.

SQL> 
SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> drop user gs_plsql cascade;

Succeed.

SQL> 
SQL> --test comment display
SQL> /*this is a comment*/
SQL> begin
  2 null;
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> 
SQL> begin/*this is a comment*/
  2 null;
  3 end;
  4 /

PL/SQL procedure successfully completed.

SQL> 
SQL> begin
  2 /*this is a comment*/
  3 null;
  4 end;
  5 /

PL/SQL procedure successfully completed.

SQL> 
SQL> begin
  2 /*this is 
  3 a comment*/
  4 null;
  5 end;
  6 /

PL/SQL procedure successfully completed.

SQL> 
SQL> begin
  2 /*this is 
  3 a comment*/null;
  4 end;
  5 /

PL/SQL procedure successfully completed.

SQL> 
SQL> -- test reord with default vaule 
SQL> DECLARE
  2   TYPE DeptRecTyp IS RECORD (
  3     dept_id    NUMBER(4) NOT NULL := 10,
  4     dept_name  VARCHAR2(30) NOT NULL := 'Administration',
  5     mgr_id     NUMBER(6) := 200,
  6     loc_id     NUMBER(4) := 1700
  7   );
  8  
  9   dept_rec DeptRecTyp;
 10 BEGIN
 11   dbe_output.print_line('dept_id:   ' || dept_rec.dept_id);
 12   dbe_output.print_line('dept_name: ' || dept_rec.dept_name);
 13   dbe_output.print_line('mgr_id:    ' || dept_rec.mgr_id);
 14   dbe_output.print_line('loc_id:    ' || dept_rec.loc_id);
 15 END;
 16 /

dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:    1700

PL/SQL procedure successfully completed.

SQL> 
SQL> -- test sequence 
SQL> DROP TABLE if exists employees_temp;

Succeed.

SQL> drop sequence if exists employees_seq;

Succeed.

SQL> 
SQL> create sequence employees_seq start with 100;

Succeed.

SQL> 
SQL> CREATE TABLE employees_temp
  2 (
  3     employee_id int
  4 );

Succeed.

SQL> 
SQL> DECLARE
  2   seq_value NUMBER;
  3   seq_tmp NUMBER;
  4   seq_select employees_temp.employee_id%TYPE;
  5 BEGIN
  6     --initial
  7     dbe_output.print_line ('sequency initial value = ' || TO_CHAR(employees_seq.NEXTVAL));
  8     
  9     -- normal expr sum 
 10     seq_tmp := 1+employees_seq.NEXTVAL+employees_seq.NEXTVAL;
 11     dbe_output.print_line ('expr sum value =' || TO_CHAR(seq_tmp));
 12     
 13     --continue incre
 14     seq_value := employees_seq.NEXTVAL;
 15     seq_value := employees_seq.NEXTVAL;
 16     dbe_output.print_line ('continue incre value =' || TO_CHAR(seq_value));
 17     
 18     --insert into     
 19     INSERT INTO employees_temp (employee_id) VALUES (employees_seq.NEXTVAL);
 20     select employee_id into seq_select from employees_temp;
 21     dbe_output.print_line ('insert into  value =' || TO_CHAR(seq_select));
 22     
 23     --select expr sum
 24     select employees_seq.NEXTVAL + employee_id into seq_select from employees_temp;
 25     dbe_output.print_line ('slect expr sum value =' || TO_CHAR(seq_select));
 26     
 27     --End current value
 28     dbe_output.print_line ('Ending sequence value = ' || TO_CHAR(employees_seq.CURRVAL));
 29 END;
 30 /

sequency initial value = 100
expr sum value =204
continue incre value =104
insert into  value =105
slect expr sum value =211
Ending sequence value = 106

PL/SQL procedure successfully completed.

SQL> 
SQL> --test bind param in select into clause. expect return compile error
SQL> declare
  2    a int := 1;
  3 begin
  4     select 1 into a from dual;
  5     select 1 into :1 from dual;
  6 end;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:19] PLC-00922 PL/SQL: illegal line(into clause cannot use param decl until in dynamic sql)

SQL> 
SQL> --test bind param in fetch into clause. expect return compile error
SQL> set serveroutput on;

ON
SQL> declare
  2    a sys_refcursor;
  3    b int := 1;
  4    c int;
  5 begin
  6    open a for select b from dual;
  7    fetch a into :1;
  8    c := :1;
  9    dbe_output.print_line('c = ' || c);
 10 end;
 11 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:17] PLC-00922 PL/SQL: illegal line(into clause cannot use param decl until in dynamic sql)

SQL> 
SQL> --add some testcases to test variant management
SQL> drop table if exists table_r1;

Succeed.

SQL> create table table_r1(a int, b int, c int);

Succeed.

SQL> drop table if exists table_r2;

Succeed.

SQL> create table table_r2(a int, b int, c int);

Succeed.

SQL> insert into table_r1 values(1,2,3);

1 rows affected.

SQL> 
SQL> drop table if exists ta1;

Succeed.

SQL> create table ta1(a char(10), b char(10));

Succeed.

SQL> 
SQL> --testcase 1
SQL> delete from ta1;

0 rows affected.

SQL> declare 
  2 v1 char(10); 
  3 v2 char(10); 
  4 begin 
  5 v1 := 'abc'; 
  6 v2 := 'cfg'; 
  7 execute immediate 'begin insert into ta1(a,b) values(:p, :p); end;' using v1, v2; 
  8 end; 
  9 /

CT-00932, [7:1] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[7:1] CT-00908, PL/SQL internal program error(The param count of dynamic sql is not same as the param count of using clause).

SQL> select * from ta1;

A          B         
---------- ----------

0 rows fetched.

SQL> 
SQL> --testcase 2
SQL> declare
  2    a int := 1;
  3 begin
  4     select 1 into a from dual;
  5     select 1 into :1 from dual;
  6 end;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:19] PLC-00922 PL/SQL: illegal line(into clause cannot use param decl until in dynamic sql)

SQL> 
SQL> --testcase 3
SQL> declare
  2    a sys_refcursor;
  3    b int := 1;
  4 begin
  5    open a for select b from dual;
  6    dbe_sql.return_cursor(a);
  7    open a for select b + 2 from dual;
  8    dbe_sql.return_cursor(a);
  9 end;
 10 /

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


ResultSet #2

:1 +2               
--------------------
3                   

1 rows fetched.


SQL> 
SQL> --testcase 4
SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED = TRUE;

Succeed.

SQL> drop table if exists #tr1;

Succeed.

SQL> create temporary table #tr1(f1 int, f2 int);

Succeed.

SQL> insert into #tr1 values(1,2);

1 rows affected.

SQL> declare
  2    a int := 1;
  3 begin
  4    select f1 into a from #tr1;   
  5    dbe_output.print_line(a);
  6 end;
  7 /

1

PL/SQL procedure successfully completed.

SQL> 
SQL> --testcase 5
SQL> DROP TABLE IF EXISTS T_TRIG_1;

Succeed.

SQL> CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16));

Succeed.

SQL> INSERT INTO T_TRIG_1 VALUES(1,2,'A');

1 rows affected.

SQL> 
SQL> CREATE OR REPLACE TRIGGER TEST_TRIG
  2 BEFORE DELETE ON T_TRIG_1
  3 BEGIN
  4   UPDATE #tr1 SET f1 = 2;
  5 END;
  6 /

Succeed.

SQL> 
SQL> --testcase 6
SQL> DROP TABLE IF EXISTS T_TRIG_1;

Succeed.

SQL> CREATE  TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16));

Succeed.

SQL> INSERT INTO T_TRIG_1 VALUES(1,2,'A');

1 rows affected.

SQL> 
SQL> CREATE OR REPLACE TRIGGER TEST_TRIG
  2 BEFORE DELETE ON T_TRIG_1
  3 BEGIN
  4   UPDATE #tr1 SET f1 = 2;
  5 END;
  6 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TRIGGER TEST_TRIG
  2 BEFORE DELETE ON T_TRIG_1
  3 BEGIN
  4   for i in (select * from #tr1) loop
  5     UPDATE #tr1 SET f1 = 2;
  6   end loop;
  7 END;
  8 /

Succeed.

SQL> 
SQL> --testcase 7
SQL> declare
  2 a decimal(22,3) := 1234567890.123412342324;
  3 xxx sys_refcursor;
  4 begin
  5 open xxx for select a from dual;
  6 dbe_sql.return_cursor(xxx);
  7 end;
  8 /

PL/SQL procedure successfully completed.

ResultSet #1

:1                                      
----------------------------------------
1234567890.123                          

1 rows fetched.


SQL> 
SQL> declare
  2 a int := 1;
  3 xxx sys_refcursor;
  4 begin
  5 open xxx for select a from dual;
  6 dbe_sql.return_cursor(xxx);
  7 end;
  8 /

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


SQL> --testcase 8
SQL> declare
  2 a char(10) := 'abc';
  3 xxx sys_refcursor;
  4 begin
  5 open xxx for select a from dual;
  6 dbe_sql.return_cursor(xxx);
  7 end;
  8 /

PL/SQL procedure successfully completed.

ResultSet #1

:1        
----------
abc       

1 rows fetched.


SQL> 
SQL>  create or replace procedure p1(f1 in int)
  2 is 
  3 v_refcur2 SYS_REFCURSOR;
  4 i decimal := 12567890123456;
  5 begin
  6 open v_refcur2 for select i from dual;
  7 dbe_sql.return_cursor(v_refcur2);
  8 end;
  9 /

Succeed.

SQL> 
SQL> call p1(1);

PL/SQL procedure successfully completed.

ResultSet #1

:1                                      
----------------------------------------
12567890123456                          

1 rows fetched.


SQL> 
SQL>  create or replace procedure p1(f1 in int)
  2 is 
  3 v_refcur2 SYS_REFCURSOR;
  4 i varchar(10) := 'abc';
  5 begin
  6 open v_refcur2 for select i from dual;
  7 dbe_sql.return_cursor(v_refcur2);
  8 end;
  9 /

Succeed.

SQL> 
SQL> call p1(1);

PL/SQL procedure successfully completed.

ResultSet #1

:1 
---
abc

1 rows fetched.


SQL> 
SQL>  create or replace procedure p2(f1 in int, f2 in int) 
  2 is                                                    
  3 v_refcur2 SYS_REFCURSOR;                              
  4 begin                                                 
  5 for i in 1..2                                         
  6 loop                                                  
  7 open v_refcur2 for select i from dual;                
  8 dbe_sql.return_cursor(v_refcur2);                    
  9 end loop;                                             
 10 end;                                                  
 11 /                                                     

Succeed.

SQL> 
SQL> call p2(1,2);   

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


ResultSet #2

:1          
------------
2           

1 rows fetched.


SQL> 
SQL> --testcase 9
SQL> declare
  2 xxx int := 1;
  3 begin
  4 execute immediate '
  5 declare
  6   rec table_r1%rowtype;
  7   c1 sys_refcursor;
  8 begin
  9   open c1 for ''select * from table_r1'';
 10   fetch c1 into rec;
 11   execute immediate ''begin null; insert into table_r2 values(:1,:1,:1);end;'' using in :1;
 12 end;
 13 ' using in xxx;
 14 end;
 15 /

PL/SQL procedure successfully completed.

SQL> --end
SQL> set serveroutput off;

OFF
SQL> CONN / AS  SYSDBA

connected.

SQL> SELECT COUNT(WHAT) FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

COUNT(WHAT)
--------------------
1

1 rows fetched.

SQL> CALL AUD$CLEAN_AUD_LOG(110);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[5:9] PL/SQL(SYS.AUD$CLEAN_AUD_LOG) terminated with execute errors
[5:9] PL/SQL(DBE_STD.THROW_EXCEPTION) terminated with execute errors
[5:25] CT--20000, argrument should between [0, 100]

SQL> CALL AUD$MODIFY_SETTING(20, 100);

PL/SQL procedure successfully completed.

SQL> SELECT WHAT FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

WHAT
----------------------------------------------------------------
AUD$CLEAN_AUD_LOG(20);

1 rows fetched.

SQL> CALL AUD$MODIFY_SETTING(110, 100);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:9] PL/SQL(SYS.AUD$MODIFY_SETTING) terminated with execute errors
[8:9] PL/SQL(DBE_STD.THROW_EXCEPTION) terminated with execute errors
[8:25] CT--20000, argrument1 should between [0, 100], argrument2 should be positive

SQL> SELECT WHAT FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

WHAT
----------------------------------------------------------------
AUD$CLEAN_AUD_LOG(20);

1 rows fetched.

SQL> CALL AUD$MODIFY_SETTING(10, 0);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:9] PL/SQL(SYS.AUD$MODIFY_SETTING) terminated with execute errors
[8:9] PL/SQL(DBE_STD.THROW_EXCEPTION) terminated with execute errors
[8:25] CT--20000, argrument1 should between [0, 100], argrument2 should be positive

SQL> SELECT WHAT FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

WHAT
----------------------------------------------------------------
AUD$CLEAN_AUD_LOG(20);

1 rows fetched.

SQL> CALL AUD$MODIFY_SETTING(10, 101);

PL/SQL procedure successfully completed.

SQL> SELECT WHAT FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

WHAT
----------------------------------------------------------------
AUD$CLEAN_AUD_LOG(10);

1 rows fetched.

SQL> CALL AUD$MODIFY_SETTING();

PL/SQL procedure successfully completed.

SQL> SELECT WHAT FROM JOB$ WHERE WHAT LIKE 'AUD$CLEAN_AUD_LOG(%);';

WHAT
----------------------------------------------------------------
AUD$CLEAN_AUD_LOG();

1 rows fetched.
 
SQL> conn / as  sysdba

connected.

SQL> drop user if exists cao1 cascade;

Succeed.

SQL> drop user if exists cao2 cascade;

Succeed.

SQL> create user cao1 identified by Cantian_234;

Succeed.

SQL> grant create session,create any procedure  to cao1;

Succeed.

SQL> create user cao2 identified by Cantian_234;

Succeed.

SQL> grant create session  to cao2;

Succeed.

SQL> conn cao1/Cantian_234@127.0.0.1:1611

connected.

SQL> CREATE OR REPLACE PACKAGE cao1_package
  2 IS
  3     FUNCTION MYF RETURN INT;
  4     PROCEDURE MYP;
  5 END;
  6 /

Succeed.

SQL> CREATE OR REPLACE PACKAGE BODY cao1_package
  2 IS
  3     FUNCTION MYF RETURN INT
  4     IS
  5         V1 INT := 10;
  6     BEGIN
  7         NULL;
  8        RETURN V1;
  9     END;
 10     PROCEDURE MYP
 11     IS
 12         V1 INT:=100;
 13     BEGIN
 14         SELECT MYF INTO V1 FROM DUAL;
 15         dbe_output.print_line(V1);
 16     END;
 17 END;
 18 /

Succeed.

SQL> conn cao1/Cantian_234@127.0.0.1:1611

connected.

SQL> CREATE OR REPLACE PACKAGE cao2.cao2_package
  2 IS
  3     FUNCTION MYF RETURN INT;
  4     PROCEDURE MYP;
  5 END;
  6 /

Succeed.

SQL> CREATE OR REPLACE PACKAGE BODY cao2.cao2_package
  2 IS
  3     FUNCTION MYF RETURN INT
  4     IS
  5         V1 INT := 10;
  6     BEGIN
  7         NULL;
  8         RETURN V1;
  9     END;
 10     PROCEDURE MYP
 11     IS
 12         V1 INT:=100;
 13     BEGIN
 14         SELECT MYF INTO V1 FROM DUAL;
 15         dbe_output.print_line(V1);
 16     END;
 17 END;
 18 /

Succeed.

SQL> conn / as  sysdba

connected.

SQL> drop user if exists cao1 cascade;

Succeed.

SQL> drop user if exists cao2 cascade;

Succeed.

SQL> conn / as  sysdba

connected.

SQL> drop user if exists jie cascade;

Succeed.

SQL> create user jie identified by jie102_jie;

Succeed.

SQL> grant connect to jie;

Succeed.

SQL> grant  execute  ON sys.AUD$MODIFY_SETTING TO jie;

Succeed.

SQL> conn jie/jie102_jie@127.0.0.1:1611

connected.

SQL> call sys.AUD$MODIFY_SETTING(3,1);

CT-00601, Sql syntax error: The common user can't call this procedure, only for sys.
SQL> exec sys.AUD$MODIFY_SETTING(4,1);

CT-00601, Sql syntax error: The common user can't call this procedure, only for sys.
SQL> exec sys.AUD$MODIFY_SETTING(6,1);

CT-00601, Sql syntax error: The common user can't call this procedure, only for sys.
SQL> conn / as sysdba

connected.

SQL> drop user if exists jie cascade;

Succeed.

SQL> 
SQL> --vmctx check
SQL> set serveroutput on;

ON
SQL> drop table if exists t_userinfo_test;

Succeed.

SQL> create table t_userinfo_test(phonenumber varchar2(100),userid int);

Succeed.

SQL> insert into t_userinfo_test(phonenumber ,userid) values('15600000014',1);

1 rows affected.

SQL> commit;

Succeed.

SQL> create or replace function f_di_test_rowtype
  2 (
  3     str_in_phonenumber        in varchar2,
  4     rec_o_userinfo      out t_userinfo_test%rowtype
  5 ) return t_userinfo_test%rowtype as
  6 str_operationdetails varchar2(1000);
  7 begin
  8 select *
  9   into rec_o_userinfo
 10   from t_userinfo_test a
 11 where phonenumber = str_in_phonenumber;
 12 dbe_output.print_line('userid is ' || rec_o_userinfo.userid );
 13 return rec_o_userinfo;
 14 end f_di_test_rowtype;
 15 /

Succeed.

SQL> declare
  2   str_in_phonenumber         varchar2(100) := '15600000014';
  3   rec_o_userinfo       t_userinfo_test%rowtype;
  4   rec_o_userinfo2       t_userinfo_test%rowtype;
  5 begin
  6          rec_o_userinfo2 := f_di_test_rowtype(str_in_phonenumber, rec_o_userinfo);
  7          dbe_output.print_line('return_value is ' || rec_o_userinfo2.userid);
  8 end;
  9 /

userid is 1
return_value is 1

PL/SQL procedure successfully completed.

SQL> drop function f_di_test_rowtype;

Succeed.

SQL> drop table t_userinfo_test;

Succeed.

SQL> 
SQL> --DTS2020030303579
SQL> drop table if  exists PROC_DTS2020030303579;

Succeed.

SQL> declare
  2 str clob;
  3 Type_1 varchar(30) := 'int';
  4 Type_2 varchar(30) := 'bigint';
  5 Type_3 varchar(30) := 'number(10,2)';
  6 Type_4 varchar(30) := 'decimal(10,2)';
  7 Type_5 varchar(30) := 'float';
  8 Type_6 varchar(30) := 'double';
  9 Type_7 varchar(30) := 'real';
 10 Type_8 varchar(30) := 'char(100)';
 11 Type_9 varchar(30) := 'varchar(100)';
 12 Type_10 varchar(30) := 'varchar2(100)';
 13 Type_11 varchar(30) := 'bool';
 14 Type_12 varchar(30) := 'boolean';
 15 Type_13 varchar(30) := 'date';
 16 Type_14 varchar(30) := 'timestamp';
 17 Type_15 varchar(30) := 'binary(10)';
 18 Type_16 varchar(30) := 'varbinary(20)';
 19 Type_17 varchar(30) := 'clob';
 20 Type_18 varchar(30) := 'blob';
 21 Type_19 varchar(30) := 'DATETIME';
 22 Type_20 varchar(30) := 'NVARCHAR(100)';
 23 b int := 0;
 24 d int;
 25 begin
 26 for i in 1..30
 27 loop
 28 b := i -1;
 29 str := str||'id'||(b*20+1)||' '||Type_1||','||'id'||(b*20+2)||' '||Type_2||','||'id'||(b*20+3)||' '||Type_3||','||'id'||(b*20+4)||' '||Type_4||','||'id'||(b*20+5)||' '||Type_5||','||
 30 'id'||(b*20+6)||' '||Type_6||','||'id'||(b*20+7)||' '||Type_7||','||'id'||(b*20+8)||' '||Type_8||','||'id'||(b*20+9)||' '||Type_9||','||'id'||(b*20+10)||' '||Type_10||','||
 31 'id'||(b*20+11)||' '||Type_11||','||'id'||(b*20+12)||' '||Type_12||','||'id'||(b*20+13)||' '||Type_13||','||'id'||(b*20+14)||' '||Type_14||','||'id'||(b*20+15)||' '||Type_15||','||
 32 'id'||(b*20+16)||' '||Type_16||','||'id'||(b*20+17)||' '||Type_17||','||'id'||(b*20+18)||' '||Type_18||','||'id'||(b*20+19)||' '||Type_19||','||'id'||(b*20+20)||' '||Type_20||',';
 33 end loop;
 34 d := length(str)-1;
 35 str := substr(str,0,d);
 36 str := 'create table PROC_DTS2020030303579('||str||')';
 37 --dbe_output.print_line(str);
 38 execute immediate str;
 39 end;
 40 /

PL/SQL procedure successfully completed.

SQL> declare
  2 str clob;
  3 Type_1 varchar(30) := 'int';
  4 Type_2 varchar(30) := 'bigint';
  5 Type_3 varchar(30) := 'number(10,2)';
  6 Type_4 varchar(30) := 'decimal(10,2)';
  7 Type_5 varchar(30) := 'float';
  8 Type_6 varchar(30) := 'double';
  9 Type_7 varchar(30) := 'real';
 10 Type_8 varchar(30) := 'char(100)';
 11 Type_9 varchar(30) := 'varchar(100)';
 12 Type_10 varchar(30) := 'varchar2(100)';
 13 Type_11 varchar(30) := 'bool';
 14 Type_12 varchar(30) := 'boolean';
 15 Type_13 varchar(30) := 'date';
 16 Type_14 varchar(30) := 'timestamp';
 17 Type_15 varchar(30) := 'binary(10)';
 18 Type_16 varchar(30) := 'varbinary(20)';
 19 Type_17 varchar(30) := 'clob';
 20 Type_18 varchar(30) := 'blob';
 21 Type_19 varchar(30) := 'DATETIME';
 22 Type_20 varchar(30) := 'NVARCHAR(100)';
 23 b int := 0;
 24 d int;
 25 begin
 26 for i in 31..50
 27 loop
 28 b := i -1;
 29 --str := 'alter table PROC_USING_BIND_006_T_01 add ( id'||(i-1)*20+1||' int,'||'id'||(i-1)*20+2||' bigint,'||'id'||(i-1)*20+3||' number,'||'id'||(i-1)*20+4||' int,'||'id'||(i-1)*20+5||' int,'||'id'||(i-1)*20+6||' int,'||'id'||(i-1)*20+7||' int,'||'id'||(i-1)*20+8||' int,'
 30 --||'id'||(i-1)*20+9||' int,'||'id'||(i-1)*20+10||' int,'||'id'||(i-1)*20+11||' int,'||'id'||(i-1)*20+12||' int,'||'id'||(i-1)*20+13||' int,'||'id'||(i-1)*20+14||' int,'||'id'||(i-1)*20+15||' int,'||'id'||(i-1)*20+16||' int,'||'id'||(i-1)*20+17||' int,'||'id'||(i-1)*20+18||' int,'';
 31 str := str||'id'||(b*20+1)||' '||Type_1||','||'id'||(b*20+2)||' '||Type_2||','||'id'||(b*20+3)||' '||Type_3||','||'id'||(b*20+4)||' '||Type_4||','||'id'||(b*20+5)||' '||Type_5||','||
 32 'id'||(b*20+6)||' '||Type_6||','||'id'||(b*20+7)||' '||Type_7||','||'id'||(b*20+8)||' '||Type_8||','||'id'||(b*20+9)||' '||Type_9||','||'id'||(b*20+10)||' '||Type_10||','||
 33 'id'||(b*20+11)||' '||Type_11||','||'id'||(b*20+12)||' '||Type_12||','||'id'||(b*20+13)||' '||Type_13||','||'id'||(b*20+14)||' '||Type_14||','||'id'||(b*20+15)||' '||Type_15||','||
 34 'id'||(b*20+16)||' '||Type_16||','||'id'||(b*20+17)||' '||Type_17||','||'id'||(b*20+18)||' '||Type_18||','||'id'||(b*20+19)||' '||Type_19||','||'id'||(b*20+20)||' '||Type_20||',';
 35 end loop;
 36 d := length(str)-1;
 37 str := substr(str,0,d);
 38 str := 'alter table PROC_DTS2020030303579 add ( '||str||')';
 39 --dbe_output.print_line(str);
 40 execute immediate str;
 41 end;
 42 /

PL/SQL procedure successfully completed.

SQL> create or replace procedure PROC_USING_BIND_009 is
  2 V_1  int;
  3 V_2  bigint;
  4 V_3  number(10,2);
  5 V_4  decimal(10,2);
  6 V_5  float;
  7 V_6  double;
  8 V_7  real;
  9 V_8  char(10);
 10 V_9  varchar(100);
 11 V_10  varchar2(100);
 12 V_11  bool;
 13 V_12  boolean;
 14 V_13  date;
 15 V_14  timestamp;
 16 V_15  binary(10);
 17 V_16  varbinary(20);
 18 V_17  clob;
 19 V_18  blob;
 20 V_19  DATETIME;
 21 V_20  NVARCHAR(100);
 22 begin
 23 V_1    :=11212                                ;
 24 V_2    :=123424234                            ;
 25 V_3    :=1234.56                              ;
 26 V_4    :=123456.78                            ;
 27 V_5    :=12.11                                ;
 28 V_6    :=1888.32                              ;
 29 V_7    :=111.11                               ;
 30 V_8    :='01'                                 ;
 31 V_9    :='1aaaaaaafdfdbadfsfdfdsf'            ;
 32 V_10   :='11aaaaaaafdfdbadfsfdfdsfaaaa'       ;
 33 V_11   :=true                                 ;
 34 V_12   :=false                                ;
 35 V_13   :=to_date('2019-06-27')                ;
 36 V_14   :=to_date('2019-06-27 14:58')          ;
 37 V_15   :='ADFD111'                            ;
 38 V_16   :='afdfdsf111'                         ;
 39 V_17   :='aaaaaaaaaaa i  am clob'             ;
 40 V_18   :='AB0101'                             ;
 41 V_19   :=to_date('2019-06-27')                ;
 42 V_20   :='abcddd#$@'                          ;
 43 execute immediate 'insert into PROC_DTS2020030303579 values
 44 (:p1,:p2,:p3,:p4,:p5,:p6,:p7,:p8,:p9,:p10,:p11,:p12,:p13,:p14,:p15,:p16,:p17,:p18,:p19,:p20,:p21,:p22,:p23,:p24,:p25,:p26,:p27,:p28,:p29,:p30,
 45 :p31,:p32,:p33,:p34,:p35,:p36,:p37,:p38,:p39,:p40,:p41,:p42,:p43,:p44,:p45,:p46,:p47,:p48,:p49,:p50,:p51,:p52,:p53,:p54,:p55,:p56,:p57,:p58,:p59,:p60,
 46 :p61,:p62,:p63,:p64,:p65,:p66,:p67,:p68,:p69,:p70,:p71,:p72,:p73,:p74,:p75,:p76,:p77,:p78,:p79,:p80,:p81,:p82,:p83,:p84,:p85,:p86,:p87,:p88,:p89,:p90,
 47 :p91,:p92,:p93,:p94,:p95,:p96,:p97,:p98,:p99,:p100,:p101,:p102,:p103,:p104,:p105,:p106,:p107,:p108,:p109,:p110,:p111,:p112,:p113,:p114,:p115,:p116,:p117,:p118,:p119,:p120,
 48 :p121,:p122,:p123,:p124,:p125,:p126,:p127,:p128,:p129,:p130,:p131,:p132,:p133,:p134,:p135,:p136,:p137,:p138,:p139,:p140,:p141,:p142,:p143,:p144,:p145,:p146,:p147,:p148,:p149,:p150,
 49 :p151,:p152,:p153,:p154,:p155,:p156,:p157,:p158,:p159,:p160,:p161,:p162,:p163,:p164,:p165,:p166,:p167,:p168,:p169,:p170,:p171,:p172,:p173,:p174,:p175,:p176,:p177,:p178,:p179,:p180,
 50 :p181,:p182,:p183,:p184,:p185,:p186,:p187,:p188,:p189,:p190,:p191,:p192,:p193,:p194,:p195,:p196,:p197,:p198,:p199,:p200,:p201,:p202,:p203,:p204,:p205,:p206,:p207,:p208,:p209,:p210,
 51 :p211,:p212,:p213,:p214,:p215,:p216,:p217,:p218,:p219,:p220,:p221,:p222,:p223,:p224,:p225,:p226,:p227,:p228,:p229,:p230,:p231,:p232,:p233,:p234,:p235,:p236,:p237,:p238,:p239,:p240,
 52 :p241,:p242,:p243,:p244,:p245,:p246,:p247,:p248,:p249,:p250,:p251,:p252,:p253,:p254,:p255,:p256,:p257,:p258,:p259,:p260,:p261,:p262,:p263,:p264,:p265,:p266,:p267,:p268,:p269,:p270,
 53 :p271,:p272,:p273,:p274,:p275,:p276,:p277,:p278,:p279,:p280,:p281,:p282,:p283,:p284,:p285,:p286,:p287,:p288,:p289,:p290,:p291,:p292,:p293,:p294,:p295,:p296,:p297,:p298,:p299,:p300,
 54 :p301,:p302,:p303,:p304,:p305,:p306,:p307,:p308,:p309,:p310,:p311,:p312,:p313,:p314,:p315,:p316,:p317,:p318,:p319,:p320,:p321,:p322,:p323,:p324,:p325,:p326,:p327,:p328,:p329,:p330,
 55 :p331,:p332,:p333,:p334,:p335,:p336,:p337,:p338,:p339,:p340,:p341,:p342,:p343,:p344,:p345,:p346,:p347,:p348,:p349,:p350,:p351,:p352,:p353,:p354,:p355,:p356,:p357,:p358,:p359,:p360,
 56 :p361,:p362,:p363,:p364,:p365,:p366,:p367,:p368,:p369,:p370,:p371,:p372,:p373,:p374,:p375,:p376,:p377,:p378,:p379,:p380,:p381,:p382,:p383,:p384,:p385,:p386,:p387,:p388,:p389,:p390,
 57 :p391,:p392,:p393,:p394,:p395,:p396,:p397,:p398,:p399,:p400,:p401,:p402,:p403,:p404,:p405,:p406,:p407,:p408,:p409,:p410,:p411,:p412,:p413,:p414,:p415,:p416,:p417,:p418,:p419,:p420,
 58 :p421,:p422,:p423,:p424,:p425,:p426,:p427,:p428,:p429,:p430,:p431,:p432,:p433,:p434,:p435,:p436,:p437,:p438,:p439,:p440,:p441,:p442,:p443,:p444,:p445,:p446,:p447,:p448,:p449,:p450,
 59 :p451,:p452,:p453,:p454,:p455,:p456,:p457,:p458,:p459,:p460,:p461,:p462,:p463,:p464,:p465,:p466,:p467,:p468,:p469,:p470,:p471,:p472,:p473,:p474,:p475,:p476,:p477,:p478,:p479,:p480,
 60 :p481,:p482,:p483,:p484,:p485,:p486,:p487,:p488,:p489,:p490,:p491,:p492,:p493,:p494,:p495,:p496,:p497,:p498,:p499,:p500,:p501,:p502,:p503,:p504,:p505,:p506,:p507,:p508,:p509,:p510,
 61 :p511,:p512,:p513,:p514,:p515,:p516,:p517,:p518,:p519,:p520,:p521,:p522,:p523,:p524,:p525,:p526,:p527,:p528,:p529,:p530,:p531,:p532,:p533,:p534,:p535,:p536,:p537,:p538,:p539,:p540,
 62 :p541,:p542,:p543,:p544,:p545,:p546,:p547,:p548,:p549,:p550,:p551,:p552,:p553,:p554,:p555,:p556,:p557,:p558,:p559,:p560,:p561,:p562,:p563,:p564,:p565,:p566,:p567,:p568,:p569,:p570,
 63 :p571,:p572,:p573,:p574,:p575,:p576,:p577,:p578,:p579,:p580,:p581,:p582,:p583,:p584,:p585,:p586,:p587,:p588,:p589,:p590,:p591,:p592,:p593,:p594,:p595,:p596,:p597,:p598,:p599,:p600,
 64 :p601,:p602,:p603,:p604,:p605,:p606,:p607,:p608,:p609,:p610,:p611,:p612,:p613,:p614,:p615,:p616,:p617,:p618,:p619,:p620,:p621,:p622,:p623,:p624,:p625,:p626,:p627,:p628,:p629,:p630,
 65 :p631,:p632,:p633,:p634,:p635,:p636,:p637,:p638,:p639,:p640,:p641,:p642,:p643,:p644,:p645,:p646,:p647,:p648,:p649,:p650,:p651,:p652,:p653,:p654,:p655,:p656,:p657,:p658,:p659,:p660,
 66 :p661,:p662,:p663,:p664,:p665,:p666,:p667,:p668,:p669,:p670,:p671,:p672,:p673,:p674,:p675,:p676,:p677,:p678,:p679,:p680,:p681,:p682,:p683,:p684,:p685,:p686,:p687,:p688,:p689,:p690,
 67 :p691,:p692,:p693,:p694,:p695,:p696,:p697,:p698,:p699,:p700,:p701,:p702,:p703,:p704,:p705,:p706,:p707,:p708,:p709,:p710,:p711,:p712,:p713,:p714,:p715,:p716,:p717,:p718,:p719,:p720,
 68 :p721,:p722,:p723,:p724,:p725,:p726,:p727,:p728,:p729,:p730,:p731,:p732,:p733,:p734,:p735,:p736,:p737,:p738,:p739,:p740,:p741,:p742,:p743,:p744,:p745,:p746,:p747,:p748,:p749,:p750,
 69 :p751,:p752,:p753,:p754,:p755,:p756,:p757,:p758,:p759,:p760,:p761,:p762,:p763,:p764,:p765,:p766,:p767,:p768,:p769,:p770,:p771,:p772,:p773,:p774,:p775,:p776,:p777,:p778,:p779,:p780,
 70 :p781,:p782,:p783,:p784,:p785,:p786,:p787,:p788,:p789,:p790,:p791,:p792,:p793,:p794,:p795,:p796,:p797,:p798,:p799,:p800,:p801,:p802,:p803,:p804,:p805,:p806,:p807,:p808,:p809,:p810,
 71 :p811,:p812,:p813,:p814,:p815,:p816,:p817,:p818,:p819,:p820,:p821,:p822,:p823,:p824,:p825,:p826,:p827,:p828,:p829,:p830,:p831,:p832,:p833,:p834,:p835,:p836,:p837,:p838,:p839,:p840,
 72 :p841,:p842,:p843,:p844,:p845,:p846,:p847,:p848,:p849,:p850,:p851,:p852,:p853,:p854,:p855,:p856,:p857,:p858,:p859,:p860,:p861,:p862,:p863,:p864,:p865,:p866,:p867,:p868,:p869,:p870,
 73 :p871,:p872,:p873,:p874,:p875,:p876,:p877,:p878,:p879,:p880,:p881,:p882,:p883,:p884,:p885,:p886,:p887,:p888,:p889,:p890,:p891,:p892,:p893,:p894,:p895,:p896,:p897,:p898,:p899,:p900,
 74 :p901,:p902,:p903,:p904,:p905,:p906,:p907,:p908,:p909,:p910,:p911,:p912,:p913,:p914,:p915,:p916,:p917,:p918,:p919,:p920,:p921,:p922,:p923,:p924,:p925,:p926,:p927,:p928,:p929,:p930,
 75 :p931,:p932,:p933,:p934,:p935,:p936,:p937,:p938,:p939,:p940,:p941,:p942,:p943,:p944,:p945,:p946,:p947,:p948,:p949,:p950,:p951,:p952,:p953,:p954,:p955,:p956,:p957,:p958,:p959,:p960,
 76 :p961,:p962,:p963,:p964,:p965,:p966,:p967,:p968,:p969,:p970,:p971,:p972,:p973,:p974,:p975,:p976,:p977,:p978,:p979,:p980,:p981,:p982,:p983,:p984,:p985,:p986,:p987,:p988,:p989,:p990,
 77 :p991,:p992,:p993,:p994,:p995,:p996,:p997,:p998,:p999,:p1000)
 78 'using
 79 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 80 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 81 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 82 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 83 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 84 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 85 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 86 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 87 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 88 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 89 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 90 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 91 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 92 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 93 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 94 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 95 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 96 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 97 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 98 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 99 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
100 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
101 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
102 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
103 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20;
104 commit;
105 end;
106 /

Succeed.

SQL> call PROC_USING_BIND_009;

PL/SQL procedure successfully completed.

SQL> create or replace procedure PROC_USING_BIND_009 (
  2 V_1  int,
  3 V_2  bigint,
  4 V_3  number,
  5 V_4  decimal,
  6 V_5  float,
  7 V_6  double,
  8 V_7  real,
  9 V_8  char,
 10 V_9  varchar,
 11 V_10  varchar2,
 12 V_11  bool,
 13 V_12  boolean,
 14 V_13  date,
 15 V_14  timestamp,
 16 V_15  binary,
 17 V_16  varbinary,
 18 V_17  clob,
 19 V_18  blob,
 20 V_19  DATETIME,
 21 V_20  NVARCHAR
 22 )
 23 is
 24 type  XX is record
 25 (
 26 Rec_1  int,
 27 Rec_2  bigint,
 28 Rec_3  number(10,2),
 29 Rec_4  decimal(10,2),
 30 Rec_5  float,
 31 Rec_6  double,
 32 Rec_7  real,
 33 Rec_8  char(10),
 34 Rec_9  varchar(100),
 35 Rec_10  varchar2(100),
 36 Rec_11  bool,
 37 Rec_12  boolean,
 38 Rec_13  date,
 39 Rec_14  timestamp,
 40 Rec_15  binary(10),
 41 Rec_16  varbinary(20),
 42 Rec_17  clob,
 43 Rec_18  blob,
 44 Rec_19  DATETIME,
 45 Rec_20  NVARCHAR(100)
 46 );
 47 v_rec XX;
 48 str clob;
 49 str2 clob;
 50 begin
 51 for i in 1..1000
 52 loop
 53 str := str||'id'||i||'=:p'||i||' and ';
 54 end loop;
 55 str := substr(str,0,length(str)-4);
 56 --dbe_output.print_line(str);
 57 for i in 1..50
 58 loop
 59 str2 := str2||'V_1'||','||'V_2'||','||'V_3'||','||'V_4'||','||'V_5'||','||'V_6'||','||'V_7'||','||'V_8'||','||'V_9'||','||'V_10'||','
 60             ||'V_11'||','||'V_12'||','||'V_13'||','||'V_14'||','||'V_15'||','||'V_16'||','||'V_17'||','||'V_18'||','||'V_19'||','||'V_20'||',';
 61 end loop;
 62 str2 :=substr(str2,0,length(str2)-1);
 63 --dbe_output.print_line(str2);
 64 execute immediate 'update  PROC_DTS2020030303579 set id1=:p1,id2=:p2,id3=:p3,id4=:p4,id5=:p5,id6=:p6,id7=:p7,id8=:p8,id9=:p9,id10=:p10,id11=:p11,id12=:p12,id13=:p13,id14=:p14,id15=:p15,id16=:p16,id17=:p17,id18=:p18,id19=:p19,id20=:p20  where   '||str
 65 using  trunc(1234.51)+ABS(-100),cast('123424234' as bigint)+ceil(12.3) + bitand(-922337203685477808,9223372036854775801),ACOS(-1),ASIN(0.5)+TO_NUMBER('00FFFFFF', '0000000X'),log(101),ln(8),11.222+ exp(4),'高斯1234',DBE_LOB.SUBSTR('123456,7890',8,1)||UNHEX('746869732069732061207465737420737472'),
 66 concat(HEX('ABC'),'like',hex(255)),1 ,'T',to_date('2018-07-05') + NUMTODSINTERVAL(1, 'HOUR'),to_date('2018-12-12')+TO_DSINTERVAL('180 00:00:00'),cast(concat(chr(67),char(56)) as binary(10)),cast(IFNULL(null,'AAAB0101fG') as varbinary(20)),TO_CLOB(if(9>1,'clobtest%QWERASGSDTRERE','null')),
 67 RAWTOHEX ('0123456789abcdef')|| hex('h#2312#%$#@$'),CONVERT('2018-06-28 13:14:15', timestamp),nvl('ABFDSF#$@',''),
 68 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 69 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 70 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 71 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 72 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 73 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 74 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 75 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 76 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 77 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 78 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 79 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 80 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 81 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 82 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 83 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 84 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 85 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 86 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 87 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 88 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 89 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 90 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 91 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 92 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 93 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 94 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 95 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 96 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 97 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 98 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
 99 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
100 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
101 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
102 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
103 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
104 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
105 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
106 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
107 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
108 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
109 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
110 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
111 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
112 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
113 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
114 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
115 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
116 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20,
117 V_1,V_2,V_3,V_4,V_5,V_6,V_7,V_8,V_9,V_10,V_11,V_12,V_13,V_14,V_15,V_16,V_17,V_18,V_19,V_20;
118 commit;
119 end;
120 /

Succeed.

SQL> --call PROC_USING_BIND_009(11212+12,cast('123424234' as bigint),1234.56,exp(3),12.11,1888.32,111.11,'01','1aaaaaaafdfdbadfsfdfdsf',concat('11aaaaaaafdfdbadfsfdfdsfaaaa',null,'!!!@##A$%$%AFD "'),true,false,to_date('2019-06-27'),to_date('2019-06-27 14:58'),'ADFD111','afdfdsf111','aaaaaaaaaaa i  am clob','AB0101',FROM_UNIXTIME(1111885200),'abcddd#$@');

SQL> select id1,id2,id3,id4,id5,id19 from PROC_DTS2020030303579;

ID1          ID2                  ID3                                      ID4                                      ID5                  ID19
------------ -------------------- ---------------------------------------- ---------------------------------------- -------------------- ----------------------
11212        123424234            1234.56                                  123456.78                                12.11                2019-06-27 00:00:00

1 rows fetched.

SQL> drop table PROC_DTS2020030303579;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS tbl_RegNETable;

Succeed.

SQL> CREATE TABLE tbl_RegNETable
  2 (
  3   cNeMgrSvrProcType BINARY_INTEGER NOT NULL,
  4   cNeMgrSvrProcHandle BINARY_INTEGER NOT NULL,
  5   cDbName VARCHAR(255 BYTE) NOT NULL,
  6   cTableName VARCHAR(255 BYTE) NOT NULL,
  7   cDevIDFieldName VARCHAR(255 BYTE) NOT NULL,
  8   cDevTypeFieldName VARCHAR(255 BYTE) NOT NULL,
  9   cDbServerName VARCHAR(255 BYTE)
 10 );

Succeed.

SQL> INSERT INTO tbl_RegNETable  values (3022,0,'InventoryDB','view_inv_3rdParty_ne_unitedmgr','iDevID','iDevTypeID',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,401,'BMSDB','tbl_RegU2kNERegionView_30_401','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,301,'BMSDB','tbl_RegU2kNERegionView_30_301','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,801,'BMSDB','tbl_RegU2kNERegionView_30_801','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,701,'BMSDB','tbl_RegU2kNERegionView_30_701','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,101,'BMSDB','tbl_RegU2kNERegionView_30_101','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,201,'BMSDB','tbl_RegU2kNERegionView_30_201','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,601,'BMSDB','tbl_RegU2kNERegionView_30_601','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (30,501,'BMSDB','tbl_RegU2kNERegionView_30_501','DevID','DevType',null);

1 rows affected.

SQL> INSERT INTO tbl_RegNETable  values (236,0,'BitsDB','tbl_RegU2kNERegionView_236_0','DevID','DevType',null);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> ALTER TABLE tbl_RegNETable ADD PRIMARY KEY(cNeMgrSvrProcType, cNeMgrSvrProcHandle);

Succeed.

SQL> 
SQL> create or replace PROCEDURE ip_GetAllEMGroup
  2 as
  3    v_SWV_ExecDyn  varchar2(1000);
  4    v_refcur SYS_REFCURSOR;
  5    v_refcur2 SYS_REFCURSOR;
  6    v_refcur3 SYS_REFCURSOR;
  7    v_ownerEMProcType  NUMBER(10,0);
  8    v_ownerEMProcHandle  NUMBER(10,0);
  9    v_procType  VARCHAR2(20);
 10    v_procHandle  VARCHAR2(20);
 11    allEMGroup_Cursor SYS_REFCURSOR;
 12 
 13 begin
 14    open allEMGroup_Cursor for select cNeMgrSvrProcType, cNeMgrSvrProcHandle from tbl_RegNETable;
 15    fetch allEMGroup_Cursor into v_ownerEMProcType,v_ownerEMProcHandle;
 16    while (allEMGroup_Cursor%FOUND) LOOP
 17       open v_refcur for select v_ownerEMProcType ownerProcType, v_ownerEMProcHandle ownerProcHandle from SYS_DUMMY;
 18       DBE_SQL.RETURN_CURSOR(v_refcur);
 19       fetch allEMGroup_Cursor into v_ownerEMProcType,v_ownerEMProcHandle;
 20    END LOOP;
 21    close allEMGroup_Cursor;
 22 commit;
 23 end;
 24 /

Succeed.

SQL> 
SQL> call ip_GetAllEMGroup();

PL/SQL procedure successfully completed.

ResultSet #1

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       101                                     

1 rows fetched.


ResultSet #2

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       201                                     

1 rows fetched.


ResultSet #3

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       301                                     

1 rows fetched.


ResultSet #4

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       401                                     

1 rows fetched.


ResultSet #5

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       501                                     

1 rows fetched.


ResultSet #6

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       601                                     

1 rows fetched.


ResultSet #7

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       701                                     

1 rows fetched.


ResultSet #8

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
30                                       801                                     

1 rows fetched.


ResultSet #9

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
236                                      0                                       

1 rows fetched.


ResultSet #10

OWNERPROCTYPE                            OWNERPROCHANDLE                         
---------------------------------------- ----------------------------------------
3022                                     0                                       

1 rows fetched.


SQL> drop PROCEDURE ip_GetAllEMGroup;

Succeed.

SQL> drop TABLE tbl_RegNETable;

Succeed.

SQL> set serveroutput off;
OFF



