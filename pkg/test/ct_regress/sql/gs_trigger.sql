--before IDU statement

set serveroutput on;

-- begin test alter session disable|enable triggers
alter session disable triggers;
drop table if exists t_enable_triggers;
create table t_enable_triggers(f1 int, f2 int);
CREATE OR REPLACE TRIGGER trig_enable_triggers1 BEFORE INSERT OR UPDATE OR DELETE ON t_enable_triggers
BEGIN
	dbe_output.print_line('BEFORE t_enable_triggers');
END;
/
CREATE OR REPLACE TRIGGER trig_enable_triggers2 AFTER INSERT OR UPDATE OR DELETE ON t_enable_triggers
BEGIN
	dbe_output.print_line('AFTER t_enable_triggers');
END;
/
insert into t_enable_triggers values(1, 2);
update t_enable_triggers set f2=3;
delete from t_enable_triggers;
drop table t_enable_triggers;

alter session enable triggers;
drop table if exists t_enable_triggers;
create table t_enable_triggers(f1 int, f2 int);
CREATE OR REPLACE TRIGGER trig_enable_triggers1 BEFORE INSERT OR UPDATE OR DELETE ON t_enable_triggers
BEGIN
	dbe_output.print_line('BEFORE t_enable_triggers');
END;
/
CREATE OR REPLACE TRIGGER trig_enable_triggers2 AFTER INSERT OR UPDATE OR DELETE ON t_enable_triggers
BEGIN
	dbe_output.print_line('AFTER t_enable_triggers');
END;
/
insert into t_enable_triggers values(1, 2);
update t_enable_triggers set f2=3;
delete from t_enable_triggers;
drop table t_enable_triggers;

-- end test alter session disable|enable triggers

-- nologging + triggers
DROP TABLE IF EXISTS T_TRIG_1;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
CREATE OR REPLACE TRIGGER TEST_NOLOGGING_TRIG BEFORE INSERT ON T_TRIG_1
   FOR EACH ROW
   BEGIN
     UPDATE T_TRIG_1 SET F_INT1 = 1;
	 insert into T_TRIG_2(F_INT1) values(2);
   END;
   /
INSERT /*+nologging*/ INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
COMMIT;
CREATE OR REPLACE TRIGGER TEST_NOLOGGING_TRIG BEFORE INSERT ON T_TRIG_1
   FOR EACH ROW
   BEGIN
     UPDATE T_TRIG_1 SET F_INT1 = 1;
	 insert into /*+nologging*/ T_TRIG_2(F_INT1) values(2);
   END;
   /
INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
COMMIT;

-- nologging + insert select
DROP TABLE IF EXISTS T_TRIG_1 CASCADE CONSTRAINTS;
CREATE TABLE T_TRIG_1
(
  "OBJECTID" NUMBER(11) NOT NULL
);
CREATE INDEX T_TRIG_1_IDX ON T_TRIG_1("OBJECTID");
DROP TABLE IF EXISTS T_TRIG_2 CASCADE CONSTRAINTS;
CREATE TABLE T_TRIG_2
(
  "CMENEID" BINARY_INTEGER NOT NULL,
  "CRCKEY" NUMBER(17) NOT NULL,
  "CRCNOTKEY" NUMBER(17) NOT NULL,
  "UUMEASCTRLTIMERLEN" NUMBER(17),
  "IUBMEASCTRLINITTIMERLEN" NUMBER(17),
  "IURMEASCTRLINITTIMERLEN" NUMBER(17),
  "MACDMEASCTRLTIMERLEN" NUMBER(17),
  "IUBMEASCTRLINITFAILDLYTIMERLEN" NUMBER(17),
  "IURMEASCTRLINITFAILDLYTIMERLEN" NUMBER(17),
  "OLPCTIMERLEN" NUMBER(17),
  "RLCMEASCTRLTIMERLEN" NUMBER(17),
  "CHANNELRETRYTIMERLEN" NUMBER(17),
  "CHANNELRETRYHOTIMERLEN" NUMBER(17),
  "RABMODIFYTIMERLEN" NUMBER(17),
  "ZERORATEUPFAILTORELTIMERLEN" NUMBER(17),
  "ADAPRETRANPUNTIMER" NUMBER(17),
  "SRBFASTHRETRYTIMERLEN" BINARY_INTEGER,
  "PARKINGRELTIMER" BINARY_INTEGER,
  "DCHSUPAHRETRYPENALTYTIME" BINARY_INTEGER,
  "DELAYTRIGAMRRBRECFGTIMER" BINARY_INTEGER,
  "TFCCTRLFAILTIMER" BINARY_INTEGER,
  PRIMARY KEY("CMENEID")
);
INSERT INTO T_TRIG_2 ("CMENEID","CRCKEY","CRCNOTKEY","UUMEASCTRLTIMERLEN","IUBMEASCTRLINITTIMERLEN","IURMEASCTRLINITTIMERLEN","MACDMEASCTRLTIMERLEN","IUBMEASCTRLINITFAILDLYTIMERLEN","IURMEASCTRLINITFAILDLYTIMERLEN","OLPCTIMERLEN","RLCMEASCTRLTIMERLEN","CHANNELRETRYTIMERLEN","CHANNELRETRYHOTIMERLEN","RABMODIFYTIMERLEN","ZERORATEUPFAILTORELTIMERLEN","ADAPRETRANPUNTIMER","SRBFASTHRETRYTIMERLEN","PARKINGRELTIMER","DCHSUPAHRETRYPENALTYTIME","DELAYTRIGAMRRBRECFGTIMER","TFCCTRLFAILTIMER") values(38690,1810552692,1810552692,3000,20000,20000,20000,5000,5000,3000,20000,5,2,5,180,10,20,300,10,50,5);
alter session enable nologging;
insert into T_TRIG_1 select CMENEID from T_TRIG_2;
alter session disable nologging;

DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
DROP TABLE IF EXISTS T_TRIG_3;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_STMT BEFORE UPDATE ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_1 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

CREATE OR REPLACE TRIGGER TRIG_BEFORE_STMT BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_1
BEGIN
  dbe_output.print_line('insert into T_TRIG_2 one row');
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

SELECT * FROM ALL_TRIGGERS WHERE TRIGGER_NAME = 'TRIG_BEFORE_STMT' AND OWNER = 'SYS';
SELECT * FROM DBA_TRIGGERS WHERE TRIGGER_NAME = 'TRIG_BEFORE_STMT' AND OWNER = 'SYS';
SELECT * FROM USER_TRIGGERS WHERE TRIGGER_NAME = 'TRIG_BEFORE_STMT';

DROP USER IF EXISTS TEST_TRIG_USER1;
CREATE USER TEST_TRIG_USER1 IDENTIFIED BY Cantian_234;
GRANT DBA TO TEST_TRIG_USER1;
grant  select on T_TRIG_1 to TEST_TRIG_USER1;
grant  select on T_TRIG_2 to TEST_TRIG_USER1;
grant insert on T_TRIG_2 to TEST_TRIG_USER1;
grant delete on T_TRIG_1 to TEST_TRIG_USER1;
grant update on T_TRIG_1 to TEST_TRIG_USER1;
grant insert on T_TRIG_1 to TEST_TRIG_USER1;
CONN TEST_TRIG_USER1/Cantian_234@127.0.0.1:1611

INSERT INTO SYS.T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO SYS.T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO SYS.T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO SYS.T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM SYS.T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM SYS.T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
COMMIT;

CONN sys/Huawei@123@127.0.0.1:1611
DROP USER TEST_TRIG_USER1;

UPDATE T_TRIG_1 SET F_INT1 = 10,F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

DELETE FROM T_TRIG_1 WHERE F_INT1 = 10;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_CHAR1 = 'MERGE_UPDATE';
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_INT1 = 100;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=0) WHEN NOT MATCHED THEN INSERT (F_CHAR1) VALUES ('MERGE_INSERT');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;



--after IDU statement
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_AFTER_STMT AFTER INSERT OR DELETE OR UPDATE OF F_INT1,F_INT2 ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT1 = 10,F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

DELETE FROM T_TRIG_1 WHERE F_INT1 = 10;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_CHAR1 = 'MERGE_UPDATE';
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_INT1 = 100;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=0) WHEN NOT MATCHED THEN INSERT (F_CHAR1) VALUES ('MERGE_INSERT');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;




--before IDU each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT1 = 10,F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

DELETE FROM T_TRIG_1 WHERE F_INT1 = 10;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_CHAR1 = 'MERGE_UPDATE';
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_INT1 = 100;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=0) WHEN NOT MATCHED THEN INSERT (F_CHAR1) VALUES ('MERGE_INSERT');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;



--after IDU each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_AFTER_EACH_ROW BEFORE INSERT OR DELETE OR UPDATE OF F_INT1,F_INT2 ON T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT1 = 10,F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

DELETE FROM T_TRIG_1 WHERE F_INT1 = 10;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_CHAR1 = 'MERGE_UPDATE';
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=1) WHEN MATCHED THEN UPDATE SET F_INT1 = 100;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

MERGE INTO T_TRIG_1 USING DUAL ON (1=0) WHEN NOT MATCHED THEN INSERT (F_CHAR1) VALUES ('MERGE_INSERT');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

--before update each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_UPDATE_EACH_ROW BEFORE UPDATE ON T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT1 = 10 WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;


--before update each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_UPDATE_EACH_ROW_2 BEFORE UPDATE ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW."F_INT2" := 1234;
  :NEW.`F_INT2` := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT1 = 10 WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

UPDATE T_TRIG_1 SET F_INT2 = 5;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

--before update each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT);

INSERT INTO T_TRIG_1 VALUES(1,2);
INSERT INTO T_TRIG_1 VALUES(3,4);
INSERT INTO T_TRIG_1 VALUES(1,3);
INSERT INTO T_TRIG_1 VALUES(2,3);
COMMIT;

ALTER TABLE T_TRIG_1 ADD column F_CHAR1 char(16);
ALTER TABLE T_TRIG_2 ADD column F_CHAR1 char(16);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_UPDATE_EACH_ROW_2 BEFORE UPDATE ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW."F_INT2" := 1234;
  :NEW.`F_INT2` := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1);
END;
/

SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1;

UPDATE T_TRIG_1 SET F_CHAR1='TRIG' WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1;

COMMIT;


--before insert each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.f_int1 := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

--before insert each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  SELECT 123 INTO :NEW.f_int1 FROM DUAL;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

--before insert each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  EXECUTE IMMEDIATE 'SELECT 123 FROM DUAL' INTO :NEW.f_int1;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

--before insert each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE PROCEDURE P1(A INT,B OUT INT)
AS
BEGIN
  B := 123;
END;
/

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  P1(1,:NEW.f_int1);
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;


--before delete each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_DELETE_EACH_ROW BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
DECLARE
	v_UsertId NUMBER(10);
	v_NESeqId NUMBER(10);
BEGIN
	SELECT ( SELECT :OLD.F_INT1 FROM DUAL ) INTO v_UsertId FROM DUAL ;
	SELECT ( SELECT :OLD.F_INT2 FROM DUAL ) INTO v_NESeqId FROM DUAL ;
	DELETE FROM T_TRIG_2 WHERE v_UsertId = F_INT1;
	DELETE T_TRIG_2 WHERE v_NESeqId = F_INT2;
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_1 VALUES(3,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_1 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_1 VALUES(2,3,'B','2017-12-11 16:08:00');
INSERT INTO T_TRIG_2 VALUES(0,2,'A','2017-12-11 14:08:00');
INSERT INTO T_TRIG_2 VALUES(1,4,'C','2017-12-12 16:08:00');
INSERT INTO T_TRIG_2 VALUES(1,3,'A','2017-12-11 14:18:00');
INSERT INTO T_TRIG_2 VALUES(2,3,'B','2017-12-11 16:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
DELETE FROM T_TRIG_1 WHERE F_INT1 = 1;
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;


--begin: test trigger compile failed
--before IDU each row
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');

CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_2
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_1 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/
--end: test trigger compile failed

--bein:the triggered table is not allowed in the row trigger
DROP TABLE IF EXISTS T_TRIG_1;
SELECT * FROM USER_TRIGGERS;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');

CREATE OR REPLACE TRIGGER TEST_TRIG AFTER INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  UPDATE T_TRIG_1 SET F_INT1 = 1;
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');


CREATE OR REPLACE TRIGGER TEST_TRIG BEFORE UPDATE ON T_TRIG_1
FOR EACH ROW
BEGIN
  UPDATE T_TRIG_1 SET F_INT1 = 2;
END;
/

UPDATE T_TRIG_1 SET F_INT1 = 10;


CREATE OR REPLACE TRIGGER TEST_TRIG AFTER UPDATE ON T_TRIG_1
FOR EACH ROW
BEGIN
  UPDATE T_TRIG_1 SET F_INT1 = 2;
END;
/

UPDATE T_TRIG_1 SET F_INT1 = 10;


CREATE OR REPLACE TRIGGER TEST_TRIG BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  UPDATE T_TRIG_1 SET F_INT1 = 2;
END;
/

DELETE FROM T_TRIG_1;


CREATE OR REPLACE TRIGGER TEST_TRIG BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  DELETE T_TRIG_1;
END;
/

DELETE FROM T_TRIG_1;
--end:the triggered table is not allowed in the row trigger


--bein:DDL or DCL is not allowed in a trigger
CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
BEGIN
  COMMIT;
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
--end:DDL or DCL is not allowed in a trigger

--bein:DDL or DCL is not allowed in a trigger
CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
BEGIN
  ROLLBACK;
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
--end:DDL or DCL is not allowed in a trigger

--bein:DDL or DCL is not allowed in a trigger
CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
BEGIN
  SAVEPOINT A;
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
--end:DDL or DCL is not allowed in a trigger

--bein:DDL or DCL is not allowed in a trigger
CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
BEGIN
  execute immediate 'COMMIT';
END;
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
--end:DDL or DCL is not allowed in a trigger

--begin:test trigger status
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_AFTER_STMT_INSERT AFTER INSERT ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

CREATE OR REPLACE TRIGGER TRIG_AFTER_STMT_DELETE AFTER DELETE ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

CREATE OR REPLACE TRIGGER TRIG_AFTER_STMT_UPDATE AFTER UPDATE OF F_INT1,F_INT2 ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = 'SYS' AND TABLE_NAME= 'T_TRIG_1' ORDER BY TRIGGER_NAME;
ALTER TABLE t_trig_1 DISABLE ALL TRIGGERS;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = 'SYS' AND TABLE_NAME= 'T_TRIG_1' ORDER BY TRIGGER_NAME;

CREATE OR REPLACE TRIGGER TRIG_AFTER_STMT_UPDATE AFTER UPDATE OF F_INT1,F_INT2 ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2 VALUES(4,2,'A','2017-12-11 14:08:00');
END;
/

SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = 'SYS' AND TABLE_NAME= 'T_TRIG_1' ORDER BY TRIGGER_NAME;

ALTER TABLE T_TRIG_1 ENABLE ALL TRIGGERS;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = 'SYS' AND TABLE_NAME= 'T_TRIG_1' ORDER BY TRIGGER_NAME;

ALTER TABLE t_trig_1 DISABLE ALL TRIGGERS;
DROP TABLE t_trig_1;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = 'SYS' AND TABLE_NAME= 'T_TRIG_1' ORDER BY TRIGGER_NAME;

--end:test trigger status

--begin DTS2018071607476: test insert null into not null column 
DROP TABLE IF EXISTS tbl_negrouptype;
CREATE TABLE tbl_negrouptype
(
type_id number(10,0) not null,
type_name varchar2(765) not null,
featurename varchar2(255) not null,
featurevalue varchar2(765) not null,
data_type number(10,0) not null,
parent_typeid number(10,0) not null,
id number(10, 0) not null
);
create unique index tbl_negrouptype_idx on tbl_negrouptype(type_id, featurename);

DROP SEQUENCE IF EXISTS next_tbl_negrouptype;
create sequence next_tbl_negrouptype
start with 1
increment by 1
minvalue 1
maxvalue 2147483647 
cycle
order;

DROP TRIGGER IF EXISTS identity_tbl_negrouptype;

insert into tbl_negrouptype(type_id, type_name, featurename, featurevalue, data_type, parent_typeid, id) values (0, 'type1', 'label', 'NeGroupType1', 1, 1, 1);
insert into tbl_negrouptype(type_id, type_name, featurename, featurevalue, data_type, parent_typeid) values (1, 'type1', 'label', 'NeGroupType1', 1, 1);
UPDATE tbl_negrouptype set id = null;

create or replace trigger identity_tbl_negrouptype before INSERT OR UPDATE on tbl_negrouptype
for each row
declare
next_id NUMBER(10,0);
begin 
select next_tbl_negrouptype.nextval into next_id from dual;
:new.id:=next_id;
end;
/
insert into tbl_negrouptype(type_id, type_name, featurename, featurevalue, data_type, parent_typeid) values (1, 'type1', 'label', 'NeGroupType1', 1, 1);
select * from tbl_negrouptype order by type_id;
UPDATE tbl_negrouptype set id = null;
select * from tbl_negrouptype order by type_id;
DROP TRIGGER identity_tbl_negrouptype;
--end DTS2018071607476


--test drop trigger
DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.F_INT1 := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/
DROP TRIGGER TRIG_BEFORE_INSERT_EACH_ROW;

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;


--begin:test drop user
DROP USER if exists user_trig1 CASCADE;
DROP USER if exists user_trig2 CASCADE;

CREATE USER user_trig1 identified by Cantian_234;
CREATE USER user_trig2 identified by Cantian_234;

CREATE TABLE user_trig1.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig1.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

GRANT INSERT ON user_trig1.T_TRIG_2 TO user_trig2;
CREATE OR REPLACE TRIGGER user_trig2.TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig1.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

DROP USER user_trig2 CASCADE;
DROP TABLE user_trig1.T_TRIG_1;
DROP TABLE user_trig1.T_TRIG_2;
DROP USER user_trig1 CASCADE;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = UPPER('user_trig2') OR  TABLE_OWNER = UPPER('user_trig1') ORDER BY TRIGGER_NAME;
--end:test drop user

--begin:test drop user
DROP USER if exists user_trig1 CASCADE;
DROP USER if exists user_trig2 CASCADE;

CREATE USER user_trig1 identified by Cantian_234;
CREATE USER user_trig2 identified by Cantian_234;

CREATE TABLE user_trig1.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig1.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
GRANT INSERT ON user_trig1.T_TRIG_2 TO user_trig2;
CREATE OR REPLACE TRIGGER user_trig2.TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig1.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

DROP USER user_trig2 CASCADE;
DROP USER user_trig1 CASCADE;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = UPPER('user_trig2') OR  TABLE_OWNER = UPPER('user_trig1') ORDER BY TRIGGER_NAME;
--end:test drop user


--begin:test drop user
DROP USER if exists user_trig1 CASCADE;
DROP USER if exists user_trig2 CASCADE;

CREATE USER user_trig1 identified by Cantian_234;
CREATE USER user_trig2 identified by Cantian_234;

CREATE TABLE user_trig1.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig1.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig2.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig2.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
GRANT INSERT ON user_trig1.T_TRIG_2 TO user_trig2;
CREATE OR REPLACE TRIGGER user_trig2.TRIG_BEFORE_EACH_ROW_1 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig1.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

CREATE OR REPLACE TRIGGER user_trig1.TRIG_BEFORE_EACH_ROW2 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig1.T_TRIG_2
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

CREATE OR REPLACE TRIGGER user_trig1.TRIG_BEFORE_EACH_ROW1 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig2.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/
CREATE OR REPLACE TRIGGER user_trig2.TRIG_BEFORE_EACH_ROW2 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig2.T_TRIG_2
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/
DROP USER user_trig2 CASCADE;
DROP USER user_trig1 CASCADE;
SELECT * FROM ALL_TRIGGERS WHERE TABLE_OWNER = UPPER('user_trig2') OR  TABLE_OWNER = UPPER('user_trig1') ORDER BY TRIGGER_NAME;
--end:test drop user

--begin:alter table(exist trigger) rename
DROP USER if exists user_trig1 CASCADE;
DROP USER if exists user_trig2 CASCADE;

CREATE USER user_trig1 identified by Cantian_234;
CREATE USER user_trig2 identified by Cantian_234;

CREATE TABLE user_trig1.T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE user_trig1.T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
GRANT INSERT ON user_trig1.T_TRIG_2 TO user_trig2;
CREATE OR REPLACE TRIGGER user_trig2.TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON user_trig1.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO user_trig1.T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/


ALTER TABLE user_trig1.T_TRIG_1 rename to T_TRIG_3;

select * from all_triggers where owner = 'USER_TRIG2';


DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW1 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON T_TRIG_2
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW2 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON sys.T_TRIG_1
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW3 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON sys."T_TRIG_1"
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/


ALTER TABLE T_TRIG_1 rename to T_TRIG_3;
select * from all_triggers where owner = 'SYS' AND trigger_name like 'TRIG_BEFORE_EACH_ROW%' order by trigger_name;

CREATE OR REPLACE TRIGGER TRIG_BEFORE_EACH_ROW3 BEFORE INSERT OR UPDATE OF F_INT1 OR DELETE ON sys."T_TRIG_3"
FOR EACH ROW
BEGIN
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT1, :NEW.f_int1, :OLD."F_CHAR1",:NEW.`F_DATE`);
END;
/

ALTER TABLE T_TRIG_3 rename to T_TRIG_1;
select * from all_triggers where owner = 'SYS' AND trigger_name like 'TRIG_BEFORE_EACH_ROW%' order by trigger_name;
--end:alter table(exist trigger) rename


DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
--expect error
select count(1) from user_triggers where trigger_name = 'BEFORE';
CREATE OR REPLACE TRIGGER BEFORE INSERT ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_1(F_INT1) VALUES(1);
END;
/
select count(1) from user_triggers where trigger_name = 'BEFORE';

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_1;
CREATE OR REPLACE TRIGGER TRIG_ERROR_1 BEFORE INSERT ON USER_TRIGGERS
BEGIN
  INSERT INTO T_TRIG_1(F_INT1) VALUES(1);
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_1;
CREATE OR REPLACE TRIGGER TRIG_ERROR_1 BEFORE INSERT ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_1(F_INT1) VALUES(1);
END;
/
INSERT INTO T_TRIG_1(F_INT1) VALUES(1);

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_1;
CREATE OR REPLACE TRIGGER TRIG_ERROR_1 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2(F_INT1) VALUES(:OLD.F_INT1);
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_2;
CREATE OR REPLACE TRIGGER TRIG_ERROR_2 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
BEGIN
  INSERT INTO T_TRIG_2(F_INT1) VALUES(:NEW.F_INT1);
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_3;
CREATE OR REPLACE TRIGGER TRIG_ERROR_3 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
BEGIN
  :OLD.F_INT2 := 1;
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_4;
CREATE OR REPLACE TRIGGER TRIG_ERROR_4 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
BEGIN
  :NEW.F_INT2 := 1;
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_5;
CREATE OR REPLACE TRIGGER TRIG_ERROR_5 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
DECLARE
X INT := 1;
BEGIN
  X := :OLD.F_INT2;
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_6;
CREATE OR REPLACE TRIGGER TRIG_ERROR_6 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
DECLARE
X INT := 1;
BEGIN
  X := :NEW.F_INT2;
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_7;
CREATE OR REPLACE TRIGGER TRIG_ERROR_7 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  :OLD.F_INT2 := 1;
END;
/

--expect error
DROP TRIGGER IF EXISTS TRIG_ERROR_8;
CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE INSERT OR UPDATE OR DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.F_INT2 := 1;
END;
/

--expect error
CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  select 1 into :NEW.F_INT2 from dual;
END;
/

--expect error
CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  execute immediate 'select 1 from dual' into :NEW.F_INT2;
END;
/

--expect error
CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  execute immediate 'select 1 from dual' using out :NEW.F_INT2;
END;
/

--expect error
CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  execute immediate 'begin :x := 1;end;' using in out :NEW.F_INT2;
END;
/

--begin:expect error
CREATE OR REPLACE PROCEDURE P1(A INT,B OUT INT)
AS
BEGIN
  B := 1;
END;
/

CREATE OR REPLACE TRIGGER TRIG_ERROR_8 BEFORE DELETE ON T_TRIG_1
FOR EACH ROW
BEGIN
  P1(1, :NEW.F_INT2);
END;
/
--end:expect error

--test create trigger with quotes
--add 2018/07/10

DROP TABLE IF EXISTS T_TRIG_1;
DROP TABLE IF EXISTS T_TRIG_2;
CREATE TABLE T_TRIG_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);
CREATE TABLE T_TRIG_2 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(16), F_DATE DATE);

--expect success
CREATE OR REPLACE TRIGGER "trig_BEFORE_INSERT_EACH_ROW" BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.F_INT1 := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END;
/
select count(*) from SYS_PROCS where name='trig_BEFORE_INSERT_EACH_ROW';

DROP TRIGGER TRIG_BEFORE_INSERT_EACH_ROW;
DROP TRIGGER "trig_BEFORE_INSERT_EACH_ROW";

select count(*) from SYS_PROCS where name='trig_BEFORE_INSERT_EACH_ROW';

--expect success
CREATE OR REPLACE TRIGGER sys."trig_BEFORE_INSERT_EACH_ROW" BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.F_INT1 := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END "trig_BEFORE_INSERT_EACH_ROW";
/

INSERT INTO T_TRIG_1 VALUES(1,2,'A','2017-12-11 14:08:00');
SELECT * FROM T_TRIG_1 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;
SELECT * FROM T_TRIG_2 ORDER BY F_INT1,F_INT2,F_CHAR1,F_DATE;

COMMIT;

DROP TRIGGER "trig_BEFORE_INSERT_EACH_ROW";

--expect error
CREATE OR REPLACE TRIGGER "trig_BEFORE_INSERT_EACH_ROW" BEFORE INSERT ON T_TRIG_1
FOR EACH ROW
BEGIN
  :NEW.F_INT1 := 123;
  INSERT INTO T_TRIG_2 VALUES(:OLD.F_INT2, :NEW.F_INT1, :OLD.F_CHAR1,:NEW.F_DATE);
END "Trig_BEFORE_INSERT_EACH_ROW";
/

--expect success
drop table if exists "t11";
create table "t11"(f1 int);
 create or replace trigger "tr_t1"       
 before insert on "t11"                   
 for each row
 begin                                   
  :new.f1 := :new.f1 +1;                 
 end;                                    
 /
 
--trigger support clob
drop table if exists pl_trigger_table_test;
drop table if exists pl_trigger_table_test_rec;
create table pl_trigger_table_test(t_a clob);
create table pl_trigger_table_test_rec(t_a clob);

CREATE OR REPLACE TRIGGER pl_trigger_before_insert BEFORE INSERT ON pl_trigger_table_test
FOR EACH ROW
BEGIN
  :NEW.t_a := 'wangwei';
  INSERT INTO pl_trigger_table_test_rec VALUES(:OLD.t_a || 'bakup');
  INSERT INTO pl_trigger_table_test_rec VALUES(:NEW.t_a || 'new');  
END;
/

insert into pl_trigger_table_test values('wanghaifeng');
select count(*) from pl_trigger_table_test;
select count(*) from pl_trigger_table_test_rec where t_a like 'wangwei%';
--end test create trigger with quotes
drop table if exists test_trig_insert;
create table test_trig_insert(f1 int, f2 int)
PARTITION BY RANGE(f1)
(
 PARTITION p1 values less than(10),
 PARTITION p2 values less than(20),
 PARTITION p3 values less than(30),
 PARTITION p4 values less than(MAXVALUE)
);

CREATE OR REPLACE TRIGGER TRIG_BEFORE_INSERT_EACH_ROW BEFORE INSERT ON test_trig_insert
FOR EACH ROW
BEGIN
  :NEW.f1 := 15;
END;
/
insert into test_trig_insert values(5,5);
select * from test_trig_insert partition (p1);
select * from test_trig_insert partition (p2);

--DTS2018092000730
drop table if exists gs_tri_test;
drop table if exists gs_tri_test1;
create table gs_tri_test(id int,name varchar(20),information clob);
insert into gs_tri_test values(1000,'aaaaaaaa','������');
insert into gs_tri_test values(2000,'aaaaaaaa','������');
commit;
create table gs_tri_test1(informations clob);
insert into gs_tri_test1 values('������');
insert into gs_tri_test1 values('������');
insert into gs_tri_test1 values('������');
commit;

set define on;
set serveroutput on;
create or replace trigger triger_003
before delete on gs_tri_test for each row
declare
v_inf gs_tri_test1.informations%TYPE;
begin
   select informations INTO v_inf from gs_tri_test1 WHERE ROWNUM=1;
   dbe_output.print_line(v_inf);
end;
/
delete from gs_tri_test where id=1000;
set serveroutput off;
drop table if exists test_trig_insert;

--test unsupport create trigger on local temp table
--begin
create user gs_tri_user identified by root_1234;
grant dba to gs_tri_user;
conn gs_tri_user/root_1234@127.0.0.1:1611

alter system set LOCAL_TEMPORARY_TABLE_ENABLED = true;

drop table if exists PROC_LOCALTEMPTAB_T_007;
create table  PROC_T_007(id  int,num numeric ,ctime date,name varchar(100));
create sequence PROC_LOCALTEMPTAB_SEQ_007 start with 100 increment by 10 maxvalue 200 cycle ;
create temporary table #PROC_LOCALTEMPTAB_T_007 as select * from PROC_T_007;

--expect error
create or replace trigger PROC_LOCALTEMPTAB_TRI_007 
before insert on #PROC_LOCALTEMPTAB_T_007 
begin
  insert into PROC_T_007 values(PROC_LOCALTEMPTAB_SEQ_007.nextval,9999.9999,sysdate,'Trigger'||PROC_LOCALTEMPTAB_SEQ_007.nextval);
end;
/

select object_name, status from user_objects where object_name = 'PROC_LOCALTEMPTAB_TRI_007';

create or replace trigger PROC_LOCALTEMPTAB_TRI_007
before insert on PROC_T_007
begin
  insert into #PROC_LOCALTEMPTAB_T_007 values(1 ,9999.9999,sysdate,'Trigger'||PROC_LOCALTEMPTAB_SEQ_007.nextval);
end;
/
select object_name, status from user_objects where object_name = 'PROC_LOCALTEMPTAB_TRI_007';

--expect success
insert into PROC_T_007 values (1,12.3,'2018-09-17 16:10:28','jim');
commit;
select * from PROC_T_007;
select ID, NUM  from #PROC_LOCALTEMPTAB_T_007;

alter system set LOCAL_TEMPORARY_TABLE_ENABLED = false;

conn sys/Huawei@123@127.0.0.1:1611
select sleep(2);
conn gs_tri_user/root_1234@127.0.0.1:1611

--expect error
insert into PROC_T_007 values (2,12.3,'2018-09-17 16:10:28','jim');
commit;

select * from PROC_T_007;
select * from #PROC_LOCALTEMPTAB_T_007;

conn sys/Huawei@123@127.0.0.1:1611
select sleep(1);
drop user gs_tri_user cascade;
--end

--test trigger on synonym DTS2019021410338
--begin
drop table if exists tri_tab_1;
drop table if exists tri_tab_2;
create table tri_tab_1(a int);
create table tri_tab_2(a int);

CREATE OR REPLACE SYNONYM  syn_tab_1 FOR tri_tab_1;

CREATE OR REPLACE TRIGGER TRIG_BEFORE_TAB1_SYN BEFORE INSERT OR UPDATE on syn_tab_1
BEGIN
  INSERT INTO tri_tab_2 VALUES(4);
END;
/

--end
set charset gbk
drop table if exists test_trigger_A;
drop table if exists test_trigger_B;
create table test_trigger_A(c1 nvarchar2(32));
create table test_trigger_B(c1 nvarchar2(32));
insert into test_trigger_A values('����������������������������������');
drop trigger if exists addeleteoperation;
CREATE OR REPLACE TRIGGER
addeleteoperation AFTER DELETE ON test_trigger_A
FOR EACH ROW
BEGIN
    INSERT INTO test_trigger_B(c1)  VALUES
    (:OLD.C1);
END;
/

delete from test_trigger_A; 
drop table if exists test_trigger_A;
drop table if exists test_trigger_B;

------------Begin test story: trigger pseudo column -----------
conn sys/Huawei@123@127.0.0.1:1611
set serveroutput on;
drop tablespace myspc_liu_test INCLUDING CONTENTS and datafiles;
create tablespace myspc_liu_test datafile 'myspc_liu_test' size 20M autoextend on next 10M;
drop user if exists gs_trigger_pseudo cascade;
create user gs_trigger_pseudo identified by Lh00420062;
grant dba to gs_trigger_pseudo;

conn gs_trigger_pseudo/Lh00420062@127.0.0.1:1611

drop table if exists test_trigger;
create table test_trigger(a int, b int) tablespace myspc_liu_test;
insert into test_trigger values(1,2);

-- expect wrong
create or replace trigger test_trigger_pseudo before insert on test_trigger
is
begin
dbe_output.print_line(:OLD.rowid);
dbe_output.print_line(:OLD.rowscn);
dbe_output.print_line(:New.rowid);
dbe_output.print_line(:New.rowscn);
end;
/

-- expect wrong
create or replace trigger test_trigger_pseudo before insert on test_trigger for each row
is
a int := 100;
begin
:OLD.rowid := a;
:OLD.rowscn := a;
:New.rowid := a;
:New.rowscn := a;
end;
/
-- expect wrong
create or replace trigger test_trigger_pseudo before insert on test_trigger for each row
is
a int := 100;
begin
:OLD.rowid := a;
:OLD.rowscn := a;
end;
/
-- expect wrong
create or replace trigger test_trigger_pseudo after insert on test_trigger for each row
is
a int := 100;
begin
:OLD.rowid := a;
:OLD.rowscn := a;
end;
/
-- expect wrong
create or replace trigger test_trigger_pseudo before delete on test_trigger for each row
is
a int := 100;
begin
:New.rowid := a;
:New.rowscn := a;
end;
/
-- expect wrong
create or replace trigger test_trigger_pseudo after delete on test_trigger for each row
is
a int := 100;
begin
:New.rowid := a;
:New.rowscn := a;
end;
/

create or replace function get_spacename_by_id(id int) return varchar2
is
spacename varchar2(64);
begin
select tablespace_name into spacename from adm_data_files where file_id = id;
return spacename;
end;
/

-- base ability
create or replace trigger test_trigger_pseudo before insert on test_trigger for each row
is
a int := 100;
begin
if :New.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
end if;
if :New.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end if;
end;
/
insert into test_trigger values(3,4);
create or replace trigger test_trigger_pseudo after insert on test_trigger for each row
is
a int := 100;
begin
if :New.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
end if;
if :New.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end if;
end;
/
insert into test_trigger values(5,6);
create or replace trigger test_trigger_pseudo before update on test_trigger for each row
is
a int := 100;
begin
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end;
/
update test_trigger set a = 10 where a = 5;
create or replace trigger test_trigger_pseudo before update on test_trigger for each row
is
a int := 100;
begin
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end;
/
update test_trigger set a = 11 where a = 10;
create or replace trigger test_trigger_pseudo before delete on test_trigger for each row
is
a int := 100;
begin
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
end;
/
delete test_trigger where a = 11;
create or replace trigger test_trigger_pseudo before delete on test_trigger for each row
is
a int := 100;
begin
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
end;
/
delete test_trigger where a = 1;
drop trigger test_trigger_pseudo;
delete from test_trigger;
-- combination test
create or replace trigger test_trigger_pseudo before update or insert or delete on test_trigger for each row
is
a int := 100;
begin
if :OLD.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
end if;
if :OLD.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
end if;
if :New.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
end if;
if :NEW.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end if;
end;
/
insert into test_trigger values(10,20);
update test_trigger set a = 11 where a = 10;
delete from test_trigger;
create or replace trigger test_trigger_pseudo after update or insert or delete on test_trigger for each row
is
a int := 100;
begin
if :OLD.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:OLD.rowid,4))));
end if;
if :OLD.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:OLD.rowscn)));
end if;
if :New.rowid is not null then
dbe_output.print_line(get_spacename_by_id(to_number(left(:New.rowid,4))));
end if;
if :NEW.rowscn is not null then
dbe_output.print_line(EXTRACT(year from now)-extract(year from scn2date(:New.rowscn)));
end if;
end;
/
insert into test_trigger values(10,20);
update test_trigger set a = 11 where a = 10;
delete from test_trigger;

create or replace procedure proc28
(
    bb1 in varchar,
    bb2 out varchar,
    bb3 in varchar
)
is
str varchar(80) := 'ab';
begin
    bb2 := (bb1 + bb3+1) /length(str) + MOD(bb3,2);
    dbe_output.print_line('bb2 is '||bb2);
end ;
/

drop table if exists fvt_trigger_table_028;
create table fvt_trigger_table_028(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_028 values(1,'1','a');
create or replace trigger fvt_trigger_028 before update on fvt_trigger_table_028
for each row 
declare
begin
	proc28(:new.rowid,:new.rowid,:new.rowid);
end;
/
create or replace procedure proc28
(
    bb1 in number,
    bb2 out number,
    bb3 in number
)
is
str varchar(80) := 'ab';
begin
    bb2 := (bb1 + bb3+1) /length(str) + MOD(bb3,2);
    dbe_output.print_line('bb2 is '||bb2);
end ;
/

drop table if exists fvt_trigger_table_028;
create table fvt_trigger_table_028(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_028 values(1,'1','a');
drop table if exists fvt_trigger_table_28;
create table fvt_trigger_table_28(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_28 values(1,'1','a');

drop table if exists fvt_trigger_table_0028;
create table fvt_trigger_table_0028(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_0028 values(1,'10000','b');
insert into fvt_trigger_table_0028 values(100,'100','b00');
create or replace trigger fvt_trigger_028 after insert or update or delete on fvt_trigger_table_28  
  for each row
begin 
    execute immediate 'call proc28(:col1, :col2, :col3)' using in :NEW.rowid, out :NEW.rowid, in :old.rowid;
    execute immediate 'call proc28(:col1, :col2, :col3)' using in :NEW.rowscn, out :NEW.rowscn, in :old.rowscn;
    execute immediate 'call proc28(:col1, :col2, :col3)' using in :NEW.rowid, out :old.rowid, in :old.rowid;
    execute immediate 'call proc28(:col1, :col2, :col3)' using in :NEW.rowscn, out :old.rowscn, in :old.rowscn;
    dbe_output.print_line( ':OLD.ROWid'|| :OLD.roWid);
     dbe_output.print_line( ':NEW.ROWid'||:New.rowid);
     dbe_output.print_line( ':OLD.ROWSCn'|| :OLD.roWSCn);
     dbe_output.print_line( ':NEW.ROWSCn'||:New.rowSCn);
    if INSERTING then 
        insert into fvt_trigger_table_028 values(:old.roWid,:old.c_varchar,:old.loc);
    elsif UPDATING then 
        insert into fvt_trigger_table_028 values(:old.roWSCn,:new.c_varchar,:old.loc);
    else
        insert into fvt_trigger_table_028 values(:new.roWSCn,:new.c_varchar,:new.loc);
    end if;
end;
/

drop table if exists test_part_t2;
drop table if exists test_subpart;
create table test_part_t2(f1 int, f2 real, f3 number)
PARTITION BY RANGE(f1)
(
 PARTITION par1 values less than(10),
 PARTITION par2 values less than(20),
 PARTITION par3 values less than(30),
 PARTITION par4 values less than(MAXVALUE)
);

create or replace trigger trigger_test_insert before insert on test_part_t2 for each row
is
a int := 100;
begin
:New.f1 := a;
end;
/

insert into test_part_t2 values(1,2,3);

create table test_subpart(id int, c_id int, name varchar(20)) partition by range(id) subpartition by range(c_id)
(
partition p1 values less than(50)
(
subpartition p11 values less than(50),
subpartition p12 values less than(100)
),
partition p2 values less than(100)
(
subpartition p21 values less than(50),
subpartition p22 values less than(100)
)
);

create or replace trigger trigger_test_insert2 before insert on test_subpart for each row
is
a int := 90;
begin
:New.id := a;
end;
/
insert into test_subpart values(1,2,'name');
drop table test_part_t2;
drop table test_subpart;

conn sys/Huawei@123@127.0.0.1:1611
drop user if exists gs_trigger_pseudo cascade;
drop tablespace myspc_liu_test INCLUDING CONTENTS and datafiles;
drop table if exists fvt_trigger_table_036;
create table fvt_trigger_table_036(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_036 values(1,'1','a');
drop table if exists fvt_trigger_table_36;
create table fvt_trigger_table_36(c_int number,c_varchar varchar(80),loc varchar(80));
drop table if exists fvt_trigger_table_0036;
create table fvt_trigger_table_0036(c_int number,c_varchar varchar(80),loc varchar(80));
insert into fvt_trigger_table_0036 values(1,'10000','b');
insert into fvt_trigger_table_0036 values(100,'100','b00');
create or replace trigger fvt_trigger_036 before insert or update or delete  on fvt_trigger_table_36
for each row 
declare
begin
if updating then 
		merge into fvt_trigger_table_036 a using fvt_trigger_table_0036 b1 on (a.c_int = b1.c_int) when matched then update set a.c_varchar = b1.c_varchar 
	 when not matched then insert (c_int,c_varchar,loc) values(b1.c_int,b1.c_varchar,b1.loc);
	end if;
end;
/
insert into fvt_trigger_table_36 values(1,'insert','1');
update fvt_trigger_table_36 set LOC = '7' where c_int = 1;
select * from fvt_trigger_table_36;
--not support trigger on column lob
drop table if exists TBL_TEST_08_02;
create table TBL_TEST_08_02(id int not null,name clob) ;
drop table if exists TBL_TEST_08_01;
create table TBL_TEST_08_01(id int not null,name varchar(100)) ;
create or replace trigger TRIG_TEST_08_01 after update of name on TBL_TEST_08_02 
declare
begin
 null;
end;
/

drop table if exists TBL_TEST_DEPENDENCY;
create table TBL_TEST_DEPENDENCY(id int,name varchar(20)) ;
drop table if exists TBL_TEST_DEPENDENCY;
create table TBL_TEST_DEPENDENCY(id int not null,name varchar(100)) ;
create or replace trigger TRIG_TEST_DEP after update of name on TBL_TEST_DEPENDENCY 
declare
begin
 null;
end;
/
select * from my_dependencies where NAME='TRIG_TEST_DEP';
alter table TBL_TEST_DEPENDENCY rename COLUMN id to id_new;
select STATUS from my_procedures where OBJECT_NAME='TRIG_TEST_DEP';
------------End test story: trigger pseydo column -----------

-- duplicate create test
drop table if exists dup_trig;
drop trigger if exists dup_trig_test;
create table dup_trig(f1 int, f2 int);
CREATE TRIGGER dup_trig_test BEFORE INSERT OR UPDATE OR DELETE ON dup_trig
BEGIN
	dbe_output.print_line('BEFORE t_enable_triggers');
END;
/
CREATE TRIGGER dup_trig_test BEFORE INSERT OR UPDATE OR DELETE ON dup_trig
BEGIN
	dbe_output.print_line('BEFORE t_enable_triggers');
END;
/
drop trigger dup_trig_test;
drop table dup_trig;

drop user if exists abcde_user cascade; 
drop user if exists test cascade;
create user abcde_user identified by Cantian_234;
create user test identified by Cantian_234;

create or replace function abcde_user.function_test(a in int)
return int as 
begin
    return 123;
end;
/

create or replace function abcde_user.function_invoke()
return int as 
begin
    return function_test(123);
end;
/
GRANT EXECUTE ON abcde_user.function_invoke TO test;

create table test.test_table(i int);
create table test.log_table(i int);
CREATE OR REPLACE TRIGGER test.test_trigger AFTER INSERT ON test_table
BEGIN
	insert into test.log_table select abcde_user.function_invoke();
END;
/

insert into test.test_table values(10);
drop table if exists myt;
create table myt(a int,b clob);
create or replace trigger mytrig before insert on myt for each row
is
begin
:new.a :=:new.a+1;
:new.b :=:new.b||'_liuhang';
end;
/

declare
sql1 clob;
begin
for i in 1..3000 loop
sql1 := sql1||'abcdeabcde';
end loop;
for i in 1..100 loop
insert into myt values(i, sql1);
end loop;
end;
/

create or replace trigger mytrig before update on myt for each row
is
begin
:new.a :=:new.a+1;
:new.b :=:new.b||'_liuhang';
end;
/
update myt set a=a+1 , b=b||'a' where a<50;
select len, count(*) from (select lengthb(b) as len from myt) t group by t.len order by 1,2;

drop table if exists myt;
drop user abcde_user cascade;
drop user test cascade;

drop table if exists test_t6;
create table test_t6 (f1 int);
CREATE OR REPLACE TRIGGER test_trig6
AFTER UPDATE OF F1 ON test_t6
BEGIN
  NULL;
END;
/

ALTER TABLE test_t6 rename column f1 to f2;
update test_t6 set f2 = 2;

drop table if exists test_t6;
create table test_t6 (f1 int, f2 int);
CREATE OR REPLACE TRIGGER test_trig6
AFTER UPDATE OF F1 ON test_t6
BEGIN
  NULL;
END;
/

ALTER TABLE test_t6 rename column f1 to f3;
update test_t6 set f2 = 2;

set serveroutput off

--DTS202106300FCG82P0H00 START
DROP TABLE IF EXISTS DTS202106300FCG82P0H00_T1;
DROP TABLE IF EXISTS DTS202106300FCG82P0H00_T2;
CREATE TABLE DTS202106300FCG82P0H00_T1(C1 INT);
CREATE TABLE DTS202106300FCG82P0H00_T2(C1 INT);
INSERT INTO DTS202106300FCG82P0H00_T1 VALUES(1);
INSERT INTO DTS202106300FCG82P0H00_T2 VALUES(1);

CREATE OR REPLACE TRIGGER DTS202106300FCG82P0H00_TRIG AFTER INSERT ON DTS202106300FCG82P0H00_T1 FOR EACH ROW
BEGIN
  INSERT INTO DTS202106300FCG82P0H00_T2 VALUES(1);
END;
/

INSERT INTO DTS202106300FCG82P0H00_T1 VALUES(1);
INSERT INTO DTS202106300FCG82P0H00_T1 SELECT * FROM DTS202106300FCG82P0H00_T1 UNION ALL SELECT * FROM DTS202106300FCG82P0H00_T2;
DROP TABLE IF EXISTS DTS202106300FCG82P0H00_T1;
DROP TABLE IF EXISTS DTS202106300FCG82P0H00_T2;
--DTS202106300FCG82P0H00 END
