

SQL> --basic test
SQL> drop table if exists func_t1;

Succeed.

SQL> create table func_t1 (i clob unique);

CT-00633, Cannot create normal index on column with datatype 'CLOB'
SQL> create table func_t1 (i blob unique);

CT-00633, Cannot create normal index on column with datatype 'BLOB'
SQL> create table func_t1 (i image unique);

CT-00633, Cannot create normal index on column with datatype 'IMAGE'
SQL> create table func_t1 (i varchar(2), id varchar(2));

Succeed.

SQL> insert into func_t1 values ('a', 'c'); 

1 rows affected.

SQL> insert into func_t1 values (NULL, NULL);

1 rows affected.

SQL> create index idx_func_1 on func_t1 (upper(i));

Succeed.

SQL> create index idx_func_2 on func_t1 (upper(i),upper(id)) online;

Succeed.

SQL> create index idx_func_3 on func_t1 (upper(i), upper(id));  -- error

CT-00726, The column has been indexed by IDX_FUNC_2.
SQL> create index idx_func_3 on func_t1 (upper(i), i);

Succeed.

SQL> insert into func_t1 values ('', '');

1 rows affected.

SQL> commit;

Succeed.

SQL> alter index idx_func_1 on func_t1 rebuild; 

Succeed.

SQL> alter index idx_func_2 on func_t1 rebuild online;

Succeed.

SQL> select * from func_t1 where upper(id) = 'C';

I  ID
-- --
a  c 

1 rows fetched.

SQL> select * from func_t1 order by i;

I  ID
-- --
a  c 
     
     

3 rows fetched.

SQL> 
SQL> --DML
SQL> insert into func_t1 values ('a', 'c'); 

1 rows affected.

SQL> update func_t1 set id = 'F' where upper(id) = 'C';

2 rows affected.

SQL> delete from func_t1 where upper(id) = 'F';

2 rows affected.

SQL> insert into func_t1 values ('a', 'c'); 

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from func_t1 where upper(id) = 'C';

I  ID
-- --
a  c 

1 rows fetched.

SQL> select * from func_t1 order by i;

I  ID
-- --
a  c 
     
     

3 rows fetched.

SQL> 
SQL> --muti table delete/update
SQL> drop table if exists func_t2;

Succeed.

SQL> create table func_t2 (i varchar(2), id varchar(2));

Succeed.

SQL> create index idx_func2_1 on func_t2 (upper(i));

Succeed.

SQL> insert into func_t2 values ('a', 'c'); 

1 rows affected.

SQL> update func_t2, func_t1 set func_t1.i = 'F', func_t2.i = 'F';

4 rows affected.

SQL> select * from func_t1 where upper(id) = 'C';

I  ID
-- --
F  c 

1 rows fetched.

SQL> select * from func_t1 order by id;

I  ID
-- --
F  c 
F    
F    

3 rows fetched.

SQL> --column with func index test
SQL> delete from func_t1; commit;

3 rows affected.


Succeed.

SQL> alter table func_t1 modify i varchar(4);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table func_t1 modify i clob;

CT-00633, Cannot create normal index on column with datatype 'CLOB'
SQL> alter table func_t1 drop column i;

Succeed.

SQL> alter table func_t1 add column i varchar(3);

Succeed.

SQL> create index idx_t1_func on func_t1 (upper(i));

Succeed.

SQL> alter table func_t1 rename column i to i55; -- error

CT-00863, Cannot rename function index column I
SQL> drop table if exists func_t2;

Succeed.

SQL> drop table if exists func_t1;

Succeed.

SQL> --constraint test(not supported)
SQL> drop table if exists t4;

Succeed.

SQL> create table t4 (id1 varchar(2), id2 varchar(2));

Succeed.

SQL> alter table t4 add constraint pk_1 primary key(id1) using index (create index idx_pk on t4(upper(id1)));

CT-00864, The index cannot be converted to a constraint.
SQL> alter table t4 add constraint pk_1 primary key(upper(id1));

CT-00601, Sql syntax error: invalid identifier
SQL> alter table t4 add constraint pk_1 unique(upper(id1));

CT-00601, Sql syntax error: invalid identifier
SQL> insert into t4 values ('a', 'c'); 

1 rows affected.

SQL> insert into t4 values (NULL, NULL);

1 rows affected.

SQL> commit;

Succeed.

SQL> create unique index idx_t4_1 on t4(upper(id2), upper(id1));

Succeed.

SQL> alter table t4 add constraint pk_func_1 unique(id2);

Succeed.

SQL> insert into t4 values ('a', 'c'); 

CT-00729, Unique constraint violated, index IDX_T4_1, duplicate key C-A
SQL> drop table if exists t4;

Succeed.

SQL> 
SQL> --partition table and local index
SQL> drop table if exists pt1;

Succeed.

SQL> create table pt1(i varchar(100), id int) partition by range (id)
  2 (
  3  PARTITION p1 values less than(10),
  4  PARTITION p2 values less than(20),
  5  PARTITION p3 values less than(30),
  6  PARTITION p4 values less than(MAXVALUE)
  7 );

Succeed.

SQL> insert into pt1 values ('a', 1);

1 rows affected.

SQL> insert into pt1 values ('asss', 15);

1 rows affected.

SQL> insert into pt1 values ('', 25);

1 rows affected.

SQL> insert into pt1 values (NULL, 35);

1 rows affected.

SQL> create index idx_loc_1 on pt1 (upper(i)) local;

Succeed.

SQL> delete from pt1;

4 rows affected.

SQL> alter table pt1 modify i varchar(4);

CT-00130, Operation modify column is not supported on functional index
SQL> 
SQL>  --temp table
SQL>  alter system set LOCAL_TEMPORARY_TABLE_ENABLED = TRUE;

Succeed.

SQL>  create temporary table #func_t1 (i varchar(2), id varchar(2));

Succeed.

SQL>  create index idx_t1 on #func_t1(upper(i)); -- error

CT-00130, Operation create function index is not supported on local temp table
SQL>  drop table #func_t1;

Succeed.

SQL>  alter system set LOCAL_TEMPORARY_TABLE_ENABLED = FALSE;

Succeed.

SQL> 
SQL>  drop table if exists temp_func_1;

Succeed.

SQL>  create global temporary table temp_func_1 (id1 varchar(2) not null, id2 varchar(2)) on commit preserve rows;

Succeed.

SQL>  insert into temp_func_1 values ('a', 'a');commit;

1 rows affected.


Succeed.

SQL>  insert into temp_func_1 values ('', 'a');

CT-00620, Can't set NULL value for column 'ID1'
SQL>  insert into temp_func_1 values (NULL, 'a'); 

CT-00620, Can't set NULL value for column 'ID1'
SQL>  create index idx_temp_1 on temp_func_1(upper(id2));

Succeed.

SQL>   insert into temp_func_1 values ('', 'a');

CT-00620, Can't set NULL value for column 'ID1'
SQL>   update temp_func_1 set id1 = NULL where upper(id2) = 'A';

CT-00620, Can't set NULL value for column 'ID1'
SQL>   update temp_func_1 set id1 = 'D' where upper(id2) = 'A';

1 rows affected.

SQL>     update temp_func_1 set id2 = NULL where upper(id2) = 'A';

1 rows affected.

SQL>   update temp_func_1 set id1 = 'D' where upper(id2) = NULL;

0 rows affected.

SQL>   delete from temp_func_1;

1 rows affected.

SQL>   drop table temp_func_1;

Succeed.

SQL> 
SQL> -- complicate func index and normal index test
SQL> drop table if exists t3;

Succeed.

SQL> create table t3 (id1 varchar(2), id2 varchar(2),  id3 varchar(20), id4 varchar(20), id5 varchar(40));

Succeed.

SQL> create index idx_t3_1 on t3 (upper(id5), id3, upper(id1));

Succeed.

SQL> create index idx_t3_2 on t3 (upper(id3), upper(id2) desc);

Succeed.

SQL> insert into t3 values ('a', 'a', 'a', 'a', 'a');

1 rows affected.

SQL> insert into t3 values ('', 'a', 'a', 'a', 'a');

1 rows affected.

SQL> drop table if exists t3;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_INDEX_5;

Succeed.

SQL> CREATE TABLE T_INDEX_5
  2 (
  3 	F_INT51 INT,
  4 	F_INT52 INT,
  5 	F_CHAR51 CHAR(20)
  6 );

Succeed.

SQL> 
SQL> INSERT INTO T_INDEX_5 VALUES(1,2,'abc');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(2,3,'dec');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(3,4,'hij');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(4,5,'qwe');

1 rows affected.

SQL> INSERT INTO T_INDEX_5 VALUES(null,6,'asd');

1 rows affected.

SQL> 
SQL> CREATE INDEX INDEX_INT_T_INDEX_5 ON T_INDEX_5(F_INT51) ONLINE;

Succeed.

SQL> CREATE INDEX INDEX_CHAR_INDEX_5 ON T_INDEX_5(upper(F_CHAR51)) ONLINE;

Succeed.

SQL> SELECT * FROM T_INDEX_5 WHERE upper(F_CHAR51) = 'ABC' or F_CHAR51 = 'qwe'; 

F_INT51      F_INT52      F_CHAR51            
------------ ------------ --------------------
1            2            abc                 
4            5            qwe                 

2 rows fetched.

SQL> ALTER INDEX INDEX_INT_T_INDEX_5 ON T_INDEX_5 REBUILD;

Succeed.

SQL> ALTER INDEX INDEX_CHAR_INDEX_5 ON T_INDEX_5 REBUILD ONLINE;

Succeed.

SQL> DROP TABLE IF EXISTS T_INDEX_5;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_1;

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_1
  2 (
  3 	F_INT1 INT,
  4 	F_INT2 INT,
  5 	F_CHAR1 CHAR(20)
  6 );

Succeed.

SQL> 
SQL> CREATE INDEX FUNC_INDEX_INT_T_INDEX_1 ON T_FUNC_INDEX_1(TO_CHAR(F_INT1));

Succeed.

SQL> CREATE INDEX FUNC_INDEX_CHAR_INDEX_1 ON T_FUNC_INDEX_1(UPPER(F_CHAR1));

Succeed.

SQL> 
SQL> INSERT INTO T_FUNC_INDEX_1 VALUES(1,2,'0001Z01000ACCOUNT028');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_1 VALUES(2,3,'0001Z01000ACCOUNT073');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_1 VALUES(3,4,'10111110000000001ZX5');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_1 VALUES(4,5,'101511100000000006NZ');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_1 VALUES(null,6,'101511100000000006NX');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 = '0001Z01000ACCOUNT028' or F_CHAR1 = '0001Z01000ACCOUNT073';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028
2            3            0001Z01000ACCOUNT073

2 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 = '10111110000000001ZX5' or F_CHAR1 = '101511100000000006NZ';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
3            4            10111110000000001ZX5
4            5            101511100000000006NZ

2 rows fetched.

SQL> 
SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_INT1 = 3 AND EXISTS (SELECT 1 FROM DUAL);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
3            4            10111110000000001ZX5

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_INT1 = 1 AND NOT EXISTS (SELECT 1 FROM DUAL);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------

0 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_INT1 = 1 AND NOT EXISTS (SELECT 1 FROM DUAL WHERE 1 = 0);

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028

1 rows fetched.

SQL> 
SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_INT1 IS NULL AND F_INT1 IS NULL;

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
             6            101511100000000006NX

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE TO_CHAR(F_INT1) = '1';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE TO_CHAR(F_INT1) IN ('1','2','3');

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028
2            3            0001Z01000ACCOUNT073
3            4            10111110000000001ZX5

3 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE F_INT1 < 2;

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_1 WHERE UPPER(F_CHAR1) = '0001Z01000ACCOUNT028';

F_INT1       F_INT2       F_CHAR1             
------------ ------------ --------------------
1            2            0001Z01000ACCOUNT028

1 rows fetched.

SQL> --DTS2020021208980
SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 = '0001Z01000ACCOUNT028';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_FUNC_INDEX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_CHAR1 = '0001Z01000ACCOUNT028'                 

9 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 IN('0001Z01000ACCOUNT028','10111110000000001ZX5');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_FUNC_INDEX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_CHAR1 IN('0001Z01000ACCOUNT028', '10111110000000001ZX5')

9 rows fetched.

SQL> --cannot use index
SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 > '0001Z01000ACCOUNT028';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_FUNC_INDEX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_CHAR1 > '0001Z01000ACCOUNT028'                 

9 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE F_CHAR1 IS NULL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_FUNC_INDEX_1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F_CHAR1 IS NULL                                  

9 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE UPPER(F_CHAR1) = '0001Z01000ACCOUNT028';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUNC_INDEX_1          |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX_CHAR_INDEX_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(F_CHAR1) = '0001Z01000ACCOUNT028'          

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE UPPER(F_CHAR1) > '0001Z01000ACCOUNT028';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUNC_INDEX_1          |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX_CHAR_INDEX_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(F_CHAR1) > '0001Z01000ACCOUNT028'          

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE UPPER(F_CHAR1) IN ('0001Z01000ACCOUNT028');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUNC_INDEX_1          |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX_CHAR_INDEX_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(F_CHAR1) = '0001Z01000ACCOUNT028'          

10 rows fetched.

SQL> EXPLAIN SELECT * FROM T_FUNC_INDEX_1 WHERE UPPER(F_CHAR1) IS NULL;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUNC_INDEX_1          |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX_CHAR_INDEX_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(F_CHAR1) IS NULL                           

10 rows fetched.

SQL> 
SQL> CREATE USER NEBULA2 IDENTIFIED BY Cantian_234;

Succeed.

SQL> DROP TABLE IF EXISTS NEBULA2.STORAGE_LIST_TBL_001;

Succeed.

SQL> CREATE TABLE NEBULA2.STORAGE_LIST_TBL_001(C_ID INT,C_D_ID INT NOT NULL,C_W_ID INT NOT NULL,C_FIRST VARCHAR(64) NOT NULL,C_MIDDLE CHAR(2),C_LAST VARCHAR(64) NOT NULL,C_STREET_1 VARCHAR(20) NOT NULL,C_STREET_2 VARCHAR(20),C_CITY VARCHAR(64) NOT NULL,C_STATE CHAR(2) NOT NULL,C_ZIP CHAR(9) NOT NULL,C_PHONE CHAR(16) NOT NULL,C_SINCE TIMESTAMP,C_CREDIT CHAR(2) NOT NULL,C_CREDIT_LIM NUMERIC(12,2),C_DISCOUNT NUMERIC(4,4),C_BALANCE NUMERIC(12,2),C_YTD_PAYMENT REAL NOT NULL,C_PAYMENT_CNT NUMBER NOT NULL,C_DELIVERY_CNT BOOLEAN NOT NULL,C_END DATE NOT NULL,C_VCHAR VARCHAR(1000),C_DATA varchar(2000),C_TEXT varchar(2000)) PARTITION BY LIST(C_D_ID,C_FIRST,C_LAST,C_CITY) (PARTITION PART_1 VALUES ((1,'A','A','A'),(10,'AA','AA','AA'),(10,'AAAA','AAAA','AAAA'),(10,'aaaa','aaaa','aaaa'),(100,'AAAA','AAAA','AAAA'),(1,'a','a','a'),(10,'aa','aa','aa'),(100,'aaaa','aaaa','aaaa')),PARTITION PART_2 VALUES ((2,'B','B','B'),(20,'BB','BB','BB'),(20,'BBBB','BBBB','BBBB'),(20,'bbbb','bbbb','bbbb'),(200,'BBBB','BBBB','BBBB'),(2,'b','b','b'),(20,'bb','bb','bb'),(200,'bbbb','bbbb','bbbb')),PARTITION PART_3 VALUES ((3,'C','C','C'),(30,'CC','CC','CC'),(30,'CCCC','CCCC','CCCC'),(30,'cccc','cccc','cccc'),(300,'CCCC','CCCC','CCCC'),(3,'c','c','c'),(30,'cc','cc','cc'),(300,'cccc','cccc','cccc')),PARTITION PART_4 VALUES ((4,'D','D','D'),(40,'DD','DD','DD'),(40,'DDDD','DDDD','DDDD'),(40,'dddd','dddd','dddd'),(400,'DDDD','DDDD','DDDD'),(4,'d','d','d'),(40,'dd','dd','dd'),(400,'dddd','dddd','dddd')),PARTITION PART_5 VALUES ((5,'E','E','E'),(50,'EE','EE','EE'),(50,'EEEE','EEEE','EEEE'),(50,'eeee','eeee','eeee'),(500,'EEEE','EEEE','EEEE'),(5,'e','e','e'),(50,'ee','ee','ee'),(500,'eeee','eeee','eeee')),PARTITION PART_6 VALUES ((6,'F','F','F'),(60,'FF','FF','FF'),(60,'FFFF','FFFF','FFFF'),(60,'ffff','ffff','ffff'),(600,'FFFF','FFFF','FFFF'),(6,'f','f','f'),(60,'ff','ff','ff'),(600,'ffff','ffff','ffff')),PARTITION PART_7 VALUES ((7,'G','G','G'),(70,'GG','GG','GG'),(70,'GGGG','GGGG','GGGG'),(70,'gggg','gggg','gggg'),(700,'GGGG','GGGG','GGGG'),(7,'g','g','g'),(70,'gg','gg','gg'),(700,'gggg','gggg','gggg')),PARTITION PART_8 VALUES ((8,'H','H','H'),(80,'HH','HH','HH'),(80,'HHHH','HHHH','HHHH'),(80,'hhhh','hhhh','hhhh'),(800,'HHHH','HHHH','HHHH'),(8,'h','h','h'),(80,'hh','hh','hh'),(800,'hhhh','hhhh','hhhh')),PARTITION PART_9 VALUES ((9,'I','I','I'),(90,'II','II','II'),(90,'IIII','IIII','IIII'),(90,'iiii','iiii','iiii'),(900,'IIII','IIII','IIII'),(9,'i','i','i'),(90,'ii','ii','ii'),(900,'iiii','iiii','iiii')),PARTITION PART_10 VALUES (DEFAULT));

Succeed.

SQL> CREATE UNIQUE INDEX  NEBULA2.STORAGE_LIST_INDEX_001_1 ON NEBULA2.STORAGE_LIST_TBL_001(C_D_ID,C_FIRST,C_LAST,C_CITY,TO_CHAR(C_ID))  LOCAL ;

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA2.STORAGE_LIST_INDEX_001_2 ON NEBULA2.STORAGE_LIST_TBL_001(TO_CHAR(C_ID),C_CITY,C_LAST,C_STREET_2)  ;

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA2.STORAGE_LIST_INDEX_001_3 ON NEBULA2.STORAGE_LIST_TBL_001(C_STREET_2,TO_CHAR(C_ID))  ;

Succeed.

SQL> CREATE INDEX NEBULA2.STORAGE_LIST_INDEX_001_4 ON NEBULA2.STORAGE_LIST_TBL_001(TO_CHAR(C_ID),C_CITY,C_FIRST)  LOCAL ;

Succeed.

SQL> CREATE INDEX NEBULA2.STORAGE_LIST_INDEX_001_5 ON NEBULA2.STORAGE_LIST_TBL_001(TO_CHAR(C_STREET_1),C_W_ID)   ;

Succeed.

SQL> INSERT INTO NEBULA2.STORAGE_LIST_TBL_001 VALUES(1,90,1,'II'||'9'||'Cabdg','OE','II'||'9'||'Bdbed','bki'||'9'||'fdger','pwo'||'9'||'vedef','II'||'9'||'Yed3f','uq',4801||'9',940||'9',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANdfdffdfRB'||'9','QVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSFQVLDETANRBRBUflnfufscHOQNGGSMjjjjgfvmgfvdfcmkgvNPFZCSYKXXYSCDSF'||'9','1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542329');

1 rows affected.

SQL> SELECT TO_CHAR(C_ID),C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA2.STORAGE_LIST_TBL_001 where TO_CHAR(C_ID)<1500 and C_D_ID<1500 and (C_FIRST like 'I%' ) and  (C_LAST like 'I%' )and  (C_CITY like 'I%' );

TO_CHAR(C_ID) C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1             90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT TO_CHAR(C_ID),C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA2.STORAGE_LIST_TBL_001 where TO_CHAR(C_ID)<1500 and C_D_ID<1500 ;

TO_CHAR(C_ID) C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1             90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT TO_CHAR(C_ID),C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA2.STORAGE_LIST_TBL_001 where  (C_FIRST like 'I%' ) and  (C_LAST like 'I%' )and  (C_CITY like 'I%' );

TO_CHAR(C_ID) C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1             90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> SELECT TO_CHAR(C_ID),C_D_ID,C_FIRST,C_LAST,C_CITY  FROM NEBULA2.STORAGE_LIST_TBL_001 ;

TO_CHAR(C_ID) C_D_ID       C_FIRST                                                          C_LAST                                                           C_CITY                                                          
------------- ------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
1             90           II9Cabdg                                                         II9Bdbed                                                         II9Yed3f                                                        

1 rows fetched.

SQL> DROP TABLE IF EXISTS NEBULA2.STORAGE_LIST_TBL_001;

Succeed.

SQL> DROP TABLE IF EXISTS NEBULA2.STRG_PARTRANGE_TBL_001;

Succeed.

SQL> CREATE TABLE NEBULA2.STRG_PARTRANGE_TBL_001(c_id int,c_d_id int not null,c_w_id int not null,c_first varchar(32) not null,c_middle char(2),c_last varchar(32) not null,c_street_1 varchar(20) not null,c_street_2 varchar(20),c_city varchar(20) not null,c_state char(2) not null,c_zip char(9) not null,c_phone char(16) not null,c_since timestamp,c_credit char(2) not null,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real not null,c_payment_cnt number not null,c_delivery_cnt bool not null,c_end date not null,c_vchar varchar(1000),c_data varchar(2000),c_text varchar(2000)) partition by range(c_id) (partition part_1 values less than (201),partition part_2 values less than (401),partition part_3 values less than (601),partition part_4 values less than (801),partition part_5 values less than (1001),partition part_6 values less than (1201),partition part_7 values less than (1401),partition part_8 values less than (1601),partition part_9 values less than (1801),partition part_10 values less than (2001),partition part_11 values less than (maxvalue));

Succeed.

SQL> CREATE UNIQUE INDEX NEBULA2.STRG_RANGE_INDEX_001_1 ON NEBULA2.STRG_PARTRANGE_TBL_001(TO_CHAR(C_ID)) LOCAL;

CT-00816, Table partition key should be subsets of local primary or unique index
SQL> CREATE UNIQUE INDEX NEBULA2.STRG_RANGE_INDEX_001_2 ON NEBULA2.STRG_PARTRANGE_TBL_001(TO_CHAR(C_W_ID));

Succeed.

SQL> CREATE INDEX NEBULA2.STRG_RANGE_INDEX_001_3 ON NEBULA2.STRG_PARTRANGE_TBL_001(UPPER(C_FIRST)) LOCAL;

Succeed.

SQL> INSERT INTO  NEBULA2.STRG_PARTRANGE_TBL_001 SELECT 1,1,1,'AA'||'is1cmvls','OE','AA'||'BAR1BARBAR','bkili'||'1'||'fcxcle'||'1','pmbwo'||'1'||'vhvpaj'||'1','dyf'||'1'||'rya'||'1','uq',4801||'1',940||'1'||215||'1',to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'GC',50000.0,0.4361328,-10.0,10.0,1,true,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss'),'QVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECC348493214893542NPFZCSYKXXYSCDSF'||'1','QVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSFQVLDETANRBRBURBMZQUJSHOQNGGSMNTECCIPRIIRDHIRWIYNPFZCSYKXXYSCDSF'||'1','\x1234354587643123455213445656723123424554566776763221132454566768767433242323445453565654542323';

1 rows affected.

SQL> SELECT COUNT(*) FROM  NEBULA2.STRG_PARTRANGE_TBL_001;

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> SELECT COUNT(*) FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE UPPER(C_FIRST) LIKE 'AA%';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> SELECT c_first FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE UPPER(C_FIRST) < 'BB';

C_FIRST                         
--------------------------------
AAis1cmvls                      

1 rows fetched.

SQL> SELECT * FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE C_ID like 1234;

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE C_ID like '1234';

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE UPPER(C_FIRST) like 1234;

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT * FROM NEBULA2.STRG_PARTRANGE_TBL_001 WHERE UPPER(C_FIRST) like '1234' OR C_ID like '1234';

C_ID         C_D_ID       C_W_ID       C_FIRST                          C_MIDDLE C_LAST                           C_STREET_1           C_STREET_2           C_CITY               C_STATE C_ZIP     C_PHONE          C_SINCE                          C_CREDIT C_CREDIT_LIM                             C_DISCOUNT                               C_BALANCE                                C_YTD_PAYMENT        C_PAYMENT_CNT                            C_DELIVERY_CNT C_END                  C_VCHAR                                                          C_DATA                                                           C_TEXT                                                          
------------ ------------ ------------ -------------------------------- -------- -------------------------------- -------------------- -------------------- -------------------- ------- --------- ---------------- -------------------------------- -------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------- ---------------------------------------- -------------- ---------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS NEBULA2.STRG_PARTRANGE_TBL_001;

Succeed.

SQL> DROP USER NEBULA2 CASCADE;

Succeed.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_2;

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_2(F1 REAL, F2 DATE, F3 TIMESTAMP, F4 NUMBER(6), F5 DECIMAL(20,5), F6 RAW(6), F7 VARBINARY(6));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_1 ON T_FUNC_INDEX_2(TO_CHAR(F1, 'FM999.99999'));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_2 ON T_FUNC_INDEX_2(TO_CHAR(F2, 'YYYY-MM-DD'));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_3 ON T_FUNC_INDEX_2(TO_CHAR(F3, 'YYYY-MM-DD HH24:MI:SS'));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_4 ON T_FUNC_INDEX_2(TO_CHAR(F4));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_5 ON T_FUNC_INDEX_2(TO_CHAR(F5, 'FM999999999.99990'));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_6 ON T_FUNC_INDEX_2(TO_CHAR(F6));

Succeed.

SQL> CREATE INDEX IDX_T_FUNC_INDEX_2_7 ON T_FUNC_INDEX_2(TO_CHAR(F7));

Succeed.

SQL> 
SQL> INSERT INTO T_FUNC_INDEX_2 VALUES(12.5, '2018-02-13', '2018-02-13 09:30:00', 1, 123456, '1111', '11111');

1 rows affected.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F1=12.5;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F2='2018-02-13';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F3='2018-02-13 09:30:00';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F4=1;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F5=123456;

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F6='1111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE F7='11111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F1,'FM999.99999')='12.5';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F2,'YYYY-MM-DD')='2018-02-13';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F3,'YYYY-MM-DD HH24:MI:SS')='2018-02-13 09:30:00';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F4)='1';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F5,'FM999999999.99990')='123456.00000';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F6)='1111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_2 WHERE to_char(F7)='11111';

F1                   F2                     F3                               F4                                       F5                                       F6                                                               F7                                                              
-------------------- ---------------------- -------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
12.5                 2018-02-13 00:00:00    2018-02-13 09:30:00.000000       1                                        123456                                   1111                                                             11111                                                           

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_3;

Succeed.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_4;

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_3(CAR_ID NUMBER(6),CAR_CUST NUMBER(3),ADDR_3 NUMBER(5),CAR_CODE VARCHAR2(32),CAR_STATUS CHAR(1),CAR_REGION NUMBER(6),CAR_DOUBLE NUMBER(6,4),PRIMARY KEY(CAR_ID)); 

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_4(PHONE_ID NUMBER(6),CUST NUMBER(3),ADDR_2 NUMBER(5),PHONE_CODE VARCHAR2(32),PHONE_STATUS CHAR(1),PHONE_REGION NUMBER(10),PHONE_DOUBLE NUMBER(20,4),PRIMARY KEY (PHONE_ID));

Succeed.

SQL> INSERT INTO T_FUNC_INDEX_3(CAR_ID,CAR_CODE) VALUES(1000,'XYZ');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_4(PHONE_ID, PHONE_CODE) VALUES(1000,'ASD');

1 rows affected.

SQL> 
SQL> SELECT CAR_CODE FROM T_FUNC_INDEX_3 WHERE CAR_ID IN(SELECT PHONE_ID FROM T_FUNC_INDEX_4 WHERE PHONE_CODE = 'ASD');

CAR_CODE                        
--------------------------------
XYZ                             

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_3,T_FUNC_INDEX_4;

CAR_ID                                   CAR_CUST                                 ADDR_3                                   CAR_CODE                         CAR_STATUS CAR_REGION                               CAR_DOUBLE                               PHONE_ID                                 CUST                                     ADDR_2                                   PHONE_CODE                       PHONE_STATUS PHONE_REGION                             PHONE_DOUBLE                            
---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------------------- ---------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- ---------------------------------------- -------------------------------- ------------ ---------------------------------------- ----------------------------------------
1000                                                                                                                       XYZ                                                                                                                           1000                                                                                                                       ASD                                                                                                                            

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS FBI_PURCHASES;

Succeed.

SQL> CREATE TABLE FBI_PURCHASES (
  2 	CUSTOMER_ID INTEGER  NOT NULL,
  3 	PRODUCT_ID INTEGER  NOT NULL,
  4 	QUANTITY INTEGER ,
  5 	TEST VARCHAR2(10) ,
  6 	PHONE VARCHAR2(12) NOT NULL,
  7 	CONSTRAINT PURCHASES_PK PRIMARY KEY(PRODUCT_ID, CUSTOMER_ID)
  8 );

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS FBI_CUSTOMERS;

Succeed.

SQL> CREATE TABLE FBI_CUSTOMERS (
  2 	CUSTOMER_ID INTEGER ,
  3 	FIRST_NAME VARCHAR2(10) NOT NULL,
  4 	LAST_NAME VARCHAR2(10) NOT NULL,
  5 	BIRTH DATE NOT NULL,
  6 	PHONE VARCHAR2(12),
  7 	TEST VARCHAR2(10),
  8 	CONSTRAINT CUSTOMERS_PK PRIMARY KEY (CUSTOMER_ID)
  9 );

Succeed.

SQL> 
SQL> INSERT INTO FBI_CUSTOMERS (CUSTOMER_ID,FIRST_NAME,LAST_NAME,BIRTH,PHONE,TEST) VALUES(1,'JOHN','BROWN','1890-01-01 00:00:00','800-555-1211','123');

1 rows affected.

SQL> INSERT INTO FBI_PURCHASES (CUSTOMER_ID,PRODUCT_ID,QUANTITY,TEST,PHONE) VALUES (1,1,1,'TEST1','13776144901');

1 rows affected.

SQL> SELECT PRODUCT_ID,QUANTITY,TEST,PHONE FROM FBI_PURCHASES P WHERE P.CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM FBI_CUSTOMERS WHERE FIRST_NAME LIKE 'JOHN' AND BIRTH < '2014-10-10');

PRODUCT_ID   QUANTITY     TEST       PHONE       
------------ ------------ ---------- ------------
1            1            TEST1      13776144901 

1 rows fetched.

SQL> 
SQL> DROP TABLE IF EXISTS FBI_TEST_MULTI_KEY;

Succeed.

SQL> CREATE TABLE FBI_TEST_MULTI_KEY(F1 INT, F2 INT);

Succeed.

SQL> CREATE INDEX IDX_TEST_MULTI_KEY_1 ON FBI_TEST_MULTI_KEY(TO_CHAR(F1));

Succeed.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(1,1);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(2,2);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(3,3);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(4,4);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(5,5);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(6,6);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(7,7);

1 rows affected.

SQL> INSERT INTO FBI_TEST_MULTI_KEY VALUES(8,8);

1 rows affected.

SQL> SELECT * FROM FBI_TEST_MULTI_KEY WHERE (F1 >=1 AND F1 <4) OR (F1 >=5 AND F1 <8) ORDER BY F1;

F1           F2          
------------ ------------
1            1           
2            2           
3            3           
5            5           
6            6           
7            7           

6 rows fetched.

SQL> SELECT * FROM FBI_TEST_MULTI_KEY WHERE (F1 >=1 AND F1 <4) OR (F1 >=5 AND F1 <8) ORDER BY F1 DESC;  

F1           F2          
------------ ------------
7            7           
6            6           
5            5           
3            3           
2            2           
1            1           

6 rows fetched.

SQL> DROP TABLE IF EXISTS FBI_TEST_MULTI_KEY;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_3;

Succeed.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_4;

Succeed.

SQL> DROP TABLE IF EXISTS FBI_PURCHASES;

Succeed.

SQL> DROP TABLE IF EXISTS FBI_CUSTOMERS;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_5;

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_5
  2 (
  3 	F_INT51 INT,
  4 	F_INT52 INT,
  5 	F_CHAR51 CHAR(20)
  6 );

Succeed.

SQL> 
SQL> INSERT INTO T_FUNC_INDEX_5 VALUES(1,2,'abc');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_5 VALUES(2,3,'dec');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_5 VALUES(3,4,'hij');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_5 VALUES(4,5,'qwe');

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_5 VALUES(null,6,'asd');

1 rows affected.

SQL> 
SQL> CREATE INDEX FUNC_INDEX_INT_T_INDEX_5 ON T_FUNC_INDEX_5(TO_CHAR(F_INT51)) ONLINE;

Succeed.

SQL> CREATE INDEX FUNC_INDEX_CHAR_INDEX_5 ON T_FUNC_INDEX_5(UPPER(F_CHAR51) )ONLINE;

Succeed.

SQL> SELECT * FROM T_FUNC_INDEX_5 WHERE F_CHAR51 = 'abc' or TO_CHAR(F_CHAR51)= 'QWE';

F_INT51      F_INT52      F_CHAR51            
------------ ------------ --------------------
1            2            abc                 

1 rows fetched.

SQL> 
SQL> ALTER INDEX FUNC_INDEX_INT_T_INDEX_5 ON T_FUNC_INDEX_5 REBUILD;

Succeed.

SQL> ALTER INDEX FUNC_INDEX_CHAR_INDEX_5 ON T_FUNC_INDEX_5 REBUILD ONLINE;

Succeed.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_5;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_55;

Succeed.

SQL> CREATE TABLE T_FUNC_INDEX_55(A INT, B BOOLEAN);

Succeed.

SQL> CREATE INDEX FUNC_IDX_T_INDEX_55_1 ON T_FUNC_INDEX_55(TO_CHAR(B));

Succeed.

SQL> INSERT INTO T_FUNC_INDEX_55 VALUES(1,0);

1 rows affected.

SQL> INSERT INTO T_FUNC_INDEX_55 VALUES(2,1);

1 rows affected.

SQL> SELECT * FROM T_FUNC_INDEX_55 WHERE TO_CHAR(B)='FALSE';

A            B     
------------ ------
1            FALSE 

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_55 WHERE B = 0;

A            B     
------------ ------
1            FALSE 

1 rows fetched.

SQL> SELECT * FROM T_FUNC_INDEX_55 WHERE B IS NULL OR B IS NULL;

A            B     
------------ ------

0 rows fetched.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_55;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_56;

Succeed.

SQL> create table T_FUNC_INDEX_56(a int, b int);

Succeed.

SQL> create index FUNC_idx_T_INDEX_56_1 on T_FUNC_INDEX_56(TO_CHAR(A));

Succeed.

SQL> SELECT * FROM T_FUNC_INDEX_56 WHERE (A>20 AND A <30) OR (A >40 AND A <50) OR (A >60 AND A <70) OR (A >25 AND A <35);

A            B           
------------ ------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS T_FUNC_INDEX_56;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS IF_NOT_EXIST;

Succeed.

SQL> CREATE TABLE IF_NOT_EXIST(c1 INTEGER, c2 VARCHAR(1000), c3 INTEGER);

Succeed.

SQL> CREATE INDEX ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

Succeed.

SQL> CREATE INDEX ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

CT-00726, The column has been indexed by IX_IF_NOT_EXIST.
SQL> CREATE INDEX IF NOT EXISTS ix_if_not_exist ON IF_NOT_EXIST(c1, c2);

Succeed.

SQL> DROP INDEX ix_if_not_exist ON IF_NOT_EXIST;

Succeed.

SQL> DROP TABLE IF_NOT_EXIST;

Succeed.

SQL> --pctfree
SQL> DROP TABLE IF EXISTS PCT_TB0;

Succeed.

SQL> CREATE TABLE PCT_TB0 (f1 int, f2 int, f3 int);

Succeed.

SQL> INSERT INTO PCT_TB0 VALUES (1,2,3);INSERT INTO PCT_TB0 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB0 VALUES (3,2,29);INSERT INTO PCT_TB0 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;INSERT INTO PCT_TB0 SELECT * FROM PCT_TB0;

256 rows affected.


512 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS PCT_TB1;

Succeed.

SQL> CREATE TABLE PCT_TB1 (f1 int, f2 int, f3 int);

Succeed.

SQL> INSERT INTO PCT_TB1 VALUES (1,2,3);INSERT INTO PCT_TB1 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB1 VALUES (3,2,29);INSERT INTO PCT_TB1 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;INSERT INTO PCT_TB1 SELECT * FROM PCT_TB1;

256 rows affected.


512 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE INDEX idx_ptctb_1 ON PCT_TB1 (f1) ONLINE crmode row;

Succeed.

SQL> CREATE INDEX idx_ptctb_2 ON PCT_TB1 (f2) PCTFREE 10 crmode page;

Succeed.

SQL> CREATE INDEX idx_ptctb_3 ON PCT_TB1 (f3) PCTFREE 80 ONLINE crmode row;

Succeed.

SQL> SELECT SEGMENT_NAME, PAGES FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_PTCTB_1' OR SEGMENT_NAME = 'IDX_PTCTB_2'  OR SEGMENT_NAME = 'IDX_PTCTB_3' ORDER BY SEGMENT_NAME;

SEGMENT_NAME                                                     PAGES               
---------------------------------------------------------------- --------------------
IDX_PTCTB_1                                                      16                  
IDX_PTCTB_2                                                      8                   
IDX_PTCTB_3                                                      40                  

3 rows fetched.

SQL> ALTER INDEX idx_ptctb_1 ON PCT_TB1 REBUILD PCTFREE 80;

Succeed.

SQL> DELETE FROM PCT_TB1;COMMIT;

1024 rows affected.


Succeed.

SQL> INSERT INTO PCT_TB1 SELECT * FROM PCT_TB0; COMMIT;

1024 rows affected.


Succeed.

SQL> ALTER INDEX idx_ptctb_2 ON PCT_TB1 REBUILD ONLINE;

Succeed.

SQL> ALTER INDEX idx_ptctb_3 ON PCT_TB1 REBUILD PCTFREE 50;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS PCT_P_TB1;

Succeed.

SQL> CREATE TABLE PCT_P_TB1 (f1 int, f2 int, f3 int)
  2 PARTITION BY RANGE(f3)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30),
  7  PARTITION p4 values less than(40)
  8 );

Succeed.

SQL> INSERT INTO PCT_P_TB1 VALUES (1,2,3);INSERT INTO PCT_P_TB1 VALUES (2,2,19);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_P_TB1 VALUES (3,2,29);INSERT INTO PCT_P_TB1 VALUES (4,2,39);

1 rows affected.


1 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

4 rows affected.


8 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

16 rows affected.


32 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

64 rows affected.


128 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

256 rows affected.


512 rows affected.

SQL> INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;INSERT INTO PCT_P_TB1 SELECT * FROM PCT_P_TB1;

1024 rows affected.


2048 rows affected.

SQL> COMMIT;

Succeed.

SQL> create index idx_p11_3 on PCT_P_TB1(f3) local
  2 (
  3 partition p1 pctfree 10,
  4 partition p2 pctfree 50,
  5 partition p3 pctfree 80,
  6 partition p4
  7 ) crmode row;

Succeed.

SQL> SELECT SEGMENT_NAME, PARTITION_NAME, PAGES FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_P11_3' ORDER BY PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
IDX_P11_3                                                        P1                                                               8                   
IDX_P11_3                                                        P2                                                               16                  
IDX_P11_3                                                        P3                                                               40                  
IDX_P11_3                                                        P4                                                               8                   
IDX_P11_3                                                                                                                         0                   

5 rows fetched.

SQL> DELETE FROM PCT_P_TB1; COMMIT;

4096 rows affected.


Succeed.

SQL> ALTER INDEX idx_p11_3 on PCT_P_TB1 REBUILD PCTFREE 10;

Succeed.

SQL> SELECT  SEGMENT_NAME, PARTITION_NAME, PAGES  FROM USER_SEGMENTS where SEGMENT_NAME = 'IDX_P11_3' ORDER BY PARTITION_NAME;

SEGMENT_NAME                                                     PARTITION_NAME                                                   PAGES               
---------------------------------------------------------------- ---------------------------------------------------------------- --------------------
IDX_P11_3                                                        P1                                                               8                   
IDX_P11_3                                                        P2                                                               8                   
IDX_P11_3                                                        P3                                                               8                   
IDX_P11_3                                                        P4                                                               8                   
IDX_P11_3                                                                                                                         0                   

5 rows fetched.

SQL> DROP TABLE IF EXISTS PCT_TB1;

Succeed.

SQL> DROP TABLE IF EXISTS PCT_P_TB1;

Succeed.

SQL> DROP TABLE IF EXISTS PCT_TB0;

Succeed.

SQL> DROP TABLE IF EXISTS I_FIXEDNETWORKLTP;

Succeed.

SQL> 
SQL> --DTS2018091501597
SQL> CREATE USER fbitester IDENTIFIED BY asdf_1234;

Succeed.

SQL> GRANT CREATE ANY TABLE TO fbitester;

Succeed.

SQL> GRANT CREATE ANY INDEX TO fbitester;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS idx_tab001;

Succeed.

SQL> DROP TABLE IF EXISTS fbitester.idx_tab001;

Succeed.

SQL> CREATE TABLE fbitester.idx_tab001 (col1 INTEGER NOT NULL, col2 VARCHAR(64));

Succeed.

SQL> CREATE TABLE idx_tab001 (col1 INTEGER NOT NULL, col2 REAL);

Succeed.

SQL> CREATE INDEX sys.ix_idx_tab001 ON fbitester.idx_tab001(TO_CHAR(col1));    -- error. schema name not same

CT-00601, [1:35]Sql syntax error: index user(SYS) is not consistent with table user(FBITESTER)
SQL> CREATE INDEX ix_idx_tab001 ON fbitester.idx_tab001(TO_CHAR(col1));        -- OK. index's schema equals with "fbitester"

Succeed.

SQL> CREATE INDEX fbitester.ix_idx_tab002 ON idx_tab001(TO_CHAR(col2));        -- error. schema name not same

CT-00601, [1:41]Sql syntax error: index user(FBITESTER) is not consistent with table user(SYS)
SQL> CREATE INDEX ix_idx_tab002 ON idx_tab001(TO_CHAR(col2));                  -- OK. index's schema equals with "sys"

Succeed.

SQL> 
SQL> SELECT U.NAME AS OWNER, T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME FROM SYS_USERS U JOIN SYS_INDEXES I ON U.ID=I.USER# AND U.NAME='fbitester' JOIN SYS_TABLES T ON I.USER#=T.USER# AND I.TABLE#=T.ID WHERE T.NAME='IDX_TAB001';  --1 row expected

OWNER                                                            TABLE_NAME                                                       INDEX_NAME                                                      
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------

0 rows fetched.

SQL> SELECT M.USER_NAME AS OWNER, T.NAME AS TABLE_NAME, I.NAME AS INDEX_NAME FROM V$ME M JOIN SYS_INDEXES I ON M.USER_ID=I.USER# JOIN SYS_TABLES T ON I.USER#=T.USER# AND I.TABLE#=T.ID WHERE T.NAME='IDX_TAB001';  --1 row expected

OWNER                                                            TABLE_NAME                                                       INDEX_NAME                                                      
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
SYS                                                              IDX_TAB001                                                       IX_IDX_TAB002                                                   

1 rows fetched.

SQL> 
SQL> DROP INDEX ix_idx_tab002 ON idx_tab001;

Succeed.

SQL> DROP TABLE idx_tab001;

Succeed.

SQL> DROP INDEX fbitester.ix_idx_tab001 ON fbitester.idx_tab001;

Succeed.

SQL> DROP TABLE fbitester.idx_tab001;

Succeed.

SQL> DROP USER fbitester CASCADE;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS FBI_TEST_IN_INDEX;

Succeed.

SQL> CREATE TABLE FBI_TEST_IN_INDEX (ID VARBINARY(36));

Succeed.

SQL> CREATE UNIQUE INDEX FBI_UDX_TEST_IN_INDEX ON FBI_TEST_IN_INDEX(TO_CHAR(ID));

Succeed.

SQL> SELECT * FROM FBI_TEST_IN_INDEX I WHERE (((((((I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  2 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  3 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  4 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) ))
  5 AND (I.ID IN (UNHEX('11E8C9FF31C8B27489990242E088AEF7'),UNHEX('11E8C9FF31C8D98589990242E088AEF7'),UNHEX('11E8C9FF31C8D98789990242E088AEF7'),UNHEX('11E8C9FF31C8D98689990242E088AEF7'),UNHEX('11E8C9FF31C9009889990242E088AEF7'),UNHEX('11E8C9FF31C9009989990242E088AEF7')) )));

ID                                                              
----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS FBI_TEST_IN_INDEX;

Succeed.

SQL> 
SQL> CREATE TABLE FBI_TEST_IN_INDEX (ID INT, PID INT, NAME VARCHAR(8));

Succeed.

SQL> CREATE INDEX IDX_IDS ON FBI_TEST_IN_INDEX(TO_CHAR(ID),PID);

Succeed.

SQL> INSERT INTO FBI_TEST_IN_INDEX VALUES (1,1,'zzz');

1 rows affected.

SQL> SELECT DISTINCT ID,PID FROM FBI_TEST_IN_INDEX;

ID           PID         
------------ ------------
1            1           

1 rows fetched.

SQL> DROP TABLE FBI_TEST_IN_INDEX;

Succeed.

SQL> 
SQL> --column name using quote, for operating index
SQL> DROP TABLE IF EXISTS FBI_TAB_INDEX_KEY_3;

Succeed.

SQL> DROP TABLE IF EXISTS FBI_TAB_INDEX_KEY_4;

Succeed.

SQL> DROP TABLE IF EXISTS FBI_TAB_INDEX_KEY_1;

Succeed.

SQL> DROP TABLE IF EXISTS FBI_TAB_INDEX_KEY_2;

Succeed.

SQL> CREATE TABLE FBI_TAB_INDEX_KEY_1 (F_INT1 INT, F_INT2 INT, F_CHAR1 CHAR(8), F_VARCHAR2 VARCHAR(8));

Succeed.

SQL> CREATE TABLE FBI_TAB_INDEX_KEY_2 (F_INT3 INT, F_INT4 INT, F_CHAR3 CHAR(8), F_VARCHAR4 VARCHAR(8));

Succeed.

SQL> CREATE TABLE FBI_TAB_INDEX_KEY_3 (F_INT5 INT, F_INT6 INT, F_CHAR5 CHAR(8), F_VARCHAR6 VARCHAR(8));

Succeed.

SQL> CREATE TABLE FBI_TAB_INDEX_KEY_4 (F_INT7 INT, F_INT8 INT, F_CHAR7 CHAR(8), F_VARCHAR8 VARCHAR(8));

Succeed.

SQL> -- INDEX
SQL> CREATE INDEX FBI_AAAA ON FBI_TAB_INDEX_KEY_1(UPPER(F_CHAR1));

Succeed.

SQL> CREATE INDEX FBI_BBBB ON FBI_TAB_INDEX_KEY_2(UPPER('F_CHAR3'));

CT-00601, [1:51]Sql syntax error: invalid variant/object name was found
SQL> -- PRIMARY KEY
SQL> ALTER TABLE FBI_TAB_INDEX_KEY_1 ADD CONSTRAINT pk_F1 PRIMARY KEY(UPPER('F_INT1'));

CT-00601, Sql syntax error: invalid identifier
SQL> ALTER TABLE FBI_TAB_INDEX_KEY_2 ADD CONSTRAINT PK_F3 PRIMARY KEY(UPPER(F_INT3), 'F_INT4');

CT-00601, Sql syntax error: invalid identifier
SQL> -- FOREIGN KEY
SQL> ALTER TABLE FBI_TAB_INDEX_KEY_3 ADD CONSTRAINT FK_F5 FOREIGN KEY (TO_CHAR('F_INT5')) REFERENCES FBI_TAB_INDEX_KEY_1 ('F_INT1');

CT-00601, Sql syntax error: invalid identifier
SQL> ALTER TABLE FBI_TAB_INDEX_KEY_4 ADD CONSTRAINT FK_F78 FOREIGN KEY (TO_CHAR(F_INT7), 'F_INT8') REFERENCES FBI_TAB_INDEX_KEY_2 (F_INT3, 'F_INT4');

CT-00601, Sql syntax error: invalid identifier
SQL> DROP TABLE FBI_TAB_INDEX_KEY_3;

Succeed.

SQL> DROP TABLE FBI_TAB_INDEX_KEY_4;

Succeed.

SQL> DROP TABLE FBI_TAB_INDEX_KEY_1;

Succeed.

SQL> DROP TABLE FBI_TAB_INDEX_KEY_2;

Succeed.

SQL> 
SQL> --TO_CHAR char
SQL> drop table if exists t_func_tochar;

Succeed.

SQL> create table t_func_tochar(f1 int, f2 char(20));

Succeed.

SQL> insert into t_func_tochar values(1,'aaa'),(2,'bbb');

2 rows affected.

SQL> create index idx_t_func_tochar on t_func_tochar(to_char(f2));

Succeed.

SQL> explain select * from t_func_tochar where to_char(f2) = 'aaa';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                   |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUNC_TOCHAR     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_T_FUNC_TOCHAR |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_CHAR(F2) = 'aaa'                              

10 rows fetched.

SQL> select * from t_func_tochar where to_char(f2) = 'aaa';

F1           F2                  
------------ --------------------
1            aaa                 

1 rows fetched.

SQL> drop table if exists t_func_tochar;

Succeed.

SQL> 
SQL> --DTS2018120310716 
SQL> drop table if exists fbi_t1;

Succeed.

SQL> create table fbi_t1(f1 int, f2 number(20), f3 int, f4 char(20), f5 varchar(20), f6 number(20));

Succeed.

SQL> create index fbi_t1_idx1 on fbi_t1(to_char(f2), to_char(f6));

Succeed.

SQL> create index fbi_t1_idx2 on fbi_t1(to_char(f4), upper(f5));

Succeed.

SQL> create unique index pk_fbi_t1 on fbi_t1(to_char(f1));

Succeed.

SQL> insert into fbi_t1 values(1,1,1,'aaa','bbb',1);

1 rows affected.

SQL> insert into fbi_t1 values(2,1,2,'abc','bca',2);

1 rows affected.

SQL> insert into fbi_t1 values(3,2,3,'acb','bac',3);

1 rows affected.

SQL> insert into fbi_t1 select * from fbi_t1 on duplicate key update f1 = f1+3, f5 = 'xxxx';

6 rows affected.

SQL> commit;

Succeed.

SQL> select * from fbi_t1 where f5 = 'xxxx' order by f1;

F1           F2                                       F3           F4                   F5                   F6                                      
------------ ---------------------------------------- ------------ -------------------- -------------------- ----------------------------------------
4            1                                        1            aaa                  xxxx                 1                                       
5            1                                        2            abc                  xxxx                 2                                       
6            2                                        3            acb                  xxxx                 3                                       

3 rows fetched.

SQL> select count(*) from fbi_t1 where f2 = 1;

COUNT(*)            
--------------------
2                   

1 rows fetched.

SQL> select f2 from fbi_t1 where f2 = 1;

F2                                      
----------------------------------------
1                                       
1                                       

2 rows fetched.

SQL> select * from fbi_t1 where to_char(f4) = 'aaa';

F1           F2                                       F3           F4                   F5                   F6                                      
------------ ---------------------------------------- ------------ -------------------- -------------------- ----------------------------------------
4            1                                        1            aaa                  xxxx                 1                                       

1 rows fetched.

SQL> drop table if exists fbi_t1;

Succeed.

SQL> 
SQL> --func index in references
SQL> drop table if exists DEP_B;

Succeed.

SQL> drop table if exists DEP_A;

Succeed.

SQL> create table DEP_A (id1 int, id2 int, id3 int,id4 int);

Succeed.

SQL> create table DEP_B (id1 int, id2 int, id3 int,id4 int);

Succeed.

SQL> create index IDX_DEP_B on DEP_B (TO_CHAR(id2), id3);

Succeed.

SQL> alter table DEP_A add primary key (id3, id2);

Succeed.

SQL> alter table DEP_B add foreign key (id2, id3) references DEP_A(id3, id2) on delete cascade;

Succeed.

SQL> insert into DEP_A values (1,1,1,1);

1 rows affected.

SQL> insert into DEP_B values (1,1,1,1);

1 rows affected.

SQL> insert into DEP_A values (2,2,2,2);

1 rows affected.

SQL> insert into DEP_B values (3,2,2,4);

1 rows affected.

SQL> commit;

Succeed.

SQL> delete from DEP_A where id1 =1; 

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from DEP_B;

ID1          ID2          ID3          ID4         
------------ ------------ ------------ ------------
3            2            2            4           

1 rows fetched.

SQL> drop table DEP_B;

Succeed.

SQL> drop table DEP_A;

Succeed.

SQL> 
SQL> --DTS2018120705742
SQL> drop user if exists nebula cascade;

Succeed.

SQL> create user nebula identified by Cantian_234;

Succeed.

SQL> grant all to nebula;

Succeed.

SQL> 
SQL> create table nebula.storage_support_upper_index_range_tbl_000(c_id int,c_d_id bigint NOT NULL,c_w_id bigint NOT NULL,c_p_id bigint NOT NULL,c_k_id bigint NOT NULL,c_middle char(20),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 binary(1500),c_data2 varbinary(8000),c_data3 float,c_data4 double,c_data5 decimal,c_clob clob,c_text blob,c_text1 long,c_text2 raw(1500),c_text3 char(20),c_first varchar(16) NOT NULL);

Succeed.

SQL> CREATE or replace procedure nebula.storage_support_upper_index_range_proc_000(startnum int,endall int) is
  2 i INT :=1;
  3 j varchar(10);
  4 BEGIN
  5   FOR i IN startnum..endall LOOP
  6     select cast(i as varchar(10)) into j from dual;
  7     insert into nebula.storage_support_upper_index_range_tbl_000 select i,i,i,i,i,'OE'||j,'BARBar'||j,'bkilifcrRGF'||j,'pmbwovhSDGj'||j,'dyfrDa'||j,'uq','4801'||j,'940215'||j,sysdate,'GC',50000.0,0.4361328,-10.0,10.0,1,true,sysdate,lpad('QVBUflcHOQNvmgfvdPFZSF',100,'QVLDfscHOQgfvmPFZDSF'),lpad('QVBUflcHOQNvmgfvdPFZSF',100,'QVLDfscHOQgfvmPFZDSF'),153.0,100.0,50.0,lpad('12314315487569809',100,'1435764ABC7890abcdef'),lpad('12314315487569809',100,'1435764ABC7890abcdef'),to_char(200),lpad('12314315487569809',100,'1435764ABC7890abcdef'),'bg','iscmRDs'||j from dual;
  8   END LOOP;
  9 END;
 10 /

Succeed.

SQL> call nebula.storage_support_upper_index_range_proc_000(1,100);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> 
SQL> --I1.create table and create index
SQL> create table nebula.storage_support_upper_index_range_tbl_010(c_id int,c_d_id bigint NOT NULL,c_w_id bigint NOT NULL,c_p_id bigint NOT NULL,c_k_id bigint NOT NULL,c_middle char(20),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 binary(1500),c_data2 varbinary(8000),c_data3 float,c_data4 double,c_data5 decimal,c_clob clob,c_text blob,c_text1 long,c_text2 raw(1500),c_text3 char(20),c_first varchar(16) NOT NULL) partition by range(c_id,c_first) (partition PART_1 values less than (9999,'iscmRDs9999'),partition PART_2 values less than (99999,'iscmRDs99999'),partition PART_3 values less than (maxvalue,maxvalue));

Succeed.

SQL> create table nebula.storage_support_upper_index_range_tbl_010_1(c_id int,c_d_id bigint NOT NULL,c_w_id bigint NOT NULL,c_p_id bigint NOT NULL,c_k_id bigint NOT NULL,c_middle char(20),c_last varchar(16) NOT NULL,c_street_1 varchar(20) NOT NULL,c_street_2 varchar(20),c_city varchar(20) NOT NULL,c_state char(2) NOT NULL,c_zip char(9) NOT NULL,c_phone char(16) NOT NULL,c_since timestamp,c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_data1 binary(1500),c_data2 varbinary(8000),c_data3 float,c_data4 double,c_data5 decimal,c_clob clob,c_text blob,c_text1 long,c_text2 raw(1500),c_text3 char(20),c_first varchar(16) NOT NULL) partition by range(c_id,c_first) (partition PART_1 values less than (9999,'iscmRDs9999'),partition PART_2 values less than (99999,'iscmRDs99999'),partition PART_3 values less than (maxvalue,maxvalue));

Succeed.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010 select * from nebula.storage_support_upper_index_range_tbl_000;

100 rows affected.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010_1 select * from nebula.storage_support_upper_index_range_tbl_000;

100 rows affected.

SQL> commit;

Succeed.

SQL> create  index nebula.storage_support_upper_index_range_indx_010_1 on nebula.storage_support_upper_index_range_tbl_010(upper(c_first)) local;

Succeed.

SQL> create  index nebula.storage_support_upper_index_range_indx_010_1_1 on nebula.storage_support_upper_index_range_tbl_010_1(to_char(c_id)) local;

Succeed.

SQL> --I2.DML
SQL> --DML
SQL> --select: join
SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_000 t1 join nebula.storage_support_upper_index_range_tbl_010 t2 on t1.c_id=t2.c_id;

COUNT(*)            
--------------------
100                 

1 rows fetched.

SQL> --delete: without where
SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010;

COUNT(*)            
--------------------
100                 

1 rows fetched.

SQL> delete from nebula.storage_support_upper_index_range_tbl_010;

100 rows affected.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010 select * from nebula.storage_support_upper_index_range_tbl_000;

100 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010;

COUNT(*)            
--------------------
100                 

1 rows fetched.

SQL> --insert:with where and without where
SQL> insert into nebula.storage_support_upper_index_range_tbl_010 select c_id+1000,c_d_id+1000,c_w_id+1000,c_p_id+1000,c_k_id+1000,substr(c_middle,1,2)||'1001',substr(c_last,1,6)||(to_number(trim(LEADING 'BARBar' from c_last))+1000),c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_clob,c_text,c_text1,c_text2,c_text3,substr(c_first,1,7)||(to_number(trim(LEADING 'iscmRDs' from c_first))+1000) from nebula.storage_support_upper_index_range_tbl_000 where c_first='iscmRDs1';

1 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010 where c_id=1;

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> delete from nebula.storage_support_upper_index_range_tbl_010 where c_d_id=1001;

1 rows affected.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010_1 select c_id+1000,c_d_id+1000,c_w_id+1000,c_p_id+1000,c_k_id+1000,substr(c_middle,1,2)||'1001',substr(c_last,1,6)||(to_number(trim(LEADING 'BARBar' from c_last))+1000),c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_clob,c_text,c_text1,c_text2,c_text3,substr(c_first,1,7)||(to_number(trim(LEADING 'iscmRDs' from c_first))+1000) from nebula.storage_support_upper_index_range_tbl_000 where c_d_id=1;

1 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010_1 where c_first='iscmRDs1001';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> delete from nebula.storage_support_upper_index_range_tbl_010_1 where c_id=1001;

1 rows affected.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010 select c_id+100,c_d_id+100,c_w_id+100,c_p_id+100,c_k_id+100,substr(c_middle,1,2)||(to_number(trim(LEADING 'OE' from c_middle))+100),substr(c_last,1,6)||(to_number(trim(LEADING 'BARBar' from c_last))+100),c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_clob,c_text,c_text1,c_text2,c_text3,substr(c_first,1,7)||(to_number(trim(LEADING 'iscmRDs' from c_first))+100) from nebula.storage_support_upper_index_range_tbl_000;

100 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010;

COUNT(*)            
--------------------
200                 

1 rows fetched.

SQL> insert into nebula.storage_support_upper_index_range_tbl_010_1 select c_id+100,c_d_id+100,c_w_id+100,c_p_id+100,c_k_id+100,substr(c_middle,1,2)||(to_number(trim(LEADING 'OE' from c_middle))+100),substr(c_last,1,6)||(to_number(trim(LEADING 'BARBar' from c_last))+100),c_street_1,c_street_2,c_city,c_state,c_zip,c_phone,c_since,c_credit,c_credit_lim,c_discount,c_balance,c_ytd_payment,c_payment_cnt,c_delivery_cnt,c_end,c_data1,c_data2,c_data3,c_data4,c_data5,c_clob,c_text,c_text1,c_text2,c_text3,substr(c_first,1,7)||(to_number(trim(LEADING 'iscmRDs' from c_first))+100) from nebula.storage_support_upper_index_range_tbl_000;

100 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010_1;

COUNT(*)            
--------------------
200                 

1 rows fetched.

SQL> commit;

Succeed.

SQL> --update single table 
SQL> update nebula.storage_support_upper_index_range_tbl_010 set c_id=2000,c_first='iscmRDs2000' where c_first='iscmRDs200';

1 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010 where c_first='iscmRDs2000';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010 set c_id=200,c_first='iscmRDs200' where c_d_id=200;

1 rows affected.

SQL> select c_id,c_first from nebula.storage_support_upper_index_range_tbl_010 where  c_d_id=200;

C_ID         C_FIRST         
------------ ----------------
200          iscmRDs200      

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010 set c_id=900,c_first='iscmRDs900' where c_id=200;

1 rows affected.

SQL> select c_id,c_first from nebula.storage_support_upper_index_range_tbl_010 where c_id=900;

C_ID         C_FIRST         
------------ ----------------
900          iscmRDs900      

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010_1 set c_id=2000,c_first='iscmRDs2000' where c_id=200;

1 rows affected.

SQL> select count(*) from nebula.storage_support_upper_index_range_tbl_010_1 where c_id=2000;

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010_1 set c_id=200,c_first='iscmRDs200' where c_w_id=200;

1 rows affected.

SQL> select c_id,c_first from nebula.storage_support_upper_index_range_tbl_010_1 where  c_w_id=200;

C_ID         C_FIRST         
------------ ----------------
200          iscmRDs200      

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010_1 set c_id=900,c_first='iscmRDs900' where c_first='iscmRDs200';

1 rows affected.

SQL> select c_id,c_first from nebula.storage_support_upper_index_range_tbl_010_1 where c_first='iscmRDs900';

C_ID         C_FIRST         
------------ ----------------
900          iscmRDs900      

1 rows fetched.

SQL> --update muti tables
SQL> update nebula.storage_support_upper_index_range_tbl_010 t1,nebula.storage_support_upper_index_range_tbl_010_1 t2 set t1.c_id=300,t1.c_first='iscmRDs300',t2.c_id=300,t2.c_first='iscmRDs300' where  t1.c_id=t2.c_id and t1.c_first='iscmRDs30';

2 rows affected.

SQL> select t1.c_id,t1.c_first,t2.c_id,t2.c_first from nebula.storage_support_upper_index_range_tbl_010 t1 join nebula.storage_support_upper_index_range_tbl_010_1 t2 on t1.c_id=t2.c_id where t1.c_first='iscmRDs300';

C_ID         C_FIRST          C_ID         C_FIRST         
------------ ---------------- ------------ ----------------
300          iscmRDs300       300          iscmRDs300      

1 rows fetched.

SQL> update nebula.storage_support_upper_index_range_tbl_010 t1,nebula.storage_support_upper_index_range_tbl_010_1 t2 set t1.c_id=30,t1.c_first='iscmRDs30',t2.c_id=30,t2.c_first='iscmRDs30' where  t1.c_id=t2.c_id and t1.c_id=300;

2 rows affected.

SQL> select t1.c_id,t1.c_first,t2.c_id,t2.c_first from nebula.storage_support_upper_index_range_tbl_010 t1 join nebula.storage_support_upper_index_range_tbl_010_1 t2 on t1.c_id=t2.c_id where t1.c_id=30;

C_ID         C_FIRST          C_ID         C_FIRST         
------------ ---------------- ------------ ----------------
30           iscmRDs30        30           iscmRDs30       

1 rows fetched.

SQL> commit;

Succeed.

SQL> drop user nebula cascade;

Succeed.

SQL> 
SQL> drop table if exists fun_t1;

Succeed.

SQL> create table fun_t1 (id varchar(1), num int);

Succeed.

SQL> create index idx_fun_01 on fun_t1 (upper(id));

Succeed.

SQL> insert into fun_t1 values ('a',2);

1 rows affected.

SQL> insert into fun_t1 values ('a',2);

1 rows affected.

SQL> truncate table fun_t1;

Succeed.

SQL> FLASHBACK TABLE fun_t1 TO BEFORE TRUNCATE FORCE;

CT-00829, Recyclebin object SYS.FUN_T1 does not exist
SQL> alter table fun_t1 shrink space compact;

Succeed.

SQL> drop table fun_t1;

Succeed.

SQL> drop table if exists test_hash1;

Succeed.

SQL> create table test_hash1 (
  2 c3 char(20) primary key,
  3 c4 number(8) not null
  4 )
  5 partition by hash(c3)
  6 (
  7 partition part_01,
  8 partition part_02,
  9 partition part_03
 10 );

Succeed.

SQL> 
SQL> insert into test_hash1 values('aaaa',111);

1 rows affected.

SQL> insert into test_hash1 values('bbbb',111);

1 rows affected.

SQL> insert into test_hash1 values('cccc',111);

1 rows affected.

SQL> insert into test_hash1 values('dddd',111);

1 rows affected.

SQL> insert into test_hash1 values('eeee',111);

1 rows affected.

SQL> insert into test_hash1 values('ffff',111);

1 rows affected.

SQL> insert into test_hash1 values('hhhh',111);

1 rows affected.

SQL> insert into test_hash1 values('iiii',111);

1 rows affected.

SQL> 
SQL> create index idx_hash_part_t2 on test_hash1(upper(c3),c4) local;

Succeed.

SQL> select * from test_hash1 partition(part_02) order by c3,c4;

C3                   C4                                      
-------------------- ----------------------------------------
aaaa                 111                                     
cccc                 111                                     
dddd                 111                                     

3 rows fetched.

SQL> 
SQL> alter table test_hash1 add partition part_04 tablespace users;

Succeed.

SQL> 
SQL> select * from test_hash1 partition(part_02) order by c3,c4;

C3                   C4                                      
-------------------- ----------------------------------------

0 rows fetched.

SQL> select * from test_hash1 partition(part_04) order by c3,c4;

C3                   C4                                      
-------------------- ----------------------------------------
aaaa                 111                                     
cccc                 111                                     
dddd                 111                                     

3 rows fetched.

SQL> drop table if exists test_hash1;

Succeed.

SQL> 
SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop table if exists lin_hash;

Succeed.

SQL> create table lin_hash(
  2 col_number1 number,
  3 col_timestamp2 timestamp(6)) crmode row;

Succeed.

SQL> create tablespace LIN_INDEX_01 datafile 'lin_index_01.dbf' size 32M autoextend on next 8M maxsize unlimited;

Succeed.

SQL> create index if not exists LIN_INDEX_TEST on lin_hash(to_char(col_timestamp2) asc,upper(col_number1) desc) tablespace LIN_INDEX_01 REVERSE;

Succeed.

SQL> select * from all_indexes where INDEX_NAME = 'LIN_INDEX_TEST';

OWNER                                                            INDEX_NAME                                                       INDEX_TYPE TABLE_NAME                                                       TABLESPACE_NAME                                                  IS_PRIMARY IS_UNIQUE IS_DUPLICATE PARTITIONED STATUS  INI_TRANS    MAX_TRANS    PCT_FREE     COLUMN_COUNT COLUMNS                                                          BYTES                PAGES                EXTENTS              BLEVEL       LEAF_BLOCKS  EMPTY_LEAF_BLOCKS DISTINCT_KEYS AVG_LEAF_BLOCKS_PER_KEY AVG_DATA_BLOCKS_PER_KEY CLUSTERING_FACTOR NUM_ROWS     SAMPLE_SIZE  LAST_ANALYZED                    SYS_GENERATE         CR_MODE IS_REVERSED
---------------------------------------------------------------- ---------------------------------------------------------------- ---------- ---------------------------------------------------------------- ---------------------------------------------------------------- ---------- --------- ------------ ----------- ------- ------------ ------------ ------------ ------------ ---------------------------------------------------------------- -------------------- -------------------- -------------------- ------------ ------------ ----------------- ------------- ----------------------- ----------------------- ----------------- ------------ ------------ -------------------------------- -------------------- ------- -----------
SYS                                                              LIN_INDEX_TEST                                                   NORMAL     LIN_HASH                                                         LIN_INDEX_01                                                     N          N         N            N           VALID   2            255          8            2            to_char(col_timestamp2), upper(col_number1)                      0                    0                    0                                                                                                                                                                                                           0                    ROW     Y          

1 rows fetched.

SQL> drop table lin_hash;

Succeed.

SQL> drop tablespace LIN_INDEX_01 including contents and datafiles;

Succeed.

SQL> 
SQL> drop table if exists func_idx_t1;

Succeed.

SQL> create table func_idx_t1(f1 nvarchar(100));

Succeed.

SQL> insert into func_idx_t1 values('访异调野野野环注爱时败世败大大试异测第务野测境智试了xhkf”—~、（；—、【—•~册本失界本了试册测时界时野版智注务测小册');

1 rows affected.

SQL> commit;

Succeed.

SQL> select * from func_idx_t1;

F1                                                              
----------------------------------------------------------------
访异调野野野环注爱时败世败大大试异测第务野测境智试了xhkf”—~、（；—、【—•~册本失界本了试册测时界时野版智注务测小册

1 rows fetched.

SQL> create index idx_upper_idx_t1 on func_idx_t1(upper(f1));

Succeed.

SQL> select count(1) from func_idx_t1 where f1 = '访异调野野野环注爱时败世败大大试异测第务野测境智试了xhkf”—~、（；—、【—•~册本失界本了试册测时界时野版智注务测小册';

COUNT(1)            
--------------------
1                   

1 rows fetched.

SQL> select count(1) from func_idx_t1 where upper(f1) = '访异调野野野环注爱时败世败大大试异测第务野测境智试了XHKF”—~、（；—、【—•~册本失界本了试册测时界时野版智注务测小册';

COUNT(1)            
--------------------
1                   

1 rows fetched.

SQL> drop index idx_upper_idx_t1 on func_idx_t1;

Succeed.

SQL> create index idx_to_char_idx_t1 on func_idx_t1(to_char(f1));

Succeed.

SQL> select count(1) from func_idx_t1 where to_char(f1) = '访异调野野野环注爱时败世败大大试异测第务野测境智试了xhkf”—~、（；—、【—•~册本失界本了试册测时界时野版智注务测小册';

COUNT(1)            
--------------------
1                   

1 rows fetched.

SQL> drop table func_idx_t1;

Succeed.

SQL> 
SQL> drop table if exists func_idx_t2;

Succeed.

SQL> create table func_idx_t2("c1" varchar(10));

Succeed.

SQL> create index idx_upper_func_idx_t2 on func_idx_t2(upper("c1"));

Succeed.

SQL> select index_name, columns from my_indexes where index_name=upper('idx_upper_func_idx_t2');

INDEX_NAME                                                       COLUMNS                                                         
---------------------------------------------------------------- ----------------------------------------------------------------
IDX_UPPER_FUNC_IDX_T2                                            upper("c1")                                                     

1 rows fetched.

SQL> drop table func_idx_t2;

Succeed.

SQL> 
SQL> create table table1(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(2396) NOT NULL,c_middle char(1500),
  2 c_last varchar(4200) NOT NULL,c_street_1 varchar2(8000) NOT NULL,c_street_2 varchar2(8000),c_city varchar(3892) NOT NULL,
  3 c_state varchar2(3900) NOT NULL,c_zip varchar2(3896) NOT NULL,c_phone varchar2(3900) NOT NULL,c_since timestamp,
  4 c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,
  5 c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),
  6 c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> create unique index index1_1 on table1 (upper(c_id),upper(c_last));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> alter table table1 modify c_last varchar(4100);

Succeed.

SQL> create unique index index1_1 on table1 (upper(c_id),upper(c_last));

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> alter table table1 modify c_last varchar(1945);

Succeed.

SQL> create unique index index1 on table1 (upper(c_id),upper(c_last));

Succeed.

SQL> alter table table1 modify c_last varchar(4100);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last varchar(4095);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last varchar(4090);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last varchar(4085);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last varchar(4080);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last varchar(4070);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table1 modify c_last char(4060);

CT-00130, Operation modify column is not supported on functional index
SQL> 
SQL> drop table table1;

Succeed.

SQL> create table table2(c_id int,c_d_id int NOT NULL,c_w_id int NOT NULL,c_first varchar(2396) NOT NULL,c_middle char(1500),
  2 c_last varchar(1000) NOT NULL,c_street_1 varchar2(8000) NOT NULL,c_street_2 varchar2(8000),c_city varchar(3892) NOT NULL,
  3 c_state varchar2(3900) NOT NULL,c_zip varchar2(3896) NOT NULL,c_phone varchar2(3900) NOT NULL,c_since timestamp,
  4 c_credit char(2) NOT NULL,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real NOT NULL,
  5 c_payment_cnt number NOT NULL,c_delivery_cnt bool NOT NULL,c_end date NOT NULL,c_unsig tinyint unsigned,c_big bigint,c_vchar varchar2(8000),
  6 c_data long,c_text blob,c_clob clob,c_image image,c_binary binary(1000),c_varbinary varbinary(1000),c_raw raw(1000));

Succeed.

SQL> 
SQL> create unique index index2_1 on table2 (c_id,c_last);

Succeed.

SQL> create unique index index2_2 on table2 (upper(c_id),upper(c_last));

Succeed.

SQL> create unique index index2_3 on table2 (c_id,upper(c_id),upper(c_last));

Succeed.

SQL> create unique index index2_4 on table2 (c_id,upper(c_id),c_last);

Succeed.

SQL> create unique index index2_5 on table2 (c_id,upper(c_id),c_last, upper(c_last));

Succeed.

SQL> 
SQL> alter table table2 modify c_last varchar(2100);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table2 modify c_last varchar(1800);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table2 modify c_last varchar(2080);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table2 modify c_last char(2060);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table2 modify c_last char(1850);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table table2 modify c_last varchar(8000);

CT-00634, The total size of index columns within an index exceeded the maximum (4058)
SQL> drop table table2;

Succeed.

SQL> 
SQL> drop table if exists func_like_t188;

Succeed.

SQL> create table func_like_t188(f1 nvarchar(10),f2 nchar(20));

Succeed.

SQL> insert into func_like_t188 values('abad','abc');

1 rows affected.

SQL> alter system set enable_permissive_unicode=true;

Succeed.

SQL> insert into func_like_t188 values('0xC0F6BDAD','0xFED0C0F6BDAD');

1 rows affected.

SQL> alter system set enable_permissive_unicode=false;

Succeed.

SQL> select * from func_like_t188 where f1 like '0xC0F6BDAD' and f2 like '0xFED0C0F6BDAD';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> select * from func_like_t188 where f1 like 0xC0F6BDAD and f2 like 0xFED0C0F6BDAD;

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> select * from func_like_t188 where f1 like 'a%0xC0F6BDAD%d' and f2 like 'a%0xC0F6BDAD%c';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> select * from func_like_t188 where f1 like substrb('中', 1, 1);

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> select * from func_like_t188 where f1 like '%0xC0F6BDAD%%' escape '0';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> select * from func_like_t188 where f1 like '%/0xC0F6BDAD%%' escape '/';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------
0xC0F6BDAD                                                   0xFED0C0F6BDAD                                                  

1 rows fetched.

SQL> select * from func_like_t188 where f1 like '%0x/C0F6BDAD%%' escape '/';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------
0xC0F6BDAD                                                   0xFED0C0F6BDAD                                                  

1 rows fetched.

SQL> select * from func_like_t188 where f1 like '%0x/C0F6BDAD%%' escape '\';

F1                                                           F2                                                              
------------------------------------------------------------ ----------------------------------------------------------------

0 rows fetched.

SQL> drop table func_like_t188;

Succeed.

SQL> 
SQL> -- test function index
SQL> drop table if exists func_idx_basic_tab;

Succeed.

SQL> create table func_idx_basic_tab (
  2  f1  binary_integer,
  3  f2  binary_uint32,
  4  f3  binary_bigint,
  5  f4  char(3),
  6  f5  varchar(30),
  7  f6  boolean,
  8  f7  datetime,
  9  f8  timestamp(3),
 10  f9  timestamp(3) with time zone,
 11  f10 timestamp(3) with local time zone,
 12  f11 float,
 13  f12 number,
 14  f13 interval day(7) to second,
 15  f14 interval year(3) to month
 16 );

Succeed.

SQL> 
SQL> insert into func_idx_basic_tab values (-1, 100, -32890473279324, 'abc', 'function', true, sysdate, '2020-01-30 13:50:59.202', '2020-02-06 11:20:09.035 +08:00', '2018-03-06 11:20:09.230', 156.275, 4544.2572, '1231 12:3:4.1234', INTERVAL '120-11' YEAR(3) TO MONTH);

1 rows affected.

SQL> insert into func_idx_basic_tab values (0, 200, 32890473279324, 'def', 'PKG', 0, sysdate, '2020-02-19 13:50:59.202', '2020-02-07 11:20:09.035 +08:00', '2002-02-06 11:20:09.230', 27.24, 2727.287, 'P1231DT16H3.3333333S', INTERVAL '10-2' YEAR TO MONTH);

1 rows affected.

SQL> insert into func_idx_basic_tab values (1, null, 4645161, 'ghi', 'INDEX', false, sysdate, '2020-03-30 13:50:59.202', '2020-02-08 11:20:09.035 +08:00', '2002-02-06 11:20:09.230', 257.52, 4542774.242, 'PT12H', null);

1 rows affected.

SQL> insert into func_idx_basic_tab values (2, 300, 48945135, 'gkl', 'test', 1, sysdate, '2020-04-30 13:50:59.202', '2020-02-09 11:20:09.035 +08:00', '2013-02-06 11:20:09.230', 2275.22, null, '-P99DT655M999.99999S', INTERVAL '10-11' YEAR(3) TO MONTH);

1 rows affected.

SQL> insert into func_idx_basic_tab values (3, null, -4315, 'mno', 'REGRESS', true, sysdate, '2020-05-30 13:50:59.202', '2020-02-19 11:20:09.035 +08:00', '2019-02-06 11:20:09.230', 54325725.2782, 25.257, '-0 00:19:7.7777777777', '999-11');

1 rows affected.

SQL> insert into func_idx_basic_tab values (null, 700, 54651364586, 'pqr', 'sql', false, sysdate, '2020-06-30 13:50:59.202', '2020-02-18 11:20:09.035 +08:00', '2013-02-06 11:20:09.230', 2542.8287, 57.27, '-1234 0:0:0.0004', '100-2');

1 rows affected.

SQL> insert into func_idx_basic_tab values (4, 800, 5451, 'stu', 'code', true, sysdate, '2020-07-30 13:50:59.202', '2020-02-11 11:20:09.035 +08:00', '2010-02-06 11:20:09.230', 67.827, 276.546, null, '100-2');

1 rows affected.

SQL> insert into func_idx_basic_tab values (5, 0, 1456465, 'vwx', 'MASTER', false, sysdate, '2020-08-30 13:50:59.202', '2020-02-10 11:20:09.035 +08:00', '2011-02-06 11:20:09.230', 372.87, null, null, null);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> -- test nvl/nvl2 function index
SQL> create index ix_nvl_tab_1 on func_idx_basic_tab (nvl('abc', 'def')); -- error

CT-00601, Sql syntax error: index column expected but not found
SQL> create index ix_nvl_tab_1 on func_idx_basic_tab (nvl(f1, 100));

Succeed.

SQL> create index ix_nvl_tab_2 on func_idx_basic_tab (nvl(f1, f2)); -error

CT-00601, Sql syntax error: multiple columns found in function index
SQL> create index ix_nvl_tab_2 on func_idx_basic_tab (f1, nvl(f1, 1000));

Succeed.

SQL> create index ix_nvl_tab_3 on func_idx_basic_tab (f1, nvl(f1, 1000), nvl2(f2, 'not null', 'null'));

Succeed.

SQL> create index ix_nvl_tab_4 on func_idx_basic_tab (nvl2(f1, f1, 10000));

Succeed.

SQL> create index ix_nvl_tab_5 on func_idx_basic_tab (nvl2(f2, f2, 10000));

Succeed.

SQL> create index ix_nvl_tab_6 on func_idx_basic_tab (nvl2(f3, f3, 10000));

Succeed.

SQL> create index ix_nvl_tab_7 on func_idx_basic_tab (nvl2(f4, f4, '-'));

Succeed.

SQL> create index ix_nvl_tab_8 on func_idx_basic_tab (nvl2(f5, f5, '-'));

Succeed.

SQL> create index ix_nvl_tab_9 on func_idx_basic_tab (nvl2(f6, f6, false));

Succeed.

SQL> create index ix_nvl_tab_10 on func_idx_basic_tab (nvl2(f7, f7, sysdate)); -- error

CT-00601, [1:64]Sql syntax error: unexpect word
SQL> create index ix_nvl_tab_11 on func_idx_basic_tab (nvl2(f8, f8, '2020-02-02 23:59:59'));

Succeed.

SQL> create index ix_nvl_tab_12 on func_idx_basic_tab (nvl2(f11, f11, -1.0342));

Succeed.

SQL> create index ix_nvl_tab_13 on func_idx_basic_tab (nvl2(f12, f12, 0));

Succeed.

SQL> create index ix_nvl_tab_14 on func_idx_basic_tab (nvl2(f13, f13, '-1234 0:0:0.0004'));

Succeed.

SQL> create index ix_nvl_tab_15 on func_idx_basic_tab (nvl2(f14, f14, '11-10'));

Succeed.

SQL> 
SQL> select index_name, columns from user_indexes where table_name = 'FUNC_IDX_BASIC_TAB' order by index_name;

INDEX_NAME                                                       COLUMNS                                                         
---------------------------------------------------------------- ----------------------------------------------------------------
IX_NVL_TAB_1                                                     nvl(f1, 100)                                                    
IX_NVL_TAB_11                                                    nvl2(f8, f8, '2020-02-02 23:59:59')                             
IX_NVL_TAB_12                                                    nvl2(f11, f11, -1.0342)                                         
IX_NVL_TAB_13                                                    nvl2(f12, f12, 0)                                               
IX_NVL_TAB_14                                                    nvl2(f13, f13, '-1234 0:0:0.0004')                              
IX_NVL_TAB_15                                                    nvl2(f14, f14, '11-10')                                         
IX_NVL_TAB_2                                                     F1, nvl(f1, 1000)                                               
IX_NVL_TAB_3                                                     F1, nvl(f1, 1000), nvl2(f2, 'not null', 'null')                 
IX_NVL_TAB_4                                                     nvl2(f1, f1, 10000)                                             
IX_NVL_TAB_5                                                     nvl2(f2, f2, 10000)                                             
IX_NVL_TAB_6                                                     nvl2(f3, f3, 10000)                                             
IX_NVL_TAB_7                                                     nvl2(f4, f4, '-')                                               
IX_NVL_TAB_8                                                     nvl2(f5, f5, '-')                                               
IX_NVL_TAB_9                                                     nvl2(f6, f6, false)                                             

14 rows fetched.

SQL> 
SQL> alter table func_idx_basic_tab modify f2 varchar(30);

CT-00805, Column F2 is not empty in table FUNC_IDX_BASIC_TAB
SQL> 
SQL> select f1, nvl(f1, 100), f2 from func_idx_basic_tab where nvl(f1, 100) = 1 order by 1,2,3;

F1           NVL(F1, 100) F2          
------------ ------------ ------------
1            1                        

1 rows fetched.

SQL> select f1, nvl(f1, 100), f2 from func_idx_basic_tab where nvl(f1, 100) = 100 order by 1,2,3;

F1           NVL(F1, 100) F2          
------------ ------------ ------------
             100          700         

1 rows fetched.

SQL> select f1, nvl(f1, 100), f2 from func_idx_basic_tab where nvl(f1, 100) > 3 order by 1,2,3;

F1           NVL(F1, 100) F2          
------------ ------------ ------------
4            4            800         
5            5            0           
             100          700         

3 rows fetched.

SQL> select f1, nvl2(f1, f1, 100), f2 from func_idx_basic_tab where nvl2(f1, f1, 100) = 1 order by 1,2,3;

F1           NVL2(F1, F1, 100) F2          
------------ ----------------- ------------
1            1                             

1 rows fetched.

SQL> select f1, nvl2(f1, f1, 100), f2 from func_idx_basic_tab where nvl2(f1, f1, 100) = 100 order by 1,2,3;

F1           NVL2(F1, F1, 100) F2          
------------ ----------------- ------------
             100               700         

1 rows fetched.

SQL> 
SQL> select f3 from func_idx_basic_tab where nvl2(f3, f3, 10000) > 100 order by f3;

F3                  
--------------------
5451                
1456465             
4645161             
48945135            
54651364586         
32890473279324      

6 rows fetched.

SQL> explain select f3 from func_idx_basic_tab where nvl2(f3, f3, 10000) > 100 and nvl2(f3, f3, 10000) <= 48945135 order by f3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_6       |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F3, F3, 10000) > 100 AND NVL2(F3, F3, 10000) <= 48945135

11 rows fetched.

SQL> select f3 from func_idx_basic_tab where nvl2(f3, f3, 10000) > 100 and nvl2(f3, f3, 10000) <= 48945135 order by f3;

F3                  
--------------------
5451                
1456465             
4645161             
48945135            

4 rows fetched.

SQL> explain select f3 from func_idx_basic_tab where nvl2(f3, f3, 10000) > 100 or nvl2(f3, f3, 10000) = -4315 order by f3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_6       |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F3, F3, 10000) > 100 OR NVL2(F3, F3, 10000) = -4315

11 rows fetched.

SQL> select f3 from func_idx_basic_tab where nvl2(f3, f3, 10000) > 100 or nvl2(f3, f3, 10000) = -4315 order by f3;

F3                  
--------------------
-4315               
5451                
1456465             
4645161             
48945135            
54651364586         
32890473279324      

7 rows fetched.

SQL> 
SQL> explain select f4 from func_idx_basic_tab where nvl2(f4, f4, '-') = 'ghi';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_7       |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F4, F4, '-') = 'ghi'                        

10 rows fetched.

SQL> select f4 from func_idx_basic_tab where nvl2(f4, f4, '-') = 'ghi';

F4 
---
ghi

1 rows fetched.

SQL> explain select f4 from func_idx_basic_tab where nvl2(f4, f4, '-') like 'ghi%';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_7       |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F4, F4, '-') LIKE 'ghi%'                    

10 rows fetched.

SQL> select f4 from func_idx_basic_tab where nvl2(f4, f4, '-') like 'ghi%';

F4 
---
ghi

1 rows fetched.

SQL> 
SQL> explain select f5 from func_idx_basic_tab where nvl2(f5, f5, '-') = 'function';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_8       |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F5, F5, '-') = 'function'                   

10 rows fetched.

SQL> select f5 from func_idx_basic_tab where nvl2(f5, f5, '-') = 'function';

F5                            
------------------------------
function                      

1 rows fetched.

SQL> explain select f5 from func_idx_basic_tab where nvl2(f5, f5, '-') like 't%' or nvl2(f5, f5, '-') like 'm%';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_8       |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F5, F5, '-') LIKE 't%' OR NVL2(F5, F5, '-') LIKE 'm%'

10 rows fetched.

SQL> select f5 from func_idx_basic_tab where nvl2(f5, f5, '-') like 't%' or nvl2(f5, f5, '-') like 'm%' order by f5;

F5                            
------------------------------
test                          

1 rows fetched.

SQL> 
SQL> explain select f6 from func_idx_basic_tab where nvl2(f6, f6, false) = 'T';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_9       |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F6, F6, FALSE) = TRUE                       

10 rows fetched.

SQL> select f6 from func_idx_basic_tab where nvl2(f6, f6, false) = true;

F6    
------
TRUE  
TRUE  
TRUE  
TRUE  

4 rows fetched.

SQL> 
SQL> explain select f8 from func_idx_basic_tab where nvl2(f8, f8, '2020-02-02 23:59:59') = '2020-03-30 13:50:59.202';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_11      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F8, F8, '2020-02-02 23:59:59') = CAST('2020-03-30 13:50:59.202' AS TIMESTAMP(6))

10 rows fetched.

SQL> select f8 from func_idx_basic_tab where nvl2(f8, f8, '2020-02-02 23:59:59') = '2020-03-30 13:50:59.202';

F8                              
--------------------------------
2020-03-30 13:50:59.202         

1 rows fetched.

SQL> explain select f8 from func_idx_basic_tab where nvl2(f8, f8, '2020-02-02 23:59:59') > '2020-03-30 13:50:59.202' and nvl2(f8, f8, '2020-02-02 23:59:59') <= '2020-06-30 13:50:59.202';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_11      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F8, F8, '2020-02-02 23:59:59') > CAST('2020-03-30 13:50:59.202' AS TIMESTAMP(6)) AND 
               NVL2(F8, F8, '2020-02-02 23:59:59') <= CAST('2020-06-30 13:50:59.202' AS TIMESTAMP(6))

11 rows fetched.

SQL> select f8 from func_idx_basic_tab where nvl2(f8, f8, '2020-02-02 23:59:59') > '2020-03-30 13:50:59.202' and nvl2(f8, f8, '2020-02-02 23:59:59') <= '2020-06-30 13:50:59.202' order by f8;

F8                              
--------------------------------
2020-04-30 13:50:59.202         
2020-05-30 13:50:59.202         
2020-06-30 13:50:59.202         

3 rows fetched.

SQL> 
SQL> explain select f11 from func_idx_basic_tab where nvl2(f11, f11, -1.0342) = 257.52;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_12      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F11, F11, -1.0342) = 257.52                 

10 rows fetched.

SQL> select f11 from func_idx_basic_tab where nvl2(f11, f11, -1.0342) = 257.52;

F11                 
--------------------
257.52              

1 rows fetched.

SQL> explain select f11 from func_idx_basic_tab where nvl2(f11, f11, -1.0342) = 257.52 or nvl2(f11, f11, -1.0342) = 372.87;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IX_NVL_TAB_12      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F11, F11, -1.0342) = 257.52 OR NVL2(F11, F11, -1.0342) = 372.87

10 rows fetched.

SQL> select f11 from func_idx_basic_tab where nvl2(f11, f11, -1.0342) = 257.52 or nvl2(f11, f11, -1.0342) = 372.87 order by f11;

F11                 
--------------------
257.52              
372.87              

2 rows fetched.

SQL> 
SQL> explain select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) = 4542774.242;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_13      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F12, F12, 0) = 4542774.242                  

10 rows fetched.

SQL> select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) = 4542774.242;

F12                                     
----------------------------------------
4542774.242                             

1 rows fetched.

SQL> explain select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) > 2727.287 or nvl2(f12, f12, 0) <= 57.27 order by f12;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_13      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F12, F12, 0) > 2727.287 OR NVL2(F12, F12, 0) <= 57.27

11 rows fetched.

SQL> select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) > 2727.287 or nvl2(f12, f12, 0) <= 57.27 order by f12;

F12                                     
----------------------------------------
25.257                                  
57.27                                   
4544.2572                               
4542774.242                             
                                        
                                        

6 rows fetched.

SQL> explain select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) >= 254.727 and nvl2(f12, f12, 0) <= 4544.2572 order by f12;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_13      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F12, F12, 0) >= 254.727 AND NVL2(F12, F12, 0) <= 4544.2572

11 rows fetched.

SQL> select f12 from func_idx_basic_tab where nvl2(f12, f12, 0) >= 254.727 and nvl2(f12, f12, 0) <= 4544.2572 order by f12;

F12                                     
----------------------------------------
276.546                                 
2727.287                                
4544.2572                               

3 rows fetched.

SQL> 
SQL> explain select f13 from func_idx_basic_tab where nvl2(f13, f13, '-1234 0:0:0.0004') = '-1234 0:0:0.0004';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_14      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F13, F13, '-1234 0:0:0.0004') = '-1234 0:0:0.0004'

10 rows fetched.

SQL> select f13 from func_idx_basic_tab where nvl2(f13, f13, '-1234 0:0:0.0004') = '-1234 0:0:0.0004' order by f13;

F13                     
------------------------
-0001234 00:00:00.000400
                        
                        

3 rows fetched.

SQL> explain select f13 from func_idx_basic_tab where nvl2(f13, f13, '-1234 0:0:0.0004') >= '100 10:0:0.0004' and nvl2(f13, f13, '-1234 0:0:0.0004') <= '+0001231 12:03:04.123400';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_14      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F13, F13, '-1234 0:0:0.0004') >= '100 10:0:0.0004' AND NVL2(F13, F13, '-1234 0:0:0.0004') <= '+0001231 12:03:04.123400'

10 rows fetched.

SQL> select f13 from func_idx_basic_tab where nvl2(f13, f13, '-1234 0:0:0.0004') >= '100 10:0:0.0004' and nvl2(f13, f13, '-1234 0:0:0.0004') <= '+0001231 12:03:04.123400' order by f13;

F13                     
------------------------
+0001231 12:03:04.123400

1 rows fetched.

SQL> 
SQL> explain select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') = '10-11';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_15      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(F14, F14, '11-10') = '10-11'                

10 rows fetched.

SQL> select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') = '10-11';

F14       
----------
+010-11   

1 rows fetched.

SQL> explain select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') > '10-11' and nvl2(f14, f14, '11-10') <= '+120-11' order by f14;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_15      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F14, F14, '11-10') > '10-11' AND NVL2(F14, F14, '11-10') <= '+120-11'

11 rows fetched.

SQL> select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') > '10-11' and nvl2(f14, f14, '11-10') <= '+120-11' order by f14;

F14       
----------
+100-02   
+100-02   
+120-11   
          
          

5 rows fetched.

SQL> explain select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') < '+100-02' or nvl2(f14, f14, '11-10') >= '+120-11' order by f14;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_15      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F14, F14, '11-10') < '+100-02' OR NVL2(F14, F14, '11-10') >= '+120-11'

11 rows fetched.

SQL> select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') < '+100-02' or nvl2(f14, f14, '11-10') >= '+120-11' order by f14;

F14       
----------
+010-02   
+010-11   
+120-11   
+999-11   
          
          

6 rows fetched.

SQL> explain select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') between '+100-02' and '+120-11' order by f14;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_15      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(F14, F14, '11-10') BETWEEN '+100-02' AND '+120-11'

11 rows fetched.

SQL> select f14 from func_idx_basic_tab where nvl2(f14, f14, '11-10') between '+100-02' and '+120-11' order by f14;

F14       
----------
+100-02   
+100-02   
+120-11   

3 rows fetched.

SQL> 
SQL> 
SQL> 
SQL> -- test substr function index
SQL> drop table if exists substr_idx_tab;

Succeed.

SQL> create table substr_idx_tab (f1 varchar(30), f2 varchar(40));

Succeed.

SQL> insert into substr_idx_tab values ('abc', 'beijing');

1 rows affected.

SQL> insert into substr_idx_tab values ('abc', 'nanjingnan');

1 rows affected.

SQL> insert into substr_idx_tab values ('Def', 'shanghai');

1 rows affected.

SQL> insert into substr_idx_tab values (null, 'guangzhou');

1 rows affected.

SQL> insert into substr_idx_tab values ('substr function index', 'nanjing');

1 rows affected.

SQL> insert into substr_idx_tab values ('test', 'shenzhen');

1 rows affected.

SQL> commit;

Succeed.

SQL> create index ix_substr_tab_1 on substr_idx_tab (substr(f1, 2, 5));

Succeed.

SQL> create index ix_substr_tab_2 on substr_idx_tab (substr(f1, 1, 3), f2);

Succeed.

SQL> create index ix_substr_tab_3 on substr_idx_tab (f2, substr(f1, 1, 3));

Succeed.

SQL> create index ix_substr_tab_2 on substr_idx_tab (substr(f2, 1, 1)); -- oralce can create succeed

CT-00753, The object index IX_SUBSTR_TAB_2 already exists.
SQL> explain select * from substr_idx_tab where substr(f1, 2, 5) = 'bc';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SUBSTR_IDX_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_SUBSTR_TAB_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: SUBSTR(F1, 2, 5) = 'bc'                          

10 rows fetched.

SQL> explain select * from substr_idx_tab where substr(f1, 2, 6) = 'dk';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SUBSTR_IDX_TAB |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: SUBSTR(F1, 2, 6) = 'dk'                          

9 rows fetched.

SQL> explain select * from substr_idx_tab where substr(f1, 2, 5) like 'bdaf%';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SUBSTR_IDX_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_SUBSTR_TAB_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: SUBSTR(F1, 2, 5) LIKE 'bdaf%'                    

10 rows fetched.

SQL> explain select * from substr_idx_tab where substr(f1, 1, 3) = 'abc';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | SUBSTR_IDX_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_SUBSTR_TAB_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: SUBSTR(F1, 1, 3) = 'abc'                         

10 rows fetched.

SQL> 
SQL> select * from substr_idx_tab where substr(f1, 2, 5) = 'bc';

F1                             F2                                      
------------------------------ ----------------------------------------
abc                            beijing                                 
abc                            nanjingnan                              

2 rows fetched.

SQL> select * from substr_idx_tab where substr(f1, 2, 5) >= 'ef' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
Def                            shanghai                                
substr function index          nanjing                                 
test                           shenzhen                                

3 rows fetched.

SQL> select * from substr_idx_tab where substr(f1, 2, 5) like 'bc%' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
abc                            beijing                                 
abc                            nanjingnan                              

2 rows fetched.

SQL> select * from substr_idx_tab where substr(f1, 2, 5) between 'bc%' and 'test' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
Def                            shanghai                                
test                           shenzhen                                

2 rows fetched.

SQL> select * from substr_idx_tab where substr(f1, 1, 3) = 'abc' order by f2;

F1                             F2                                      
------------------------------ ----------------------------------------
abc                            beijing                                 
abc                            nanjingnan                              

2 rows fetched.

SQL> 
SQL> -- test to_date function index
SQL> drop table if exists to_date_tab;

Succeed.

SQL> create table to_date_tab(f1 varchar(30), f2 number);

Succeed.

SQL> create index ix_to_date_1 on to_date_tab(to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF'));

Succeed.

SQL> create index ix_to_date_2 on to_date_tab(to_date(f2, 'YYYYMMDD HH24MISS'));

Succeed.

SQL> 
SQL> insert into to_date_tab values ('2009-10-01 00:00:00:00', 20091001000000);

1 rows affected.

SQL> insert into to_date_tab values ('2012-05-28 12:00:00:59', 20120528120000);

1 rows affected.

SQL> insert into to_date_tab values ('2015-08-28 12:00:00:59', 20150828120059);

1 rows affected.

SQL> insert into to_date_tab values ('2019-12-31 12:59:59:59', 20191231125959);

1 rows affected.

SQL> insert into to_date_tab values ('2020-02-02 23:59:59:59', 20200202235959);

1 rows affected.

SQL> 
SQL> commit;

Succeed.

SQL> insert into to_date_tab values ('2020-02-02 12:59:59:59-', 20191231125959); --error

CT-00105, [1:1]Invalid format of datetime
SQL> insert into to_date_tab values ('2020-02-02 12:59:59:59', 20191231125960); --error

CT-00105, [1:1]Invalid format of datetime
SQL> explain select * from to_date_tab where f1 = '2015-08-28 12:00:00:59';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------
| Id  | Description          | Owner | Name        | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |             |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TO_DATE_TAB |      |      |       |        |
-----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F1 = '2015-08-28 12:00:00:59'                    

9 rows fetched.

SQL> select * from to_date_tab where f1 = '2015-08-28 12:00:00:59'; -- can also use the function index

F1                             F2                                      
------------------------------ ----------------------------------------
2015-08-28 12:00:00:59         20150828120059                          

1 rows fetched.

SQL> explain select * from to_date_tab where to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') < '2012-05-28 12:00:00' or to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') >= '2019-12-31 12:59:59';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_DATE_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_DATE_1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_DATE(F1, 'YYYY-MM-DD HH24:MI:SS:FF') < CAST('2012-05-28 12:00:00' AS DATE) OR TO_DATE(F1, 
               'YYYY-MM-DD HH24:MI:SS:FF') >= CAST('2019-12-31 12:59:59' AS DATE)

11 rows fetched.

SQL> select * from to_date_tab where to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') < '2012-05-28 12:00:00' or to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') >= '2019-12-31 12:59:59' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
2009-10-01 00:00:00:00         20091001000000                          
2019-12-31 12:59:59:59         20191231125959                          
2020-02-02 23:59:59:59         20200202235959                          

3 rows fetched.

SQL> explain select * from to_date_tab where to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') >= '2012-05-28 12:00:00' and to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') < '2019-12-31 12:59:59';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_DATE_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_DATE_1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_DATE(F1, 'YYYY-MM-DD HH24:MI:SS:FF') >= CAST('2012-05-28 12:00:00' AS DATE) AND TO_DATE(F1, 
               'YYYY-MM-DD HH24:MI:SS:FF') < CAST('2019-12-31 12:59:59' AS DATE)

11 rows fetched.

SQL> select * from to_date_tab where to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') >= '2012-05-28 12:00:00' and to_date(f1, 'YYYY-MM-DD HH24:MI:SS:FF') < '2019-12-31 12:59:59' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
2012-05-28 12:00:00:59         20120528120000                          
2015-08-28 12:00:00:59         20150828120059                          

2 rows fetched.

SQL> 
SQL> explain select * from to_date_tab where f2 = 20150828120059;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------
| Id  | Description          | Owner | Name        | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |             |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TO_DATE_TAB |      |      |       |        |
-----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F2 = 20150828120059                              

9 rows fetched.

SQL> explain select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') = '2015-08-28 12:00:59';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_DATE_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_DATE_2 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_DATE(F2, 'YYYYMMDD HH24MISS') = CAST('2015-08-28 12:00:59' AS DATE)

10 rows fetched.

SQL> select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') = '2015-08-28 12:00:59';

F1                             F2                                      
------------------------------ ----------------------------------------
2015-08-28 12:00:00:59         20150828120059                          

1 rows fetched.

SQL> explain select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') < '2012-05-28 12:00:00' or to_date(f2, 'YYYYMMDD HH24MISS') >= '2019-12-31 12:59:59' order by f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TO_DATE_TAB  |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_TO_DATE_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TO_DATE(F2, 'YYYYMMDD HH24MISS') < CAST('2012-05-28 12:00:00' AS DATE) OR TO_DATE(F2, 'YYYYMMDD HH24MISS') >= CAST('2019-12-31 12:59:59' AS 
               DATE)                                            

12 rows fetched.

SQL> select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') < '2012-05-28 12:00:00' or to_date(f2, 'YYYYMMDD HH24MISS') >= '2019-12-31 12:59:59' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
2009-10-01 00:00:00:00         20091001000000                          
2019-12-31 12:59:59:59         20191231125959                          
2020-02-02 23:59:59:59         20200202235959                          

3 rows fetched.

SQL> explain select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') >= '2012-05-28 12:00:00' and to_date(f2, 'YYYYMMDD HH24MISS') < '2020-02-02 23:59:59' order by f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TO_DATE_TAB  |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_TO_DATE_2 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TO_DATE(F2, 'YYYYMMDD HH24MISS') >= CAST('2012-05-28 12:00:00' AS DATE) AND TO_DATE(F2, 
               'YYYYMMDD HH24MISS') < CAST('2020-02-02 23:59:59' AS DATE)

12 rows fetched.

SQL> select * from to_date_tab where to_date(f2, 'YYYYMMDD HH24MISS') >= '2012-05-28 12:00:00' and to_date(f2, 'YYYYMMDD HH24MISS') < '2020-02-02 23:59:59' order by f1;

F1                             F2                                      
------------------------------ ----------------------------------------
2012-05-28 12:00:00:59         20120528120000                          
2015-08-28 12:00:00:59         20150828120059                          
2019-12-31 12:59:59:59         20191231125959                          

3 rows fetched.

SQL> 
SQL> -- test trunc function index
SQL> drop table if exists trunc_tab;

Succeed.

SQL> create table trunc_tab (f1 number);

Succeed.

SQL> insert into trunc_tab values (14563.45);

1 rows affected.

SQL> insert into trunc_tab values (34354.43234);

1 rows affected.

SQL> insert into trunc_tab values (35435.3472);

1 rows affected.

SQL> insert into trunc_tab values (3422540.2404);

1 rows affected.

SQL> insert into trunc_tab values (40.240);

1 rows affected.

SQL> insert into trunc_tab values (278.45);

1 rows affected.

SQL> insert into trunc_tab values (145323);

1 rows affected.

SQL> commit;

Succeed.

SQL> create index ix_trunc_tab on trunc_tab (trunc(f1, 2));

Succeed.

SQL> explain select * from trunc_tab where trunc(f1,2) = 35435.34;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TRUNC_TAB    |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TRUNC_TAB |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TRUNC(F1, 2) = 35435.34                          

10 rows fetched.

SQL> select * from trunc_tab where trunc(f1,2) = 35435.34 order by f1;

F1                                      
----------------------------------------
35435.3472                              

1 rows fetched.

SQL> explain select * from trunc_tab where trunc(f1,2) > 278.40 and trunc(f1,2) <= 145323;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TRUNC_TAB    |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TRUNC_TAB |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TRUNC(F1, 2) > 278.4 AND TRUNC(F1, 2) <= 145323  

10 rows fetched.

SQL> select * from trunc_tab where trunc(f1,2) > 278.40 and trunc(f1,2) <= 145323 order by f1;

F1                                      
----------------------------------------
278.45                                  
14563.45                                
34354.43234                             
35435.3472                              
145323                                  

5 rows fetched.

SQL> explain select * from trunc_tab where trunc(f1,2) > 35435.3 or trunc(f1,2) <= 278.454 order by f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |              |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |              |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TRUNC_TAB    |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_TRUNC_TAB |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TRUNC(F1, 2) > 35435.3 OR TRUNC(F1, 2) <= 278.454

11 rows fetched.

SQL> select * from trunc_tab where trunc(f1,2) > 35435.3 or trunc(f1,2) <= 278.454 order by f1;

F1                                      
----------------------------------------
40.24                                   
278.45                                  
35435.3472                              
145323                                  
3422540.2404                            

5 rows fetched.

SQL> explain select * from trunc_tab where trunc(f1,2) in (14563.45, 145323, 3422540.240);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TRUNC_TAB    |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | IX_TRUNC_TAB |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TRUNC(F1, 2) IN(14563.45, 145323, 3422540.24)    

10 rows fetched.

SQL> select * from trunc_tab where trunc(f1,2) in (14563.45, 145323, 3422540.240);

F1                                      
----------------------------------------
14563.45                                
145323                                  
3422540.2404                            

3 rows fetched.

SQL> 
SQL> -- test to_number function index
SQL> drop table if exists to_number_tab;

Succeed.

SQL> create table to_number_tab(f1 varchar(30));

Succeed.

SQL> create index ix_to_number_1 on to_number_tab (to_number(f1, 'XXXXXXX'));

Succeed.

SQL> insert into to_number_tab values ('ABCfd00');

1 rows affected.

SQL> insert into to_number_tab values ('FA00340');

1 rows affected.

SQL> insert into to_number_tab values ('123E500');

1 rows affected.

SQL> insert into to_number_tab values ('1456A00');

1 rows affected.

SQL> insert into to_number_tab values ('213AD00');

1 rows affected.

SQL> insert into to_number_tab values ('12DE500');

1 rows affected.

SQL> insert into to_number_tab values ('123.500'); -- error format

CT-00636, [1:11]Invalid number -- unexpected character
SQL> insert into to_number_tab values ('123H500'); -- error format

CT-00636, [1:11]Invalid number -- unexpected character
SQL> 
SQL> explain select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') = 19129600;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_NUMBER_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_NUMBER_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_NUMBER(F1, 'XXXXXXX') = 19129600              

10 rows fetched.

SQL> select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') = 19129600;

F1                             TO_NUMBER(F1, 'XXXXXXX')                
------------------------------ ----------------------------------------
123E500                        19129600                                

1 rows fetched.

SQL> explain select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') <= 21326336 order by 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_NUMBER_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_NUMBER_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_NUMBER(F1, 'XXXXXXX') <= 21326336             

10 rows fetched.

SQL> select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') <= 21326336 order by 2;

F1                             TO_NUMBER(F1, 'XXXXXXX')                
------------------------------ ----------------------------------------
123E500                        19129600                                
12DE500                        19784960                                
1456A00                        21326336                                

3 rows fetched.

SQL> explain select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') > 19784960 and to_number(f1, 'XXXXXXX') <= 180157696order by 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TO_NUMBER_TAB  |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_TO_NUMBER_1 |      |      |       |        |
------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TO_NUMBER(F1, 'XXXXXXX') > 19784960 AND TO_NUMBER(F1, 'XXXXXXX') <= 180157696

10 rows fetched.

SQL> select f1, to_number(f1, 'XXXXXXX') from to_number_tab where to_number(f1, 'XXXXXXX') > 19784960 and to_number(f1, 'XXXXXXX') <= 180157696order by 2;

F1                             TO_NUMBER(F1, 'XXXXXXX')                
------------------------------ ----------------------------------------
1456A00                        21326336                                
213AD00                        34843904                                
ABCfd00                        180157696                               

3 rows fetched.

SQL> 
SQL> -- test lower function index
SQL> create index ix_nvl_tab_16 on func_idx_basic_tab (lower(f5));

Succeed.

SQL> explain select f5 from func_idx_basic_tab where lower(f5) = 'master';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_16      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: LOWER(F5) = 'master'                             

10 rows fetched.

SQL> select f5 from func_idx_basic_tab where lower(f5) = 'master';

F5                            
------------------------------
MASTER                        

1 rows fetched.

SQL> 
SQL> -- test REGEXP_INSTR function index
SQL> insert into func_idx_basic_tab (f5) values ('17,20,23');

1 rows affected.

SQL> insert into func_idx_basic_tab (f5) values ('abasd,fdjsalfj,fjdlsaj');

1 rows affected.

SQL> insert into func_idx_basic_tab (f5) values (',fejljf,fjdls,1232');

1 rows affected.

SQL> insert into func_idx_basic_tab (f5) values (',fdsaf,17,20wour4389,2r4jfos,');

1 rows affected.

SQL> insert into func_idx_basic_tab (f5) values ('fewfd,fewqff325,frewg523,');

1 rows affected.

SQL> insert into func_idx_basic_tab (f5) values ('ferf1d5,fdsafd5416,fdsagra156a');

1 rows affected.

SQL> create index ix_nvl_tab_17 on func_idx_basic_tab (regexp_instr(f5, '[^,]+',1,3,0,'i'));

Succeed.

SQL> explain select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') = 16 order by 3,2,1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_17      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_INSTR(F5, '[^,]+', 1, 3, 0, 'i') = 16     

11 rows fetched.

SQL> select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') = 16 order by 3,2,1;

F1           F5                             REGEXP_INSTR(F5, '[^,]+',1,3,0,'I')
------------ ------------------------------ -----------------------------------
             abasd,fdjsalfj,fjdlsaj         16                                 

1 rows fetched.

SQL> explain select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') >= 11 and regexp_instr(f5, '[^,]+',1,3,0,'i') < 17 order by 3,2,1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_17      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_INSTR(F5, '[^,]+', 1, 3, 0, 'i') >= 11 AND REGEXP_INSTR(F5, '[^,]+', 1, 3, 0, 'i') < 17

11 rows fetched.

SQL> select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') >= 11 and regexp_instr(f5, '[^,]+',1,3,0,'i') < 17 order by 3,2,1;

F1           F5                             REGEXP_INSTR(F5, '[^,]+',1,3,0,'I')
------------ ------------------------------ -----------------------------------
             ,fdsaf,17,20wour4389,2r4jfos,  11                                 
             ,fejljf,fjdls,1232             15                                 
             abasd,fdjsalfj,fjdlsaj         16                                 

3 rows fetched.

SQL> explain select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') < 11 or regexp_instr(f5, '[^,]+',1,3,0,'i') >= 17 order by 3,2,1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_17      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_INSTR(F5, '[^,]+', 1, 3, 0, 'i') < 11 OR REGEXP_INSTR(F5, '[^,]+', 1, 3, 0, 'i') >= 17

11 rows fetched.

SQL> select f1, f5, regexp_instr(f5, '[^,]+',1,3,0,'i') from func_idx_basic_tab where regexp_instr(f5, '[^,]+',1,3,0,'i') < 11 or regexp_instr(f5, '[^,]+',1,3,0,'i') >= 17 order by 3,2,1;

F1           F5                             REGEXP_INSTR(F5, '[^,]+',1,3,0,'I')
------------ ------------------------------ -----------------------------------
1            INDEX                          0                                  
5            MASTER                         0                                  
0            PKG                            0                                  
3            REGRESS                        0                                  
4            code                           0                                  
-1           function                       0                                  
             sql                            0                                  
2            test                           0                                  
             17,20,23                       7                                  
             fewfd,fewqff325,frewg523,      17                                 
             ferf1d5,fdsafd5416,fdsagra156a 20                                 

11 rows fetched.

SQL> 
SQL> -- test regexp_substr function index
SQL> create index ix_nvl_tab_18 on func_idx_basic_tab (regexp_substr(f5, '[^,]+',1,3,'i'));

Succeed.

SQL> explain select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') is null order by 2, 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_18      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') IS NULL    

11 rows fetched.

SQL> select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') is null order by 2, 1;

F1           F5                             REGEXP_SUBSTR(F5, '[^,]+',1,3,'I')
------------ ------------------------------ ----------------------------------
1            INDEX                                                            
5            MASTER                                                           
0            PKG                                                              
3            REGRESS                                                          
4            code                                                             
-1           function                                                         
             sql                                                              
2            test                                                             

8 rows fetched.

SQL> explain select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') = 'fjdlsaj' order by 2, 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_18      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') = 'fjdlsaj'

11 rows fetched.

SQL> select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') = 'fjdlsaj' order by 2, 1;

F1           F5                             REGEXP_SUBSTR(F5, '[^,]+',1,3,'I')
------------ ------------------------------ ----------------------------------
             abasd,fdjsalfj,fjdlsaj         fjdlsaj                           

1 rows fetched.

SQL> explain select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') >= '23' and regexp_substr(f5, '[^,]+',1,3,'i') < 'frewg523' order by 3, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_18      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') >= '23' AND REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') < 'frewg523'

11 rows fetched.

SQL> select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') >= '23' and regexp_substr(f5, '[^,]+',1,3,'i') < 'frewg523' order by 3, 2;

F1           F5                             REGEXP_SUBSTR(F5, '[^,]+',1,3,'I')
------------ ------------------------------ ----------------------------------
             17,20,23                       23                                
             ferf1d5,fdsafd5416,fdsagra156a fdsagra156a                       
             abasd,fdjsalfj,fjdlsaj         fjdlsaj                           

3 rows fetched.

SQL> explain select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') < '23' or regexp_substr(f5, '[^,]+',1,3,'i') >= 'frewg523' order by 3, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_18      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') < '23' OR REGEXP_SUBSTR(F5, '[^,]+', 1, 3, 'i') >= 'frewg523'

11 rows fetched.

SQL> select f1, f5, regexp_substr(f5, '[^,]+',1,3,'i') from func_idx_basic_tab where regexp_substr(f5, '[^,]+',1,3,'i') < '23' or regexp_substr(f5, '[^,]+',1,3,'i') >= 'frewg523' order by 3, 2;

F1           F5                             REGEXP_SUBSTR(F5, '[^,]+',1,3,'I')
------------ ------------------------------ ----------------------------------
             ,fejljf,fjdls,1232             1232                              
             ,fdsaf,17,20wour4389,2r4jfos,  20wour4389                        
             fewfd,fewqff325,frewg523,      frewg523                          

3 rows fetched.

SQL> 
SQL> -- test trim function index
SQL> create index ix_nvl_tab_19 on func_idx_basic_tab (trim(leading f5 from 'apockf'));

Succeed.

SQL> explain select f5, trim(leading f5 from 'apockf') from func_idx_basic_tab where trim(leading f5 from 'apockf') = 'apockf' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_19      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TRIM('apockf', F5) = 'apockf'                    

11 rows fetched.

SQL> select f5, trim(leading f5 from 'apockf') from func_idx_basic_tab where trim(leading f5 from 'apockf') = 'apockf' order by 1;

F5                             TRIM(LEADING F5 FROM 'APOCKF')
------------------------------ ------------------------------
,fejljf,fjdls,1232             apockf                        
17,20,23                       apockf                        
INDEX                          apockf                        
MASTER                         apockf                        
PKG                            apockf                        
REGRESS                        apockf                        
code                           apockf                        
fewfd,fewqff325,frewg523,      apockf                        
function                       apockf                        
sql                            apockf                        
test                           apockf                        

11 rows fetched.

SQL> explain select f5, trim(leading f5 from 'apockf') from func_idx_basic_tab where trim(leading f5 from 'apockf') like 'poc%' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_19      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TRIM('apockf', F5) LIKE 'poc%'                   

11 rows fetched.

SQL> select f5, trim(leading f5 from 'apockf') from func_idx_basic_tab where trim(leading f5 from 'apockf') like 'poc%' order by 1;

F5                             TRIM(LEADING F5 FROM 'APOCKF')
------------------------------ ------------------------------
,fdsaf,17,20wour4389,2r4jfos,  pockf                         
abasd,fdjsalfj,fjdlsaj         pockf                         
ferf1d5,fdsafd5416,fdsagra156a pockf                         

3 rows fetched.

SQL> create index ix_nvl_tab_20 on func_idx_basic_tab (trim(both ',apock137' from f5));

Succeed.

SQL> explain select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) = '20,2' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_20      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TRIM(F5, ',apock137') = '20,2'                   

11 rows fetched.

SQL> select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) = '20,2' order by 1;

F5                             TRIM(BOTH ',APOCK137' FROM F5)
------------------------------ ------------------------------
17,20,23                       20,2                          

1 rows fetched.

SQL> explain select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) like 'f%' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_20      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: TRIM(F5, ',apock137') LIKE 'f%'                  

11 rows fetched.

SQL> select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) like 'f%' order by 1;

F5                             TRIM(BOTH ',APOCK137' FROM F5)
------------------------------ ------------------------------
,fdsaf,17,20wour4389,2r4jfos,  fdsaf,17,20wour4389,2r4jfos   
,fejljf,fjdls,1232             fejljf,fjdls,1232             
ferf1d5,fdsafd5416,fdsagra156a ferf1d5,fdsafd5416,fdsagra156 
fewfd,fewqff325,frewg523,      fewfd,fewqff325,frewg52       
function                       function                      

5 rows fetched.

SQL> explain select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) > 'de' and trim(both ',apock137' from f5) <= 'indfx' order by 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_20      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: TRIM(F5, ',apock137') > 'de' AND TRIM(F5, ',apock137') <= 'indfx'

10 rows fetched.

SQL> select f5, trim(both ',apock137' from f5) from func_idx_basic_tab where trim(both ',apock137' from f5) > 'de' and trim(both ',apock137' from f5) <= 'indfx' order by 2;

F5                             TRIM(BOTH ',APOCK137' FROM F5)
------------------------------ ------------------------------
,fdsaf,17,20wour4389,2r4jfos,  fdsaf,17,20wour4389,2r4jfos   
,fejljf,fjdls,1232             fejljf,fjdls,1232             
ferf1d5,fdsafd5416,fdsagra156a ferf1d5,fdsafd5416,fdsagra156 
fewfd,fewqff325,frewg523,      fewfd,fewqff325,frewg52       
function                       function                      

5 rows fetched.

SQL> 
SQL> -- test decode function index
SQL> create index ix_nvl_tab_21 on func_idx_basic_tab (decode(f1, -1, 100, 0, 200, 2, 300, 400));

Succeed.

SQL> explain select f1, decode(f1, -1, 100, 0, 200, 2, 300, 400) from func_idx_basic_tab where decode(f1, -1, 100, 0, 200, 2, 300, 400) = 200 order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_21      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: DECODE(F1, -1, 100, 0, 200, 2, 300, 400) = 200   

11 rows fetched.

SQL> select f1, decode(f1, -1, 100, 0, 200, 2, 300, 400) from func_idx_basic_tab where decode(f1, -1, 100, 0, 200, 2, 300, 400) = 200 order by 1, 2;

F1           DECODE(F1, -1, 100, 0, 200, 2, 300, 400)
------------ ----------------------------------------
0            200                                     

1 rows fetched.

SQL> explain select f1, decode(f1, -1, 100, 0, 200, 2, 300, 400) from func_idx_basic_tab where decode(f1, -1, 100, 0, 200, 2, 300, 400) >= 200 and decode(f1, -1, 100, 0, 200, 2, 300, 400) < 400 order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_21      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: DECODE(F1, -1, 100, 0, 200, 2, 300, 400) >= 200 AND DECODE(F1, -1, 100, 0, 200, 2, 300, 
               400) < 400                                       

12 rows fetched.

SQL> select f1, decode(f1, -1, 100, 0, 200, 2, 300, 400) from func_idx_basic_tab where decode(f1, -1, 100, 0, 200, 2, 300, 400) >= 200 and decode(f1, -1, 100, 0, 200, 2, 300, 400) < 400 order by 1, 2;

F1           DECODE(F1, -1, 100, 0, 200, 2, 300, 400)
------------ ----------------------------------------
0            200                                     
2            300                                     

2 rows fetched.

SQL> 
SQL> create index ix_nvl_tab_22 on func_idx_basic_tab (decode(-1, f1, 0, 0, f1, 2));

Succeed.

SQL> create index ix_nvl_tab_23 on func_idx_basic_tab (decode(-1, f1, 0, 0, f2, 2)); -- not support now

CT-00601, Sql syntax error: multiple columns found in function index
SQL> explain select f1, decode(-1, f1, 0, 0, f1, 2) from func_idx_basic_tab where decode(-1, f1, 0, 0, f1, 2) = 0 order by f1, f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_22      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: DECODE(-1, F1, 0, 0, F1, 2) = 0                  

11 rows fetched.

SQL> explain select f1, decode(-1, f1, 0, 0, f1, 2) from func_idx_basic_tab where decode(-1, f1, 0, 0, f1, 2) > 3 order by f1, f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_22      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: DECODE(-1, F1, 0, 0, F1, 2) > 3                  

11 rows fetched.

SQL> select f1, decode(-1, f1, 0, 0, f1, 2) from func_idx_basic_tab where decode(-1, f1, 0, 0, f1, 2) > 3 order by f1, f2;

F1           DECODE(-1, F1, 0, 0, F1, 2)
------------ ---------------------------

0 rows fetched.

SQL> 
SQL> -- test case when
SQL> create index ix_nvl_tab_24 on func_idx_basic_tab (case f1 when -1 then 'abc' when 1 then 'def' when null then 'null' else 'ok' end);

Succeed.

SQL> explain select * from (select f1, case f1 when -1 then 'abc' when 1 then 'def' when null then 'null' else 'ok' end as result from func_idx_basic_tab) where result = 'def';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_24      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE F1 WHEN -1 THEN 'abc' WHEN 1 THEN 'def' WHEN NULL THEN 'null' ELSE 'ok' END = 'def'

10 rows fetched.

SQL> select * from (select f1, case f1 when -1 then 'abc' when 1 then 'def' when null then 'null' else 'ok' end as result from func_idx_basic_tab) where result = 'def';

F1           RESULT
------------ ------
1            def   

1 rows fetched.

SQL> explain select * from (select f1, case f1 when -1 then 'abc' when 1 then 'def' when null then 'null' else 'ok' end as result from func_idx_basic_tab) where result like 'abc%';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_24      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE F1 WHEN -1 THEN 'abc' WHEN 1 THEN 'def' WHEN NULL THEN 'null' ELSE 'ok' END LIKE 'abc%'

10 rows fetched.

SQL> select * from (select f1, case f1 when -1 then 'abc' when 1 then 'def' when null then 'null' else 'ok' end as result from func_idx_basic_tab) where result like 'abc%';

F1           RESULT
------------ ------
-1           abc   

1 rows fetched.

SQL> 
SQL> create index ix_nvl_tab_25 on func_idx_basic_tab (case when f1 = -1 then 'abc' when f1=1 then 'def' when f1 is null then 'null' else 'ok' end);

Succeed.

SQL> explain select * from (select f1, case when f1 = -1 then 'abc' when f1=1 then 'def' when f1 is null then 'null' else 'ok' end as result from func_idx_basic_tab) where result = 'def';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_25      |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE  WHEN F1 = -1 THEN 'abc' WHEN F1 = 1 THEN 'def' WHEN F1 IS NULL THEN 'null' ELSE 'ok' END = 'def'

10 rows fetched.

SQL> select * from (select f1, case when f1 = -1 then 'abc' when f1=1 then 'def' when f1 is null then 'null' else 'ok' end as result from func_idx_basic_tab) where result = 'def';

F1           RESULT
------------ ------
1            def   

1 rows fetched.

SQL> explain select * from (select f1, case when f1 = -1 then 'abc' when f1=1 then 'def' when f1 is null then 'null' else 'ok' end as result from func_idx_basic_tab) where result like 'o%' order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IX_NVL_TAB_25      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: CASE  WHEN F1 = -1 THEN 'abc' WHEN F1 = 1 THEN 'def' WHEN F1 IS NULL THEN 'null' ELSE 'ok' END LIKE 'o%'

11 rows fetched.

SQL> select * from (select f1, case when f1 = -1 then 'abc' when f1=1 then 'def' when f1 is null then 'null' else 'ok' end as result from func_idx_basic_tab) where result like 'o%' order by 1, 2;

F1           RESULT
------------ ------
0            ok    
2            ok    
3            ok    
4            ok    
5            ok    

5 rows fetched.

SQL> 
SQL> explain select f1 from func_idx_basic_tab where f1 is null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name               | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                    |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_IDX_BASIC_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IX_NVL_TAB_2       |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: F1 IS NULL                                       

10 rows fetched.

SQL> select f1 from func_idx_basic_tab where f1 is null;

F1          
------------
            
            
            
            
            
            
            

7 rows fetched.

SQL> 
SQL> -- not support
SQL> create index ix_nvl_tab_26 on func_idx_basic_tab (case when f8 = systimestamp then 'abc' else 'def' end); -- error

CT-00601, [1:66]Sql syntax error: unexpect word
SQL> 
SQL> -- temp table
SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED = TRUE;

Succeed.

SQL> create table #func_t1(i varchar(30), id int);

CT-00601, [1:14]Sql syntax error: table name is invalid
SQL> create index idx_t1 on #func_t1(case when i='abc' then 'def' else 'dfds' end); -- error

CT-00843, The table or view SYS.#FUNC_T1 does not exist.
SQL> drop table #func_t1;

CT-00843, The table or view SYS.#FUNC_T1 does not exist.
SQL> alter system set LOCAL_TEMPORARY_TABLE_ENABLED = FALSE;

Succeed.

SQL> 
SQL> -- global temp table
SQL> drop table if exists temp_func_1;

Succeed.

SQL> create global temporary table temp_func_1 (id1 varchar(2) not null, id2 varchar(2)) on commit preserve rows;

Succeed.

SQL> insert into temp_func_1 values ('a', 'a');

1 rows affected.

SQL> insert into temp_func_1 values ('a', 'b');

1 rows affected.

SQL> insert into temp_func_1 values ('a', null);

1 rows affected.

SQL> insert into temp_func_1 values ('b', '');

1 rows affected.

SQL> create index idx_temp_1 on temp_func_1(nvl2(id2, id2, 'kk'));

Succeed.

SQL> explain select * from temp_func_1 where nvl2(id2, id2, 'kk') = 'kk' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name        | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |             |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |             |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP_FUNC_1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEMP_1  |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NVL2(ID2, ID2, 'kk') = 'kk'                      

11 rows fetched.

SQL> select * from temp_func_1 where nvl2(id2, id2, 'kk') = 'kk' order by 1;

ID1 ID2
--- ---
a      
b      

2 rows fetched.

SQL> create index idx_temp_2 on temp_func_1(case id1 when 'a' then 'A' else 'B' end);

Succeed.

SQL> explain select * from temp_func_1 where case id1 when 'a' then 'A' else 'B' end = 'A' order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name        | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |             |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |             |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP_FUNC_1 |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_TEMP_2  |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: CASE ID1 WHEN 'a' THEN 'A' ELSE 'B' END = 'A'    

11 rows fetched.

SQL> select * from temp_func_1 where case id1 when 'a' then 'A' else 'B' end = 'A' order by 1, 2;

ID1 ID2
--- ---
a   a  
a   b  
a      

3 rows fetched.

SQL> explain update temp_func_1 set id1 = 'k' where nvl2(id2, id2, 'kk') = 'kk';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT               |       |             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP_FUNC_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_TEMP_1  |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL2(ID2, ID2, 'kk') = 'kk'                      

10 rows fetched.

SQL> explain update temp_func_1 set id1 = 'k' where case id1 when 'a' then 'A' else 'B' end = 'A';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT               |       |             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP_FUNC_1 |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_TEMP_2  |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE ID1 WHEN 'a' THEN 'A' ELSE 'B' END = 'A'    

10 rows fetched.

SQL> 
SQL> --partition table and local index
SQL> drop table if exists func_idx_part_tab;

Succeed.

SQL> create table func_idx_part_tab(i varchar(100), id int) partition by range (id)
  2 (
  3  PARTITION p1 values less than(10),
  4  PARTITION p2 values less than(20),
  5  PARTITION p3 values less than(30),
  6  PARTITION p4 values less than(MAXVALUE)
  7 );

Succeed.

SQL> insert into func_idx_part_tab values ('a', 1);

1 rows affected.

SQL> insert into func_idx_part_tab values ('asss', 15);

1 rows affected.

SQL> insert into func_idx_part_tab values ('', 25);

1 rows affected.

SQL> insert into func_idx_part_tab values (NULL, 35);

1 rows affected.

SQL> create index idx_part_tab_1 on func_idx_part_tab (case i when 'a' then 'A' else 'B' end) local;

Succeed.

SQL> alter table func_idx_part_tab modify i varchar(4000);

CT-00130, Operation modify column is not supported on functional index
SQL> explain select * from func_idx_part_tab where case i when 'a' then 'A' else 'B' end = 'A';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                   |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,4) | SYS   | FUNC_IDX_PART_TAB |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | IDX_PART_TAB_1    |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE I WHEN 'a' THEN 'A' ELSE 'B' END = 'A'      

10 rows fetched.

SQL> select * from func_idx_part_tab where case i when 'a' then 'A' else 'B' end = 'A';

I                                                                ID          
---------------------------------------------------------------- ------------
a                                                                1           

1 rows fetched.

SQL> alter table func_idx_part_tab modify i varchar(4); -- error

CT-00805, Column I is not empty in table FUNC_IDX_PART_TAB
SQL> alter table func_idx_part_tab rename column i to f1; -- not support

CT-00863, Cannot rename function index column I
SQL> alter table func_idx_part_tab modify i int;

CT-00805, Column I is not empty in table FUNC_IDX_PART_TAB
SQL> create index idx_loc_2 on func_idx_part_tab (decode(id, 1, 'abc', 2, 'def', 'null'));

Succeed.

SQL> alter table func_idx_part_tab modify id varchar(10);

CT-00805, Column ID is not empty in table FUNC_IDX_PART_TAB
SQL> truncate table func_idx_part_tab;

Succeed.

SQL> create index idx_loc_6 on func_idx_part_tab (upper(i));

Succeed.

SQL> alter table func_idx_part_tab modify i varchar(4000);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table func_idx_part_tab modify i varchar(4043);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table func_idx_part_tab modify i varchar(4042);

CT-00130, Operation modify column is not supported on functional index
SQL> 
SQL> -- check is the same index
SQL> create index idx_loc_2 on func_idx_part_tab (case i when  'a' then 'A' else 'B' end) local; -- error

CT-00726, The column has been indexed by IDX_PART_TAB_1.
SQL> create index idx_loc_2 on func_idx_part_tab (case I when  'a' then 'A' else 'B' end) local; -- error

CT-00726, The column has been indexed by IDX_PART_TAB_1.
SQL> create index idx_loc_2 on func_idx_part_tab (case I when  'a' then 'A' else 'C' end) local; -- succeed

CT-00753, The object index IDX_LOC_2 already exists.
SQL> create index idx_loc_3 on func_idx_part_tab (to_char(id + 1));

Succeed.

SQL> create index idx_loc_4 on func_idx_part_tab (to_char(id +1)); -- error

CT-00726, The column has been indexed by IDX_LOC_3.
SQL> create index idx_loc_4 on func_idx_part_tab (to_char(ID + 1)); -- error

CT-00726, The column has been indexed by IDX_LOC_3.
SQL> create index idx_loc_4 on func_idx_part_tab (id);

Succeed.

SQL> create index idx_loc_5 on func_idx_part_tab (id); -- error

CT-00726, The column has been indexed by IDX_LOC_4.
SQL> 
SQL> -- create function index on lob/array field
SQL> drop table if exists test_array_index_tab;

Succeed.

SQL> create table test_array_index_tab (f1 int, f2 varchar(30), f3 int[], f4 clob, f5 blob, f6 image);

Succeed.

SQL> create index ix_test_array_1 on test_array_index_tab (nvl2(f3, f3, '{12,34,42}')); -- error

CT-01366, [1:59]Invalid function argument type
SQL> create index ix_test_array_1 on test_array_index_tab (case f3 when '{12,34,42}' then null else array[1,3] end)); -- error

CT-00633, [1:55]Cannot create functional index on column with datatype 'ARRAY'
SQL> create index ix_test_array_1 on test_array_index_tab (case f1 when 1 then array[1,2] else array[3,4] end); -- error

CT-00633, [1:55]Cannot create functional index on column with datatype 'ARRAY'
SQL> create index ix_test_array_1 on test_array_index_tab (nvl(f4, 'abc'));

CT-00633, [1:55]Cannot create functional index on column with datatype 'CLOB'
SQL> create index ix_test_array_1 on test_array_index_tab (nvl(f5, 'abc'));

CT-00633, [1:55]Cannot create functional index on column with datatype 'BLOB'
SQL> create index ix_test_array_1 on test_array_index_tab (nvl(f6, 'abc'));

CT-00633, [1:55]Cannot create functional index on column with datatype 'IMAGE'
SQL> 
SQL> -- can not create function index on 2 different columns
SQL> drop table if exists tab_func_index_cols_test;

Succeed.

SQL> create table tab_func_index_cols_test (f1 int, "f2" int, "F2" varchar(30));

Succeed.

SQL> create index ix_cols_test_1 on tab_func_index_cols_test (f1, "f2");

Succeed.

SQL> create index ix_cols_test_2 on tab_func_index_cols_test (f1, "F2");

Succeed.

SQL> create index ix_cols_test_3 on tab_func_index_cols_test (f1, f2); -- conflict with ix_cols_test_2

CT-00726, The column has been indexed by IX_COLS_TEST_2.
SQL> create index ix_cols_test_4 on tab_func_index_cols_test (f1, F2); -- conflict with ix_cols_test_2

CT-00726, The column has been indexed by IX_COLS_TEST_2.
SQL> create index ix_cols_test_5 on tab_func_index_cols_test (f1, nvl2(f2, f2, 100));

Succeed.

SQL> create index ix_cols_test_6 on tab_func_index_cols_test (f1, nvl2("f2", "f2", 100));

Succeed.

SQL> create index ix_cols_test_7 on tab_func_index_cols_test (f1, nvl2("F2", "F2", 100)); -- conflict with ix_cols_test_5

CT-00726, The column has been indexed by IX_COLS_TEST_5.
SQL> create index ix_cols_test_8 on tab_func_index_cols_test (f1, nvl2(F2, F2, 100)); -- conflict with ix_cols_test_5

CT-00726, The column has been indexed by IX_COLS_TEST_5.
SQL> create index ix_cols_test_9 on tab_func_index_cols_test (f1, nvl2(F2, "f2", 100)); -- report error

CT-00601, Sql syntax error: multiple columns found in function index
SQL> create index ix_cols_test_9 on tab_func_index_cols_test (f1, nvl2("f2", "F2", 100)); -- report error

CT-00601, Sql syntax error: multiple columns found in function index
SQL> create index ix_cols_test_10 on tab_func_index_cols_test (f1, nvl2(f2, "F2", 100)); -- conflict with ix_cols_test_5

CT-00726, The column has been indexed by IX_COLS_TEST_5.
SQL> create index ix_cols_test_10 on tab_func_index_cols_test (f1, nvl2("F2", f2, 100)); -- conflict with ix_cols_test_5

CT-00726, The column has been indexed by IX_COLS_TEST_5.
SQL> 
SQL> drop table if exists t_fun_index_001;

Succeed.

SQL> create table t_fun_index_001(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10) not null,c_vchar2 varchar2(100),c_clob clob,
  4 c_long varchar(200),c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> insert into t_fun_index_001 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-03-05 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> 
SQL> create index idx_t_fun_index_001 on t_fun_index_001(case count(c_int) over() when 1007 then 'abc' else 'def' end,SUBSTR(c_vchar,2,3)); -- error

CT-01316, [1:58]Unexpected windows sort analytic function
SQL> create index idx_t_fun_index_001 on t_fun_index_001(case prior id when 1 then 'abc' else 'def' end); -- error

CT-00601, [1:58]Sql syntax error: 'prior' operator not allowed here
SQL> create index idx_t_fun_index_001 on t_fun_index_001(case when id in (select 1 from dual) then 'ab' else 'def' end); -- error

CT-01316, [1:77]Unexpected SUBSELECT
SQL> create index idx_t_fun_index_001 on t_fun_index_001(case when sys_connect_by_path(id, '/') = 'abc' then 1 else 2 end); -- error

CT-00243, [1:58]SYS_CONNECT_BY_PATH function is not allowed here.
SQL> create index idx_t_fun_index_001 on t_fun_index_001(case c_int when 1007 then 'abc' else 'def' end,case c_int when 1007 then 'abc' else 'def' end,SUBSTR(c_vchar,2,3)); --error

CT-00604, Duplicate column name case c_int when 1007 then 'abc' else 'def' end
SQL> create index idx_t_fun_index_001 on t_fun_index_001(SUBSTR(c_vchar,2,3),SUBSTR(c_vchar,2,3)); -error

CT-00604, Duplicate column name SUBSTR(c_vchar,2,3)
SQL> 
SQL> -- rollback test
SQL> DROP TABLE IF EXISTS t_function_index_004;

Succeed.

SQL> DROP TABLE IF EXISTS t_function_index_005;

Succeed.

SQL> CREATE TABLE t_function_index_004(staff_id INT NOT NULL, staff_name CHAR(50), job VARCHAR(30), bonus NUMBER);

Succeed.

SQL> CREATE TABLE t_function_index_005(staff_id INT NOT NULL, staff_name CHAR(50), job VARCHAR(30), bonus NUMBER);

Succeed.

SQL> CREATE INDEX idx_function_index_004_001 ON t_function_index_004(case staff_id when 21 then to_char(staff_id) else 999 end,NVL(staff_name,'2020-03-10'),case job when 'tester' then to_char(job) else 'doctor' end);

Succeed.

SQL> CREATE INDEX idx_function_index_005_001 ON t_function_index_005(case staff_id when 21 then to_char(staff_id) else 999 end,NVL(staff_name,'2020-03-10'),case job when 'tester' then to_char(job) else 'doctor' end,trim(to_char(bonus),'1'));

Succeed.

SQL> INSERT INTO t_function_index_004(staff_id, staff_name, job, bonus) VALUES(23,'wangxia','developer',5000);

1 rows affected.

SQL> INSERT INTO t_function_index_004(staff_id, staff_name, job, bonus) VALUES(24,'limingying','tester',7000);

1 rows affected.

SQL> INSERT INTO t_function_index_004(staff_id, staff_name, job, bonus) VALUES(25,'liulili','quality control',8000);

1 rows affected.

SQL> INSERT INTO t_function_index_004(staff_id, staff_name, job, bonus) VALUES(29,'liuxue','tester',8000);

1 rows affected.

SQL> INSERT INTO t_function_index_004(staff_id, staff_name, job, bonus) VALUES(21,'caoming','document developer',11000);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> INSERT INTO t_function_index_005(staff_id, staff_name, job, bonus) VALUES(23,'wangxia','developer',7000);

1 rows affected.

SQL> INSERT INTO t_function_index_005(staff_id, staff_name, job, bonus) VALUES(27,'wangxuefen','document developer',7000);

1 rows affected.

SQL> INSERT INTO t_function_index_005(staff_id, staff_name, job, bonus) VALUES(28,'denghui','quality control',8000);

1 rows affected.

SQL> INSERT INTO t_function_index_005(staff_id, staff_name, job, bonus) VALUES(25,'liulili','quality control',10000);

1 rows affected.

SQL> INSERT INTO t_function_index_005(staff_id, staff_name, job, bonus) VALUES(21,'caoming','document developer',12000);

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> MERGE INTO t_function_index_004 BD1 USING t_function_index_005 NBD1 ON (BD1.staff_id = NBD1.staff_id) WHEN MATCHED THEN UPDATE SET BD1.bonus = NBD1.bonus WHEN NOT MATCHED THEN INSERT (staff_id, staff_name, job, bonus) VALUES (NBD1.staff_id, NBD1.staff_name, NBD1.job, NBD1.bonus);

5 rows affected.

SQL> rollback;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS tb_func_idx_009;

Succeed.

SQL> CREATE TABLE tb_func_idx_009(
  2 COL_2 varchar(20),
  3 COL_3 varchar(20),
  4 COL_4 varchar(20),
  5 COL_6 char(30)
  6 );

Succeed.

SQL> insert into tb_func_idx_009 values(19947,446.255,97.02,'@@@abc');

1 rows affected.

SQL> CREATE INDEX idx_func_026 ON tb_func_idx_009(upper(SUBSTR(COL_6,2,3)),TRUNC(COL_3,1),to_char(DECODE(COL_2,10,'正确',12,'错误','unknown')) ,case SUBSTR(COL_4,2,4) when upper(SUBSTR(COL_4,2,3)) then to_char(DECODE(COL_4,10,'正确',12,'错误','unknown')) else 'def' end);

Succeed.

SQL> 
SQL> drop table if exists t_fun_index_101;

Succeed.

SQL> create table t_fun_index_101(id int,c_int int, constraint t_fun_index_101_con_pri primary key(c_int when c_int then c_int else c_int end)); -- error

CT-00601, Sql syntax error: invalid identifier
SQL> create table t_fun_index_101(id int,c_int int, constraint t_fun_index_101_con_pri primary key(id, c_int when c_int then c_int else c_int end)); -- error

CT-00601, Sql syntax error: invalid identifier
SQL> create table t_fun_index_101(id int,c_int int, constraint t_fun_index_101_con_pri primary key(upper(id))); -- error

CT-00601, Sql syntax error: invalid identifier
SQL> 
SQL> --DTS2020031903511
SQL> drop table if exists test_func_index_nvl2;

Succeed.

SQL> create table test_func_index_nvl2(id int);

Succeed.

SQL> create index ix_nvl2 on test_func_index_nvl2(nvl2(id, 1, 0));

Succeed.

SQL> insert into test_func_index_nvl2 values(1);

1 rows affected.

SQL> update test_func_index_nvl2 set id=2;

1 rows affected.

SQL> select * from test_func_index_nvl2 where nvl2(id, 1, 0)=0;

ID          
------------

0 rows fetched.

SQL> select * from test_func_index_nvl2 where nvl2(id, 1, 0)=1;

ID          
------------
2           

1 rows fetched.

SQL> update test_func_index_nvl2 set id=2;

1 rows affected.

SQL> select * from test_func_index_nvl2 where nvl2(id, 1, 0)=0;

ID          
------------

0 rows fetched.

SQL> select * from test_func_index_nvl2 where nvl2(id, 1, 0)=1;

ID          
------------
2           

1 rows fetched.

SQL> drop table test_func_index_nvl2;

Succeed.

SQL> 
SQL> -- DTS2020040308787
SQL> drop table if exists t_fun_index_1010;

Succeed.

SQL> create table t_fun_index_1010(id int);

Succeed.

SQL> create index idx_t_fun_index_1010_100001 on t_fun_index_1010(case when DBE_LOB.SUBSTR('123456',id,1)=SUBSTR('123456',id,1) then id end);

Succeed.

SQL> explain select * from t_fun_index_1010 where case when DBE_LOB.SUBSTR('123456',id,1)=SUBSTR('123456',id,1) then id end = 1020;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                        | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_FUN_INDEX_1010            |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_T_FUN_INDEX_1010_100001 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CASE  WHEN SUBSTR('123456', ID, 1) = SUBSTR('123456', ID, 1) THEN ID END = 1020

10 rows fetched.

SQL> 
SQL> 
SQL> --DTS20201110035W5TP0G00
SQL> drop table if exists func_index_upper;

Succeed.

SQL> create table func_index_upper(a varbinary(200), b int);

Succeed.

SQL> insert into func_index_upper values('a', 1);

1 rows affected.

SQL> create index func_index_upper_idx_1 on func_index_upper (upper(a));

Succeed.

SQL> create index func_index_upper_idx_2 on func_index_upper (a,b);

Succeed.

SQL> delete func_index_upper;

1 rows affected.

SQL> drop table func_index_upper;

Succeed.

SQL> 
SQL> -- func index only scan test start
SQL> drop table if exists func_index_only_scan;

Succeed.

SQL> create table func_index_only_scan (c_int int, c_vchar varchar(30), c_num number, c_float float, c_decimal decimal);

Succeed.

SQL> insert into func_index_only_scan values (1, 'ABC', 2000, 100.1, 100);

1 rows affected.

SQL> insert into func_index_only_scan values (1, 'def', 2001, 100.2, 300);

1 rows affected.

SQL> insert into func_index_only_scan values (2, 'AkF', 2002, 100.3, 400);

1 rows affected.

SQL> insert into func_index_only_scan values (2, 'ADD', 2004, 100.4, 500);

1 rows affected.

SQL> insert into func_index_only_scan values (3, 'fdj', 2004, 100.5, 600);

1 rows affected.

SQL> insert into func_index_only_scan values (3, 'fdj', 2004, 100.5, 700);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create index IDX_FUNC_INDEX_ONLY_SCAN_1 on func_index_only_scan(upper(c_vchar), c_int);

Succeed.

SQL> create index idx_func_index_only_scan_2 on func_index_only_scan(upper(c_vchar), c_int, c_num, nvl(c_float, 200.0));

Succeed.

SQL> 
SQL> -- distinct / index distinct
SQL> explain select * from func_index_only_scan where upper(c_vchar) = 'AKF'; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                            |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C_VCHAR) = 'AKF'                           

10 rows fetched.

SQL> explain select upper(c_vchar) from func_index_only_scan where upper(c_vchar) = 'AKF'; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                       | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                            |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C_VCHAR) = 'AKF'                           

10 rows fetched.

SQL> explain select distinct c_int from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ'; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY   | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

11 rows fetched.

SQL> explain select distinct upper(c_vchar) from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ'; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   INDEX DISTINCT                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY   | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

11 rows fetched.

SQL> explain select count(distinct upper(c_vchar)) from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ'; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   AGGR                           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY   | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

11 rows fetched.

SQL> explain select distinct upper(c_vchar), c_float from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ'; -- index_1 rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

11 rows fetched.

SQL> explain select distinct c_decimal from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ'; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

11 rows fetched.

SQL> explain select distinct a from (select distinct upper(c_vchar) a from func_index_only_scan where upper(c_vchar) = 'AKF' or upper(c_vchar) = 'FDJ');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                    |       |                            |      |      |       |        |
| 2   |     SUBSELECT                      |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY   | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 4   |         OPTIMIZED INDEX RANGE SCAN | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: UPPER(C_VCHAR) = 'AKF' OR UPPER(C_VCHAR) = 'FDJ' 

12 rows fetched.

SQL> explain select distinct upper(c_vchar), c_int from func_index_only_scan; -- index distinct

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   INDEX DISTINCT                |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select distinct upper(c_vchar), c_num from func_index_only_scan; -- hash distinct

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select distinct c_int, c_num from func_index_only_scan;	-- hash distinct

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH DISTINCT                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> 
SQL> -- order by / eliminate sort by index
SQL> explain select c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_vchar; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_vchar from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY            |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by 1; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> 
SQL> explain select c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by upper(c_vchar); -- index only, eliminate sort by index

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                       | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                            |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

10 rows fetched.

SQL> select c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by upper(c_vchar); -- index only

C_INT       
------------
1           
2           
2           

3 rows fetched.

SQL> 
SQL> explain select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int, upper(c_vchar); -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int, upper(c_vchar); -- index only

C_INT        UPPER(C_VCHAR)                
------------ ------------------------------
1            ABC                           
2            ADD                           
2            AKF                           

3 rows fetched.

SQL> 
SQL> explain select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by 1, 2; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by 1, 2; -- index only

C_INT        UPPER(C_VCHAR)                
------------ ------------------------------
1            ABC                           
2            ADD                           
2            AKF                           

3 rows fetched.

SQL> explain select upper(c_vchar), c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by upper(c_vchar), c_int; -- eliminate sort by index

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                       | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                            |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

10 rows fetched.

SQL> explain select upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> select upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int;

UPPER(C_VCHAR)                
------------------------------
ABC                           
ADD                           
AKF                           

3 rows fetched.

SQL> 
SQL> -- index aggr
SQL> explain select max(c_int) from func_index_only_scan where upper(c_vchar) = 'DEF';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   INDEX AGGR                      |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY    | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN DESCENDING | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'DEF' AND C_INT IS NOT NULL     

11 rows fetched.

SQL> explain select min(c_int) from func_index_only_scan where upper(c_vchar) = 'DEF';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   INDEX AGGR                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'DEF' AND C_INT IS NOT NULL     

11 rows fetched.

SQL> explain select max(c_int), min(c_int) from func_index_only_scan where upper(c_vchar) = 'DEF';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   AGGR                          |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) = 'DEF'                           

11 rows fetched.

SQL> 
SQL> -- group by / having
SQL> explain select count(*) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int, count(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int, count(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, c_vchar; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int, count(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, upper(c_vchar); -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, upper(c_vchar); -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, upper(c_vchar) having c_int in (2) order by 1, 2; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   HAVING                          |       |                            |      |      |       |        |
| 2   |     SORT GROUP BY                 |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_INT = 2                                        
   4 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

13 rows fetched.

SQL> explain select c_int c1, upper(c_vchar) c2 from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, upper(c_vchar) having c_int in (2) order by c1, c2; -- index only

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   HAVING                          |       |                            |      |      |       |        |
| 2   |     SORT GROUP BY                 |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: C_INT = 2
   4 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'

13 rows fetched.

SQL> explain select c_int, upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_int, upper(c_vchar) having upper(c_vchar) = 'ADD' order by 1, 2; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   HAVING                          |       |                            |      |      |       |        |
| 2   |     SORT GROUP BY                 |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: UPPER(C_VCHAR) = 'ADD'                           
   4 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

13 rows fetched.

SQL> explain select count(*) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_num, nvl(c_float, 200.0); -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select count(*) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_num, nvl(c_float, 200.1); -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select sum(c_decimal) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_num, nvl(c_float, 200.0); -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> explain select to_char(nvl(c_float, 200.0)) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' group by c_num, nvl(c_float, 200.0); -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY                 |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

11 rows fetched.

SQL> 
SQL> -- start with / connect by
SQL> explain select c_int, c_decimal, sys_connect_by_path(c_int, '->') from func_index_only_scan start with upper(c_vchar) >= 'D' connect by prior c_int = c_decimal / 10; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   START WITH                     |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 4   |   CONNECT BY MATERIALIZE         |       |                            |      |      |       |        |
| 5   |     TABLE ACCESS FULL            | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'D'                            
   4 - access: PRIOR C_INT = C_DECIMAL / 10                     

14 rows fetched.

SQL> explain select c_int, sys_connect_by_path(c_int, '->') from func_index_only_scan start with upper(c_vchar) >= 'D' connect by prior c_int = c_num; -- index_2 index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                       | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                            |      |      |       |        |
| 1   |   START WITH                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
| 4   |   CONNECT BY MATERIALIZE        |       |                            |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 6   |       INDEX FAST FULL SCAN      | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) >= 'D'                            
   4 - access: PRIOR C_INT = C_NUM                              

15 rows fetched.

SQL> 
SQL> -- winsort, not support index only scan
SQL> explain select c_int, avg(c_num) over(partition by c_int) avg from func_index_only_scan where upper(c_vchar) > 'A' and upper(c_vchar) <= 'D'; -- -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   WINDOW SORT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) > 'A' AND UPPER(C_VCHAR) <= 'D'   

11 rows fetched.

SQL> explain select c_int, avg(c_num) over(partition by c_int order by c_decimal) avg from func_index_only_scan where upper(c_vchar) > 'A' and upper(c_vchar) <= 'D'; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   WINDOW SORT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) > 'A' AND UPPER(C_VCHAR) <= 'D'   

11 rows fetched.

SQL> explain select upper(c_vchar), c_int, avg(c_num) over(partition by c_int order by upper(c_vchar) desc) avg from func_index_only_scan where upper(c_vchar) > 'A' and upper(c_vchar) <= 'D';  -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   WINDOW SORT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: UPPER(C_VCHAR) > 'A' AND UPPER(C_VCHAR) <= 'D'   

11 rows fetched.

SQL> select upper(c_vchar), c_int, avg(c_num) over(partition by c_int order by upper(c_vchar) desc) avg from func_index_only_scan where upper(c_vchar) > 'A' and upper(c_vchar) <= 'D'; -- rowid

UPPER(C_VCHAR)                 C_INT        AVG                                     
------------------------------ ------------ ----------------------------------------
ABC                            1            2000                                    
AKF                            2            2002                                    
ADD                            2            2003                                    

3 rows fetched.

SQL> select upper(c_vchar), c_int, avg(c_num) over(partition by c_int order by upper(c_vchar)) avg from func_index_only_scan where upper(c_vchar) > 'A' and upper(c_vchar) <= 'D'; -- rowid

UPPER(C_VCHAR)                 C_INT        AVG                                     
------------------------------ ------------ ----------------------------------------
ABC                            1            2000                                    
ADD                            2            2004                                    
AKF                            2            2003                                    

3 rows fetched.

SQL> 
SQL> -- or -> union
SQL> alter system set cbo = on;

Succeed.

SQL> declare
  2 	count int;
  3 begin
  4 	for count in 1 .. 10000 loop
  5 		insert into func_index_only_scan (c_int, c_vchar) values (count, substr(to_char(uuid()), 1, 30));
  6 	end loop;
  7 	commit;
  8 end;
  9 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select upper(c_vchar), c_int from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' and (exists (select 1 from sys_dummy where 1 = func_index_only_scan.c_int) or exists (select 1 from sys_dummy where 1 = func_index_only_scan.c_int + 1));

UPPER(C_VCHAR)                 C_INT       
------------------------------ ------------
ABC                            1           

1 rows fetched.

SQL> 
SQL> alter system set cbo = off;

Succeed.

SQL> 
SQL> -- join
SQL> create table func_index_test_tab (f1 int, f2 varchar(30));

Succeed.

SQL> insert into func_index_test_tab values (2, 'abc');

1 rows affected.

SQL> insert into func_index_test_tab values (4, 'def');

1 rows affected.

SQL> commit;

Succeed.

SQL> explain select /*+use_nl(t1 t2) leading(t2)*/ t1.c_int, t1.c_vchar from func_index_only_scan t1 join func_index_test_tab t2 on t1.c_int = t2.f1 where upper(t1.c_vchar) >= 'A' and upper(t1.c_vchar) <=  'D' order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY              |       |                            |      |      |       |        |
| 2   |     NESTED LOOPS                   |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | FUNC_INDEX_TEST_TAB T2     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN T1    |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: UPPER(T1.C_VCHAR) >= 'A' AND UPPER(T1.C_VCHAR) <= 'D' AND T1.C_INT = T2.F1

13 rows fetched.

SQL> explain select /*+use_nl(t1 t2) leading(t2)*/ t1.c_int, upper(t1.c_vchar) from func_index_only_scan t1 join func_index_test_tab t2 on t1.c_int = t2.f1 where upper(t1.c_vchar) >= 'A' and upper(t1.c_vchar) <=  'D' order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY             |       |                            |      |      |       |        |
| 2   |     NESTED LOOPS                  |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | FUNC_INDEX_TEST_TAB T2     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN T1    |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: UPPER(T1.C_VCHAR) >= 'A' AND UPPER(T1.C_VCHAR) <= 'D' AND T1.C_INT = T2.F1

13 rows fetched.

SQL> explain select /*+use_hash(t1 t2) leading(t2)*/ t1.c_int, upper(t1.c_vchar) from func_index_only_scan t1 join func_index_test_tab t2 on t1.c_int = t2.f1 where upper(t1.c_vchar) >= 'A' and upper(t1.c_vchar) <=  'D' order by 1, 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   QUERY SORT ORDER BY             |       |                            |      |      |       |        |
| 2   |     HASH JOIN(L)                  |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | FUNC_INDEX_TEST_TAB T2     |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN T1    |      |      |       |        |
| 5   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.F1 = T1.C_INT                                 
   5 - access: UPPER(T1.C_VCHAR) >= 'A' AND UPPER(T1.C_VCHAR) <= 'D'

14 rows fetched.

SQL> 
SQL> -- sub-select
SQL> explain select t1.a, t1.b from (select c_int a, upper(c_vchar) b from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int) t1 where
  2  exists (select 1 from func_index_test_tab where upper(f2) = t1.b);  -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name                       | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |                            |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)                 |       |                            |      |      |       |        |
| 2   |     SUBSELECT                       |       | T1                         |      |      |       |        |
| 3   |       QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 5   |           INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 6   |     SUBSELECT                       |       |                            |      |      |       |        |
| 7   |       TABLE ACCESS FULL             | SYS   | FUNC_INDEX_TEST_TAB        |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = UPPER(F2)                                 
   5 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

16 rows fetched.

SQL> 
SQL> explain select t1.a, t1.b from (select c_int a, upper(c_vchar) b, c_decimal c from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int) t1 where
  2  exists (select 1 from func_index_test_tab where upper(f2) = t1.b and f1 = t1.c);  -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                            |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)                  |       |                            |      |      |       |        |
| 2   |     SUBSELECT                        |       | T1                         |      |      |       |        |
| 3   |       QUERY SORT ORDER BY            |       |                            |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 5   |           INDEX RANGE SCAN           | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 6   |     SUBSELECT                        |       |                            |      |      |       |        |
| 7   |       TABLE ACCESS FULL              | SYS   | FUNC_INDEX_TEST_TAB        |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.C = F1 AND T1.B = UPPER(F2)                   
   5 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

16 rows fetched.

SQL> 
SQL> select t1.a, t1.b from (select c_int a, upper(c_vchar) b from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int) t1 where
  2  exists (select 1 from func_index_test_tab where upper(f2) = t1.b);	 -- one row

A            B                             
------------ ------------------------------
1            ABC                           

1 rows fetched.

SQL> 
SQL> explain select f1, f2, (select upper(c_vchar) from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int limit 1) res from func_index_test_tab; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                       | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                            |      |      |       |        |
| 1   |   QUERY LIMIT                     |       |                            |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM    |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 5   |   TABLE ACCESS FULL               | SYS   | FUNC_INDEX_TEST_TAB        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

13 rows fetched.

SQL> explain select c_int, (select f2 from func_index_test_tab where upper(f2) = upper(t1.c_vchar) order by f2 limit 1) res from func_index_only_scan t1 order by 1; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |                         |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM |       |                         |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | FUNC_INDEX_TEST_TAB     |      |      |       |        |
| 4   |   QUERY SORT ORDER BY          |       |                         |      |      |       |        |
| 5   |     TABLE ACCESS FULL          | SYS   | FUNC_INDEX_ONLY_SCAN T1 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: UPPER(F2) = UPPER(T1.C_VCHAR)                    

13 rows fetched.

SQL> 
SQL> explain with t1 as (select c_int a, upper(c_vchar) b from func_index_only_scan where upper(c_vchar) >= 'A' and upper(c_vchar) <= 'D' order by c_int)
  2  select * from func_index_test_tab t2, t1 where upper(t2.f2) = t1.b; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name                       | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |                            |      |      |       |        |
| 1   |   HASH JOIN(L)                      |       |                            |      |      |       |        |
| 2   |     SUBSELECT                       |       | T1                         |      |      |       |        |
| 3   |       QUERY SORT ORDER BY           |       |                            |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_ONLY_SCAN       |      |      |       |        |
| 5   |           INDEX RANGE SCAN          | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 6   |     TABLE ACCESS FULL               | SYS   | FUNC_INDEX_TEST_TAB T2     |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.B = UPPER(T2.F2)                              
   5 - access: UPPER(C_VCHAR) >= 'A' AND UPPER(C_VCHAR) <= 'D'  

15 rows fetched.

SQL> 
SQL> -- hash mtrl
SQL> select t1.c_int, upper(t1.c_vchar) from func_index_only_scan t1 where c_int < (select avg(f1) from func_index_test_tab where upper(f2) = t1.c_vchar);

C_INT        UPPER(T1.C_VCHAR)             
------------ ------------------------------
1            ABC                           

1 rows fetched.

SQL> explain select /*+index(t1 IDX_FUNC_INDEX_ONLY_SCAN_1)*/ t1.c_int, upper(t1.c_vchar) from func_index_only_scan t1 where c_int < (select avg(f1) from func_index_test_tab where upper(f2) = upper(t1.c_vchar)); -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   KERNEL FILTER                  |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_ONLY_SCAN T1    |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | IDX_FUNC_INDEX_ONLY_SCAN_1 |      |      |       |        |
| 4   |     HASH MATERIALIZE             |       |                            |      |      |       |        |
| 5   |       TABLE ACCESS FULL          | SYS   | FUNC_INDEX_TEST_TAB        |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: C_INT < (SELECT AVG(F1) FROM FUNC_INDEX_TEST_TAB GROUP BY UPPER(F2))
   4 - access: UPPER(F2) = UPPER(T1.C_VCHAR)                    

14 rows fetched.

SQL> 
SQL> -- json_value
SQL> DROP TABLE IF EXISTS t_school;

Succeed.

SQL> CREATE TABLE t_school(id INT NOT NULL, info VARCHAR2(8000) check(info IS JSON));

Succeed.

SQL> INSERT INTO t_school VALUES(1, '{"name":"First Primary School", "create_time":"2012-05-08", "classes": [{"name":"class 1", "size":50, "teachers":{"teacher":"Master Zhang", "age":31}}, {"name":"class 2", "size":45, "teachers":{"teacher":"Master Liu", "age":40}}]}');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> CREATE INDEX idx_t_school_info_name ON t_school(JSON_VALUE(info, '$.name'));

Succeed.

SQL> EXPLAIN SELECT * FROM T_SCHOOL WHERE JSON_VALUE(info, '$.name') = 'First Primary School'; -- rowid

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                   | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                        |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | T_SCHOOL               |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_T_SCHOOL_INFO_NAME |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: JSON_VALUE(INFO, '$.name') = 'First Primary School'

10 rows fetched.

SQL> EXPLAIN SELECT count(*) FROM T_SCHOOL WHERE JSON_VALUE(info, '$.name') = 'First Primary School'; -- index only

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                   | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                        |      |      |       |        |
| 1   |   AGGR                          |       |                        |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_SCHOOL               |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_T_SCHOOL_INFO_NAME |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: JSON_VALUE(INFO, '$.name') = 'First Primary School'

11 rows fetched.

SQL> explain select case when JSON_VALUE(info, '$.name') = 'class 1' then 0 else 1 end type from t_school where JSON_VALUE(info, '$.name') <= 'class 3' order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                   | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                        |      |      |       |        |
| 1   |   QUERY SORT ORDER BY           |       |                        |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_SCHOOL               |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_T_SCHOOL_INFO_NAME |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: JSON_VALUE(INFO, '$.name') <= 'class 3'          

11 rows fetched.

SQL> 
SQL> -- parallel
SQL> DROP TABLE if exists t_index_only_scan2;

Succeed.

SQL> CREATE TABLE t_index_only_scan2(id INT,c_js varchar(150),c_vchar varchar(10),c_int int,c_num number,c_date date,check(c_js is json));

Succeed.

SQL> insert into t_index_only_scan2 values(1,'{"ctry":{"pro1":"a0001", "pro2":{"city1":"a0001","city2":"b0001"}, "pro3":["a0001","b0001","c0001"]}}','ctry1',1,1,ADD_MONTHS(to_timestamp('1000-01-01 10:10:10','yyyy-mm-dd hh24:mi:ss'),MOD(1,10000)));

1 rows affected.

SQL> insert into t_index_only_scan2 values(2,'{"ctry":{"pro1":"a0002", "pro2":{"city1":"a0002","city2":"b0002"}, "pro3":["a0002","b0002","c0002"]}}','ctry2',2,2,ADD_MONTHS(to_timestamp('1000-01-01 10:10:10','yyyy-mm-dd hh24:mi:ss'),MOD(2,10000)));

1 rows affected.

SQL> insert into t_index_only_scan2 values(3,'{"ctry":{"pro1":"a0003", "pro2":{"city1":"a0003","city2":"b0003"}, "pro3":["a0003","b0003","c0003"]}}','ctry3',3,3,ADD_MONTHS(to_timestamp('1000-01-01 10:10:10','yyyy-mm-dd hh24:mi:ss'),MOD(3,10000)));

1 rows affected.

SQL> insert into t_index_only_scan2 values(4,'{"ctry":{"pro1":"a0004", "pro2":{"city1":"a0004","city2":"b0004"}, "pro3":["a0004","b0004","c0004"]}}','ctry4',4,4,ADD_MONTHS(to_timestamp('1000-01-01 10:10:10','yyyy-mm-dd hh24:mi:ss'),MOD(4,10000)));

1 rows affected.

SQL> insert into t_index_only_scan2 values(5,'{"ctry":{"pro1":"a0005", "pro2":{"city1":"a0005","city2":"b0005"}, "pro3":["a0005","b0005","c0005"]}}','ctry5',5,5,ADD_MONTHS(to_timestamp('1000-01-01 10:10:10','yyyy-mm-dd hh24:mi:ss'),MOD(5,10000)));

1 rows affected.

SQL> create index idx_t_index_only_scan2_05 on t_index_only_scan2(JSON_VALUE((c_js),'$.ctry.pro1'),SUBSTR(c_vchar,1));

Succeed.

SQL> select count(*) from t_index_only_scan2 t1 where JSON_VALUE(c_js,'$.ctry.pro1') <='a0004';

COUNT(*)            
--------------------
4                   

1 rows fetched.

SQL> select /*+parallel(8)*/count(*) from t_index_only_scan2 t1 where JSON_VALUE(c_js,'$.ctry.pro1') <='a0004';

COUNT(*)            
--------------------
4                   

1 rows fetched.

SQL> explain plan for select /*+parallel(8)*/count(*) from t_index_only_scan2 t1 where JSON_VALUE(c_js,'$.ctry.pro1') <='a0004';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                             | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                                  |      |      |       |        |
| 1   |   AGGR                          |       |                                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_INDEX_ONLY_SCAN2 T1(p   8)     |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | IDX_T_INDEX_ONLY_SCAN2_05(p   8) |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: JSON_VALUE(C_JS, '$.ctry.pro1') <= 'a0004'       

11 rows fetched.

SQL> -- merge join not support
SQL> create index idx_t_index_only_scan2_001 on t_index_only_scan2(upper(id));

Succeed.

SQL> create index idx_t_index_only_scan2_017 on t_index_only_scan2(upper(id+id));

Succeed.

SQL> select sum(upper(t1.id+t1.id)) from t_index_only_scan2 t1 full join t_index_only_scan2 t2 on upper(t1.id+t1.id)>upper(t2.id) join t_index_only_scan2 t3 on upper(t1.id+t1.id)>upper(t3.id);

SUM(UPPER(T1.ID+T1.ID))                 
----------------------------------------
398                                     

1 rows fetched.

SQL> explain select sum(upper(t1.id+t1.id)) from t_index_only_scan2 t1 full join t_index_only_scan2 t2 on upper(t1.id+t1.id)>upper(t2.id) join t_index_only_scan2 t3 on upper(t1.id+t1.id)>upper(t3.id);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                            |      |      |       |        |
| 1   |   AGGR                               |       |                            |      |      |       |        |
| 2   |     MERGE JOIN                       |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID    | SYS   | T_INDEX_ONLY_SCAN2 T3      |      |      |       |        |
| 4   |         INDEX FULL SCAN              | SYS   | IDX_T_INDEX_ONLY_SCAN2_001 |      |      |       |        |
| 5   |       NESTED LOOPS FULL              |       |                            |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_INDEX_ONLY_SCAN2 T1      |      |      |       |        |
| 7   |           INDEX FULL SCAN            | SYS   | IDX_T_INDEX_ONLY_SCAN2_017 |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ROWID  | SYS   | T_INDEX_ONLY_SCAN2 T2      |      |      |       |        |
| 9   |           INDEX FULL SCAN            | SYS   | IDX_T_INDEX_ONLY_SCAN2_001 |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(T3.ID) < UPPER(T1.ID + T1.ID)              
   8 - filter: UPPER(T1.ID + T1.ID) > UPPER(T2.ID)              

18 rows fetched.

SQL> -- index group
SQL> create index idx_t_index_only_scan2_06 on t_index_only_scan2(UPPER(JSON_VALUE((c_js),'$.ctry.pro1')));

Succeed.

SQL> explain select UPPER(JSON_VALUE((c_js),'$.ctry.pro1')) from t_index_only_scan2 group by UPPER(JSON_VALUE((c_js),'$.ctry.pro1'));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                           |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_INDEX_ONLY_SCAN2        |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_T_INDEX_ONLY_SCAN2_06 |      |      |       |        |
------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select count(*) from t_index_only_scan2 group by UPPER(JSON_VALUE((c_js),'$.ctry.pro1'));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                           |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_INDEX_ONLY_SCAN2        |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_T_INDEX_ONLY_SCAN2_06 |      |      |       |        |
------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select group_concat(UPPER(JSON_VALUE((c_js),'$.ctry.pro1')), '-') from t_index_only_scan2 group by UPPER(JSON_VALUE((c_js),'$.ctry.pro1'));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                           |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_INDEX_ONLY_SCAN2        |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_T_INDEX_ONLY_SCAN2_06 |      |      |       |        |
------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select JSON_VALUE(c_js,'$.ctry.pro1') from t_index_only_scan2 group by JSON_VALUE(c_js,'$.ctry.pro1');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                      | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                           |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_INDEX_ONLY_SCAN2        |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | IDX_T_INDEX_ONLY_SCAN2_05 |      |      |       |        |
------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> select group_concat(UPPER(JSON_VALUE((c_js),'$.ctry.pro1')), '-') from t_index_only_scan2 group by UPPER(JSON_VALUE((c_js),'$.ctry.pro1')) order by 1;

GROUP_CONCAT(UPPER(JSON_VALUE((C_JS),'$.CTRY.PRO1')), '-')      
----------------------------------------------------------------
A0001-                                                          
A0002-                                                          
A0003-                                                          
A0004-                                                          
A0005-                                                          

5 rows fetched.

SQL> 
SQL> drop table if exists complex_func_index_t;

Succeed.

SQL> create table complex_func_index_t(col_1 int, col_2 int);

Succeed.

SQL> insert into complex_func_index_t values(1,2);

1 rows affected.

SQL> insert into complex_func_index_t values(100,4);

1 rows affected.

SQL> insert into complex_func_index_t values(200,6);

1 rows affected.

SQL> create index complex_func_index_t_idx on complex_func_index_t(case when col_1 < 100 then 1 when col_1 < 200 then 2 else 3 end);

Succeed.

SQL> create index complex_func_index_t_nested_func_idx2 on complex_func_index_t(nvl(to_char(col_1 + 1), '100'));

Succeed.

SQL> 
SQL> explain select nvl(to_char(col_1 + 1), '100') as c1 from complex_func_index_t group by nvl(to_char(col_1 + 1), '100');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                                  | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                                       |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                                       |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | COMPLEX_FUNC_INDEX_T                  |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | COMPLEX_FUNC_INDEX_T_NESTED_FUNC_IDX2 |      |      |       |        |
------------------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select nvl(to_char(col_1 + 1), '100') as c1 from complex_func_index_t order by c1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                                  | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                                       |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | COMPLEX_FUNC_INDEX_T                  |      |      |       |        |
| 2   |     INDEX FULL SCAN           | SYS   | COMPLEX_FUNC_INDEX_T_NESTED_FUNC_IDX2 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select case when col_1 < 100 then 1 when col_1 < 200 then 2 else 3 end as c1 from complex_func_index_t group by case when col_1 < 100 then 1 when col_1 < 200 then 2 else 3 end;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                     | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                          |      |      |       |        |
| 1   |   INDEX GROUP BY                 |       |                          |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | COMPLEX_FUNC_INDEX_T     |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | COMPLEX_FUNC_INDEX_T_IDX |      |      |       |        |
------------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select case when col_1 < 100 then 1 when col_1 < 200 then 2 else 3 end as c1 from complex_func_index_t order by 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | COMPLEX_FUNC_INDEX_T     |      |      |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | COMPLEX_FUNC_INDEX_T_IDX |      |      |       |        |
----------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> drop table complex_func_index_t;

Succeed.

SQL> 
SQL> drop table if exists func_index_t;

Succeed.

SQL> create table func_index_t (a int, b int, c varchar(10));

Succeed.

SQL> 
SQL> create index func_index1 on func_index_t(upper(c), a);

Succeed.

SQL> explain select upper(upper(c)) from func_index_t where upper(c) = 'BC';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_T |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | FUNC_INDEX1  |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C) = 'BC'                                  

10 rows fetched.

SQL> explain select reverse(upper(c)) from func_index_t where upper(c) = 'BC' and (a = 6 or a = 10);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY   | SYS   | FUNC_INDEX_T |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | FUNC_INDEX1  |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C) = 'BC' AND A = 6 OR A = 10              

10 rows fetched.

SQL> explain select upper(nvl(upper(c),b)) from func_index_t where upper(c) = 'BC';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_T |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX1  |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: UPPER(C) = 'BC'                                  

10 rows fetched.

SQL> drop index func_index1 on func_index_t;

Succeed.

SQL> 
SQL> create index func_index2 on func_index_t(nvl(upper(upper(c)),1));

Succeed.

SQL> explain select 1 from  func_index_t where nvl(upper(upper(c)),1) = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name         | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | FUNC_INDEX_T |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN      | SYS   | FUNC_INDEX2  |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NVL(UPPER(UPPER(C)), 1) = 1                      

10 rows fetched.

SQL> drop index func_index2 on func_index_t;

Succeed.

SQL> 
SQL> create index func_index3 on func_index_t(nvl(upper(upper(c)),1),upper(upper(c)));

Succeed.

SQL> explain select upper(upper(c)) from func_index_t where nvl(upper(upper(c)),1) = 'BC';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |              |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | FUNC_INDEX_T |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | FUNC_INDEX3  |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NVL(UPPER(UPPER(C)), 1) = 'BC'                   

10 rows fetched.

SQL> drop index func_index3 on func_index_t;

Succeed.

SQL> 
SQL> drop table func_index_t;

Succeed.

SQL> 
SQL> --reverse function index
SQL> drop table if exists test_reverse_func_index;

Succeed.

SQL> create table test_reverse_func_index(f1 int, f2 varchar(20), f3 char(10));

Succeed.

SQL> insert into test_reverse_func_index values(1,'abc','abc');

1 rows affected.

SQL> insert into test_reverse_func_index values(2,'abd','abd');

1 rows affected.

SQL> commit;

Succeed.

SQL> create index temp_idx_001 on test_reverse_func_index(reverse(f2));

Succeed.

SQL> create index temp_idx_002 on test_reverse_func_index(reverse(f3));

Succeed.

SQL> create index temp_idx_003 on test_reverse_func_index(f1, reverse(f2));

Succeed.

SQL> create index temp_idx_004 on test_reverse_func_index(reverse(f3),f1);

Succeed.

SQL> --index only
SQL> --index fast full scan
SQL> explain select reverse(f3) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select reverse(reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select count(distinct reverse(f2)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> --index range scan
SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = 'cba'

10 rows fetched.

SQL> explain select reverse(f2) from test_reverse_func_index where f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: F1 = 1

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) > 'aaa';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) > 'aaa'

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) >= 'aaa';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) >= 'aaa'

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) < 'aaa';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) < 'aaa'

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) <= 'aaa';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) <= 'aaa'

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) between '123' and '789';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) BETWEEN '123' AND '789'

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where reverse(f3) is null;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) IS NULL

10 rows fetched.

SQL> --concatenation
SQL> explain select * from test_reverse_func_index where reverse(f3) = '  0000099999' or reverse(f2) = '9999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   CONCATENATION                  |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F3) = '  0000099999' OR REVERSE(F2) = '9999900000'
   3 - access: REVERSE(F3) = '  0000099999'
   4 - filter: REVERSE(F3) = '  0000099999' OR REVERSE(F2) = '9999900000'
   5 - access: REVERSE(F2) = '9999900000'

16 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f3) < '  0000099999' or reverse(f2) > '9999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   CONCATENATION                  |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F3) < '  0000099999' OR REVERSE(F2) > '9999900000'
   3 - access: REVERSE(F3) < '  0000099999'
   4 - filter: REVERSE(F3) < '  0000099999' OR REVERSE(F2) > '9999900000'
   5 - access: REVERSE(F2) > '9999900000'

16 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f3) < '  0001099999' or reverse(f2) > '8999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   CONCATENATION                  |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F3) < '  0001099999' OR REVERSE(F2) > '8999900000'
   3 - access: REVERSE(F3) < '  0001099999'
   4 - filter: REVERSE(F3) < '  0001099999' OR REVERSE(F2) > '8999900000'
   5 - access: REVERSE(F2) > '8999900000'

16 rows fetched.

SQL> --union minus
SQL> explain select * from test_reverse_func_index where reverse(f3) = '  0000099999' union select * from test_reverse_func_index where reverse(f2) = '9999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   HASH UNION                     |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '  0000099999'
   5 - access: REVERSE(F2) = '9999900000'

14 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f3) = '  0000099999' union all select * from test_reverse_func_index where reverse(f2) = '9999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   UNION ALL                      |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '  0000099999'
   5 - access: REVERSE(F2) = '9999900000'

14 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f3) < '  0000099999' minus select * from test_reverse_func_index where reverse(f2) = '9999900000';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   HASH MINUS                     |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) < '  0000099999'
   5 - access: REVERSE(F2) = '9999900000'

14 rows fetched.

SQL> --like
SQL> explain select * from test_reverse_func_index where reverse(f3) like '  0000%';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) LIKE '  0000%'

10 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f3) like '  0000_9999_';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) LIKE '  0000_9999_'

10 rows fetched.

SQL> explain select count(*) from test_reverse_func_index where reverse(f3) like '  %';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_002            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) LIKE '  %'

11 rows fetched.

SQL> explain select count(*) from test_reverse_func_index where reverse(f3) like '%';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_002            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F3) LIKE '%'

11 rows fetched.

SQL> --in
SQL> explain select * from test_reverse_func_index where reverse(f2) in ('9999900000','8999910000','7999920000','6999930000','5999940000','9899901000','8899911000','7899921000','6899931000','5899941000');

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     OPTIMIZED INDEX RANGE SCAN | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) IN('9999900000', '8999910000', '7999920000', '6999930000', '5999940000', '9899901000',
               '8899911000', '7899921000', '6899931000', '5899941000')

11 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select rtrim(reverse(f3)) from test_reverse_func_index where f1 < 20);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                         |      |      |       |        |
| 1   |   NESTED LOOPS                       |       |                         |      |      |       |        |
| 2   |     SUBSELECT                        |       |                         |      |      |       |        |
| 3   |       HASH DISTINCT                  |       |                         |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |           INDEX RANGE SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 7   |       INDEX RANGE SCAN               | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   5 - access: F1 < 20
   7 - access: REVERSE(F2) = RTRIM(REVERSE(F3))

16 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select rtrim(f3) from test_reverse_func_index where f1 < 20);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                         |      |      |       |        |
| 1   |   NESTED LOOPS                       |       |                         |      |      |       |        |
| 2   |     SUBSELECT                        |       |                         |      |      |       |        |
| 3   |       HASH DISTINCT                  |       |                         |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 5   |           INDEX RANGE SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
| 6   |     TABLE ACCESS BY INDEX ROWID      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 7   |       INDEX RANGE SCAN               | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   5 - access: F1 < 20
   7 - access: REVERSE(F2) = RTRIM(F3)

16 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select reverse(f2) from test_reverse_func_index where f1 < 20) and f1 in (select f1 from test_reverse_func_index where f1 < 20);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                         |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)                   |       |                         |      |      |       |        |
| 2   |     NESTED LOOPS                      |       |                         |      |      |       |        |
| 3   |       SUBSELECT                       |       |                         |      |      |       |        |
| 4   |         HASH DISTINCT                 |       |                         |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 6   |             INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ROWID     | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 8   |         INDEX RANGE SCAN              | SYS   | TEMP_IDX_001            |      |      |       |        |
| 9   |     SUBSELECT                         |       |                         |      |      |       |        |
| 10  |       TABLE ACCESS BY INDEX ONLY      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 11  |         INDEX RANGE SCAN              | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - access: F1 = TEST_REVERSE_FUNC_INDEX.F1
   6 - access: F1 < 20
   8 - access: REVERSE(F2) = REVERSE(F2)
   11 - access: F1 < 20

22 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select reverse(f2) from test_reverse_func_index where f1 < 20) or f1 in (select f1 from test_reverse_func_index where f1 < 20);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
| Id  | Description                               | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                          |       |                         |      |      |       |        |
| 1   |   SUBSELECT                               |       |                         |      |      |       |        |
| 2   |     HASH UNION                            |       |                         |      |      |       |        |
| 3   |       NESTED LOOPS                        |       |                         |      |      |       |        |
| 4   |         SUBSELECT                         |       |                         |      |      |       |        |
| 5   |           HASH DISTINCT                   |       |                         |      |      |       |        |
| 6   |             TABLE ACCESS BY INDEX ONLY    | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 7   |               INDEX RANGE SCAN            | SYS   | TEMP_IDX_003            |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ROWID       | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 9   |           INDEX RANGE SCAN                | SYS   | TEMP_IDX_001            |      |      |       |        |
| 10  |       NESTED LOOPS                        |       |                         |      |      |       |        |
| 11  |         NESTED LOOPS                      |       |                         |      |      |       |        |
| 12  |           SUBSELECT                       |       |                         |      |      |       |        |
| 13  |             HASH DISTINCT                 |       |                         |      |      |       |        |
| 14  |               TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 15  |                 INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
| 16  |           TABLE ACCESS BY INDEX ONLY      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 17  |             INDEX RANGE SCAN              | SYS   | TEMP_IDX_003            |      |      |       |        |
| 18  |         TABLE ACCESS BY ROWID             | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 19  |           ROWID SCAN                      |       |                         |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   7 - access: F1 < 20
   9 - access: REVERSE(F2) = REVERSE(F2)
   15 - access: F1 < 20
   17 - access: F1 = TEST_REVERSE_FUNC_INDEX.F1

30 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select reverse(f2) from test_reverse_func_index where f1 < 20) or f1 in (select f1 from test_reverse_func_index where f1 > 3000);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
| Id  | Description                               | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                          |       |                         |      |      |       |        |
| 1   |   SUBSELECT                               |       |                         |      |      |       |        |
| 2   |     HASH UNION                            |       |                         |      |      |       |        |
| 3   |       NESTED LOOPS                        |       |                         |      |      |       |        |
| 4   |         SUBSELECT                         |       |                         |      |      |       |        |
| 5   |           HASH DISTINCT                   |       |                         |      |      |       |        |
| 6   |             TABLE ACCESS BY INDEX ONLY    | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 7   |               INDEX RANGE SCAN            | SYS   | TEMP_IDX_003            |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ROWID       | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 9   |           INDEX RANGE SCAN                | SYS   | TEMP_IDX_001            |      |      |       |        |
| 10  |       NESTED LOOPS                        |       |                         |      |      |       |        |
| 11  |         NESTED LOOPS                      |       |                         |      |      |       |        |
| 12  |           SUBSELECT                       |       |                         |      |      |       |        |
| 13  |             HASH DISTINCT                 |       |                         |      |      |       |        |
| 14  |               TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 15  |                 INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
| 16  |           TABLE ACCESS BY INDEX ONLY      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 17  |             INDEX RANGE SCAN              | SYS   | TEMP_IDX_003            |      |      |       |        |
| 18  |         TABLE ACCESS BY ROWID             | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 19  |           ROWID SCAN                      |       |                         |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   7 - access: F1 < 20
   9 - access: REVERSE(F2) = REVERSE(F2)
   15 - access: F1 > 3000
   17 - access: F1 = TEST_REVERSE_FUNC_INDEX.F1

30 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) in (select reverse(f2) from test_reverse_func_index where f1 < 110) and f1 in (select f1 from test_reverse_func_index where f1 < 110);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                         |      |      |       |        |
| 1   |   HASH JOIN SEMI(R)                   |       |                         |      |      |       |        |
| 2   |     NESTED LOOPS                      |       |                         |      |      |       |        |
| 3   |       SUBSELECT                       |       |                         |      |      |       |        |
| 4   |         HASH DISTINCT                 |       |                         |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 6   |             INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ROWID     | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 8   |         INDEX RANGE SCAN              | SYS   | TEMP_IDX_001            |      |      |       |        |
| 9   |     SUBSELECT                         |       |                         |      |      |       |        |
| 10  |       TABLE ACCESS BY INDEX ONLY      | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 11  |         INDEX RANGE SCAN              | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - access: F1 = TEST_REVERSE_FUNC_INDEX.F1
   6 - access: F1 < 110
   8 - access: REVERSE(F2) = REVERSE(F2)
   11 - access: F1 < 110

22 rows fetched.

SQL> --index order by
SQL> explain select reverse(f3) from test_reverse_func_index order by 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                    | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FULL SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
--------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index order by 1 desc;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY   | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FULL SCAN DESCENDING | SYS   | TEMP_IDX_002            |      |      |       |        |
---------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> --index rowid
SQL> explain select f3 from test_reverse_func_index where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select reverse(f3) from test_reverse_func_index where f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: F1 = 1

10 rows fetched.

SQL> --index aggr
SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   AGGR                           |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

11 rows fetched.

SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) = '       cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   AGGR                           |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '       cba'

11 rows fetched.

SQL> explain select /*+index(test_reverse_func_index temp_idx_004)*/ max(f1) from test_reverse_func_index where reverse(f3) = '       cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                    | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                         |      |      |       |        |
| 1   |   INDEX AGGR                      |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY    | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN DESCENDING | SYS   | TEMP_IDX_004            |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '       cba' AND F1 IS NOT NULL

11 rows fetched.

SQL> explain select min(reverse(f2)) from test_reverse_func_index where f1 = 2;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX AGGR                    |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: F1 = 2 AND REVERSE(F2) IS NOT NULL

11 rows fetched.

SQL> explain select max(reverse(f2)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   INDEX AGGR                     |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY   | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN DESCENDING | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F2) IS NOT NULL

11 rows fetched.

SQL> explain select min(reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX AGGR                    |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - filter: REVERSE(F3) IS NOT NULL

11 rows fetched.

SQL> explain select min(reverse(f3)), max(reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_002            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> --index group by
SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z' group by reverse(f3);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                 |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

11 rows fetched.

SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) = '       cba' group by reverse(f3);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                 |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '       cba'

11 rows fetched.

SQL> explain select /*+index(test_reverse_func_index temp_idx_004)*/ max(f1) from test_reverse_func_index where reverse(f3) = '       cba' group by reverse(f3);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_004            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F3) = '       cba'

11 rows fetched.

SQL> explain select min(reverse(f2)) from test_reverse_func_index where f1 = 2 group by f1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: F1 = 2

11 rows fetched.

SQL> explain select reverse(f2) from test_reverse_func_index group by reverse(f2);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> --having
SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z' group by reverse(f3) having count(1) = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                         |      |      |       |        |
| 1   |   HAVING                           |       |                         |      |      |       |        |
| 2   |     INDEX GROUP BY                 |       |                         |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: COUNT(1) = 1
   4 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

13 rows fetched.

SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z' group by reverse(f3) having count(reverse(f3)) = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                         |      |      |       |        |
| 1   |   HAVING                           |       |                         |      |      |       |        |
| 2   |     INDEX GROUP BY                 |       |                         |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: COUNT(REVERSE(F3)) = 1
   4 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

13 rows fetched.

SQL> explain select /*+index(test_reverse_func_index temp_idx_004)*/ max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z' group by reverse(f3) having count(reverse(f3)) = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                    | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                  |       |                         |      |      |       |        |
| 1   |   HAVING                          |       |                         |      |      |       |        |
| 2   |     INDEX GROUP BY                |       |                         |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 4   |         INDEX RANGE SCAN          | SYS   | TEMP_IDX_004            |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: COUNT(REVERSE(F3)) = 1
   4 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

13 rows fetched.

SQL> explain select max(f1) from test_reverse_func_index where reverse(f3) between 'a' and 'z' group by reverse(f3) having count(reverse(f2)) = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                         |      |      |       |        |
| 1   |   HAVING                           |       |                         |      |      |       |        |
| 2   |     INDEX GROUP BY                 |       |                         |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: COUNT(REVERSE(F2)) = 1
   4 - access: REVERSE(F3) BETWEEN 'a' AND 'z'

13 rows fetched.

SQL> --index distinct
SQL> explain select distinct reverse(f2) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX DISTINCT                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select distinct f1,reverse(f2) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX DISTINCT                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select distinct reverse(f2) from test_reverse_func_index where f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX DISTINCT                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: F1 = 1

11 rows fetched.

SQL> --hash distinct + index range scan
SQL> explain select distinct reverse(f2) from test_reverse_func_index where f1 > 0;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   HASH DISTINCT                 |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN          | SYS   | TEMP_IDX_003            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: F1 > 0

11 rows fetched.

SQL> --connect by
SQL> explain select sys_connect_by_path(f1,'/') from test_reverse_func_index start with f1 = 1 connect by reverse(prior f3) > reverse(f3);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   START WITH                     |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
| 4   |   CONNECT BY                     |       |                         |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 6   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: F1 = 1
   4 - filter: REVERSE(PRIOR F3) > REVERSE(F3)
   6 - access: REVERSE(PRIOR F3) > REVERSE(F3)

16 rows fetched.

SQL> explain select sys_connect_by_path(f1,'/') from test_reverse_func_index start with f1 = 1 connect by reverse(prior f3) > reverse(f3) order siblings by 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   START WITH                     |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003            |      |      |       |        |
| 4   |   CONNECT BY                     |       |                         |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 6   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_002            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F1 = 1                                           
   4 - filter: REVERSE(PRIOR F3) > REVERSE(F3)                  
   6 - access: REVERSE(PRIOR F3) > REVERSE(F3)                  

16 rows fetched.

SQL> --winsort
SQL> explain select row_number() over (partition by f1 order by reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                         |      |      |       |        |
| 1   |   WINDOW SORT          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select max(reverse(f3)) over (partition by f1 order by reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                         |      |      |       |        |
| 1   |   WINDOW SORT          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select /*+index(test_reverse_func_index temp_idx_004)*/ max(reverse(f3)) over (partition by f1 order by reverse(f3)) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   WINDOW SORT                    |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | TEMP_IDX_004            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> --parallel
SQL> explain select /*+parallel(2)*/ reverse(f3) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                           | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                                |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX(p   2) |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_002(p   2)            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain select /*+parallel(2)*/ reverse(f2) from test_reverse_func_index group by reverse(f2);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> drop table if exists test_reverse_func_index2;

Succeed.

SQL> create table test_reverse_func_index2(f1 int, f2 varchar(20), f3 char(10));

Succeed.

SQL> insert into test_reverse_func_index2 values(1,'abc','abc');

1 rows affected.

SQL> insert into test_reverse_func_index2 values(2,'abd','abd');

1 rows affected.

SQL> commit;

Succeed.

SQL> create unique index temp_idx_103 on test_reverse_func_index2(f1, reverse(f2));

Succeed.

SQL> explain select /*+index(test_reverse_func_index2 temp_idx_103)*/ * from test_reverse_func_index2 where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX2 |      |      |       |        |
| 2   |     INDEX FULL SCAN            | SYS   | TEMP_IDX_103             |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> --index unique scan
SQL> explain select * from test_reverse_func_index2 where reverse(f2) = 'cba' and f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                          |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX2 |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | TEMP_IDX_103             |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: F1 = 1 AND REVERSE(F2) = 'cba'

10 rows fetched.

SQL> --join
SQL> explain select * from test_reverse_func_index a join test_reverse_func_index2 b on reverse(a.f2) = b.f1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | TEST_REVERSE_FUNC_INDEX A  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX2 B |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_103               |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   4 - access: REVERSE(A.F2) = B.F1

12 rows fetched.

SQL> explain select /*+leading(b)*/ * from test_reverse_func_index a join test_reverse_func_index2 b on reverse(a.f2) = b.f1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                            |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX2 B |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX A  |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - access: B.F1 = REVERSE(A.F2)

11 rows fetched.

SQL> explain select * from test_reverse_func_index2 b join test_reverse_func_index a on reverse(a.f2) = b.f1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | TEST_REVERSE_FUNC_INDEX A  |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX2 B |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_103               |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   4 - access: REVERSE(A.F2) = B.F1

12 rows fetched.

SQL> explain select * from test_reverse_func_index a join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(A.F2) = 'cba'
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a left join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(A.F2) = 'cba'
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a left join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a right join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                           |      |      |       |        |
| 1   |   FILTER                           |       |                           |      |      |       |        |
| 2   |     NESTED LOOPS OUTER             |       |                           |      |      |       |        |
| 3   |       TABLE ACCESS FULL            | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 5   |         INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
---------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(A.F2) = 'cba'
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a right join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a full join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name                      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                           |      |      |       |        |
| 1   |   FILTER                 |       |                           |      |      |       |        |
| 2   |     HASH JOIN FULL(L)    |       |                           |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(A.F2) = 'cba'
   2 - access: REVERSE(A.F2) = REVERSE(B.F2)

13 rows fetched.

SQL> explain select * from test_reverse_func_index a full join test_reverse_func_index b on reverse(a.f2) = reverse(b.f2) where a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS OUTER             |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a cross join test_reverse_func_index b where reverse(a.f2) = reverse(b.f2) and reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(A.F2) = 'cba'
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a cross join test_reverse_func_index b where reverse(a.f2) = reverse(b.f2) and a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a , test_reverse_func_index b where reverse(a.f2) = reverse(b.f2) and reverse(a.f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(A.F2) = 'cba'
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> explain select * from test_reverse_func_index a , test_reverse_func_index b where reverse(a.f2) = reverse(b.f2) and a.f1 = 1;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                           |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX A |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_003              |      |      |       |        |
| 4   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B |      |      |       |        |
| 5   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001              |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: A.F1 = 1
   5 - access: REVERSE(A.F2) = REVERSE(B.F2)

14 rows fetched.

SQL> --hint
SQL> explain select /*+no_index(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F2) = 'cba'

9 rows fetched.

SQL> explain select /*+no_index(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F2) = 'cba'

9 rows fetched.

SQL> delete from test_reverse_func_index;

2 rows affected.

SQL> insert into test_reverse_func_index values(1,'123','cba'),(2,'223','cba');

2 rows affected.

SQL> explain select /*+index_asc(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> explain select /*+index_desc(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID   | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN DESCENDING | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> select /*+index_asc(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) like '32_';

F1           F2                   F3
------------ -------------------- ----------
1            123                  cba
2            223                  cba

2 rows fetched.

SQL> select /*+index_desc(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) like '32_';

F1           F2                   F3
------------ -------------------- ----------
2            223                  cba
1            123                  cba

2 rows fetched.

SQL> explain select /*+index_ffs(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN       | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> explain select /*+index_ffs(test_reverse_func_index temp_idx_001)*/ count(*) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN      | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select /*+no_index_ffs(test_reverse_func_index temp_idx_001)*/ count(*) from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name                    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                         |      |      |       |        |
| 1   |   AGGR                          |       |                         |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
----------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select /*+index_ffs(test_reverse_func_index temp_idx_001)*/ * from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN       | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> create index upper_idx_001_002 on test_reverse_func_index(upper(f2));

Succeed.

SQL> explain select /*+index_ffs(test_reverse_func_index upper_idx_001_002)*/ * from test_reverse_func_index where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN       | SYS   | UPPER_IDX_001_002       |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> explain select /*+index_ffs(test_reverse_func_index upper_idx_001_002)*/ * from test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN       | SYS   | UPPER_IDX_001_002       |      |      |       |        |
---------------------------------------------------------------------------------------------------------

7 rows fetched.

SQL> --table type
SQL> drop table if exists temp_test_reverse_func_index;

Succeed.

SQL> create global temporary table temp_test_reverse_func_index(f1 int, f2 varchar(400)) ON COMMIT preserve ROWS;

Succeed.

SQL> create index temp_test_reverse_func_index_idx_001 on temp_test_reverse_func_index(reverse(f2));

Succeed.

SQL> insert into temp_test_reverse_func_index values(1, '123'), (3, '456'), (5, '789');

3 rows affected.

SQL> explain select * from temp_test_reverse_func_index where reverse(f2) = '456';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                                 | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEMP_TEST_REVERSE_FUNC_INDEX         |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_TEST_REVERSE_FUNC_INDEX_IDX_001 |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = '456'

10 rows fetched.

SQL> explain with temp as (select * from test_reverse_func_index where reverse(f2) = 'cba') select * from temp;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   SUBSELECT                      |       | TEMP                    |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   3 - access: REVERSE(F2) = 'cba'

11 rows fetched.

SQL> explain with temp as (select * from test_reverse_func_index) select * from temp where reverse(f2) = 'cba';

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                    | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                         |      |      |       |        |
| 1   |   SUBSELECT            |       | TEMP                    |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> create or replace view view_test_reverse_func_index as select * from test_reverse_func_index where reverse(f2) = 'cba';

Succeed.

SQL> explain select * from view_test_reverse_func_index;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | TEMP_IDX_001            |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = 'cba'

10 rows fetched.

SQL> drop view view_test_reverse_func_index;

Succeed.

SQL> drop table temp_test_reverse_func_index;

Succeed.

SQL> drop table test_reverse_func_index;

Succeed.

SQL> drop table test_reverse_func_index2;

Succeed.

SQL>
SQL> --origin sql
SQL> drop table if exists CPS_SIM_DEVICE;

Succeed.

SQL> create table CPS_SIM_DEVICE (
  2   DEVICE_ID                        NUMBER(18) NOT NULL,
  3   MSISDN                           VARCHAR2(18) NOT NULL,
  4   IMSI                             VARCHAR2(64),
  5   IDENTITY_TYPE                    VARCHAR2(4) NOT NULL,
  6   IDENTITY_ID                      NUMBER(18) NOT NULL,
  7   STATUS                           VARCHAR2(2),
  8   DEVICE_TYPE                      CHAR NOT NULL,
  9   CREATE_TIME                      TIMESTAMP,
 10   PIN_KEY                          VARCHAR2(1024),
 11   STK_SIM_KEYT                     NUMBER(16),
 12   ICCID                            VARCHAR2(32),
 13   STK_APP_VERSION                  NUMBER(32),
 14   LOAD_DATA_TS                     TIMESTAMP
 15 );

Succeed.

SQL> create unique index IX_SIM_DEVICE_MSISDN2 on CPS_SIM_DEVICE (MSISDN ASC);

Succeed.

SQL> create index IDX_CPS_SIM_DEVICE_3 on CPS_SIM_DEVICE (REVERSE(MSISDN) ASC);

Succeed.

SQL> create index IDX_SIM_DEVICE_ICCID on CPS_SIM_DEVICE (ICCID ASC);

Succeed.

SQL> alter table CPS_SIM_DEVICE add constraint PK_CPS_SIM_DEVICE primary key (DEVICE_ID);

Succeed.

SQL> explain SELECT * FROM (SELECT T.IDENTITY_ID, T.MSISDN FROM CPS_SIM_DEVICE T WHERE T.IDENTITY_TYPE ='1000'AND REVERSE(T.MSISDN) LIKE REVERSE('%959456219258') ORDER BY T.MSISDN) WHERE 1=1 AND ROWNUM<= 10;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                 | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                      |      |      |       |        |
| 1   |   ROWNUM FILTER                      |       |                      |      |      |       |        |
| 2   |     SUBSELECT                        |       |                      |      |      |       |        |
| 3   |       QUERY SORT ORDER BY ROWNUM     |       |                      |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ROWID  | SYS   | CPS_SIM_DEVICE T     |      |      |       |        |
| 5   |           INDEX RANGE SCAN           | SYS   | IDX_CPS_SIM_DEVICE_3 |      |      |       |        |
------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: ROWNUM <= 10
   4 - filter: T.IDENTITY_TYPE = '1000'
   5 - access: REVERSE(T.MSISDN) LIKE '852912654959%'

15 rows fetched.

SQL> drop table CPS_SIM_DEVICE;

Succeed.

SQL>
SQL> --ddl
SQL> drop table if exists test_reverse_func_index;

Succeed.

SQL> create table test_reverse_func_index(f1 int, f2 varchar(20), f3 char(10));

Succeed.

SQL> create index rev_temp_idx_001 on test_reverse_func_index(reverse(f2)) asc;

CT-00601, [1:71]Sql syntax error: unexpected text asc
SQL> create index rev_temp_idx_002 on test_reverse_func_index(reverse(f1)) dsc;

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_003 on test_reverse_func_index(reverse(f1), reverse(f2));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_004 on test_reverse_func_index(reverse(f3), reverse(f2));

Succeed.

SQL> create index rev_temp_idx_005 on test_reverse_func_index(f1, reverse(f2)) reverse;

Succeed.

SQL> create index rev_temp_idx_006 on test_reverse_func_index(reverse(f2)) reverse;

Succeed.

SQL> drop index rev_temp_idx_005 on test_reverse_func_index;

Succeed.

SQL> drop index rev_temp_idx_006 on test_reverse_func_index;

Succeed.


SQL> drop index rev_temp_idx_001 on test_reverse_func_index;

CT-00830, Index SYS.REV_TEMP_IDX_001 does not exist
SQL> drop index rev_temp_idx_004 on test_reverse_func_index;

Succeed.

SQL> create index rev_temp_idx_005 on test_reverse_func_index(f1, reverse(f2));

Succeed.

SQL> create unique index rev_temp_idx_007 on test_reverse_func_index(reverse(f2)) online;

Succeed.

SQL> create unique index rev_temp_idx_008 on test_reverse_func_index(reverse(f2)) reverse;

CT-00726, The column has been indexed by REV_TEMP_IDX_007.
SQL> create unique index rev_temp_idx_009 on test_reverse_func_index(reverse('aaa'));

CT-00601, [1:72]Sql syntax error: invalid variant/object name was found
SQL> create index rev_temp_idx_100 on test_reverse_func_index(reverse(reverse(f2)));

Succeed.

SQL> create index rev_temp_idx_101 on test_reverse_func_index(upper(reverse(f2)));

Succeed.

SQL> create index if not exists index rev_temp_idx_007 on test_reverse_func_index(reverse(f2));

CT-00601, [1:28]Sql syntax error: invalid variant/object name was found
SQL> create index if not exists index rev_temp_idx_107 on test_reverse_func_index(reverse(f2));

CT-00601, [1:28]Sql syntax error: invalid variant/object name was found
SQL> alter table test_reverse_func_index add constraint pk_111101 primary key (f1) using index rev_temp_idx_005;

CT-00679, The index cannot be used as a constraint
SQL> alter table test_reverse_func_index add constraint pk_111101 primary key (reverse(f2)) using index rev_temp_idx_007;

CT-00601, Sql syntax error: invalid identifier
SQL> explain select * from test_reverse_func_index where reverse(reverse(f2))=?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | REV_TEMP_IDX_100        |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(REVERSE(F2)) = ?

10 rows fetched.

SQL> --alter index
SQL> alter index rev_temp_idx_007 on test_reverse_func_index rebuild;

Succeed.

SQL> alter index rev_temp_idx_007 on test_reverse_func_index rebuild online;

Succeed.

SQL> alter index rev_temp_idx_007 on test_reverse_func_index rebuild online parallel 2;

CT-00130, Operation parallel rebuild is not supported on rebuild index online
SQL> alter index rev_temp_idx_007 on test_reverse_func_index rebuild parallel 2;

CT-00130, Operation rebuild index parallel is not supported on functional index
SQL> alter index rev_temp_idx_007 on test_reverse_func_index rename to rev_temp_idx_009;

Succeed.

SQL> drop table test_reverse_func_index;

Succeed.

SQL>
SQL> --datatype
SQL> create table test_reverse_func_index(f1 bigint, f2 binary(10), f3 binary_bigint, f4 binary_double, f5 binary_float, f6 binary_integer, f7 binary_uint32, f8 blob, f9 bool, f10 boolean, f11 bpchar, f12 bytea, f13 char, f14 character, f15 clob, f16 date, f17 datetime, f18 decimal, f19 double, f20 float, f21 image, f23 int, f24 integer, f25 interval year to month, f26 long, f27 longblob, f28 longtext, f29 mediumblob, f30 nchar, f31 number, f32 numeric, f33 nvarchar(10), f34 nvarchar2(10), f35 raw(10), f36 real, f37 serial primary key, f38 short, f39 smallint, f40 text, f41 timestamp, f42 tinyint, f43 interval day to second, f44 uint, f45 uinteger, f46 ushort, f47 usmallint, f48 utinyint, f49 varbinary(10), f50 varchar(10), f51 varchar2(10));

Succeed.

SQL> create index rev_temp_idx_001 on test_reverse_func_index(reverse(f1));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_BIGINT
SQL> create index rev_temp_idx_002 on test_reverse_func_index(reverse(f2));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY
SQL> create index rev_temp_idx_003 on test_reverse_func_index(reverse(f3));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_BIGINT
SQL> create index rev_temp_idx_004 on test_reverse_func_index(reverse(f4));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_DOUBLE
SQL> create index rev_temp_idx_005 on test_reverse_func_index(reverse(f5));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_DOUBLE
SQL> create index rev_temp_idx_006 on test_reverse_func_index(reverse(f6));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_007 on test_reverse_func_index(reverse(f7));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_008 on test_reverse_func_index(reverse(f8));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BLOB
SQL> create index rev_temp_idx_009 on test_reverse_func_index(reverse(f9));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BOOLEAN
SQL> create index rev_temp_idx_010 on test_reverse_func_index(reverse(f10));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BOOLEAN
SQL> create index rev_temp_idx_011 on test_reverse_func_index(reverse(f11));

Succeed.

SQL> create index rev_temp_idx_012 on test_reverse_func_index(reverse(f12));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BLOB
SQL> create index rev_temp_idx_013 on test_reverse_func_index(reverse(f13));

Succeed.

SQL> create index rev_temp_idx_014 on test_reverse_func_index(reverse(f14));

Succeed.

SQL> create index rev_temp_idx_015 on test_reverse_func_index(reverse(f15));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got CLOB
SQL> create index rev_temp_idx_016 on test_reverse_func_index(reverse(f16));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got DATE
SQL> create index rev_temp_idx_017 on test_reverse_func_index(reverse(f17));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got DATE
SQL> create index rev_temp_idx_018 on test_reverse_func_index(reverse(f18));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got NUMBER
SQL> create index rev_temp_idx_019 on test_reverse_func_index(reverse(f19));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_DOUBLE
SQL> create index rev_temp_idx_020 on test_reverse_func_index(reverse(f20));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_DOUBLE
SQL> create index rev_temp_idx_021 on test_reverse_func_index(reverse(f21));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got IMAGE
SQL> create index rev_temp_idx_022 on test_reverse_func_index(reverse(f22));

CT-00601, [1:65]Sql syntax error: invalid column name 'F22'
SQL> create index rev_temp_idx_023 on test_reverse_func_index(reverse(f23));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_024 on test_reverse_func_index(reverse(f24));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_025 on test_reverse_func_index(reverse(f25));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got INTERVAL YEAR TO MONTH
SQL> create index rev_temp_idx_026 on test_reverse_func_index(reverse(f26));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got CLOB
SQL> create index rev_temp_idx_027 on test_reverse_func_index(reverse(f27));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got IMAGE
SQL> create index rev_temp_idx_028 on test_reverse_func_index(reverse(f28));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got CLOB
SQL> create index rev_temp_idx_029 on test_reverse_func_index(reverse(f29));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got IMAGE
SQL> create index rev_temp_idx_030 on test_reverse_func_index(reverse(f30));

Succeed.

SQL> create index rev_temp_idx_031 on test_reverse_func_index(reverse(f31));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got NUMBER
SQL> create index rev_temp_idx_032 on test_reverse_func_index(reverse(f32));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got NUMBER
SQL> create index rev_temp_idx_033 on test_reverse_func_index(reverse(f33));

Succeed.

SQL> create index rev_temp_idx_034 on test_reverse_func_index(reverse(f34));

Succeed.

SQL> create index rev_temp_idx_035 on test_reverse_func_index(reverse(f35));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got RAW
SQL> create index rev_temp_idx_036 on test_reverse_func_index(reverse(f36));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_DOUBLE
SQL> create index rev_temp_idx_037 on test_reverse_func_index(reverse(f37));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_BIGINT
SQL> create index rev_temp_idx_038 on test_reverse_func_index(reverse(f38));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_039 on test_reverse_func_index(reverse(f39));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_040 on test_reverse_func_index(reverse(f40));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got CLOB
SQL> create index rev_temp_idx_041 on test_reverse_func_index(reverse(f41));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got TIMESTAMP
SQL> create index rev_temp_idx_042 on test_reverse_func_index(reverse(f42));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_INTEGER
SQL> create index rev_temp_idx_043 on test_reverse_func_index(reverse(f43));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got INTERVAL DAY TO SECOND
SQL> create index rev_temp_idx_044 on test_reverse_func_index(reverse(f44));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_045 on test_reverse_func_index(reverse(f45));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_046 on test_reverse_func_index(reverse(f46));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_047 on test_reverse_func_index(reverse(f47));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_048 on test_reverse_func_index(reverse(f48));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got BINARY_UINT32
SQL> create index rev_temp_idx_049 on test_reverse_func_index(reverse(f49));

CT-00614, [1:65]Parameter error: illegal function argument: string argument expected - got VARBINARY
SQL> create index rev_temp_idx_050 on test_reverse_func_index(reverse(f50));

Succeed.

SQL> create index rev_temp_idx_051 on test_reverse_func_index(reverse(f51));

Succeed.

SQL> drop table test_reverse_func_index;

Succeed.

SQL>
SQL> --PARTITION
SQL> create table test_reverse_func_index(f1 varchar(10), f2 varchar(10), f3 varchar(10)) partition by range (f1) (partition p1 values less than ('10'), partition p2 values less than (maxvalue));

Succeed.

SQL> create unique index rev_temp_idx_001 on test_reverse_func_index(reverse(f1)) local;

CT-00816, Table partition key should be subsets of local primary or unique index
SQL> create index rev_temp_idx_101 on test_reverse_func_index(reverse(dbe_lob.substr('123456',1) || f1)) local;

Succeed.

SQL> create index rev_temp_idx_001 on test_reverse_func_index(reverse(f1));

Succeed.

SQL> create index rev_temp_idx_002 on test_reverse_func_index(reverse(f2));

Succeed.

SQL> create index rev_temp_idx_003 on test_reverse_func_index(reverse(f3)) local;

Succeed.

SQL> explain select * from test_reverse_func_index where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_003        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_002        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index partition(p1) where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_003        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index partition(p1) where reverse(f2) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_002        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f1) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_001        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F1) = ?

10 rows fetched.

SQL> alter index rev_temp_idx_002 on test_reverse_func_index modify partition p1 initrans 2;

CT-01112, The common index was treated as a (sub)partitioned index
SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 initrans 2;

Succeed.

SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 coalesce;

Succeed.

SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 unusable;

Succeed.

SQL> explain select * from test_reverse_func_index where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                    | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS FULL Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   1 - filter: REVERSE(F3) = ?

9 rows fetched.

SQL> alter table test_reverse_func_index modify f2 varchar(5);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table test_reverse_func_index modify f2 char(10);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table test_reverse_func_index modify f2 varchar(10);

CT-00130, Operation modify column is not supported on functional index
SQL> insert into test_reverse_func_index values ('aaa','aaa','aaa');

1 rows affected.

SQL> alter table test_reverse_func_index modify f2 varchar(20);

CT-00130, Operation modify column is not supported on functional index
SQL> alter table test_reverse_func_index modify f2 varchar(5);

CT-00805, Column F2 is not empty in table TEST_REVERSE_FUNC_INDEX
SQL> alter table test_reverse_func_index modify f2 char(20);

CT-00130, Operation modify column is not supported on functional index
SQL> select * from test_reverse_func_index where f2 = 'aaa';

F1         F2         F3        
---------- ---------- ----------
aaa        aaa        aaa       

1 rows fetched.

SQL> drop table test_reverse_func_index;

Succeed.

SQL> --subpartition
SQL> create table test_reverse_func_index(f1 varchar(10), f2 varchar(10), f3 varchar(10)) partition by range (f1) subpartition by range (f2) (partition p1 values less than ('10') (subpartition p11 values less than('123'), subpartition p12 values less than('789')), partition p2 values less than (maxvalue)(subpartition p21 values less than('123'), subpartition p22 values less than('789')));

Succeed.

SQL> create index rev_temp_idx_001 on test_reverse_func_index(reverse(f1));

Succeed.

SQL> create index rev_temp_idx_002 on test_reverse_func_index(reverse(f2));

Succeed.

SQL> create index rev_temp_idx_003 on test_reverse_func_index(reverse(f3)) local;

Succeed.

SQL> explain select * from test_reverse_func_index where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_003        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f2) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_002        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index partition(p1) where reverse(f3) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_003        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F3) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index partition(p1) where reverse(f2) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,1) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_002        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F2) = ?

10 rows fetched.

SQL> explain select * from test_reverse_func_index where reverse(f1) = ?;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID Filter:[0,2) | SYS   | TEST_REVERSE_FUNC_INDEX |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | REV_TEMP_IDX_001        |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   2 - access: REVERSE(F1) = ?

10 rows fetched.

SQL> alter index rev_temp_idx_002 on test_reverse_func_index modify partition p1 initrans 2;

CT-01112, The common index was treated as a (sub)partitioned index
SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 initrans 2;

Succeed.

SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 coalesce;

Succeed.

SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify partition p1 unusable;

Succeed.

SQL> alter table test_reverse_func_index modify f2 varchar(5);

CT-00130, Operation modify column is not supported on functional index
SQL> alter index rev_temp_idx_002 on test_reverse_func_index modify subpartition p21 initrans 2;

CT-00601, [1:54]Sql syntax error: unexpected word initrans found.
SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify subpartition p21 initrans 2;

CT-00601, [1:54]Sql syntax error: unexpected word initrans found.
SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify subpartition p21 coalesce;

Succeed.

SQL> alter index rev_temp_idx_003 on test_reverse_func_index modify subpartition p21 unusable;

Succeed.

SQL> drop table test_reverse_func_index;

Succeed.

SQL> --dts
SQL> create table test_reverse_func_index(f1 varchar(20));

Succeed.

SQL> insert into test_reverse_func_index values('123');

1 rows affected.

SQL> create index idx_test_reverse_func_index_001 on test_reverse_func_index(reverse(f1));

Succeed.

SQL> explain select * from test_reverse_func_index a join test_reverse_func_index b on reverse(a.f1) > reverse(b.f1);

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                 |      |      |       |        |
| 1   |   NESTED LOOPS                   |       |                                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL            | SYS   | TEST_REVERSE_FUNC_INDEX A       |      |      |       |        |
| 3   |     TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_REVERSE_FUNC_INDEX B       |      |      |       |        |
| 4   |       INDEX RANGE SCAN           | SYS   | IDX_TEST_REVERSE_FUNC_INDEX_001 |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):
-----------------------------------------
   4 - access: REVERSE(A.F1) > REVERSE(B.F1)

12 rows fetched.

SQL> insert into test_reverse_func_index select * from test_reverse_func_index ON DUPLICATE KEY UPDATE f1 = reverse(f1);

1 rows affected.

SQL> drop table test_reverse_func_index;

Succeed.

