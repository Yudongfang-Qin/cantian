

SQL> --test orcle pl/sql example 
SQL> --URL: https://docs.oracle.com/cd/B28359_01/appdev.111/b28370/overview.htm#g12979
SQL> 
SQL> set serveroutput on;

ON
SQL> 
SQL> --prepare table
SQL> drop table if exists employees;

Succeed.

SQL> CREATE TABLE employees
  2 (
  3 employee_id      number,
  4 salary           number,
  5 job_id           varchar2(32),
  6 last_name        varchar2(32),
  7 first_name       varchar2(32),
  8 commission_pct   number,
  9 hire_date        date,
 10 manager_id       number
 11 );

Succeed.

SQL> 
SQL> insert into employees values(1,1000,'PU_CLERK','zhang','san',500,'2017-5-4',10);

1 rows affected.

SQL> insert into employees values(2,2000,'SH_CLERK','li','si',1000,'2017-5-5',10);

1 rows affected.

SQL> insert into employees values(100,3000,'ST_CLERK','liu','xing',2000,'2017-5-6',10);

1 rows affected.

SQL> insert into employees values(115,2000,'SH_CLERK','lll','si',1000,'2017-5-5',10);

1 rows affected.

SQL> insert into employees values(120,4000,'ST_CLERK','wang',',xing',4000,'2018-5-6',10);

1 rows affected.

SQL> select * from employees;

EMPLOYEE_ID                              SALARY                                   JOB_ID                           LAST_NAME                        FIRST_NAME                       COMMISSION_PCT                           HIRE_DATE              MANAGER_ID                              
---------------------------------------- ---------------------------------------- -------------------------------- -------------------------------- -------------------------------- ---------------------------------------- ---------------------- ----------------------------------------
1                                        1000                                     PU_CLERK                         zhang                            san                              500                                      2017-05-04 00:00:00    10                                      
2                                        2000                                     SH_CLERK                         li                               si                               1000                                     2017-05-05 00:00:00    10                                      
100                                      3000                                     ST_CLERK                         liu                              xing                             2000                                     2017-05-06 00:00:00    10                                      
115                                      2000                                     SH_CLERK                         lll                              si                               1000                                     2017-05-05 00:00:00    10                                      
120                                      4000                                     ST_CLERK                         wang                             ,xing                            4000                                     2018-05-06 00:00:00    10                                      

5 rows fetched.

SQL> 
SQL> --Example 1-1 PL/SQL Block Structure
SQL> 
SQL> DECLARE    -- Declarative part (optional)
  2   -- Declarations of local types, variables, & subprograms
  3 
  4 BEGIN      -- Executable part (required)
  5   -- Statements (which can use items declared in declarative part)
  6 
  7 EXCEPTION -- Exception-handling part (optional)
  8   -- Exception handlers for exceptions raised in executable part]
  9 END;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[9:1] PLC-00954 WHEN expected but END found
[10:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> --Example 1-2 PL/SQL Variable Declarations
SQL> 
SQL> DECLARE
  2     part_number       NUMBER(6);     -- SQL data type
  3     part_name         VARCHAR2(20);  -- SQL data type
  4     in_stock          BOOLEAN;       -- PL/SQL-only data type
  5     part_price        NUMBER(6,2);   -- SQL data type
  6     part_description  VARCHAR2(50);  -- SQL data type
  7   BEGIN
  8     NULL;
  9   END;
 10   /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --Example 1-3 Assigning Values to Variables with the Assignment Operator
SQL> 
SQL> DECLARE  -- You can assign values here
  2   wages          NUMBER;
  3   hours_worked   NUMBER := 40;
  4   hourly_salary  NUMBER := 22.50;
  5   bonus          NUMBER := 150;
  6   country        VARCHAR2(128);
  7   counter        NUMBER := 0;
  8   done           BOOLEAN;
  9   valid_id       BOOLEAN;
 10   emp_rec1       employees%ROWTYPE;
 11   emp_rec2       employees%ROWTYPE;
 12   TYPE commissions IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
 13   comm_tab       commissions;
 14 
 15 BEGIN  -- You can assign values here too
 16    wages := (hours_worked * hourly_salary) + bonus;
 17    country := 'France';
 18    country := UPPER('Canada');
 19    done := (counter > 100);
 20    valid_id := TRUE;
 21    emp_rec1.first_name := 'Antonio';
 22    emp_rec1.last_name := 'Ortiz';
 23    emp_rec1 := emp_rec2;
 24    comm_tab(5) := 20000 * 0.15;
 25 END;
 26 /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL>  --Example 1-4 Using SELECT INTO to Assign Values to Variables
SQL> 
SQL> DECLARE
  2   bonus   NUMBER(8,2);
  3   emp_id  NUMBER(6) := 100;
  4 BEGIN
  5   SELECT salary * 0.10 INTO bonus
  6     FROM employees
  7       WHERE employee_id = emp_id;
  8 END;
  9 /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> 
SQL> --Example 1-5 Assigning Values to Variables as Parameters of a Subprogram
SQL> 
SQL> create or replace PROCEDURE adjust_salary (
  2   emp_id      NUMBER,
  3   sal IN  OUT NUMBER
  4 ) IS
  5   emp_job  VARCHAR2(10);
  6   avg_sal  NUMBER(8,2);
  7 BEGIN
  8   SELECT job_id INTO emp_job
  9     FROM employees
 10       WHERE employee_id = emp_id;
 11 
 12   SELECT AVG(salary) INTO avg_sal
 13     FROM employees
 14       WHERE job_id = emp_job;
 15 
 16   dbe_output.print_line ('The average salary for '
 17                         || emp_job
 18                         || ' employees: '
 19                         || TO_CHAR(avg_sal)
 20                        );
 21 
 22   sal := (sal + avg_sal)/2;
 23 END;
 24 /

Succeed.

SQL> 
SQL> DECLARE
  2 new_sal  NUMBER(8,2);
  3 emp_id   NUMBER(6) := 126;
  4   BEGIN
  5     SELECT AVG(salary) INTO new_sal
  6       FROM employees;
  7     dbe_output.print_line ('The average salary for all employees: '
  8                           || TO_CHAR(new_sal)
  9                          );
 10   
 11     adjust_salary(emp_id, new_sal);
 12   END;
 13   /

The average salary for all employees: 2400
CT-00932, [11:5] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:3] PL/SQL(SYS.ADJUST_SALARY) terminated with execute errors
[8:3] CT-00906, In PL/SQL, running SELECT INTO or EXECUTE IMMEDIATE INTO to grant values to variables had no data found.

SQL> 
SQL> drop procedure adjust_salary;

Succeed.

SQL> 
SQL> 
SQL> 
SQL> --Example 1-6 Using %ROWTYPE with an Explicit Cursor
SQL> DECLARE
  2   CURSOR c1 IS
  3     SELECT last_name, salary, hire_date, job_id
  4       FROM employees
  5         WHERE employee_id = 120;
  6 
  7    employee_rec c1%ROWTYPE;
  8 
  9 BEGIN
 10   OPEN c1;
 11   FETCH c1 INTO employee_rec;
 12   dbe_output.print_line('Employee name: ' || employee_rec.last_name);
 13   CLOSE c1;
 14 END;
 15 /

Employee name: wang

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --Example 1-7 Using a PL/SQL Collection Type
SQL> 
SQL> DECLARE
  2   TYPE staff_list IS TABLE OF employees.employee_id%TYPE;
  3   staff  staff_list;
  4   lname  employees.last_name%TYPE;
  5   fname  employees.first_name%TYPE;
  6 BEGIN
  7   staff := staff_list(100, 114, 115, 120, 122);
  8 
  9   FOR i IN staff.FIRST..staff.LAST LOOP
 10     SELECT last_name, first_name INTO lname, fname
 11       FROM employees
 12         WHERE employees.employee_id = staff(i);
 13 
 14      dbe_output.print_line (TO_CHAR(staff(i))
 15                            || ': '
 16                            || lname
 17                            || ', '
 18                            || fname
 19                           );
 20   END LOOP;
 21 END;
 22 /

100: liu, xing
CT-00932, [10:5] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[10:5] CT-00906, In PL/SQL, running SELECT INTO or EXECUTE IMMEDIATE INTO to grant values to variables had no data found.

SQL> 
SQL> 
SQL> 
SQL> --Example 1-8 Declaring a Record Type
SQL> 
SQL> DECLARE
  2   TYPE timerec IS RECORD (
  3     hours   SMALLINT,
  4     minutes SMALLINT
  5   );
  6 
  7   TYPE meeting_type IS RECORD (
  8     date_held  DATE,
  9     duration   timerec,  -- nested record
 10     location   VARCHAR2(20),
 11     purpose    VARCHAR2(50)
 12   );
 13 
 14 BEGIN
 15   NULL;
 16 END;
 17 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --Example 1-9 Defining an Object Type
SQL> 
SQL> CREATE OR REPLACE TYPE bank_account AS OBJECT (
  2   acct_number NUMBER(5),
  3   balance     NUMBER,
  4   status      VARCHAR2(10),
  5 
  6   MEMBER PROCEDURE open
  7     (SELF IN OUT NOCOPY bank_account,
  8      amount IN NUMBER),
  9 
 10   MEMBER PROCEDURE close
 11     (SELF IN OUT NOCOPY bank_account,
 12      num IN NUMBER,
 13      amount OUT NUMBER),
 14 
 15   MEMBER PROCEDURE deposit
 16     (SELF IN OUT NOCOPY bank_account,
 17      num IN NUMBER,
 18      amount IN NUMBER),
 19 
 20   MEMBER PROCEDURE withdraw
 21     (SELF IN OUT NOCOPY bank_account,
 22      num IN NUMBER,
 23      amount IN NUMBER),
 24 
 25   MEMBER FUNCTION curr_bal (num IN NUMBER) RETURN NUMBER
 26 );
 27 /

Succeed.
Warning:
PL/SQL(SYS.BANK_ACCOUNT) terminated with compiling errors
[6:3] PLC-00958 Unsupported feature


SQL> 
SQL> --Example 1-10 Using the IF-THEN-ELSE and CASE Statement for Conditional Control
SQL> 
SQL>  DECLARE
  2     jobid      employees.job_id%TYPE;
  3     empid      employees.employee_id%TYPE := 115;
  4     sal        employees.salary%TYPE;
  5     sal_raise  NUMBER(3,2);
  6  BEGIN
  7    SELECT job_id, salary INTO jobid, sal
  8      FROM employees
  9        WHERE employee_id = empid;
 10  
 11    CASE
 12      WHEN jobid = 'PU_CLERK' THEN
 13        IF sal < 3000 THEN
 14          sal_raise := .12;
 15        ELSE
 16          sal_raise := .09;
 17        END IF;
 18  
 19      WHEN jobid = 'SH_CLERK' THEN
 20        IF sal < 4000 THEN
 21          sal_raise := .11;
 22        ELSE
 23          sal_raise := .08;
 24        END IF;
 25  
 26      WHEN jobid = 'ST_CLERK' THEN
 27        IF sal < 3500 THEN
 28          sal_raise := .10;
 29        ELSE
 30          sal_raise := .07;
 31        END IF;
 32  
 33      ELSE
 34        BEGIN
 35          dbe_output.print_line('No raise for this job: ' || jobid);
 36        END;
 37     END CASE;
 38  
 39     UPDATE employees
 40       SET salary = salary + salary * sal_raise
 41         WHERE employee_id = empid;
 42  END;
 43  /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> --Example 1-11 Using the FOR-LOOP
SQL> drop table if exists sqr_root_sum;

Succeed.

SQL> CREATE TABLE sqr_root_sum (
  2   num NUMBER,
  3   sq_root NUMBER(6,2),
  4   sqr NUMBER,
  5   sum_sqrs NUMBER
  6 );

Succeed.

SQL> DECLARE
  2    s  INTEGER;
  3 BEGIN
  4   FOR i in 1..100 LOOP
  5     s := (i * (i + 1) * (2*i +1)) / 6;  -- sum of squares
  6 
  7     INSERT INTO sqr_root_sum
  8       VALUES (i, SQRT(i), i*i, s );
  9   END LOOP;
 10 END;
 11 /

PL/SQL procedure successfully completed.

SQL> drop table if exists sqr_root_sum;

Succeed.

SQL> 
SQL> --Example 1-12 Using WHILE-LOOP for Control
SQL> drop table if exists temp_20181220_whileloop;

Succeed.

SQL> CREATE TABLE temp_20181220_whileloop (
  2   tempid   NUMBER(6),
  3   tempsal  NUMBER(8,2),
  4   tempname VARCHAR2(25)
  5 );

Succeed.

SQL> 
SQL> DECLARE
  2   sal             employees.salary%TYPE := 0;
  3   mgr_id          employees.manager_id%TYPE;
  4   lname           employees.last_name%TYPE;
  5   starting_empid  employees.employee_id%TYPE := 120;
  6 
  7 BEGIN
  8    SELECT manager_id INTO mgr_id
  9      FROM employees
 10        WHERE employee_id = starting_empid;
 11 
 12    WHILE sal <= 15000 LOOP
 13      SELECT salary, manager_id, last_name INTO sal, mgr_id, lname
 14        FROM employees
 15          WHERE employee_id = mgr_id;
 16    END LOOP;
 17 
 18    INSERT INTO temp_20181220_whileloop
 19       VALUES (NULL, sal, lname);
 20 
 21 EXCEPTION
 22   WHEN NO_DATA_FOUND THEN
 23     INSERT INTO temp_20181220_whileloop VALUES (NULL, NULL, 'Not found');
 24 END;
 25 /

PL/SQL procedure successfully completed.

SQL> drop table if exists temp_20181220_whileloop;

Succeed.

SQL> 
SQL> 
SQL> --Example 1-13 Using the EXIT-WHEN Statement
SQL> 
SQL> CREATE TABLE temp_20181220_exitwhen (
  2   tempid   NUMBER(6),
  3   tempsal  NUMBER(8,2),
  4   tempname VARCHAR2(25)
  5 );

Succeed.

SQL> 
SQL> DECLARE
  2   total    NUMBER(9) := 0;
  3   counter  NUMBER(6) := 0;
  4 BEGIN
  5   LOOP
  6     counter := counter + 1;
  7     total   := total + counter * counter;
  8     EXIT WHEN total > 25000;
  9   END LOOP;
 10 
 11   dbe_output.print_line ('Counter: '
 12                         || TO_CHAR(counter)
 13                         || ' Total: '
 14                         || TO_CHAR(total)
 15                        );
 16 END;
 17 /

Counter: 42 Total: 25585

PL/SQL procedure successfully completed.

SQL> drop table if exists temp_20181220_exitwhen;

Succeed.

SQL> 
SQL> 
SQL> 
SQL> --Example 1-14 Using the GOTO Statement
SQL> 
SQL> DECLARE
  2   total    NUMBER(9) := 0;
  3   counter  NUMBER(6) := 0;
  4 BEGIN
  5   <<calc_total>>
  6   counter := counter + 1;
  7   total := total + counter * counter;
  8 
  9   IF total > 25000 THEN
 10     GOTO print_total;
 11   ELSE
 12     GOTO calc_total;
 13   END IF;
 14 
 15   <<print_total>>
 16   dbe_output.print_line
 17     ('Counter: ' || TO_CHAR(counter) || ' Total: ' || TO_CHAR(total));
 18 END;
 19 /

Counter: 42 Total: 25585

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> 
SQL> --Example 1-15 PL/SQL Procedure   
SQL> -- error: not support creating a inner PROCEDURE 
SQL> DECLARE
  2   in_string   VARCHAR2(100) := 'Test string';
  3   out_string  VARCHAR2(200);
  4 
  5   PROCEDURE double (
  6     original    IN  VARCHAR2,
  7     new_string  OUT VARCHAR2
  8   ) AS
  9   BEGIN
 10     new_string := original || original;
 11   END;
 12 
 13 BEGIN
 14   dbe_output.print_line ('in_string: ' || in_string);
 15   double (in_string, out_string);
 16   dbe_output.print_line ('out_string: ' || out_string);
 17 END;
 18 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:13] PLC-00958 Unsupported feature

SQL> 
SQL> 
SQL> 
SQL> --Example 1-16 Creating a Standalone PL/SQL Procedure
SQL> 
SQL> CREATE OR REPLACE PROCEDURE award_bonus (
  2   emp_id NUMBER, bonus NUMBER) AS
  3   commission    REAL;
  4   comm_missing  EXCEPTION;
  5 BEGIN
  6   SELECT commission_pct / 100 INTO commission
  7     FROM employees
  8       WHERE employee_id = emp_id;
  9 
 10   IF commission IS NULL THEN
 11     RAISE comm_missing;
 12   ELSE
 13     UPDATE employees
 14       SET salary = salary + bonus*commission
 15         WHERE employee_id = emp_id;
 16   END IF;
 17 EXCEPTION
 18   WHEN comm_missing THEN
 19     dbe_output.print_line
 20       ('This employee does not receive a commission.');
 21     commission := 0;
 22   WHEN OTHERS THEN
 23     NULL;
 24 END award_bonus;
 25 /

Succeed.

SQL> 
SQL> 
SQL> 
SQL>  --Example 1-17 Invoking a Standalone Procedure from SQL*Plus
SQL> 
SQL> -- Invoke standalone procedure with CALL statement
SQL> CALL award_bonus(179, 1000);

PL/SQL procedure successfully completed.

SQL> -- Invoke standalone procedure from within block
SQL> 
SQL> BEGIN
  2   award_bonus(179, 10000);
  3 END;
  4 /

PL/SQL procedure successfully completed.

SQL> 
SQL> drop procedure award_bonus;

Succeed.

SQL> 
SQL> 
SQL> 
SQL> 
SQL> --Example 1-18 Creating a Trigger
SQL> drop table if exists emp_audit_createTrigger;

Succeed.

SQL> CREATE TABLE emp_audit_createTrigger (
  2   emp_audit_id  NUMBER(6),
  3   up_date       DATE,
  4   new_sal       NUMBER(8,2),
  5   old_sal       NUMBER(8,2)
  6 );

Succeed.

SQL> 
SQL> CREATE OR REPLACE TRIGGER audit_sal
  2   AFTER UPDATE OF salary
  3     ON employees
  4       FOR EACH ROW
  5 BEGIN
  6   INSERT INTO emp_audit_createTrigger
  7     VALUES(:old.employee_id, SYSDATE, :new.salary, :old.salary);
  8 END;
  9 /

Succeed.

SQL> 
SQL>  drop table if exists emp_audit_createTrigger;

Succeed.

SQL>  drop TRIGGER audit_sal;

Succeed.

SQL> 
SQL> --Example 1-19 Creating a Package and Package Body
SQL> -- error: not support Package specification:
SQL> 
SQL> CREATE OR REPLACE PACKAGE emp_actions AS
  2   PROCEDURE hire_employee (
  3     employee_id     NUMBER,
  4     last_name       VARCHAR2,
  5     first_name      VARCHAR2,
  6     email           VARCHAR2,
  7     phone_number    VARCHAR2,
  8     hire_date       DATE,
  9     job_id          VARCHAR2,
 10     salary          NUMBER,
 11     commission_pct  NUMBER,
 12     manager_id      NUMBER,
 13     department_id   NUMBER
 14   );
 15 
 16   PROCEDURE fire_employee (emp_id NUMBER);
 17 
 18   FUNCTION num_above_salary (emp_id NUMBER) RETURN NUMBER;
 19 END emp_actions;
 20 /

Succeed.

SQL> -- Package body:
SQL> CREATE OR REPLACE PACKAGE BODY emp_actions AS
  2   -- Code for procedure hire_employee:
  3   PROCEDURE hire_employee (
  4     employee_id     NUMBER,
  5     last_name       VARCHAR2,
  6     first_name      VARCHAR2,
  7     email           VARCHAR2,
  8     phone_number    VARCHAR2,
  9     hire_date       DATE,
 10     job_id          VARCHAR2,
 11     salary          NUMBER,
 12     commission_pct  NUMBER,
 13     manager_id      NUMBER,
 14     department_id   NUMBER
 15   ) IS
 16   BEGIN
 17     INSERT INTO employees
 18       VALUES (employee_id,
 19               last_name,
 20               first_name,
 21               email,
 22               phone_number,
 23               hire_date,
 24               job_id,
 25               salary,
 26               commission_pct,
 27               manager_id,
 28               department_id);
 29   END hire_employee;
 30 
 31   -- Code for procedure fire_employee:
 32   PROCEDURE fire_employee (emp_id NUMBER) IS
 33   BEGIN
 34     DELETE FROM employees
 35       WHERE employee_id = emp_id;
 36   END fire_employee;
 37   -- Code for function num_above_salary:
 38 
 39   FUNCTION num_above_salary (emp_id NUMBER) RETURN NUMBER IS
 40     emp_sal NUMBER(8,2);
 41     num_count NUMBER;
 42   BEGIN
 43     SELECT salary INTO emp_sal
 44       FROM employees
 45         WHERE employee_id = emp_id;
 46 
 47     SELECT COUNT(*) INTO num_count
 48       FROM employees
 49         WHERE salary > emp_sal;
 50 
 51     RETURN num_count;
 52   END num_above_salary;
 53 END emp_actions;
 54 /

Succeed.
Warning:
PL/SQL(SYS.EMP_ACTIONS) terminated with compiling errors
[15:3] PLC-00944 PL/SQL(SYS.EMP_ACTIONS.HIRE_EMPLOYEE) terminated with compiling errors
[17:5] PLC-00601 Sql syntax error: too many value expressions



SQL> 
SQL> 
SQL> --Example 1-20 Invoking a Procedure in a Package
SQL> --error, same as Example 1-19
SQL> CALL emp_actions.hire_employee (300, 'Belden', 'Enrique',
  2   'EBELDEN', '555.111.2222',
  3   '31-AUG-04', 'AC_MGR', 9000,
  4   .1, 101, 110);

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[1:2] CT-00944, PL/SQL(SYS.EMP_ACTIONS) terminated with compiling errors
[15:3] PLC-00944 PL/SQL(SYS.EMP_ACTIONS.HIRE_EMPLOYEE) terminated with compiling errors
[17:5] PLC-00601 Sql syntax error: too many value expressions



SQL> BEGIN
  2   dbe_output.print_line
  3     ('Number of employees with higher salary: ' ||
  4       TO_CHAR(emp_actions.num_above_salary(120)));
  5 
  6   emp_actions.fire_employee(300);
  7 END;
  8 /

CT-00932, [2:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[2:3] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
[4:7] PL/SQL(PUBLIC.TO_CHAR) terminated with execute errors
[4:15] CT-00944, PL/SQL(SYS.EMP_ACTIONS) terminated with compiling errors
[15:3] PLC-00944 PL/SQL(SYS.EMP_ACTIONS.HIRE_EMPLOYEE) terminated with compiling errors
[17:5] PLC-00601 Sql syntax error: too many value expressions



SQL> 
SQL> 
SQL> 
SQL> --Example 1-21 Processing Query Results in a LOOP
SQL> BEGIN
  2   FOR someone IN (SELECT * FROM employees WHERE employee_id < 120)
  3   LOOP
  4     dbe_output.print_line('First name = ' || someone.first_name ||
  5                          ', Last name = ' || someone.last_name);
  6   END LOOP;
  7 END;
  8 /

First name = san, Last name = zhang
First name = si, Last name = li
First name = xing, Last name = liu
First name = si, Last name = lll

PL/SQL procedure successfully completed.

SQL> 
SQL> --TO the end
SQL> select * from employees;

EMPLOYEE_ID                              SALARY                                   JOB_ID                           LAST_NAME                        FIRST_NAME                       COMMISSION_PCT                           HIRE_DATE              MANAGER_ID                              
---------------------------------------- ---------------------------------------- -------------------------------- -------------------------------- -------------------------------- ---------------------------------------- ---------------------- ----------------------------------------
1                                        1000                                     PU_CLERK                         zhang                            san                              500                                      2017-05-04 00:00:00    10                                      
2                                        2000                                     SH_CLERK                         li                               si                               1000                                     2017-05-05 00:00:00    10                                      
100                                      3000                                     ST_CLERK                         liu                              xing                             2000                                     2017-05-06 00:00:00    10                                      
115                                      2220                                     SH_CLERK                         lll                              si                               1000                                     2017-05-05 00:00:00    10                                      
120                                      4000                                     ST_CLERK                         wang                             ,xing                            4000                                     2018-05-06 00:00:00    10                                      

5 rows fetched.

SQL> drop table if exists employees;

Succeed.

SQL> 
SQL> --DTS2019011607612
SQL> drop table if exists trigger8_bingfa_Tab_001;

Succeed.

SQL> create table trigger8_bingfa_Tab_001(id int primary key,sal number(10,2),name varchar(100),text clob default 'test',c_time date,m_time datetime);

Succeed.

SQL> insert into trigger8_bingfa_Tab_001 values(1,123.11,'test','lob',sysdate,sysdate);

1 rows affected.

SQL> insert into trigger8_bingfa_Tab_001 values(19,123.11,'test','lob',sysdate,sysdate);

1 rows affected.

SQL> insert into trigger8_bingfa_Tab_001 values(100,123.11,'test','lob',sysdate,sysdate);

1 rows affected.

SQL> create or replace procedure  FVT_FUNCTION_DDL_002_Proc_01 is
  2 a varchar(10);
  3 begin
  4 select 'abc' into a from dual;
  5 update trigger8_bingfa_Tab_001 set text = a;
  6 end;
  7 /

Succeed.

SQL> create or replace procedure  FVT_FUNCTION_DDL_002_Proc_02 is
  2 a varchar(10);
  3 begin
  4 for i in 1..5
  5 loop
  6 sys.FVT_FUNCTION_DDL_002_Proc_01;
  7 end loop;
  8 end;
  9 /

Succeed.

SQL> exec FVT_FUNCTION_DDL_002_Proc_02;

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists FVT_FUNCTION_DML_004_T_03;

Succeed.

SQL> create table FVT_FUNCTION_DML_004_T_03(id int,name varchar2(100));

Succeed.

SQL> drop user if exists FVT_FUNCTION_DML_004_U_01 cascade;

Succeed.

SQL> create user FVT_FUNCTION_DML_004_U_01 identified by password_123;

Succeed.

SQL> 
SQL> GRANT INSERT ON sys.FVT_FUNCTION_DML_004_T_03 TO FVT_FUNCTION_DML_004_U_01;

Succeed.

SQL> create or replace function  FVT_FUNCTION_DML_004_U_01.FVT_FUNCTION_DML_004_V_03 return int
  2 is 
  3 a int := 0;
  4 begin
  5 for i in  1..5
  6 loop
  7 insert into sys.FVT_FUNCTION_DML_004_T_03 values(2,'commit');
  8 a := a+1;
  9 end loop;
 10 return a;
 11 end;
 12 /

Succeed.

SQL> select FVT_FUNCTION_DML_004_U_01.FVT_FUNCTION_DML_004_V_03;

FVT_FUNCTION_DML_004_V_03
-------------------------
5                        

1 rows fetched.

SQL> --DTS2019011711418 
SQL> drop table if exists FVT_FUNCTION_DML_006_T;

Succeed.

SQL> drop table if exists FVT_FUNCTION_DML_006_T_02;

Succeed.

SQL> drop table if exists FVT_FUNCTION_DML_006_T_03;

Succeed.

SQL> create table FVT_FUNCTION_DML_006_T(id int,name varchar2(100));

Succeed.

SQL> create table FVT_FUNCTION_DML_006_T_02(id int ,name varchar2(100));

Succeed.

SQL> create table FVT_FUNCTION_DML_006_T_03(id int ,name varchar2(100));

Succeed.

SQL> insert into FVT_FUNCTION_DML_006_T values(30,'commit');

1 rows affected.

SQL> insert into FVT_FUNCTION_DML_006_T values(10,'commit');

1 rows affected.

SQL> insert into FVT_FUNCTION_DML_006_T_02 values(30,'commit');

1 rows affected.

SQL> insert into FVT_FUNCTION_DML_006_T_03 values(30,'commit');

1 rows affected.

SQL> create or replace function  FVT_FUNCTION_DML_006_V_03 return int
  2 is 
  3 a int := 0;
  4 begin
  5 for i in  1..5
  6 loop
  7 insert into sys.FVT_FUNCTION_DML_006_T_02 values(2,'commit');
  8 a := a+1;
  9 end loop;
 10 return a;
 11 end;
 12 /

Succeed.

SQL> merge into FVT_FUNCTION_DML_006_T_02 t2 using  FVT_FUNCTION_DML_006_T t1 on (t2.id = t1.id) when  matched then update set t2.name = 'update' when not matched then insert(id,name) values (FVT_FUNCTION_DML_006_V_03(),'not matched');   

CT-00932, [7:1] PL/SQL(SYS.FVT_FUNCTION_DML_006_V_03) terminated with execute errors
[7:1] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.FVT_FUNCTION_DML_006_T_02 did not find the table.

SQL> merge into FVT_FUNCTION_DML_006_T_02 t2 using  FVT_FUNCTION_DML_006_T t1 on (t2.id = t1.id) when  matched then update set t2.name = 'update' when not matched then insert(id,name) values (FVT_FUNCTION_DML_006_V_03,'not matched'); 

CT-00932, [7:1] PL/SQL(SYS.FVT_FUNCTION_DML_006_V_03) terminated with execute errors
[7:1] CT-00927, The trigger or user-defined function used by a SQL statement which is adjusting a table SYS.FVT_FUNCTION_DML_006_T_02 did not find the table.

SQL> select * from FVT_FUNCTION_DML_006_T_02;

ID           NAME                                                            
------------ ----------------------------------------------------------------
30           commit                                                          

1 rows fetched.

SQL> select * from FVT_FUNCTION_DML_006_T; 

ID           NAME                                                            
------------ ----------------------------------------------------------------
30           commit                                                          
10           commit                                                          

2 rows fetched.

SQL> 
SQL> insert into FVT_FUNCTION_DML_006_T_02 values(111,'commit');

1 rows affected.

SQL> select * from FVT_FUNCTION_DML_006_T; 

ID           NAME                                                            
------------ ----------------------------------------------------------------
30           commit                                                          
10           commit                                                          

2 rows fetched.

SQL> select * from FVT_FUNCTION_DML_006_T_02;

ID           NAME                                                            
------------ ----------------------------------------------------------------
30           commit                                                          
111          commit                                                          

2 rows fetched.

SQL> select * from FVT_FUNCTION_DML_006_T_03;

ID           NAME                                                            
------------ ----------------------------------------------------------------
30           commit                                                          

1 rows fetched.

SQL> merge into FVT_FUNCTION_DML_006_T_03 t3 using  FVT_FUNCTION_DML_006_T_02 t2 on (t3.id = t2.id) when  matched then update set t3.name = 'update' when not matched then insert(id,name) values (FVT_FUNCTION_DML_006_V_03,'not matched');   

2 rows affected.

SQL> merge into FVT_FUNCTION_DML_006_T_03 t3 using  FVT_FUNCTION_DML_006_T_02 t2 on (t3.id = t2.id) when  matched then update set t3.name = 'update' when not matched then insert(id,name) values (FVT_FUNCTION_DML_006_V_03(),'not matched');

7 rows affected.

SQL> --DTS2019011204222
SQL> drop table if exists test_a;

Succeed.

SQL> drop table if exists test_b;

Succeed.

SQL> drop table if exists test1;

Succeed.

SQL> 
SQL> create table test1(a int, b int);

Succeed.

SQL> 
SQL> begin
  2 	for i in 1..100 loop
  3 		insert into test1(a, b)values(i, i);
  4 	end loop; 
  5 	
  6 	commit;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> create table test_a(a int, b int);

Succeed.

SQL> insert into test_a(a, b)values(1, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(2, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(3, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table test_b(a int, b int);

Succeed.

SQL> insert into test_b(a, b)values(97, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(98, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(99, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create or replace procedure test_p1
  2 as
  3 cursor cur_PHYCHID is select a from test1 where exists (select 1 from test_a  where test_a.a=test1.a) 
  4 or exists (select 1 from test_b  where test_b.a=test1.a);
  5 var_a    int;
  6 str      varchar(256);
  7 cnt      int;
  8 begin
  9     cnt := 0;
 10     open cur_PHYCHID;
 11     fetch cur_PHYCHID into var_a;
 12     while cur_PHYCHID%found loop
 13     cnt := cnt + 1;
 14     dbe_stats.collect_table_stats('SYS','test_a');
 15     dbe_stats.collect_table_stats('SYS','test_b');
 16     
 17     fetch cur_PHYCHID into var_a;        
 18     end loop;
 19     
 20     dbe_output.print_line(cnt);
 21 end;
 22 /

Succeed.

SQL> exec test_p1;

6

PL/SQL procedure successfully completed.

SQL> --TRUNCATE TABLE
SQL> drop table if exists test_a;

Succeed.

SQL> drop table if exists test_b;

Succeed.

SQL> drop table if exists test1;

Succeed.

SQL> 
SQL> create table test1(a int, b int);

Succeed.

SQL> 
SQL> begin
  2 	for i in 1..100 loop
  3 		insert into test1(a, b)values(i, i);
  4 	end loop; 
  5 	
  6 	commit;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> create table test_a(a int, b int);

Succeed.

SQL> insert into test_a(a, b)values(1, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(2, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(3, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table test_b(a int, b int);

Succeed.

SQL> insert into test_b(a, b)values(97, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(98, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(99, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> create or replace procedure test_p1
  2 as
  3 cursor cur_PHYCHID is select a from test1 where exists (select 1 from test_a  where test_a.a=test1.a) 
  4 or exists (select 1 from test_b  where test_b.a=test1.a);
  5 var_a    int;
  6 str      varchar(256);
  7 cnt      int;
  8 begin
  9     cnt := 0;
 10     open cur_PHYCHID;
 11     fetch cur_PHYCHID into var_a;
 12     while cur_PHYCHID%found loop
 13     cnt := cnt + 1;
 14     str := 'truncate table test_a';
 15     execute immediate str;    
 16     str := 'truncate table test_b';
 17     execute immediate str;
 18     
 19     fetch cur_PHYCHID into var_a;
 20     end loop;
 21     
 22     dbe_output.print_line(cnt);
 23 end;
 24 /

Succeed.

SQL> exec test_p1;

1

PL/SQL procedure successfully completed.

SQL> --DROP TABLE
SQL> drop table if exists test_a;

Succeed.

SQL> drop table if exists test_b;

Succeed.

SQL> drop table if exists test1;

Succeed.

SQL> 
SQL> create table test1(a int, b int);

Succeed.

SQL> 
SQL> begin
  2 	for i in 1..100 loop
  3 		insert into test1(a, b)values(i, i);
  4 	end loop; 
  5 	
  6 	commit;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> create table test_a(a int, b int);

Succeed.

SQL> insert into test_a(a, b)values(1, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(2, 1);

1 rows affected.

SQL> insert into test_a(a, b)values(3, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> create table test_b(a int, b int);

Succeed.

SQL> insert into test_b(a, b)values(97, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(98, 1);

1 rows affected.

SQL> insert into test_b(a, b)values(99, 1);

1 rows affected.

SQL> commit;

Succeed.

SQL> create or replace procedure test_p1
  2 as
  3 cursor cur_PHYCHID is select a from test1 where exists (select 1 from test_a  where test_a.a=test1.a) 
  4 or exists (select 1 from test_b  where test_b.a=test1.a);
  5 var_a    int;
  6 str      varchar(256);
  7 cnt      int;
  8 begin
  9     cnt := 0;
 10     open cur_PHYCHID;
 11     fetch cur_PHYCHID into var_a;
 12     while cur_PHYCHID%found loop
 13     cnt := cnt + 1;
 14     str := 'drop table if exists test_a';
 15     execute immediate str;
 16     str := 'drop table if exists test_b';
 17     execute immediate str;
 18     
 19     fetch cur_PHYCHID into var_a;
 20     end loop;
 21     
 22     dbe_output.print_line(cnt);
 23 end;
 24 /

Succeed.

SQL> 
SQL> exec test_p1;

1

PL/SQL procedure successfully completed.

SQL> --DTS2019030609743
SQL> drop table if exists FVT_AUTOCOMMIT_PROC_005_Tab1;

Succeed.

SQL> create table FVT_AUTOCOMMIT_PROC_005_Tab1(id1 int, id2 int, id3 int, c_v1 varchar(4000),c_v2 varchar(4000),c_v3 varchar2(4000));

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE FVT_AUTOCOMMIT_PROC_005_P1(f1 int,f2 int,f3 int,f4 varchar,f5 varchar,f6 varchar2)
  2 AS
  3 BEGIN
  4 insert into FVT_AUTOCOMMIT_PROC_005_Tab1 values(f1,f2,f3,f4,f5,f6);
  5 END;
  6 /

Succeed.

SQL> exec FVT_AUTOCOMMIT_PROC_005_P1(1, '1', 1,null,@#$Af'','?SFDsf');

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[1:44] PLC-00601 Sql syntax error: text is incorrect

SQL> --
SQL> drop table if exists test_part_t1;

Succeed.

SQL> create table test_part_t1(f1 int, f2 real, f3 number, f4 char(30), f5 varchar(30), f6 date, f7 timestamp)PARTITION BY RANGE(f1)( PARTITION p1 values less than(10), PARTITION p2 values less than(20), PARTITION p3 values less than(30), PARTITION p4 values less than(MAXVALUE));

Succeed.

SQL> create index idx_test_part_t1_1 on test_part_t1(f2,f3);

Succeed.

SQL> create index idx_test_part_t1_2 on test_part_t1(f4,f5) local;

Succeed.

SQL> insert into test_part_t1 values(5, 15, 28, 'abcd', 'abcd', to_date('2018/01/24', 'YYYY/MM/DD'), to_timestamp('2018-01-24 16:00:00.00', 'YYYY-MM-DD HH24:MI:SS.FF3'));

1 rows affected.

SQL> insert into test_part_t1 values(6, 16, 29, '16', '29', to_date('2018/01/24', 'YYYY/MM/DD'), to_timestamp('2018-01-24 16:00:00.00', 'YYYY-MM-DD HH24:MI:SS.FF3'));

1 rows affected.

SQL> SELECT DBE_DIAGNOSE.DBA_PARTITIONED_INDSIZE(0,'SYS','TEST_PART_T1');

DBE_DIAGNOSE.DBA_PARTITIONED_INDSIZE(0,'SYS','TEST_PART_T1')
------------------------------------------------------------
65536                                                       

1 rows fetched.

SQL> SELECT DBE_DIAGNOSE.DBA_PARTITIONED_LOBSIZE(0,'SYS','TEST_PART_T1');

DBE_DIAGNOSE.DBA_PARTITIONED_LOBSIZE(0,'SYS','TEST_PART_T1')
------------------------------------------------------------
0                                                           

1 rows fetched.

SQL> select DBE_DIAGNOSE.DBA_PARTITIONED_TABSIZE(0,'SYS','TEST_PART_T1');

DBE_DIAGNOSE.DBA_PARTITIONED_TABSIZE(0,'SYS','TEST_PART_T1')
------------------------------------------------------------
65536                                                       

1 rows fetched.

SQL> drop table if exists test_part_t1;

Succeed.

SQL> 
SQL> DROP TABLE if exists env_prepare_t;

Succeed.

SQL> CREATE TABLE env_prepare_t(ID INT, NAME VARCHAR(64));

Succeed.

SQL> 
SQL> declare
  2 v1 NUMBER;
  3 v2 VARCHAR(20);
  4 v3 INT;
  5 v4 INT;
  6 TYPE xxx IS RECORD( a INT, b INT, c env_prepare_t%ROWTYPE);
  7 BEGIN
  8   DECLARE
  9   TYPE yyy IS RECORD( a INT, b INT, c xxx);
 10   v5 yyy;
 11   BEGIN
 12     v5.a := 1;
 13     v5.b := 2;
 14     v5.c.c.id := 3;
 15     dbe_output.print_line('v5.a:'||v5.a);
 16     dbe_output.print_line('v5.b:'||v5.b);
 17     dbe_output.print_line('v5.c.c.id:'||v5.c.c.id);
 18   END;
 19 END;
 20 /

v5.a:1
v5.b:2
v5.c.c.id:3

PL/SQL procedure successfully completed.

SQL> 
SQL> DROP TABLE env_prepare_t;

Succeed.

SQL> CREATE TABLE env_prepare_t(ID INT, NAME VARCHAR(64));

Succeed.

SQL> INSERT INTO env_prepare_t VALUES(0, '');

1 rows affected.

SQL> INSERT INTO env_prepare_t VALUES(1, 'zyc');

1 rows affected.

SQL> COMMIT;

Succeed.

SQL> 
SQL> declare
  2 TYPE xxx IS RECORD( a INT, b VARCHAR(64));
  3 BEGIN
  4   DECLARE
  5   TYPE yyy IS RECORD( a INT, b INT, c xxx);
  6   v5 yyy;
  7   BEGIN
  8     SELECT * INTO v5.c FROM env_prepare_t WHERE id = 1;
  9     dbe_output.print_line('v5.c.b:'||v5.c.b);
 10   END;
 11 END;
 12 /

v5.c.b:zyc

PL/SQL procedure successfully completed.

SQL> 
SQL> BEGIN
  2   DECLARE
  3   TYPE yyy IS RECORD( a INT, b VARCHAR(64));
  4   v5 yyy;
  5   BEGIN
  6     SELECT * INTO v5 FROM env_prepare_t WHERE id = 1;
  7     dbe_output.print_line('v5.b:'||v5.b);
  8   END;
  9 END;
 10 /

v5.b:zyc

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v1 NUMBER;
  3 v2 VARCHAR(64);
  4 v3 INT;
  5 v4 INT;
  6 TYPE xxx IS RECORD( a INT, b VARCHAR(64));
  7 BEGIN
  8   DECLARE
  9   v5 zzz;
 10   v6 xxx;
 11   BEGIN
 12     SELECT * INTO v6 FROM env_prepare_t WHERE id = 1;
 13     dbe_output.print_line('v6.b:'||v6.b);
 14   END;
 15 END;
 16 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[9:6] PLC-00601 Sql syntax error: datatype expected, but got 'zzz'

SQL> 
SQL> declare
  2 v1 NUMBER;
  3 v2 VARCHAR(20);
  4 v3 INT;
  5 v4 INT;
  6 TYPE xxx IS RECORD( a INT, b INT);
  7 BEGIN
  8   <<block1>>
  9   DECLARE
 10   TYPE xxx IS RECORD( a INT, b INT, c INT);
 11   v5 block1.xxx;
 12   BEGIN
 13     v5.a := 1;
 14     v5.b := 2;
 15     v5.c := 3;
 16     dbe_output.print_line('v5.a:'||v5.a);
 17     dbe_output.print_line('v5.b:'||v5.b);
 18     dbe_output.print_line('v5.c:'||v5.c);
 19   END;
 20 end;
 21 /

v5.a:1
v5.b:2
v5.c:3

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v1 NUMBER;
  3 v2 VARCHAR(20);
  4 v3 INT;
  5 v4 INT;
  6 TYPE yyy IS RECORD( a INT, b INT);
  7 BEGIN
  8   <<block1>>
  9   DECLARE
 10   TYPE xxx IS RECORD( a INT, b INT);
 11   v5 yyy;
 12   BEGIN
 13     block1.v5.a := 1;
 14     block1.v5.b := 2;
 15     dbe_output.print_line('v5.a:'||v5.a);
 16     dbe_output.print_line('v5.b:'||v5.b);
 17   END;
 18 end;
 19 /

v5.a:1
v5.b:2

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists forcursor_t;

Succeed.

SQL> create table forcursor_t(a int);

Succeed.

SQL> insert into forcursor_t values(1);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> declare
  2 b int := 1;
  3 c int;
  4 begin
  5 for i in (select a from forcursor_t) loop
  6     select b into c from dual;
  7     dbe_output.print_line(c);
  8 end loop;
  9 end;
 10 /

1

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1 from dual' using b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:1 from dual' using b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00932, [6:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00922, PL/SQL: illegal line(variables bound mismatch)

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:2 from dual' using b, 2*b+1;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

:1           :2                  
------------ --------------------
1            3                   

1 rows fetched.


SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:2 from dual' using in b, in 2*b+1;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

PL/SQL procedure successfully completed.

ResultSet #1

:1           :2                  
------------ --------------------
1            3                   

1 rows fetched.


SQL> ----expected error
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:2 from dual' using out b, in 2*b+1;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:3] PLC-00922 PL/SQL: illegal line(OUT and IN/OUT modes cannot be opened in refcursor)

SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:2 from dual' using in out b, in 2*b+1;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:3] PLC-00922 PL/SQL: illegal line(OUT and IN/OUT modes cannot be opened in refcursor)

SQL> declare
  2  a sys_refcursor;
  3  b int;
  4  c int;
  5 begin
  6   b := 1;
  7   open a for 'select :1 into :2 from dual' using in b, out c;
  8   dbe_sql.return_cursor(a);
  9 end;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:3] PLC-00922 PL/SQL: illegal line(OUT and IN/OUT modes cannot be opened in refcursor)

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4  c int;
  5 begin
  6   b := 1;
  7   open a for 'select :1 from dual' using in b, in c;
  8   dbe_sql.return_cursor(a);
  9 end;
 10 / 

CT-00932, [7:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[7:3] CT-00922, PL/SQL: illegal line(variables bound mismatch)

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'begin select :1 from dual; end' using in b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00932, [6:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00922, PL/SQL: illegal line(sys_refcursor must open a legal SELECT statement)

SQL> declare
  2  a sys_refcursor;
  3  b int;
  4  c varchar(200);
  5 begin
  6   b := 1;
  7   c := 'select :1 from dual';
  8   open a for c using in b;
  9   dbe_sql.return_cursor(a);
 10 end;
 11 /

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


SQL> declare
  2  a sys_refcursor;
  3  b int;
  4  c varchar(200);
  5 begin
  6   b := 1;
  7   c := 'select 1 from dual';
  8   open a for c using in b;
  9   dbe_sql.return_cursor(a);
 10 end;
 11 /

CT-00932, [8:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:3] CT-00922, PL/SQL: illegal line(variables bound mismatch)

SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for (select 1 from dual) using in out b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:3] PLC-00954 ';' expected but using found

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for (select ?,? from dual) using in out b, in 2*b+1;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:3] PLC-00954 ';' expected but using found

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for (select 1 from dual) using in out b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:3] PLC-00954 ';' expected but using found

SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1,:2 from dual' using in b;
  7   dbe_sql.return_cursor(a);
  8 end;
  9 /

CT-00932, [6:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00922, PL/SQL: illegal line(variables bound mismatch)

SQL> 
SQL> declare
  2  a sys_refcursor;
  3  b int;
  4 begin
  5   b := 1;
  6   open a for 'select :1 from dual' using b;
  7   b := 2;
  8   dbe_sql.return_cursor(a);
  9 end;
 10 /

PL/SQL procedure successfully completed.

ResultSet #1

:1          
------------
1           

1 rows fetched.


SQL> 
SQL> set serveroutput off;
OFF



