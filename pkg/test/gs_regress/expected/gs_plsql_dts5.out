

SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists gs_plsql_dts5 cascade;

Succeed.

SQL> create user gs_plsql_dts5 identified by Lh00420062;

Succeed.

SQL> grant dba to gs_plsql_dts5;

Succeed.

SQL> 
SQL> conn gs_plsql_dts5/Lh00420062@127.0.0.1:1611

connected.

SQL> set serveroutput on;

ON
SQL> 
SQL> --regexp_like
SQL> declare
  2 a varchar(30);
  3 begin
  4 a := '111111aaaaaaa';
  5 if REGEXP_LIKE(a, '^[[:digit:]]{1,10}') then
  6 dbe_output.print_line(1);
  7 else
  8 dbe_output.print_line(2);
  9 end if;
 10 
 11 if not REGEXP_LIKE(a, '^[[:digit:]]{1,10}') then
 12 dbe_output.print_line(3);
 13 else
 14 dbe_output.print_line(4);
 15 end if;
 16 
 17 if REGEXP_LIKE(a, '^[[:digit:]]{1,10}') = true then
 18 dbe_output.print_line(5);
 19 else
 20 dbe_output.print_line(6);
 21 end if;
 22 
 23 if REGEXP_LIKE(a, '^[[:digit:]]{1,10}') != true then
 24 dbe_output.print_line(7);
 25 else
 26 dbe_output.print_line(8);
 27 end if;
 28 
 29 if not REGEXP_LIKE(a, '^[[:digit:]]{1,10}') <> true then
 30 dbe_output.print_line(9);
 31 else
 32 dbe_output.print_line(10);
 33 end if;
 34 
 35 if not REGEXP_LIKE(a, '^[[:digit:]]{1,10}') = false then
 36 dbe_output.print_line(11);
 37 else
 38 dbe_output.print_line(12);
 39 end if;
 40 
 41 if REGEXP_LIKE(a, '^[[:digit:]]{1,10}') != false then
 42 dbe_output.print_line(13);
 43 else
 44 dbe_output.print_line(14);
 45 end if;
 46 
 47 if not REGEXP_LIKE(a, '^[[:digit:]]{1,10}') <> false then
 48 dbe_output.print_line(15);
 49 else
 50 dbe_output.print_line(16);
 51 end if;
 52 end;
 53 /

1
4
5
8
9
11
13
16

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 a varchar(30);
  3 begin
  4 a := '111111aaaaaaa';
  5 if REGEXP_LIKE(a, '^[[:digit:]]{1,10}') = 1 then
  6 dbe_output.print_line(1);
  7 end if;
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_DTS5.ANONYMOUS BLOCK) terminated with compiling errors
[5:43] PLC-00601 Sql syntax error: invalid word '1' found
[7:5] PLC-00920 Undefined symbol IF

SQL> 
SQL> begin
  2 if REGEXP_LIKE then
  3 dbe_output.print_line(1);
  4 end if;
  5 end;
  6 /

CT-00944, PL/SQL(GS_PLSQL_DTS5.ANONYMOUS BLOCK) terminated with compiling errors
[2:16] PLC-00601 Sql syntax error: (...) expected but REGEXP_LIKE found
[4:5] PLC-00920 Undefined symbol IF

SQL> 
SQL> begin
  2 savepoint aa;
  3 savepoint aa;
  4 savepoint aa;
  5 savepoint aa;
  6 savepoint aa;
  7 savepoint aa;
  8 savepoint aa;
  9 savepoint aa;
 10 savepoint aa;
 11 end;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --dts index primary key error
SQL> DROP TABLE IF EXISTS T_EDGE_AKGKHGHKAJKGHH CASCADE;

CT-00601, [1:51]Sql syntax error: CONSTRAINTS expected
SQL> CREATE TABLE "T_EDGE_AKGKHGHKAJKGHH"
  2 (
  3   "IGS_EDGEID" VARBINARY(16) NOT NULL,
  4   "IGS_STARTID" VARBINARY(16) NOT NULL,
  5   "IGS_STARTTYPE" VARCHAR(128 BYTE) NOT NULL,
  6   "IGS_ENDID" VARBINARY(16) NOT NULL,
  7   "IGS_ENDTYPE" VARCHAR(128 BYTE) NOT NULL,
  8   "IGS_NAME" VARCHAR(128 BYTE) NOT NULL,
  9   "HISTORY_BEGIN_TIME" BINARY_BIGINT NOT NULL,
 10   "HISTORY_END_TIME" BINARY_BIGINT NOT NULL
 11 );

Succeed.

SQL> 
SQL> ALTER TABLE "T_EDGE_AKGKHGHKAJKGHH" ADD CONSTRAINT constraint_123_easy PRIMARY KEY("IGS_STARTID", "HISTORY_BEGIN_TIME", "IGS_NAME", "IGS_ENDID");

Succeed.

SQL> ALTER TABLE "T_EDGE_AKGKHGHKAJKGHH" ADD UNIQUE("IGS_EDGEID");

Succeed.

SQL> 
SQL> insert into T_EDGE_AKGKHGHKAJKGHH values(UNHEX('11EADD782A195AFE8250286ED588C66A'),UNHEX('11EADBEC44A3EDAFB821286ED588C66A'),'ZZNetworkElement',UNHEX('11EADBEC91777080B821286ED588C66A'),'MirrorNetworkElement','ZNeHasMNe',0,1597331887687);

1 rows affected.

SQL> insert into T_EDGE_AKGKHGHKAJKGHH values(UNHEX('11EADD782A195AFE8250286ED588C66A'),UNHEX('11EADBEC44A3EDAFB821286ED588C66A'),'ZZNetworkElement',UNHEX('11EADBEC91777080B821286ED588C66A'),'MirrorNetworkElement','ZNeHasMNe',0,1597331887687);

CT-00729, Unique constraint violated, index CONSTRAINT_123_EASY, duplicate key 11EADBEC44A3EDAFB821286ED588C66A-0-ZNeHasMNe-11EADBEC91777080B821286ED588C66A
SQL> DROP TABLE IF EXISTS T_EDGE_AKGKHGHKAJKGHH CASCADE CONSTRAINTS;

Succeed.

SQL> 
SQL> declare 
  2 sql1 varchar(1024);
  3 begin
  4 for item in (select * from dv_dynamic_views) loop
  5 begin
  6 sql1 :='drop table if exists my'||item.name;
  7 execute immediate sql1;
  8 sql1 :=' create table my'||item.name||' as select * from '||item.name;
  9 execute immediate sql1;
 10 exception 
 11     when others then
 12         dbe_output.print(sql_err_code||', '||sql_err_msg||', '||sql1);
 13 end;
 14 end loop;
 15 end;
 16 /

PL/SQL procedure successfully completed.

SQL> 
SQL> set serveroutput off;

OFF
SQL> conn / as sysdba

connected.

SQL> drop user if exists gs_plsql_dts5 cascade;

Succeed.

SQL> drop user if exists  liuhang cascade;

Succeed.

SQL> create user liuhang identified by Cantian_234;

Succeed.

SQL> grant all privileges to liuhang;

Succeed.

SQL> conn liuhang/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> create table tt1 (a int,b int);

Succeed.

SQL> declare
  2 begin
  3 for item in (select * from tt1) loop
  4 dbe_output.print(item.a);
  5 end loop;
  6 end;
  7 /

PL/SQL procedure successfully completed.

SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists liuhang cascade;

Succeed.

SQL> create user liuhang identified by Cantian_234;

Succeed.

SQL> grant all privileges to liuhang;

Succeed.

SQL> conn liuhang/Cantian_234@127.0.0.1:1611

connected.

SQL> declare
  2 begin
  3 for item in (select * from tt1) loop
  4 dbe_output.print(item.a);
  5 end loop;
  6 end;
  7 /

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[3:27] PLC-00843 The table or view LIUHANG.TT1 does not exist.

SQL> 
SQL> --DTS202009220HIXP6P0J00
SQL> CREATE OR REPLACE FUNCTION Zenith_Test_005() return varchar2
  2 AS
  3 Begin
  4     return (select 1 from dual);
  5 End Zenith_Test_005;
  6 /

Succeed.
Warning:
PL/SQL(LIUHANG.ZENITH_TEST_005) terminated with compiling errors
[4:20] PLC-01316 Unexpected SUBSELECT


SQL> 
SQL> select Zenith_Test_005();

CT-00944, [1:8]PL/SQL(LIUHANG.ZENITH_TEST_005) terminated with compiling errors
[4:20] PLC-01316 Unexpected SUBSELECT

SQL> 
SQL> --DTS20201021053RUIP0F00
SQL> set serveroutput on;

ON
SQL> drop table if exists array_test_034;

Succeed.

SQL> create table array_test_034 (COL1 int,COL2 INTERVAL YEAR TO MONTH[],COL3 number[]);

Succeed.

SQL> insert into array_test_034 values(1,array[(INTERVAL '12' YEAR(4)) , (INTERVAL '-99' YEAR(3)) , (INTERVAL '0' YEAR(2))],array[-0.9E128 , 1.0E126 -1 , -89.0000001]);

1 rows affected.

SQL> insert into array_test_034 values(2,array[(INTERVAL '12' YEAR(4)) , (INTERVAL '-99' YEAR(3)) , (INTERVAL '0' YEAR(2))],array[-1.0E127 , 1.0E28 , -1-128]);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> CREATE OR REPLACE PROCEDURE PROC_ARRAY_TEST_005(P1 out real )
  2 AS
  3 V1 real;
  4 BEGIN
  5         select COL3[2] into V1 from array_test_034 where COL1 =2;
  6         P1:= V1;
  7         dbe_output.print_line(P1);
  8 EXCEPTION WHEN NO_DATA_FOUND THEN dbe_output.print_line('NO_DATA_FOUND');
  9 END;
 10 /

Succeed.

SQL> 
SQL> DECLARE
  2 V_P1 real[];
  3 BEGIN
  4         PROC_ARRAY_TEST_005(V_P1);
  5 END;
  6 /

CT-00932, [4:9] PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with execute errors
[4:9] CT-00606, Inconsistent datatypes, expected BINARY_DOUBLE - got ARRAY

SQL> 
SQL> drop PACKAGE if exists a;

Succeed.

SQL> create or replace PACKAGE a
  2 AS
  3 FUNCTION  B() RETURN INT;
  4 END;
  5 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE PACKAGE BODY a
  2 AS
  3 FUNCTION B()RETURN INT
  4 AS
  5 a int;
  6 begin
  7 a :=1;
  8 return a ;
  9 end;
 10 end;
 11 /

Succeed.

SQL> --expect error
SQL> create or replace function B() return int
  2 as
  3 a int;
  4 begin
  5 a :=a.b();
  6 return a ;
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(LIUHANG.B) terminated with compiling errors
[5:5] PLC-02602 Invalid reference to variable 'a'


SQL> select b() from sys_dummy;

CT-00944, [1:8]PL/SQL(LIUHANG.B) terminated with compiling errors
[5:5] PLC-02602 Invalid reference to variable 'a'

SQL> --expect error
SQL> create or replace function C(a in out int) return int
  2 as
  3 begin
  4 a :=a.b();
  5 return a ;
  6 end;
  7 /

Succeed.
Warning:
PL/SQL(LIUHANG.C) terminated with compiling errors
[4:5] PLC-02602 Invalid reference to variable 'a'


SQL> 
SQL> --core: plc_try_obj_access_single  word->ex_count != 0 && word->type == WORD_TYPE_PARAM
SQL> create or replace procedure PROC_TEST1()
  2 as
  3 begin
  4 dbe_output.print_line('b');
  5 commit;:end ;
  6 /

Succeed.
Warning:
PL/SQL(LIUHANG.PROC_TEST1) terminated with compiling errors
[5:8] PLC-00945 Param only allowed in dml or anonymous block or call
[6:1] PLC-00954 more text expected but EOF found


SQL> 
SQL> begin
  2 dbe_output.print_line('b');
  3 :end ;
  4 /

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[3:1] PLC-00916 PL/SQL:syntax error(an undefined procedure was called)
[4:1] PLC-00954 more text expected but EOF found

SQL> 
SQL> declare
  2    p int;
  3 begin
  4    p := :2();
  5 end;
  6 /

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[4:12] PLC-00601 Sql syntax error: the word "" is not correct

SQL> 
SQL> declare
  2    p int;
  3 begin
  4    p := :a.b;
  5 end;
  6 /

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[4:11] PLC-00601 Sql syntax error: the word "." is not correct

SQL> 
SQL> begin
  2    :B;
  3 end;
  4 /

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00916 PL/SQL:syntax error(an undefined procedure was called)

SQL> 
SQL> drop PACKAGE a;

Succeed.

SQL> drop function B;

Succeed.

SQL> 
SQL> --plm_is_out_arg
SQL> CREATE OR REPLACE FUNCTION function_out(a int, b int) RETURN INT
  2   AS
  3     c INT;
  4   BEGIN
  5        c := a * b * a * 4;
  6   RETURN c;
  7 END;
  8 /

Succeed.

SQL> CREATE OR REPLACE PROCEDURE procedure_out(a in int, b out int) IS
  2 c int;
  3 BEGIN
  4   b := a * a * 2;
  5   c := b;
  6   dbe_output.print_line(c);
  7   c := function_out(a, b);
  8   dbe_output.print_line(c);
  9 END;
 10 /

Succeed.

SQL> DECLARE
  2 a int;
  3 b int;
  4 BEGIN
  5  a := 2;
  6  b := 3;
  7  procedure_out(a, b);
  8  dbe_output.print_line(b);
  9 END;
 10 /

8
128
8

PL/SQL procedure successfully completed.

SQL> drop function function_out;

Succeed.

SQL> drop procedure procedure_out;

Succeed.

SQL> 
SQL> 
SQL> create or replace procedure myp(v1 in int default 1, v2 int default 2) 
  2 is
  3 v3 int;
  4 begin
  5 dbe_output.print(v1||'  '||v2);
  6 end;
  7 /

Succeed.

SQL> --except error
SQL> call myp(v1=>1,v22=>1);

CT-00944, PL/SQL(LIUHANG.ANONYMOUS BLOCK) terminated with compiling errors
[1:17] PLC-00699 Argument V22 is not found in procedure/function

SQL> 
SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> drop user if exists liuhang cascade;
Succeed.

SQL> 
SQL> 
SQL> create or replace procedure test_user_view471 as 
  2 BEGIN 
  3 EXECUTE IMMEDIATE  'select * from USER_OBJECTS'; 
  4 END;
  5  /

Succeed.

SQL> 
SQL> call test_user_view471;

PL/SQL procedure successfully completed.

SQL> drop procedure test_user_view471;

Succeed.

SQL> 
SQL> --expect error
SQL> savepoint sp1;

Succeed.

SQL> begin
  2 execute immediate 'rollback to sp1';
  3 end;
  4 /

CT-00932, [2:1] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[2:1] CT-01600, cannot find this savepoint SP1 using of rollback in this plsql block

SQL> rollback; 

Succeed.

SQL> --exepect right
SQL> begin
  2 execute immediate 'savepoint sp1';
  3 execute immediate 'savepoint sp1';
  4 execute immediate 'savepoint sp1';
  5 execute immediate 'savepoint sp1';
  6 execute immediate 'savepoint sp1';
  7 execute immediate 'savepoint sp1';
  8 execute immediate 'savepoint sp1';
  9 execute immediate 'savepoint sp1';
 10 execute immediate 'savepoint sp1';
 11 rollback to sp1;
 12 end;
 13 /

PL/SQL procedure successfully completed.

SQL> --exepect error
SQL> begin
  2 execute immediate 'savepoint sp1';
  3 execute immediate 'savepoint sp2';
  4 execute immediate 'savepoint sp3';
  5 execute immediate 'savepoint sp4';
  6 execute immediate 'savepoint sp5';
  7 execute immediate 'savepoint sp6';
  8 execute immediate 'savepoint sp7';
  9 execute immediate 'savepoint sp8';
 10 execute immediate 'savepoint sp9';
 11 end;
 12 /

CT-00932, [10:1] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[10:1] CT-00737, Session holds too many savepoints

SQL> 
SQL> --exepect right
SQL> begin
  2 execute immediate 'savepoint sp1';
  3 execute immediate 'savepoint sp2';
  4 execute immediate 'savepoint sp3';
  5 execute immediate 'savepoint sp4';
  6 savepoint sp5;
  7 savepoint sp6;
  8 savepoint sp7;
  9 savepoint sp8;
 10 rollback to sp8;
 11 rollback to sp7;
 12 rollback to sp6;
 13 rollback to sp5;
 14 execute immediate 'rollback to sp4';
 15 execute immediate 'rollback to sp3';
 16 execute immediate 'rollback to sp2';
 17 execute immediate 'rollback to sp1';
 18 end;
 19 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --exepect right
SQL> begin
  2 execute immediate 'savepoint sp1';
  3 execute immediate 'rollback to sp1';
  4 end;
  5 /

PL/SQL procedure successfully completed.

SQL> 
SQL> set serveroutput off;

OFF
SQL> 
SQL> --DTS202012260GAZSSP1F00 anonymou and xa test
SQL> drop table if exists transaction_stored_anonymous_rang_tabl_014;

Succeed.

SQL> create table transaction_stored_anonymous_rang_tabl_014(c_id int,c_d_id bigint not null,c_w_id tinyint unsigned not null,c_first varchar(16) not null,c_middle varchar(10),c_last varchar(16) not null,c_street_1 varchar(20) not null,c_street_2 varchar(20),c_city varchar(20) not null,c_state char(2) not null,c_zip char(9) not null,c_phone char(16) not null,c_since timestamp,c_credit char(2) not null,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real not null,c_payment_cnt number not null,c_delivery_cnt bool not null,c_end date not null,c_data1 varchar(8000),c_data2 varchar(8000),c_data3 varchar(8000),c_data4 varchar(8000),c_data5 varchar(8000),c_data6 varchar(8000),c_data7 varchar(8000),c_data8 varchar(8000),c_clob clob,c_blob blob,primary key (c_w_id,c_last)) partition by range(c_d_id)(partition part_1 values less than(150),partition part_2 values less than(300),partition part_3 values less than(450),partition part_4 values less than(700),partition part_5 values less than(850),partition part_6 values less than(maxvalue));

Succeed.

SQL> 
SQL> drop table if exists transaction_stored_anonymous_tabl_000;

Succeed.

SQL> create table transaction_stored_anonymous_tabl_000(c_id int,c_d_id bigint not null,c_w_id tinyint unsigned not null,c_first varchar(16) not null,c_middle char(2),c_last varchar(16) not null,c_street_1 varchar(20) not null,c_street_2 varchar(20),c_city varchar(20) not null,c_state char(2) not null,c_zip char(9) not null,c_phone char(16) not null,c_since timestamp,c_credit char(2) not null,c_credit_lim numeric(12,2),c_discount numeric(4,4),c_balance numeric(12,2),c_ytd_payment real not null,c_payment_cnt number not null,c_delivery_cnt bool not null,c_end date not null,c_data1 varchar(8000),c_data2 varchar(8000),c_data3 varchar(8000),c_data4 varchar(8000),c_data5 varchar(8000),c_data6 varchar(8000),c_data7 varchar(8000),c_data8 varchar(8000),c_clob clob,c_blob blob,primary key (c_id));

Succeed.

SQL> set serveroutput on;

ON
SQL> declare
  2     i int :=1;
  3     j varchar(10);
  4     print_str varchar(1000);
  5     sql_str varchar(1000);
  6     begin
  7         for i in 1..1000 loop
  8             select cast(i as varchar(10)) into j from sys_dummy;
  9             if j<201 then
 10                 --lob存行内，rowsize<8k
 11                 insert into transaction_stored_anonymous_tabl_000 select i,i,i,'is'||(mod(j,6)+1),'oa','last'||mod(j,5),'street_1'||j,'street_2'||j,'city'||j,'uq','4801'||j,'940215'||j,to_date('2020-07-15','yyyy-mm-dd')+i,'cd',10000.0,0.4361328,-10.0,10.0,i+0.1*j,to_char(mod(j,2)),sysdate,lpad('qvf',200,'qvf'),lpad('qsf',200,'fsf'),lpad('vvd',200,'qvf'),lpad('qsf',200,'qvsf'),lpad('qvf',200,'qsf'),lpad('bqf',200,'qvf'),lpad('qvf',200,'qqf'),lpad('fsf',200,'qvl'),lpad('qvf',200,'qvl'),lpad('123',400,'abc') from sys_dummy;
 12             elsif j<401 then
 13                 --lob存行内，8k<rowsize<64k(行链接)
 14                 insert into transaction_stored_anonymous_tabl_000 select i,i,i,'is'||(mod(j,6)+1),'oa','last'||mod(j,5),'street_1'||j,'street_2'||j,'city'||j,'uq','4801'||j,'940215'||j,to_date('2020-07-15','yyyy-mm-dd')+i,'cd',10000.0,0.4361328,-10.0,10.0,i+0.1*j,to_char(mod(j,2)),sysdate,lpad('vcf',2000,'qvl'),lpad('lch',2000,'dfs'),lpad('qvb',2000,'qvl'),lpad('oqn',2000,'oqg'),lpad('zsf',2000,'fvf'),lpad('vdp',2000,'mpf'),lpad('zsf',2000,'dsf'),lpad('qsf',2000,'csf'),lpad('zsf',3000,'mpf'),lpad('123',1000,'abc') from sys_dummy;
 15             elsif j<601 then
 16                 --lob存行外，rowsize<8k,local temporary不超过8k
 17                 insert into transaction_stored_anonymous_tabl_000 select i,i,i,'is'||(mod(j,6)+1),'oa','last'||mod(j,5),'street_1'||j,'street_2'||j,'city'||j,'uq','4801'||j,'940215'||j,to_date('2020-07-15','yyyy-mm-dd')+i,'cd',10000.0,0.4361328,-10.0,10.0,i+0.1*j,to_char(mod(j,2)),sysdate,lpad('vcf',400,'qvl'),lpad('lch',400,'dfs'),lpad('qvb',400,'qvl'),lpad('oqn',400,'oqg'),lpad('zsf',400,'fvf'),lpad('vdp',400,'mpf'),lpad('zsf',400,'dsf'),lpad('qsf',400,'csf'),lpad('zsf',3000,'mpf'),lpad('123',3000,'abc') from sys_dummy;
 18             elsif j<801 then
 19                 --lob存行外，8K<rowsize<64k(行链接)csf,temporary,不超过64k,local temporary不超过8k
 20                 insert into transaction_stored_anonymous_tabl_000 select i,i,i,'is'||(mod(j,6)+1),'oa','last'||mod(j,5),'street_1'||j,'street_2'||j,'city'||j,'uq','4801'||j,'940215'||j,to_date('2020-07-15','yyyy-mm-dd')+i,'cd',10000.0,0.4361328,-10.0,10.0,i+0.1*j,to_char(mod(j,2)),sysdate,lpad('vcf',2000,'qvl'),lpad('lch',2000,'dfs'),lpad('qvb',2000,'qvl'),lpad('oqn',2000,'oqg'),lpad('zsf',2000,'fvf'),lpad('vdp',2000,'mpf'),lpad('zsf',2000,'dsf'),lpad('qsf',2000,'csf'),lpad('zsf',3000,'mpf'),lpad('123',3000,'abc') from sys_dummy;      
 21             else
 22                 --rowsize>64k(lob存行外,且行链接)csf,temporary,不超过64k
 23                 insert into transaction_stored_anonymous_tabl_000 select i,i,i,'is'||(mod(j,6)+1),'oa','last'||mod(j,5),'street_1'||j,'street_2'||j,'city'||j,'uq','4801'||j,'940215'||j,to_date('2020-07-15','yyyy-mm-dd')+i,'cd',10000.0,0.4361328,-10.0,10.0,i+0.1*j,to_char(mod(j,2)),sysdate,lpad('vcf',7500,'qvl'),lpad('lch',7500,'dfs'),lpad('qvb',7500,'qvl'),lpad('oqn',7500,'oqg'),lpad('zsf',7500,'fvf'),lpad('vdp',7500,'mpf'),lpad('zsf',7500,'dsf'),lpad('qsf',7500,'csf'),lpad('zsf',3000,'mpf'),lpad('123',3000,'abc') from sys_dummy;
 24             end if;
 25         end loop;
 26         sql_str :='select count(*) from transaction_stored_anonymous_tabl_000';
 27         execute immediate 'select count(*) from transaction_stored_anonymous_tabl_000' into print_str;
 28         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);
 29     end;
 30 /

select count(*) from transaction_stored_anonymous_tabl_000
1000

PL/SQL procedure successfully completed.

SQL> 
SQL> create unique index transaction_stored_anonymous_rang_tabl_014_indx_001 on transaction_stored_anonymous_rang_tabl_014(c_phone);

Succeed.

SQL> create index transaction_stored_anonymous_rang_tabl_014_indx_002 on transaction_stored_anonymous_rang_tabl_014(c_middle,c_payment_cnt);

Succeed.

SQL> create unique index transaction_stored_anonymous_rang_tabl_014_indx_003 on transaction_stored_anonymous_rang_tabl_014(upper(c_phone));

Succeed.

SQL> create index transaction_stored_anonymous_rang_tabl_014_indx_004 on transaction_stored_anonymous_rang_tabl_014(upper(c_first)) ;

Succeed.

SQL> create index transaction_stored_anonymous_rang_tabl_014_indx_005 on transaction_stored_anonymous_rang_tabl_014(to_char(c_since)) tablespace tablespace_transaction_stored_anonymous_1 crmode row;

CT-00780, The tablespace TABLESPACE_TRANSACTION_STORED_ANONYMOUS_1 does not exist.
SQL> create unique index transaction_stored_anonymous_rang_tabl_014_indx_006 on transaction_stored_anonymous_rang_tabl_014(to_char(c_w_id),c_phone) crmode row;

Succeed.

SQL> create unique index transaction_stored_anonymous_rang_tabl_014_indx_007 on transaction_stored_anonymous_rang_tabl_014(c_d_id,c_street_1,c_since);

Succeed.

SQL> create index transaction_stored_anonymous_rang_tabl_014_indx_008 on transaction_stored_anonymous_rang_tabl_014(c_payment_cnt,to_char(c_phone),c_since) ;

Succeed.

SQL> create index transaction_stored_anonymous_rang_tabl_014_indx_009 on transaction_stored_anonymous_rang_tabl_014(to_char(c_w_id),upper(c_first),c_since,c_payment_cnt,to_char(c_phone));

Succeed.

SQL> alter table transaction_stored_anonymous_rang_tabl_014 add constraint constraint_transaction_stored_anonymous_rang_tabl_014 unique (c_id,c_first,c_since);

Succeed.

SQL> 
SQL> declare
  2     print_str varchar(1000);
  3     sql_str varchar(1000);
  4     begin
  5         insert into transaction_stored_anonymous_rang_tabl_014 select * from transaction_stored_anonymous_tabl_000;savepoint aa;
  6         select count(*) into print_str from transaction_stored_anonymous_rang_tabl_014;
  7         sql_str :='select count(*) from transaction_stored_anonymous_rang_tabl_014';
  8         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);commit;
  9         delete from transaction_stored_anonymous_rang_tabl_014 where c_d_id<=100 or c_d_id>900;
 10     end;
 11 /

select count(*) from transaction_stored_anonymous_rang_tabl_014
1000

PL/SQL procedure successfully completed.

SQL> 
SQL> insert into transaction_stored_anonymous_rang_tabl_014 select * from transaction_stored_anonymous_tabl_000 where c_d_id<=100 or c_d_id>900;

200 rows affected.

SQL> update transaction_stored_anonymous_rang_tabl_014 set c_middle='XH' where c_d_id<=200 or c_d_id>800;

400 rows affected.

SQL> select distinct c_middle,count(*) from transaction_stored_anonymous_rang_tabl_014 group by c_middle order by 1;

C_MIDDLE   COUNT(*)            
---------- --------------------
XH         400                 
oa         600                 

2 rows fetched.

SQL> 
SQL> prepare transaction '2431.aaeabe.000014';

Succeed.

SQL> select distinct c_middle,count(*) from transaction_stored_anonymous_rang_tabl_014 group by c_middle order by 1;

C_MIDDLE   COUNT(*)            
---------- --------------------
oa         1000                

1 rows fetched.

SQL> 
SQL> update transaction_stored_anonymous_rang_tabl_014 set c_middle='WP' where c_d_id>200 and c_d_id<=800;

600 rows affected.

SQL> 
SQL> select distinct c_middle,count(*) from transaction_stored_anonymous_rang_tabl_014 group by c_middle order by 1;

C_MIDDLE   COUNT(*)            
---------- --------------------
WP         600                 
oa         400                 

2 rows fetched.

SQL> commit;

Succeed.

SQL> 
SQL> commit prepared '2431.aaeabe.000014';

Succeed.

SQL> select distinct c_middle,count(*) from transaction_stored_anonymous_rang_tabl_014 group by c_middle order by 1;

C_MIDDLE   COUNT(*)            
---------- --------------------
WP         600                 
XH         400                 

2 rows fetched.

SQL> 
SQL> declare
  2     print_str varchar(1000);
  3     sql_str varchar(1000);
  4     begin
  5         update transaction_stored_anonymous_rang_tabl_014 set c_d_id=(floor(c_d_id/150)+1)*400+c_d_id,c_first=c_first||'fsg',c_middle='W',c_street_1='rer',c_data1=lpad('dffhkswwwee',400,'c484zcsfjf'),c_data2=lpad('qvbuflchoqnsf',400,'qvoqgfvmpfzdsf'),c_data3=lpad('qvbuflggfgfdgchoqngfg',400,'qvgfgdfgldfsgfvmp'),c_data4=lpad('qvbugfgfgfvdpfzsf',400,'qvldgdfgfvmdfhfzdsf'),c_data5=lpad('qvbuflchfvdpfzsf',400,'qvldfschoqgfvmpfzdsf'),c_data6=lpad('qvbqnvmgfvdpfzsf',400,'qvldfschoqgfvmpfzdsf'),c_data7=lpad('qvbuhfhfgvmgfvdpfzsf',100,'qvldfhqgfvmpfzdsf'),c_data8=lpad('qvbuflchgfgfvdpfzsf',200,'qvlgdfoqgfvmpfzdsf'),c_clob=lpad('qvbuflchoqnvmgfvdpfzsf',400,'qvldfschoqgfvmpfzdsf'),c_blob=lpad('123143187569809',100,'1435764abc7890abcdef') where c_d_id<=400;
  6         execute immediate 'prepare transaction ''2431.aaeabe.000014''';
  7         savepoint aa;
  8         select count(*) into print_str from transaction_stored_anonymous_rang_tabl_014 where c_street_1='rer';
  9         sql_str :='select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1=''rer''';
 10         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);
 11 
 12         select count(*) into print_str from transaction_stored_anonymous_rang_tabl_014 where c_street_1='rer';
 13         sql_str :='select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1=''rer''';
 14         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);
 15 
 16 
 17         delete from transaction_stored_anonymous_rang_tabl_014 where c_d_id>400 and c_d_id<=500;
 18         sql_str :='select count(*) from transaction_stored_anonymous_rang_tabl_014';
 19         select count(*) into print_str from transaction_stored_anonymous_rang_tabl_014;
 20         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);
 21 
 22         sql_str :='select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1=''rer''';
 23         select count(*) into print_str from transaction_stored_anonymous_rang_tabl_014 where c_street_1='rer';
 24         dbe_output.print_line(sql_str);dbe_output.print_line(print_str);
 25         savepoint bb;
 26     end;
 27 /

select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1='rer'
0
select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1='rer'
0
select count(*) from transaction_stored_anonymous_rang_tabl_014
900
select count(*) from transaction_stored_anonymous_rang_tabl_014 c_street_1='rer'
0

PL/SQL procedure successfully completed.

SQL> select count(*) from transaction_stored_anonymous_rang_tabl_014;

COUNT(*)            
--------------------
900                 

1 rows fetched.

SQL> select distinct c_middle,count(*) from transaction_stored_anonymous_rang_tabl_014 group by c_middle order by 1;

C_MIDDLE   COUNT(*)            
---------- --------------------
WP         500                 
XH         400                 

2 rows fetched.

SQL> 
SQL> create or replace function SYN_FUN_001_2021(ARRAY_C integer[]) return integer[]
  2 as
  3 ARRAY_A integer[];
  4 begin
  5         ARRAY_A:=ARRAY_C;
  6         return ARRAY_A;
  7 end;
  8 /

Succeed.

SQL> create or replace function SYN_FUN_002_2021 (ARRAY_A integer[]) return integer[]
  2 as
  3 begin
  4         return SYN_FUN_001_2021(ARRAY_A);
  5 end;
  6 /

Succeed.

SQL> select SYN_FUN_002_2021(SYN_FUN_001_2021(array[1,2,3,4,5,6,7,8,9,10])) from SYS_DUMMY;

SYN_FUN_002_2021(SYN_FUN_001_2021(ARRAY[1,2,3,4,5,6,7,8,9,10])) 
----------------------------------------------------------------
{1,2,3,4,5,6,7,8,9,10}                                          

1 rows fetched.

SQL> 
SQL> declare
  2 x int[] :=array[1,2,3,4];
  3 y int[];
  4 begin
  5 y:=SYN_FUN_001_2021(x[1:3]);
  6 dbe_output.print_line(y);
  7 end;
  8 /

{1,2,3}

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace function SYN_FUN_005_2021(ARRAY_C integer[]) return integer[]
  2 as
  3 ARRAY_A integer[];
  4 begin
  5         ARRAY_A:=ARRAY_C;
  6         return ARRAY_A[1:2];
  7 end;
  8 /

Succeed.

SQL> select SYN_FUN_005_2021(array[1,2,3,4]) from sys_dummy;

SYN_FUN_005_2021(ARRAY[1,2,3,4])                                
----------------------------------------------------------------
{1,2}                                                           

1 rows fetched.

SQL> 
SQL> create or replace function SYN_FUN_006_2021(ARRAY_C integer[]) return integer[]
  2 as
  3 ARRAY_A integer[];
  4 begin
  5         ARRAY_A:=ARRAY_C;
  6         return ARRAY_A[1];
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(SYS.SYN_FUN_006_2021) terminated with compiling errors
[6:16] PLC-00606 Inconsistent datatypes, expected ARRAY - got BINARY_INTEGER


SQL> drop function if exists SYN_FUN_006_2021;

Succeed.

SQL> drop function if exists SYN_FUN_005_2021;

Succeed.

SQL> drop function if exists SYN_FUN_001_2021;

Succeed.

SQL> drop function if exists SYN_FUN_002_2021;

Succeed.

SQL> 
SQL> --create user
SQL> conn / as sysdba

connected.

SQL> drop user if exists CURSOR_FUNCTION_001_USR_01 cascade;

Succeed.

SQL> create user CURSOR_FUNCTION_001_USR_01  identified by Cantian_234;

Succeed.

SQL> grant dba to CURSOR_FUNCTION_001_USR_01;

Succeed.

SQL> drop table if exists CURSOR_FUNCTION_TEST_TAB_01;

Succeed.

SQL> drop view if exists CURSOR_FUNCTION_001_VIEW_01;

Succeed.

SQL> create table CURSOR_FUNCTION_TEST_TAB_01(empno int,ename varchar(10),job varchar(10) ,sal integer);

Succeed.

SQL> create or replace view CURSOR_FUNCTION_001_VIEW_01 as select * from CURSOR_FUNCTION_TEST_TAB_01;

Succeed.

SQL> --functionA
SQL> create or replace function CURSOR_FUNCTION_001_FUN_01 (str1 varchar) return int 
  2 is 
  3 mycursor1 sys_refcursor;
  4 a int;
  5 begin
  6  select empno into a from CURSOR_FUNCTION_001_VIEW_01;
  7    dbe_output.print_line(a);
  8    exception
  9    when  TOO_MANY_ROWS  then
 10    begin
 11       select empno into a from CURSOR_FUNCTION_001_VIEW_01 limit 1;
 12      dbe_output.print_line(a);
 13      return length(str1);
 14    end;
 15 end;
 16 /

Succeed.

SQL> conn CURSOR_FUNCTION_001_USR_01/Cantian_234@127.0.0.1:1611

connected.

SQL> select * from table(DBA_PROC_DECODE('SYS','CURSOR_FUNCTION_001_FUN_01','FUNCTION'));

LINE_NUM     LINE_TYPE                        LOC_LINE     SPECIAL_DESCRIPTION                                             
------------ -------------------------------- ------------ ----------------------------------------------------------------
1            LINE_BEGIN                       5            except[4];end[13];                                              
2            LINE_SQL                         6                                                                            
3            LINE_PROC                        7                                                                            
4            LINE_EXCEPTION                   8            end[12];                                                        
5            LINE_WHEN                        9                                                                            
6            LINE_BEGIN                       10           except[null];end[10];                                           
7            LINE_SQL                         11                                                                           
8            LINE_PROC                        12                                                                           
9            LINE_RETURN                      13                                                                           
10           LINE_END                         14                                                                           
11           LINE_END_WHEN                    14                                                                           
12           LINE_END_EXCEPTION               14                                                                           
13           LINE_END                         15                                                                           

13 rows fetched.

SQL> conn / as sysdba

connected.

SQL> drop user if exists CURSOR_FUNCTION_001_USR_01 cascade;

Succeed.

SQL> set serveroutput off;

OFF
SQL> 
SQL> --DTS2021051908BELMP1L00 START
SQL> CONN / AS SYSDBA

connected.

SQL> ALTER SYSTEM SET LOCAL_TEMPORARY_TABLE_ENABLED = TRUE;

Succeed.

SQL> DROP TABLE IF EXISTS #DTS2021051908BELMP1L00_T1;

Succeed.

SQL> CREATE TEMPORARY TABLE #DTS2021051908BELMP1L00_T1 AS SELECT * FROM SYS_DUMMY;

Succeed.

SQL> DECLARE
  2  CURSOR1 SYS_REFCURSOR;
  3 BEGIN
  4  OPEN CURSOR1 FOR SELECT * FROM #DTS2021051908BELMP1L00_T1;
  5  DBE_SQL.RETURN_CURSOR(CURSOR1);
  6 END;
  7 /

PL/SQL procedure successfully completed.

ResultSet #1

DUMMY
-----
X    

1 rows fetched.


SQL> CONN / AS SYSDBA --important, do not delete

connected.

SQL> --DTS2021051908BELMP1L00 END


