

SQL> set serveroutput on;

ON
SQL> 
SQL> create or replace function test_for_loop_f return boolean is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4   /*
  5   abc
  6   */
  7 begin
  8   test_num := 0;
  9   <<loop_label>>
 10   FOR i IN 1..10 LOOP
 11   /*
 12   abc
 13   */
 14     test_num := test_num + 1;
 15     CONTINUE loop_label when i > 7;
 16     test_num := test_num + 1;
 17     CONTINUE;
 18     test_num := test_num + 1;
 19   END LOOP;
 20   dbe_output.print_line(test_num);
 21   FunctionResult := TRUE;
 22   /*
 23   abc
 24   */
 25   return(FunctionResult);
 26 exception
 27   when others then
 28   /*
 29   abc
 30   */
 31     SYS.dbe_output.print_line('other error');
 32     return(FunctionResult);
 33 end;
 34 /

Succeed.

SQL> 
SQL> create or replace procedure test_for_loop_p is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 0;
  6   FOR i IN 1..10 LOOP
  7     test_num := test_num + 1;
  8     CONTINUE when i > 7;
  9     test_num := test_num + 1;
 10     CONTINUE;
 11     test_num := test_num + 1;
 12   END LOOP;
 13   dbe_output.print_line(test_num);
 14   FunctionResult := TRUE;
 15 exception
 16   when others then
 17     SYS.dbe_output.print_line('other error');
 18 end;
 19 /

Succeed.

SQL> 
SQL> create or replace function test_while_loop_f return boolean is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 5;
  6   WHILE test_num > 1 LOOP
  7     test_num := test_num - 1;
  8     test_num := test_num - 1;
  9     CONTINUE;
 10     test_num := test_num - 1;
 11   END LOOP;
 12   dbe_output.print_line(test_num);
 13   FunctionResult := TRUE;
 14   return(FunctionResult);
 15 exception
 16   when others then
 17     SYS.dbe_output.print_line('other error');
 18     return(FunctionResult);
 19 end;
 20 /

Succeed.

SQL> 
SQL> create or replace procedure test_while_loop_p is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 5;
  6   WHILE test_num = 0 LOOP
  7     test_num := test_num - 1;
  8     test_num := test_num - 1;
  9     CONTINUE;
 10     test_num := test_num - 1;
 11   END LOOP;
 12   dbe_output.print_line(test_num);
 13   FunctionResult := TRUE;
 14 exception
 15   when others then
 16     SYS.dbe_output.print_line('other error');
 17 end;
 18 /

Succeed.

SQL> 
SQL> create or replace function test_loop_f return boolean is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 5;
  6   LOOP
  7     EXIT;
  8 	test_num := 7;
  9   END LOOP;
 10   dbe_output.print_line(test_num);
 11   FunctionResult := TRUE;
 12   return(FunctionResult);
 13 exception
 14   when others then
 15     SYS.dbe_output.print_line('other error');
 16     return(FunctionResult);
 17 end;
 18 /

Succeed.

SQL> 
SQL> create or replace procedure test_loop_p is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 5;
  6   LOOP
  7     GOTO goto_label;
  8 	test_num := 7;
  9   END LOOP;
 10   dbe_output.print_line(test_num);
 11   <<goto_label>>
 12   FunctionResult := TRUE;
 13 exception
 14   when others then
 15     SYS.dbe_output.print_line('other error');
 16 end;
 17 /

Succeed.

SQL> 
SQL> create or replace function test_if_else_f return boolean is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 18;
  6   IF test_num = 17 THEN
  7     FunctionResult := TRUE;
  8   ELSIF test_num = 18 THEN
  9     FunctionResult := FALSE;
 10   ELSE
 11     FunctionResult := FALSE;
 12   END IF;
 13   dbe_output.print_line(test_num);
 14   FunctionResult := TRUE;
 15   return(FunctionResult);
 16 exception
 17   when others then
 18     SYS.dbe_output.print_line('other error');
 19     return(FunctionResult);
 20 end;
 21 /

Succeed.

SQL> 
SQL> create or replace procedure test_if_else_p is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 19;
  6   IF test_num = 17 THEN
  7     FunctionResult := TRUE;
  8   ELSIF test_num = 18 THEN
  9     FunctionResult := FALSE;
 10   ELSE
 11     FunctionResult := FALSE;
 12   END IF;
 13   dbe_output.print_line(test_num);
 14   FunctionResult := TRUE;
 15 exception
 16   when others then
 17     SYS.dbe_output.print_line('other error');
 18 end;
 19 /

Succeed.

SQL> 
SQL> create or replace function test_case_f return boolean is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 19;
  6   CASE test_num
  7   WHEN 19 THEN
  8     FunctionResult := FALSE;
  9   WHEN 20 THEN
 10     FunctionResult := FALSE;
 11   END CASE;
 12   dbe_output.print_line(test_num);
 13   FunctionResult := TRUE;
 14   return(FunctionResult);
 15 exception
 16   when others then
 17     SYS.dbe_output.print_line('other error');
 18     return(FunctionResult);
 19 end;
 20 /

Succeed.

SQL> 
SQL> create or replace procedure test_case_p is
  2   FunctionResult boolean;
  3   test_num       NUMBER;
  4 begin
  5   test_num := 20;
  6   CASE test_num
  7   WHEN 19 THEN
  8     FunctionResult := FALSE;
  9   WHEN 20 THEN
 10     FunctionResult := FALSE;
 11   END CASE;
 12   dbe_output.print_line(test_num);
 13   FunctionResult := TRUE;
 14 exception
 15   when others then
 16     SYS.dbe_output.print_line('other error');
 17 end;
 18 /

Succeed.

SQL> 
SQL> create or replace procedure test_level_3_p is
  2 v1 int;
  3 begin
  4   v1 := 1;
  5 end;
  6 /

Succeed.

SQL> 
SQL> create or replace procedure test_level_2_p is
  2 begin
  3   test_level_3_p();
  4 end;
  5 /

Succeed.

SQL> 
SQL> create or replace procedure test_level_1_p is
  2 begin
  3   test_level_2_p();
  4 end;
  5 /

Succeed.

SQL> 
SQL> drop user if exists gs_plsql_cover cascade;

Succeed.

SQL> create user gs_plsql_cover identified by Abc123456;

Succeed.

SQL> grant dba to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_for_loop_f to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_for_loop_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_while_loop_f to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_while_loop_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_loop_f to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_loop_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_if_else_f to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_if_else_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_case_f to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_case_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_level_1_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_level_2_p to gs_plsql_cover;

Succeed.

SQL> grant EXECUTE on test_level_3_p to gs_plsql_cover;

Succeed.

SQL> 
SQL> alter system set COVERAGE_ENABLE = FALSE;

Succeed.

SQL> drop table if exists COVERAGE$;

Succeed.

SQL> alter system set COVERAGE_ENABLE = TRUE;

Succeed.

SQL> conn gs_plsql_cover/Abc123456@127.0.0.1:1611

connected.

SQL> 
SQL> alter system set COVERAGE_ENABLE = TRUE;

CT-01001, Permissions were insufficient
SQL> 
SQL> drop table if exists test_sql_t;

Succeed.

SQL> create table test_sql_t(a int, b number(2), c varchar(20));

Succeed.

SQL> create or replace procedure test_sql_p is
  2 sql_str varchar(80);
  3 v1 int;
  4 begin
  5   delete test_sql_t;
  6   insert into test_sql_t(a,b,c)
  7     values(1, 2, '3');
  8   sql_str := 'insert into test_sql_t(a,b,c) values(4, 15, ''16'')';
  9   execute immediate sql_str;
 10   select a into v1 
 11   from test_sql_t 
 12   where b = 5;
 13 exception
 14   when no_data_found then
 15     SYS.dbe_output.print_line('not found error');
 16   when others then
 17     SYS.dbe_output.print_line('other error');
 18 end;
 19 /

Succeed.

SQL> 
SQL> create or replace trigger test_trigger after delete on test_sql_t
  2 begin
  3   insert into test_sql_t(a,b,c) values(9, 20, '30');
  4   return;
  5   insert into test_sql_t(a,b,c) values(10, 30, '100');
  6 end;
  7 /

Succeed.

SQL> 
SQL> drop table if exists test_func_in_dml_t;

Succeed.

SQL> create table test_func_in_dml_t(a int);

Succeed.

SQL> insert into test_func_in_dml_t(a) values(10);

1 rows affected.

SQL> create or replace function test_func_in_dml_f(p1 int) return int is
  2 begin
  3   return p1;
  4 end;
  5 /

Succeed.

SQL> 
SQL> create or replace procedure test_out_param_p(p1 out int) is
  2   v1 int;
  3 begin
  4   p1 := 1;
  5 end;
  6 /

Succeed.

SQL> 
SQL> declare
  2   v1 int;
  3 begin
  4   test_out_param_p(v1);
  5 end;
  6 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select sys.test_for_loop_f() from dual;

SYS.TEST_FOR_LOOP_F()
---------------------
TRUE                 

1 rows fetched.

17

SQL> call sys.test_for_loop_p();

17

PL/SQL procedure successfully completed.

SQL> select sys.test_while_loop_f() from dual;

SYS.TEST_WHILE_LOOP_F()
-----------------------
TRUE                   

1 rows fetched.

1

SQL> call sys.test_while_loop_p();

5

PL/SQL procedure successfully completed.

SQL> select sys.test_loop_f() from dual;

SYS.TEST_LOOP_F()
-----------------
TRUE             

1 rows fetched.

5

SQL> call sys.test_loop_p();

PL/SQL procedure successfully completed.

SQL> select sys.test_if_else_f() from dual;

SYS.TEST_IF_ELSE_F()
--------------------
TRUE                

1 rows fetched.

18

SQL> call sys.test_if_else_p();

19

PL/SQL procedure successfully completed.

SQL> select sys.test_case_f() from dual;

SYS.TEST_CASE_F()
-----------------
TRUE             

1 rows fetched.

19

SQL> call sys.test_case_p();

20

PL/SQL procedure successfully completed.

SQL> call test_sql_p();

not found error

PL/SQL procedure successfully completed.

SQL> call sys.test_level_1_p();

PL/SQL procedure successfully completed.

SQL> update test_func_in_dml_t set a = test_func_in_dml_f(2) where a = 10;

1 rows affected.

SQL> 
SQL> conn sys/Huawei@123@127.0.0.1:1611

connected.

SQL> 
SQL> select count(*) from user_indexes where INDEX_NAME = 'IX_COVERAGE';

COUNT(*)            
--------------------
1                   

1 rows fetched.

SQL> 
SQL> select OWNER,OBJ_NAME,COVER_INFO from COVERAGE$ where OWNER != 'COVERAGE' and OBJ_NAME like 'TEST_%';

OWNER                                                            OBJ_NAME                                                         COVER_INFO                                                      
---------------------------------------------------------------- ---------------------------------------------------------------- ----------------------------------------------------------------
GS_PLSQL_COVER                                                   TEST_OUT_PARAM_P                                                 3:1;4:1;5:1;                                                    
SYS                                                              TEST_FOR_LOOP_F                                                  7:1;8:1;9:1;10:11;14:10;15:10;16:7;17:7;18:0;19:1;20:1;21:1;25:1;26:0;27:0;31:0;32:0;33:1;
SYS                                                              TEST_FOR_LOOP_P                                                  4:1;5:1;6:11;7:10;8:10;9:7;10:7;11:0;12:1;13:1;14:1;15:0;16:0;17:0;18:1;
SYS                                                              TEST_WHILE_LOOP_F                                                4:1;5:1;6:3;7:2;8:2;9:2;10:0;11:1;12:1;13:1;14:1;15:0;16:0;17:0;18:0;19:1;
SYS                                                              TEST_WHILE_LOOP_P                                                4:1;5:1;6:1;7:0;8:0;9:0;10:0;11:1;12:1;13:1;14:0;15:0;16:0;17:1;
SYS                                                              TEST_LOOP_F                                                      4:1;5:1;6:1;7:1;8:0;9:1;10:1;11:1;12:1;13:0;14:0;15:0;16:0;17:1;
SYS                                                              TEST_LOOP_P                                                      4:1;5:1;6:1;7:1;8:0;9:0;10:0;11:1;12:1;13:0;14:0;15:0;16:1;     
SYS                                                              TEST_IF_ELSE_F                                                   4:1;5:1;6:1;7:0;8:1;9:1;10:1;11:0;12:1;13:1;14:1;15:1;16:0;17:0;18:0;19:0;20:1;
SYS                                                              TEST_IF_ELSE_P                                                   4:1;5:1;6:1;7:0;8:1;9:0;10:1;11:1;12:1;13:1;14:1;15:0;16:0;17:0;18:1;
SYS                                                              TEST_CASE_F                                                      4:1;5:1;6:1;7:1;8:1;9:1;10:0;11:1;12:1;13:1;14:1;15:0;16:0;17:0;18:0;19:1;
SYS                                                              TEST_CASE_P                                                      4:1;5:1;6:1;7:1;8:0;9:1;10:1;11:1;12:1;13:1;14:0;15:0;16:0;17:1;
GS_PLSQL_COVER                                                   TEST_TRIGGER                                                     2:1;3:1;4:1;5:0;6:1;                                            
GS_PLSQL_COVER                                                   TEST_SQL_P                                                       4:1;5:1;6:1;8:1;9:1;10:1;13:1;14:1;15:1;16:0;17:0;18:1;         
SYS                                                              TEST_LEVEL_3_P                                                   3:1;4:1;5:1;                                                    
SYS                                                              TEST_LEVEL_2_P                                                   2:1;3:1;4:1;                                                    
SYS                                                              TEST_LEVEL_1_P                                                   2:1;3:1;4:1;                                                    
GS_PLSQL_COVER                                                   TEST_FUNC_IN_DML_F                                               2:1;3:1;4:1;                                                    

17 rows fetched.

SQL> 
SQL> create or replace function test_loop_func(p1 int) return int is
  2 begin
  3   return p1;
  4 end;
  5 /

Succeed.

SQL> 
SQL> declare
  2 v1 int;
  3 begin
  4   for i in 1..50 loop
  5     v1 := test_loop_func(i);
  6   end loop;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select count(*) from COVERAGE$ where OBJ_NAME = 'TEST_LOOP_FUNC';

COUNT(*)            
--------------------
50                  

1 rows fetched.

SQL> 
SQL> alter system set COVERAGE_ENABLE = FALSE;

Succeed.

SQL> drop table if exists COVERAGE$;

Succeed.

SQL> drop user gs_plsql_cover cascade;

Succeed.

SQL> 
SQL> -- test can not core
SQL> alter system set COVERAGE_ENABLE = TRUE;

Succeed.

SQL> DROP TABLE IF EXISTS FVT_TRIGGER_TABLE_yf_095;

Succeed.

SQL> create table FVT_TRIGGER_TABLE_yf_095 (id number,name varchar2(20),sal number);

Succeed.

SQL> insert into FVT_TRIGGER_TABLE_yf_095 values(35,'yueming',8000);

1 rows affected.

SQL> insert into FVT_TRIGGER_TABLE_yf_095 values(5,'yueming',3000);

1 rows affected.

SQL> insert into FVT_TRIGGER_TABLE_yf_095 values(3,'yueming',5000);

1 rows affected.

SQL> 
SQL> drop table if exists FVT_TRIGGER_TABLE_yf_100;

Succeed.

SQL> create table FVT_TRIGGER_TABLE_yf_100(id number,name varchar2(20),sal number);

Succeed.

SQL> 
SQL> create or replace view YF_view_1 as select  * from FVT_TRIGGER_TABLE_yf_095;

Succeed.

SQL> create or replace trigger del_YF_00
  2 before delete or update or insert on FVT_TRIGGER_TABLE_yf_095 for each
  3 row begin
  4 insert into FVT_TRIGGER_TABLE_yf_100
  5 values( 1,'test',1);
  6 end;
  7 /

Succeed.

SQL> delete from FVT_TRIGGER_TABLE_yf_095 where id =35;

1 rows affected.

SQL> 
SQL> drop trigger del_YF_00;

Succeed.

SQL> drop view YF_view_1;

Succeed.

SQL> drop table FVT_TRIGGER_TABLE_yf_100;

Succeed.

SQL> DROP TABLE FVT_TRIGGER_TABLE_yf_095;

Succeed.

SQL> alter system set COVERAGE_ENABLE = FALSE;

Succeed.

SQL> drop table if exists COVERAGE$;

Succeed.

SQL> 
SQL> --DTS2020011400868
SQL> alter system set UPPER_CASE_TABLE_NAMES= false;

Succeed.

SQL> drop table if exists t_vlan_mapping;

Succeed.

SQL> 
SQL> CREATE TABLE t_vlan_mapping(
  2 devID INT not null,
  3 vrID INT NOT NULL,
  4 ifName varchar(63) not null,
  5 mappingVid int NOT null,
  6 transVlans  varchar(1948) not null,
  7 deployStatus int not null,
  8 transVlansBitMap varchar(1948) not null
  9 );

Succeed.

SQL> 
SQL> insert into t_vlan_mapping values(1,1,'ddd',1,'fdff',1,'22222');

1 rows affected.

SQL> 
SQL> create or replace function func_getMappingVlan111(v_DevID   IN NUMBER ,v_vrID   IN NUMBER,v_ifName  IN VARCHAR2)
  2 RETURN VARCHAR2
  3    as
  4    v_str VARCHAR2(1024);
  5 begin
  6     v_str := '';
  7     for param in (select mappingVid,transVlans from t_vlan_mapping where devID = v_DevID and vrID = v_vrID and ifName = v_ifName) loop
  8         if param.transVlans is null or param.transVlans = '--' then
  9             v_str := v_str||'{"vlan":null,"mapping-vlan":';
 10         else
 11             v_str := v_str||'{"vlan":"'||param.transVlans||'","mapping-vlan":';
 12         end if;
 13         
 14         if param.mappingVid is null then
 15             v_str := v_str||'null},';
 16         else 
 17             v_str := v_str||'"'||param.mappingVid||'"'||'},';
 18         end if;
 19     end loop;
 20     if instr(v_str,',') > 0 then
 21         v_str := SUBSTR(v_str,0,LENGTH(v_str)-1);
 22     end if;
 23     if length(v_str) > 0 then
 24         v_str := '['||v_str|| ']';
 25     else
 26         v_str := null;
 27     end if;
 28    return(v_str);
 29 end;
 30 /

Succeed.

SQL> 
SQL> select func_getMappingVlan111(1,1,'ddd') from dual;

FUNC_GETMAPPINGVLAN111(1,1,'DDD')                               
----------------------------------------------------------------
[{"vlan":"fdff","mapping-vlan":"1"}]                            

1 rows fetched.

SQL> drop function func_getMappingVlan111;

Succeed.

SQL> drop TABLE t_vlan_mapping;

Succeed.

SQL> alter system set UPPER_CASE_TABLE_NAMES= true;

Succeed.

SQL> 
SQL> select * from GADM_TABLES;

GROUP_ID     NODE_NAME                                                        OWNER                                                            TABLE_NAME                                                       TABLE_ID     TABLESPACE_NAME                                                  COLUMN_COUNT INDEX_COUNT  PARTITIONED CREATED_TIME           LAST_DDL_TIME          PCT_FREE     INI_TRANS    MAX_TRANS    BYTES                PAGES                EXTENTS              NUM_ROWS     BLOCKS       EMPTY_BLOCKS AVG_SPACE                                CHAIN_CNT                                AVG_ROW_LEN          SAMPLE_SIZE  LAST_ANALYZED                    STATUS TEMPORARY_ APPENDONLY_ TABLE_TYPE   CR_MODE ROW_FORMAT NOLOGGING_INSERT COMPRESS_ALGO
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ---------------------------------------------------------------- ------------ ------------ ----------- ---------------------- ---------------------- ------------ ------------ ------------ -------------------- -------------------- -------------------- ------------ ------------ ------------ ---------------------------------------- ---------------------------------------- -------------------- ------------ -------------------------------- ------ ---------- ----------- ------------ ------- ---------- ---------------- -------------

0 rows fetched.

count = 0

SQL> alter system set UPPER_CASE_TABLE_NAMES=FALSE;

Succeed.

SQL> select * from sys.GADM_TABLES;

GROUP_ID     NODE_NAME                                                        OWNER                                                            TABLE_NAME                                                       TABLE_ID     TABLESPACE_NAME                                                  COLUMN_COUNT INDEX_COUNT  PARTITIONED CREATED_TIME           LAST_DDL_TIME          PCT_FREE     INI_TRANS    MAX_TRANS    BYTES                PAGES                EXTENTS              NUM_ROWS     BLOCKS       EMPTY_BLOCKS AVG_SPACE                                CHAIN_CNT                                AVG_ROW_LEN          SAMPLE_SIZE  LAST_ANALYZED                    STATUS TEMPORARY_ APPENDONLY_ TABLE_TYPE   CR_MODE ROW_FORMAT NOLOGGING_INSERT COMPRESS_ALGO
------------ ---------------------------------------------------------------- ---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ---------------------------------------------------------------- ------------ ------------ ----------- ---------------------- ---------------------- ------------ ------------ ------------ -------------------- -------------------- -------------------- ------------ ------------ ------------ ---------------------------------------- ---------------------------------------- -------------------- ------------ -------------------------------- ------ ---------- ----------- ------------ ------- ---------- ---------------- -------------

0 rows fetched.

count = 0

SQL> alter system set UPPER_CASE_TABLE_NAMES=TRUE;

Succeed.

SQL> 
SQL> 
SQL> set serveroutput off;

OFF
SQL> 


