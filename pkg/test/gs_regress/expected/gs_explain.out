

SQL> drop table if exists customer1;

Succeed.

SQL> create table customer1
  2 (
  3     c_customer_sk             integer               not null,
  4     c_customer_id             char(16)              not null,
  5     c_current_cdemo_sk        integer                       ,
  6     c_current_hdemo_sk        integer                       ,
  7     c_current_addr_sk         integer                       ,
  8     c_first_shipto_date_sk    integer                       ,
  9     c_first_sales_date_sk     integer                       ,
 10     c_salutation              char(10)                      ,
 11     c_first_name              char(20)                      ,
 12     c_last_name               char(30)                      ,
 13     c_preferred_cust_flag     char(1)                       ,
 14     c_birth_day               integer                       ,
 15     c_birth_month             integer                       ,
 16     c_birth_year              integer                       ,
 17     c_birth_country           varchar(20)                   ,
 18     c_login                   char(13)                      ,
 19     c_email_address           char(50)                      ,
 20     c_last_review_date        char(10)
 21 ) ;

Succeed.

SQL> drop table if exists item;

Succeed.

SQL> create table item
  2 (
  3     i_item_sk                 integer               not null,
  4     i_item_id                 char(16)              not null,
  5     i_rec_start_date          date                          ,
  6     i_rec_end_date            date                          ,
  7     i_item_desc               varchar(200)                  ,
  8     i_current_price           decimal(7,2)                  ,
  9     i_wholesale_cost          decimal(7,2)                  ,
 10     i_brand_id                double                       ,
 11     i_brand                   char(50)                      ,
 12     i_class_id                integer                       ,
 13     i_class                   char(50)                      ,
 14     i_category_id             integer                       ,
 15     i_category                char(50)                      ,
 16     i_manufact_id             integer                       ,
 17     i_manufact                char(50)                      ,
 18     i_size                    char(20)                      ,
 19     i_formulation             char(20)                      ,
 20     i_color                   char(20)                      ,
 21     i_units                   char(20)                      ,
 22     i_container               char(10)                      ,
 23     i_manager_id              integer                       ,
 24     i_product_name            char(50)
 25 );

Succeed.

SQL> explain select substr(c_current_cdemo_sk, length(c_current_cdemo_sk) - 3, 1),
  2 substr(c_current_cdemo_sk, -7, 2) a,
  3 substr((substr(max(c_current_cdemo_sk), -3, 5)),
  4 substr(c_current_cdemo_sk, -7, 1),
  5 2),
  6 substr((substr((substr(c_current_cdemo_sk, -3, 5)),
  7 substr(c_current_cdemo_sk, -7, 1),
  8 2)),
  9 2)
 10 from customer1
 11 inner join item
 12 on substr(c_current_cdemo_sk, -7, 2) = c_birth_day
 13 where trim(c_customer_id, 'A') like '%OPO%'
 14 and c_current_cdemo_sk ::numeric * c_current_hdemo_sk is not null
 15 group by c_current_cdemo_sk
 16 order by 1, 2, 3, 4;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |           |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |           |      |      |       |        |
| 2   |     HASH GROUP BY              |       |           |      |      |       |        |
| 3   |       NESTED LOOPS             |       |           |      |      |       |        |
| 4   |         SUBSELECT              |       |           |      |      |       |        |
| 5   |           HASH GROUP BY        |       |           |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | CUSTOMER1 |      |      |       |        |
| 7   |         TABLE ACCESS FULL      | SYS   | ITEM      |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - filter: TRIM(C_CUSTOMER_ID, 'A') LIKE '%OPO%' AND SUBSTR(C_CURRENT_CDEMO_SK, -7, 2) = C_BIRTH_DAY AND 
               CAST(C_CURRENT_CDEMO_SK AS NUMBER) * C_CURRENT_HDEMO_SK IS NOT NULL

16 rows fetched.

SQL> drop table if exists item;

Succeed.

SQL> drop table if exists customer1;

Succeed.

SQL> drop table if exists test_explain1;

Succeed.

SQL> drop table if exists test_explain2;

Succeed.

SQL> drop table if exists test_explain3;

Succeed.

SQL> drop table if exists test_explain4;

Succeed.

SQL> create table test_explain1(f1 int, f2 int);

Succeed.

SQL> create table test_explain2(f1 int, f2 int);

Succeed.

SQL> create table test_explain3(f1 int, f2 int);

Succeed.

SQL> create table test_explain4(f1 int, f2 int)
  2 PARTITION BY RANGE(f1)
  3 (
  4  PARTITION p1 values less than(10),
  5  PARTITION p2 values less than(20),
  6  PARTITION p3 values less than(30)
  7 );

Succeed.

SQL> 
SQL> -- explain [plan for]
SQL> explain p select 1 from dual;

CT-00601, [1:9]Sql syntax error: missing keyword
SQL> explain plan f select 1 from dual;

CT-00601, [1:14]Sql syntax error: FOR expected
SQL> explain plan for select 1 from dual;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description          | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |           |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SYS_DUMMY |      |      |       |        |
---------------------------------------------------------------------------------

6 rows fetched.

SQL> explain select 1 from dual;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description          | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |           |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SYS_DUMMY |      |      |       |        |
---------------------------------------------------------------------------------

6 rows fetched.

SQL> 
SQL> -- explain [plan binding parameters]
SQL> explain select * from dual where 1 > :1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------
| Id  | Description          | Owner | Name      | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |           |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | SYS_DUMMY |      |      |       |        |
---------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: 1 > ?                                            

9 rows fetched.

SQL> 
SQL> --test push down cond
SQL> explain plan for select *
  2   from (
  3   select distinct f1
  4           from (select distinct test_explain1.f1
  5                   from test_explain1, test_explain2) t1
  6          where t1.f1 in (select f1 from test_explain3)
  7          ) t2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |               |      |      |       |        |
| 1   |   SUBSELECT                      |       | T2            |      |      |       |        |
| 2   |     HASH DISTINCT                |       |               |      |      |       |        |
| 3   |       SUBSELECT                  |       | T1            |      |      |       |        |
| 4   |         NESTED LOOPS             |       |               |      |      |       |        |
| 5   |           HASH JOIN SEMI(L)      |       |               |      |      |       |        |
| 6   |             SUBSELECT            |       |               |      |      |       |        |
| 7   |               TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN3 |      |      |       |        |
| 8   |             TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL      | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: TEST_EXPLAIN3.F1 = TEST_EXPLAIN1.F1              

17 rows fetched.

SQL> 
SQL> -- explain select
SQL> explain plan for select 1 from dual where not exists (select f1 from test_explain1 where test_explain1.f1 = 0);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   KERNEL FILTER        |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | SYS_DUMMY     |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: NOT EXISTS(SELECT 1 FROM TEST_EXPLAIN1 WHERE TEST_EXPLAIN1.F1 = 0)
   3 - filter: TEST_EXPLAIN1.F1 = 0                             

12 rows fetched.

SQL> explain plan for select 1 from dual where exists (select f1 from test_explain1 where test_explain1.f1 = 0);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   KERNEL FILTER        |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | SYS_DUMMY     |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM TEST_EXPLAIN1 WHERE TEST_EXPLAIN1.F1 = 0)
   3 - filter: TEST_EXPLAIN1.F1 = 0                             

12 rows fetched.

SQL> explain plan for select distinct f1,f2 from test_explain1 where f1=1 and f2=2 group by f1, f2 having f1=1 and f2=2 order by f1 asc, f2 desc;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |               |      |      |       |        |
| 1   |   SORT DISTINCT            |       |               |      |      |       |        |
| 2   |     HAVING                 |       |               |      |      |       |        |
| 3   |       HASH GROUP BY        |       |               |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F1 = 1 AND F2 = 2                                
   4 - filter: F2 = 2 AND F1 = 1                                

13 rows fetched.

SQL> explain plan for select * from test_explain1 union select * from test_explain2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   HASH UNION           |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
---------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain plan for select * from (select * from test_explain1 union all select * from test_explain2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |               |      |      |       |        |
| 1   |   SUBSELECT              |       |               |      |      |       |        |
| 2   |     UNION ALL            |       |               |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-----------------------------------------------------------------------------------------

9 rows fetched.

SQL> explain plan for select count(*) from test_explain1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |               |      |      |       |        |
| 1   |   AGGR                 |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
---------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain plan for select * from test_explain1 where rowid in (to_char('000863641600000'), to_char('000863641700000'), to_char('000863641700000'), to_char('000863641700000'), to_char('000863641600000'), to_char('000863641800000'), to_char('000863642700000'));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description             | Owner | Name          | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT        |       |               |      |      |       |        |
| 1   |   TABLE ACCESS BY ROWID | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 2   |     ROWID SCAN          |       |               |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ROWID IN(TO_CHAR('000863641600000'), TO_CHAR('000863641700000'), TO_CHAR('000863641700000'), 
               TO_CHAR('000863641700000'), TO_CHAR('000863641600000'), TO_CHAR('000863641800000'), TO_CHAR('000863642700000'))

11 rows fetched.

SQL> explain plan for select * from test_explain1 union all select * from test_explain2 limit 10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |               |      |      |       |        |
| 1   |   SELECT LIMIT           |       |               |      |      |       |        |
| 2   |     UNION ALL            |       |               |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-----------------------------------------------------------------------------------------

9 rows fetched.

SQL> -- explain insert
SQL> explain plan for insert into test_explain1(f1) select 1 from dual where exists (select f1 from test_explain1 where test_explain1.f1 = 0);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT           |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 2   |     SUBSELECT              |       |               |      |      |       |        |
| 3   |       KERNEL FILTER        |       |               |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | SYS_DUMMY     |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: EXISTS(SELECT 1 FROM TEST_EXPLAIN1 WHERE TEST_EXPLAIN1.F1 = 0)
   5 - filter: TEST_EXPLAIN1.F1 = 0                             

14 rows fetched.

SQL> explain plan for insert into test_explain1(f1, f2) values(1, 2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT           |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain plan for insert into test_explain1 select distinct f1,f2 from test_explain2 where f1=1 and f2=2 group by f1, f2 having f1=1 and f2=2 order by f1 asc, f2 desc;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT               |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL      | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 2   |     SUBSELECT                  |       |               |      |      |       |        |
| 3   |       SORT DISTINCT            |       |               |      |      |       |        |
| 4   |         HAVING                 |       |               |      |      |       |        |
| 5   |           HASH GROUP BY        |       |               |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: F1 = 1 AND F2 = 2                                
   6 - filter: F2 = 2 AND F1 = 1                                

15 rows fetched.

SQL> explain plan for insert into test_explain1 select * from test_explain2 union select * from test_explain3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT           |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 2   |     SUBSELECT              |       |               |      |      |       |        |
| 3   |       HASH UNION           |       |               |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN3 |      |      |       |        |
-------------------------------------------------------------------------------------------

10 rows fetched.

SQL> explain plan for insert into test_explain1 select * from (select * from test_explain2 union all select * from test_explain3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT             |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL    | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 2   |     SUBSELECT                |       |               |      |      |       |        |
| 3   |       SUBSELECT              |       |               |      |      |       |        |
| 4   |         UNION ALL            |       |               |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN3 |      |      |       |        |
---------------------------------------------------------------------------------------------

11 rows fetched.

SQL> explain plan for insert into test_explain4 values(1,1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                             | Owner | Name          | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                        |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:id=0) | SYS   | TEST_EXPLAIN4 |      |      |       |        |
--------------------------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain plan for insert into test_explain4 values(40,40);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                               | Owner | Name          | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                          |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:id=N/A) | SYS   | TEST_EXPLAIN4 |      |      |       |        |
----------------------------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain plan for insert into test_explain4 select * from test_explain1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                       |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:N/A) | SYS   | TEST_EXPLAIN4 |      |      |       |        |
| 2   |     SUBSELECT                          |       |               |      |      |       |        |
| 3   |       TABLE ACCESS FULL                | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> 
SQL> -- explain delete
SQL> explain plan for delete from test_explain1 where f1=1 and f2=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F2 = 2 AND F1 = 1                                

9 rows fetched.

SQL> explain plan for delete from test_explain1 where f1=(select f1 from test_explain2 union select f1 from test_explain3) and f2=(select f2 from test_explain2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |               |      |      |       |        |
| 1   |   KERNEL FILTER          |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 3   |     HASH UNION           |       |               |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN3 |      |      |       |        |
| 6   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F1 = ((SELECT F1 FROM TEST_EXPLAIN2) UNION (SELECT F1 FROM TEST_EXPLAIN3)) AND F2 = (SELECT 
               F2 FROM TEST_EXPLAIN2)                           

15 rows fetched.

SQL> explain plan for delete from test_explain1 order by f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain plan for delete from test_explain1 limit 3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name          | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT       |       |               |      |      |       |        |
| 1   |   QUERY LIMIT          |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
---------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain plan for delete from test_explain1 order by f1 limit 3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT               |       |               |      |      |       |        |
| 1   |   QUERY LIMIT                  |       |               |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM |       |               |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-----------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain plan for delete t1,t2 from test_explain1 t1 join test_explain2 t2 on t1.f1=t2.f1 order by t1.f1 limit 3;

CT-00601, [1:90]Sql syntax error: multi delete do not support order by
SQL> -- explain update
SQL> explain plan for update test_explain1 set f1=1, f2=2 where f1=1 and f2=2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F2 = 2 AND F1 = 1                                

9 rows fetched.

SQL> explain plan for update test_explain1 set f1=(select f1 from test_explain2 union select f1 from test_explain3), f2=(select f2 from test_explain2) where f1=(select f1 from test_explain2 union select f1 from test_explain3) and f2=(select f2 from test_explain2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |               |      |      |       |        |
| 1   |   KERNEL FILTER          |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN1 |      |      |       |        |
| 3   |     HASH UNION           |       |               |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN3 |      |      |       |        |
| 6   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 7   |   HASH UNION             |       |               |      |      |       |        |
| 8   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN2 |      |      |       |        |
| 9   |     TABLE ACCESS FULL    | SYS   | TEST_EXPLAIN3 |      |      |       |        |
| 10  |   TABLE ACCESS FULL      | SYS   | TEST_EXPLAIN2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F1 = ((SELECT F1 FROM TEST_EXPLAIN2) UNION (SELECT F1 FROM TEST_EXPLAIN3)) AND F2 = (SELECT 
               F2 FROM TEST_EXPLAIN2)                           

19 rows fetched.

SQL> 
SQL> -- explain view
SQL> drop view if exists test_explain_view1;

Succeed.

SQL> drop view if exists test_explain_view2;

Succeed.

SQL> drop view if exists test_explain_view3;

Succeed.

SQL> create view test_explain_view1 as select distinct f1,f2 from test_explain1 where f1=1 and f2=2 group by f1, f2 having f1=1 and f2=2 order by f1 asc, f2 desc;

Succeed.

SQL> create view test_explain_view2 as select * from test_explain1 union select * from test_explain2;

Succeed.

SQL> create view test_explain_view3 as select * from (select * from test_explain1 union all select * from test_explain2);

Succeed.

SQL> explain plan for select * from test_explain_view1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                    |      |      |       |        |
| 1   |   VIEW                       | SYS   | TEST_EXPLAIN_VIEW1 |      |      |       |        |
| 2   |     SORT DISTINCT            |       |                    |      |      |       |        |
| 3   |       HAVING                 |       |                    |      |      |       |        |
| 4   |         HASH GROUP BY        |       |                    |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: F1 = 1 AND F2 = 2                                
   5 - filter: F1 = 1 AND F2 = 2                                

14 rows fetched.

SQL> explain plan for select * from test_explain_view2 union select * from test_explain_view3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                    |      |      |       |        |
| 1   |   HASH UNION               |       |                    |      |      |       |        |
| 2   |     VIEW                   | SYS   | TEST_EXPLAIN_VIEW2 |      |      |       |        |
| 3   |       HASH UNION           |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2      |      |      |       |        |
| 6   |     SUBSELECT              |       |                    |      |      |       |        |
| 7   |       UNION ALL            |       |                    |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 9   |         TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2      |      |      |       |        |
------------------------------------------------------------------------------------------------

14 rows fetched.

SQL> explain plan for insert into test_explain1 select * from test_explain_view1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name               | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                 |       |                    |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL        | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 2   |     SUBSELECT                    |       |                    |      |      |       |        |
| 3   |       VIEW                       | SYS   | TEST_EXPLAIN_VIEW1 |      |      |       |        |
| 4   |         SORT DISTINCT            |       |                    |      |      |       |        |
| 5   |           HAVING                 |       |                    |      |      |       |        |
| 6   |             HASH GROUP BY        |       |                    |      |      |       |        |
| 7   |               TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: F1 = 1 AND F2 = 2                                
   7 - filter: F1 = 1 AND F2 = 2                                

16 rows fetched.

SQL> explain plan for insert into test_explain1 select * from test_explain_view2 union select * from test_explain_view3;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT               |       |                    |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL      | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 2   |     SUBSELECT                  |       |                    |      |      |       |        |
| 3   |       HASH UNION               |       |                    |      |      |       |        |
| 4   |         VIEW                   | SYS   | TEST_EXPLAIN_VIEW2 |      |      |       |        |
| 5   |           HASH UNION           |       |                    |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2      |      |      |       |        |
| 8   |         SUBSELECT              |       |                    |      |      |       |        |
| 9   |           UNION ALL            |       |                    |      |      |       |        |
| 10  |             TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1      |      |      |       |        |
| 11  |             TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN2      |      |      |       |        |
----------------------------------------------------------------------------------------------------

16 rows fetched.

SQL> 
SQL> --test pasre rowid
SQL> explain plan for select t1.rowid from test_explain1 t1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                  |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | TEST_EXPLAIN1 T1 |      |      |       |        |
----------------------------------------------------------------------------------------

6 rows fetched.

SQL> 
SQL> -- explain replace into
SQL> drop table if exists test_explain5;

Succeed.

SQL> create table test_explain5(
  2 id int ,
  3 col_char1 varchar(30),
  4 col_char2 varchar(40),
  5 col_char3 varchar(40)
  6 );

Succeed.

SQL> alter table test_explain5 add constraint test_explain5_pk1 primary key(id ,col_char1);

Succeed.

SQL> alter table test_explain5 add constraint test_explain5_pk2 UNIQUE(col_char3);

Succeed.

SQL> alter table test_explain5 add constraint test_explain5_pk3 UNIQUE(col_char1);

Succeed.

SQL> explain plan for replace into test_explain5 set id = 1,col_char1 ='a',col_char2='b',col_char3='ABCDEFG';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | REPLACE STATEMENT          |       |               |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL  | SYS   | TEST_EXPLAIN5 |      |      |       |        |
-------------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain replace into test_explain5 select * from test_explain5 where id = 1 and col_char1 ='a' and col_char2='b' and col_char3='ABCDEFG';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name              | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | REPLACE STATEMENT                  |       |                   |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL          | SYS   | TEST_EXPLAIN5     |      |      |       |        |
| 2   |     SUBSELECT                      |       |                   |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_EXPLAIN5     |      |      |       |        |
| 4   |         INDEX UNIQUE SCAN          | SYS   | TEST_EXPLAIN5_PK1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: COL_CHAR2 = 'b' AND COL_CHAR3 = 'ABCDEFG'        
   4 - access: COL_CHAR1 = 'a' AND ID = 1                       

13 rows fetched.

SQL> 
SQL> -- support length of explain more than one package
SQL> drop table if exists bmsql_stock;

Succeed.

SQL> create table bmsql_stock (
  2   s_w_id       integer       not null,
  3   s_i_id       integer       not null,
  4   s_quantity   integer,
  5   s_ytd        integer,
  6   s_order_cnt  integer,
  7   s_remote_cnt integer,
  8   s_data       varchar(50),
  9   s_dist_01    char(24),
 10   s_dist_02    char(24),
 11   s_dist_03    char(24),
 12   s_dist_04    char(24),
 13   s_dist_05    char(24),
 14   s_dist_06    char(24),
 15   s_dist_07    char(24),
 16   s_dist_08    char(24),
 17   s_dist_09    char(24),
 18   s_dist_10    char(24)
 19 );

Succeed.

SQL> alter table bmsql_stock add constraint bmsql_stock_pkey
  2   primary key (s_w_id, s_i_id);

Succeed.

SQL> 
SQL> drop table if exists bmsql_district;

Succeed.

SQL> create table bmsql_district (
  2   d_w_id       integer       not null,
  3   d_id         integer       not null,
  4   d_ytd        decimal(12,2),
  5   d_tax        decimal(4,4),
  6   d_next_o_id  integer,
  7   d_name       varchar(10),
  8   d_street_1   varchar(20),
  9   d_street_2   varchar(20),
 10   d_city       varchar(20),
 11   d_state      char(2),
 12   d_zip        char(9)
 13 );

Succeed.

SQL> alter table bmsql_district add constraint bmsql_district_pkey
  2   primary key (d_w_id, d_id);

Succeed.

SQL> 
SQL> drop table if exists bmsql_order_line;

Succeed.

SQL> create table bmsql_order_line (
  2   ol_w_id         integer   not null,
  3   ol_d_id         integer   not null,
  4   ol_o_id         integer   not null,
  5   ol_number       integer   not null,
  6   ol_i_id         integer   not null,
  7   ol_delivery_d   timestamp,
  8   ol_amount       decimal(6,2),
  9   ol_supply_w_id  integer,
 10   ol_quantity     integer,
 11   ol_dist_info    char(24)
 12 );

Succeed.

SQL> alter table bmsql_order_line add constraint bmsql_order_line_pkey
  2   primary key (ol_w_id, ol_d_id, ol_o_id, ol_number);

Succeed.

SQL> 
SQL> explain 
  2 select count(*) from 
  3 (
  4 	SELECT count(*) AS low_stock FROM 
  5 	(
  6 		SELECT s_w_id, s_i_id, s_quantity 
  7 			FROM bmsql_stock
  8 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
  9 				SELECT ol_i_id 
 10 					FROM bmsql_district 
 11 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 12 					 AND ol_d_id = d_id 
 13 					 AND ol_o_id >= d_next_o_id - 20 
 14 					 AND ol_o_id < d_next_o_id 
 15 					WHERE d_w_id = 2 AND d_id = 2 
 16 			) 
 17 	)
 18 	union all 
 19 	SELECT count(*) AS low_stock FROM 
 20 	(
 21 		SELECT s_w_id, s_i_id, s_quantity 
 22 			FROM bmsql_stock
 23 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 24 				SELECT ol_i_id 
 25 					FROM bmsql_district 
 26 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 27 					 AND ol_d_id = d_id 
 28 					 AND ol_o_id >= d_next_o_id - 20 
 29 					 AND ol_o_id < d_next_o_id 
 30 					WHERE d_w_id = 2 AND d_id = 2 
 31 			) 
 32 	)
 33 	union 
 34 	SELECT count(*) AS low_stock FROM 
 35 	(
 36 		SELECT s_w_id, s_i_id, s_quantity 
 37 			FROM bmsql_stock
 38 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 39 				SELECT ol_i_id 
 40 					FROM bmsql_district 
 41 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 42 					 AND ol_d_id = d_id 
 43 					 AND ol_o_id >= d_next_o_id - 20 
 44 					 AND ol_o_id < d_next_o_id 
 45 					WHERE d_w_id = 2 AND d_id = 2 
 46 			) 
 47 	)
 48 	minus 	
 49 	SELECT count(*) AS low_stock FROM 
 50 	(
 51 		SELECT s_w_id, s_i_id, s_quantity 
 52 			FROM bmsql_stock
 53 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 54 				SELECT ol_i_id 
 55 					FROM bmsql_district 
 56 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 57 					 AND ol_d_id = d_id 
 58 					 AND ol_o_id >= d_next_o_id - 20 
 59 					 AND ol_o_id < d_next_o_id 
 60 					WHERE d_w_id = 2 AND d_id = 2 
 61 			) 
 62 	)
 63 	union 
 64 	SELECT count(*) AS low_stock FROM 
 65 	(
 66 		SELECT s_w_id, s_i_id, s_quantity 
 67 			FROM bmsql_stock
 68 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 69 				SELECT ol_i_id 
 70 					FROM bmsql_district 
 71 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 72 					 AND ol_d_id = d_id 
 73 					 AND ol_o_id >= d_next_o_id - 20 
 74 					 AND ol_o_id < d_next_o_id 
 75 					WHERE d_w_id = 2 AND d_id = 2 
 76 			) 
 77 	)
 78 	union all 
 79 	SELECT count(*) AS low_stock FROM 
 80 	(
 81 		SELECT s_w_id, s_i_id, s_quantity 
 82 			FROM bmsql_stock
 83 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 84 				SELECT ol_i_id 
 85 					FROM bmsql_district 
 86 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 87 					 AND ol_d_id = d_id 
 88 					 AND ol_o_id >= d_next_o_id - 20 
 89 					 AND ol_o_id < d_next_o_id 
 90 					WHERE d_w_id = 2 AND d_id = 2 
 91 			) 
 92 	)
 93 	union 
 94 	SELECT count(*) AS low_stock FROM 
 95 	(
 96 		SELECT s_w_id, s_i_id, s_quantity 
 97 			FROM bmsql_stock
 98 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 99 				SELECT ol_i_id 
100 					FROM bmsql_district 
101 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
102 					 AND ol_d_id = d_id 
103 					 AND ol_o_id >= d_next_o_id - 20 
104 					 AND ol_o_id < d_next_o_id 
105 					WHERE d_w_id = 2 AND d_id = 2 
106 			) 
107 	)
108 	minus 	
109 	SELECT count(*) AS low_stock FROM 
110 	(
111 		SELECT s_w_id, s_i_id, s_quantity 
112 			FROM bmsql_stock
113 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
114 				SELECT ol_i_id 
115 					FROM bmsql_district 
116 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
117 					 AND ol_d_id = d_id 
118 					 AND ol_o_id >= d_next_o_id - 20 
119 					 AND ol_o_id < d_next_o_id 
120 					WHERE d_w_id = 2 AND d_id = 2 
121 			) 
122 	)
123 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                              | Owner | Name                  | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                                         |       |                       |      |      |       |        |
| 1   |   AGGR                                                   |       |                       |      |      |       |        |
| 2   |     SUBSELECT                                            |       |                       |      |      |       |        |
| 3   |       HASH MINUS                                         |       |                       |      |      |       |        |
| 4   |         HASH UNION                                       |       |                       |      |      |       |        |
| 5   |           UNION ALL                                      |       |                       |      |      |       |        |
| 6   |             HASH MINUS                                   |       |                       |      |      |       |        |
| 7   |               UNION ALL                                  |       |                       |      |      |       |        |
| 8   |                 AGGR                                     |       |                       |      |      |       |        |
| 9   |                   NESTED LOOPS                           |       |                       |      |      |       |        |
| 10  |                     SUBSELECT                            |       |                       |      |      |       |        |
| 11  |                       HASH DISTINCT                      |       |                       |      |      |       |        |
| 12  |                         NESTED LOOPS                     |       |                       |      |      |       |        |
| 13  |                           NESTED LOOPS                   |       |                       |      |      |       |        |
| 14  |                             TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 15  |                               INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 16  |                             TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 17  |                               INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 18  |                           TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 19  |                             ROWID SCAN                   |       |                       |      |      |       |        |
| 20  |                     TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 21  |                       INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 22  |                 AGGR                                     |       |                       |      |      |       |        |
| 23  |                   NESTED LOOPS                           |       |                       |      |      |       |        |
| 24  |                     SUBSELECT                            |       |                       |      |      |       |        |
| 25  |                       HASH DISTINCT                      |       |                       |      |      |       |        |
| 26  |                         NESTED LOOPS                     |       |                       |      |      |       |        |
| 27  |                           NESTED LOOPS                   |       |                       |      |      |       |        |
| 28  |                             TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 29  |                               INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 30  |                             TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 31  |                               INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 32  |                           TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 33  |                             ROWID SCAN                   |       |                       |      |      |       |        |
| 34  |                     TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 35  |                       INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 36  |                 AGGR                                     |       |                       |      |      |       |        |
| 37  |                   NESTED LOOPS                           |       |                       |      |      |       |        |
| 38  |                     SUBSELECT                            |       |                       |      |      |       |        |
| 39  |                       HASH DISTINCT                      |       |                       |      |      |       |        |
| 40  |                         NESTED LOOPS                     |       |                       |      |      |       |        |
| 41  |                           NESTED LOOPS                   |       |                       |      |      |       |        |
| 42  |                             TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 43  |                               INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 44  |                             TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 45  |                               INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 46  |                           TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 47  |                             ROWID SCAN                   |       |                       |      |      |       |        |
| 48  |                     TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 49  |                       INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 50  |               AGGR                                       |       |                       |      |      |       |        |
| 51  |                 NESTED LOOPS                             |       |                       |      |      |       |        |
| 52  |                   SUBSELECT                              |       |                       |      |      |       |        |
| 53  |                     HASH DISTINCT                        |       |                       |      |      |       |        |
| 54  |                       NESTED LOOPS                       |       |                       |      |      |       |        |
| 55  |                         NESTED LOOPS                     |       |                       |      |      |       |        |
| 56  |                           TABLE ACCESS BY INDEX ROWID    | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 57  |                             INDEX UNIQUE SCAN            | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 58  |                           TABLE ACCESS BY INDEX ONLY     | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 59  |                             INDEX RANGE SCAN             | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 60  |                         TABLE ACCESS BY ROWID            | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 61  |                           ROWID SCAN                     |       |                       |      |      |       |        |
| 62  |                   TABLE ACCESS BY INDEX ROWID            | SYS   | BMSQL_STOCK           |      |      |       |        |
| 63  |                     INDEX UNIQUE SCAN                    | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 64  |             AGGR                                         |       |                       |      |      |       |        |
| 65  |               NESTED LOOPS                               |       |                       |      |      |       |        |
| 66  |                 SUBSELECT                                |       |                       |      |      |       |        |
| 67  |                   HASH DISTINCT                          |       |                       |      |      |       |        |
| 68  |                     NESTED LOOPS                         |       |                       |      |      |       |        |
| 69  |                       NESTED LOOPS                       |       |                       |      |      |       |        |
| 70  |                         TABLE ACCESS BY INDEX ROWID      | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 71  |                           INDEX UNIQUE SCAN              | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 72  |                         TABLE ACCESS BY INDEX ONLY       | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 73  |                           INDEX RANGE SCAN               | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 74  |                       TABLE ACCESS BY ROWID              | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 75  |                         ROWID SCAN                       |       |                       |      |      |       |        |
| 76  |                 TABLE ACCESS BY INDEX ROWID              | SYS   | BMSQL_STOCK           |      |      |       |        |
| 77  |                   INDEX UNIQUE SCAN                      | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 78  |             AGGR                                         |       |                       |      |      |       |        |
| 79  |               NESTED LOOPS                               |       |                       |      |      |       |        |
| 80  |                 SUBSELECT                                |       |                       |      |      |       |        |
| 81  |                   HASH DISTINCT                          |       |                       |      |      |       |        |
| 82  |                     NESTED LOOPS                         |       |                       |      |      |       |        |
| 83  |                       NESTED LOOPS                       |       |                       |      |      |       |        |
| 84  |                         TABLE ACCESS BY INDEX ROWID      | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 85  |                           INDEX UNIQUE SCAN              | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 86  |                         TABLE ACCESS BY INDEX ONLY       | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 87  |                           INDEX RANGE SCAN               | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 88  |                       TABLE ACCESS BY ROWID              | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 89  |                         ROWID SCAN                       |       |                       |      |      |       |        |
| 90  |                 TABLE ACCESS BY INDEX ROWID              | SYS   | BMSQL_STOCK           |      |      |       |        |
| 91  |                   INDEX UNIQUE SCAN                      | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 92  |           AGGR                                           |       |                       |      |      |       |        |
| 93  |             NESTED LOOPS                                 |       |                       |      |      |       |        |
| 94  |               SUBSELECT                                  |       |                       |      |      |       |        |
| 95  |                 HASH DISTINCT                            |       |                       |      |      |       |        |
| 96  |                   NESTED LOOPS                           |       |                       |      |      |       |        |
| 97  |                     NESTED LOOPS                         |       |                       |      |      |       |        |
| 98  |                       TABLE ACCESS BY INDEX ROWID        | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 99  |                         INDEX UNIQUE SCAN                | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 100 |                       TABLE ACCESS BY INDEX ONLY         | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 101 |                         INDEX RANGE SCAN                 | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 102 |                     TABLE ACCESS BY ROWID                | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 103 |                       ROWID SCAN                         |       |                       |      |      |       |        |
| 104 |               TABLE ACCESS BY INDEX ROWID                | SYS   | BMSQL_STOCK           |      |      |       |        |
| 105 |                 INDEX UNIQUE SCAN                        | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 106 |         AGGR                                             |       |                       |      |      |       |        |
| 107 |           NESTED LOOPS                                   |       |                       |      |      |       |        |
| 108 |             SUBSELECT                                    |       |                       |      |      |       |        |
| 109 |               HASH DISTINCT                              |       |                       |      |      |       |        |
| 110 |                 NESTED LOOPS                             |       |                       |      |      |       |        |
| 111 |                   NESTED LOOPS                           |       |                       |      |      |       |        |
| 112 |                     TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 113 |                       INDEX UNIQUE SCAN                  | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 114 |                     TABLE ACCESS BY INDEX ONLY           | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 115 |                       INDEX RANGE SCAN                   | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 116 |                   TABLE ACCESS BY ROWID                  | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 117 |                     ROWID SCAN                           |       |                       |      |      |       |        |
| 118 |             TABLE ACCESS BY INDEX ROWID                  | SYS   | BMSQL_STOCK           |      |      |       |        |
| 119 |               INDEX UNIQUE SCAN                          | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   14 - filter: D_W_ID = D_ID                                   
   15 - access: D_W_ID = 2 AND D_ID = 2                         
   17 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   20 - filter: S_QUANTITY < 11                                 
   21 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   28 - filter: D_W_ID = D_ID                                   
   29 - access: D_W_ID = 2 AND D_ID = 2                         
   31 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   34 - filter: S_QUANTITY < 11                                 
   35 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   42 - filter: D_W_ID = D_ID                                   
   43 - access: D_W_ID = 2 AND D_ID = 2                         
   45 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   48 - filter: S_QUANTITY < 11                                 
   49 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   56 - filter: D_W_ID = D_ID                                   
   57 - access: D_W_ID = 2 AND D_ID = 2                         
   59 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   62 - filter: S_QUANTITY < 11                                 
   63 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   70 - filter: D_W_ID = D_ID                                   
   71 - access: D_W_ID = 2 AND D_ID = 2                         
   73 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   76 - filter: S_QUANTITY < 11                                 
   77 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   84 - filter: D_W_ID = D_ID                                   
   85 - access: D_W_ID = 2 AND D_ID = 2                         
   87 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   90 - filter: S_QUANTITY < 11                                 
   91 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   98 - filter: D_W_ID = D_ID                                   
   99 - access: D_W_ID = 2 AND D_ID = 2                         
   101 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   104 - filter: S_QUANTITY < 11                                
   105 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   112 - filter: D_W_ID = D_ID                                  
   113 - access: D_W_ID = 2 AND D_ID = 2                        
   115 - access: D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID AND OL_D_ID = D_ID AND OL_O_ID < D_NEXT_O_ID AND 
               OL_W_ID = D_ID AND D_W_ID = OL_W_ID AND OL_D_ID = 2 AND OL_W_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 
               20                                               
   118 - filter: S_QUANTITY < 11                                
   119 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID

182 rows fetched.

SQL> 
SQL> explain 
  2 insert into test_explain1(f1) 
  3 select count(*) from 
  4 (
  5 	SELECT count(*) AS low_stock FROM 
  6 	(
  7 		SELECT s_w_id, s_i_id, s_quantity 
  8 			FROM bmsql_stock
  9 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 10 				SELECT ol_i_id 
 11 					FROM bmsql_district 
 12 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 13 					 AND ol_d_id = d_id 
 14 					 AND ol_o_id >= d_next_o_id - 20 
 15 					 AND ol_o_id < d_next_o_id 
 16 					WHERE d_w_id = 2 AND d_id = 2 
 17 			) 
 18 	)
 19 	union all 
 20 	SELECT count(*) AS low_stock FROM 
 21 	(
 22 		SELECT s_w_id, s_i_id, s_quantity 
 23 			FROM bmsql_stock
 24 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 25 				SELECT ol_i_id 
 26 					FROM bmsql_district 
 27 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 28 					 AND ol_d_id = d_id 
 29 					 AND ol_o_id >= d_next_o_id - 20 
 30 					 AND ol_o_id < d_next_o_id 
 31 					WHERE d_w_id = 2 AND d_id = 2 
 32 			) 
 33 	)
 34 	union 
 35 	SELECT count(*) AS low_stock FROM 
 36 	(
 37 		SELECT s_w_id, s_i_id, s_quantity 
 38 			FROM bmsql_stock
 39 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 40 				SELECT ol_i_id 
 41 					FROM bmsql_district 
 42 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 43 					 AND ol_d_id = d_id 
 44 					 AND ol_o_id >= d_next_o_id - 20 
 45 					 AND ol_o_id < d_next_o_id 
 46 					WHERE d_w_id = 2 AND d_id = 2 
 47 			) 
 48 	)
 49 	minus 	
 50 	SELECT count(*) AS low_stock FROM 
 51 	(
 52 		SELECT s_w_id, s_i_id, s_quantity 
 53 			FROM bmsql_stock
 54 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 55 				SELECT ol_i_id 
 56 					FROM bmsql_district 
 57 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 58 					 AND ol_d_id = d_id 
 59 					 AND ol_o_id >= d_next_o_id - 20 
 60 					 AND ol_o_id < d_next_o_id 
 61 					WHERE d_w_id = 2 AND d_id = 2 
 62 			) 
 63 	)
 64 	union 
 65 	SELECT count(*) AS low_stock FROM 
 66 	(
 67 		SELECT s_w_id, s_i_id, s_quantity 
 68 			FROM bmsql_stock
 69 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 70 				SELECT ol_i_id 
 71 					FROM bmsql_district 
 72 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 73 					 AND ol_d_id = d_id 
 74 					 AND ol_o_id >= d_next_o_id - 20 
 75 					 AND ol_o_id < d_next_o_id 
 76 					WHERE d_w_id = 2 AND d_id = 2 
 77 			) 
 78 	)
 79 	union all 
 80 	SELECT count(*) AS low_stock FROM 
 81 	(
 82 		SELECT s_w_id, s_i_id, s_quantity 
 83 			FROM bmsql_stock
 84 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
 85 				SELECT ol_i_id 
 86 					FROM bmsql_district 
 87 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
 88 					 AND ol_d_id = d_id 
 89 					 AND ol_o_id >= d_next_o_id - 20 
 90 					 AND ol_o_id < d_next_o_id 
 91 					WHERE d_w_id = 2 AND d_id = 2 
 92 			) 
 93 	)
 94 	union 
 95 	SELECT count(*) AS low_stock FROM 
 96 	(
 97 		SELECT s_w_id, s_i_id, s_quantity 
 98 			FROM bmsql_stock
 99 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
100 				SELECT ol_i_id 
101 					FROM bmsql_district 
102 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
103 					 AND ol_d_id = d_id 
104 					 AND ol_o_id >= d_next_o_id - 20 
105 					 AND ol_o_id < d_next_o_id 
106 					WHERE d_w_id = 2 AND d_id = 2 
107 			) 
108 	)
109 	minus 	
110 	SELECT count(*) AS low_stock FROM 
111 	(
112 		SELECT s_w_id, s_i_id, s_quantity 
113 			FROM bmsql_stock
114 			WHERE s_w_id = 2 AND s_quantity < 11 AND s_i_id IN (
115 				SELECT ol_i_id 
116 					FROM bmsql_district 
117 					JOIN bmsql_order_line ON ol_w_id = d_w_id 
118 					 AND ol_d_id = d_id 
119 					 AND ol_o_id >= d_next_o_id - 20 
120 					 AND ol_o_id < d_next_o_id 
121 					WHERE d_w_id = 2 AND d_id = 2 
122 			) 
123 	)
124 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                                  | Owner | Name                  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                                             |       |                       |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL                                    | SYS   | TEST_EXPLAIN1         |      |      |       |        |
| 2   |     SUBSELECT                                                |       |                       |      |      |       |        |
| 3   |       AGGR                                                   |       |                       |      |      |       |        |
| 4   |         SUBSELECT                                            |       |                       |      |      |       |        |
| 5   |           HASH MINUS                                         |       |                       |      |      |       |        |
| 6   |             HASH UNION                                       |       |                       |      |      |       |        |
| 7   |               UNION ALL                                      |       |                       |      |      |       |        |
| 8   |                 HASH MINUS                                   |       |                       |      |      |       |        |
| 9   |                   UNION ALL                                  |       |                       |      |      |       |        |
| 10  |                     AGGR                                     |       |                       |      |      |       |        |
| 11  |                       NESTED LOOPS                           |       |                       |      |      |       |        |
| 12  |                         SUBSELECT                            |       |                       |      |      |       |        |
| 13  |                           HASH DISTINCT                      |       |                       |      |      |       |        |
| 14  |                             NESTED LOOPS                     |       |                       |      |      |       |        |
| 15  |                               NESTED LOOPS                   |       |                       |      |      |       |        |
| 16  |                                 TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 17  |                                   INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 18  |                                 TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 19  |                                   INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 20  |                               TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 21  |                                 ROWID SCAN                   |       |                       |      |      |       |        |
| 22  |                         TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 23  |                           INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 24  |                     AGGR                                     |       |                       |      |      |       |        |
| 25  |                       NESTED LOOPS                           |       |                       |      |      |       |        |
| 26  |                         SUBSELECT                            |       |                       |      |      |       |        |
| 27  |                           HASH DISTINCT                      |       |                       |      |      |       |        |
| 28  |                             NESTED LOOPS                     |       |                       |      |      |       |        |
| 29  |                               NESTED LOOPS                   |       |                       |      |      |       |        |
| 30  |                                 TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 31  |                                   INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 32  |                                 TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 33  |                                   INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 34  |                               TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 35  |                                 ROWID SCAN                   |       |                       |      |      |       |        |
| 36  |                         TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 37  |                           INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 38  |                     AGGR                                     |       |                       |      |      |       |        |
| 39  |                       NESTED LOOPS                           |       |                       |      |      |       |        |
| 40  |                         SUBSELECT                            |       |                       |      |      |       |        |
| 41  |                           HASH DISTINCT                      |       |                       |      |      |       |        |
| 42  |                             NESTED LOOPS                     |       |                       |      |      |       |        |
| 43  |                               NESTED LOOPS                   |       |                       |      |      |       |        |
| 44  |                                 TABLE ACCESS BY INDEX ROWID  | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 45  |                                   INDEX UNIQUE SCAN          | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 46  |                                 TABLE ACCESS BY INDEX ONLY   | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 47  |                                   INDEX RANGE SCAN           | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 48  |                               TABLE ACCESS BY ROWID          | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 49  |                                 ROWID SCAN                   |       |                       |      |      |       |        |
| 50  |                         TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_STOCK           |      |      |       |        |
| 51  |                           INDEX UNIQUE SCAN                  | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 52  |                   AGGR                                       |       |                       |      |      |       |        |
| 53  |                     NESTED LOOPS                             |       |                       |      |      |       |        |
| 54  |                       SUBSELECT                              |       |                       |      |      |       |        |
| 55  |                         HASH DISTINCT                        |       |                       |      |      |       |        |
| 56  |                           NESTED LOOPS                       |       |                       |      |      |       |        |
| 57  |                             NESTED LOOPS                     |       |                       |      |      |       |        |
| 58  |                               TABLE ACCESS BY INDEX ROWID    | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 59  |                                 INDEX UNIQUE SCAN            | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 60  |                               TABLE ACCESS BY INDEX ONLY     | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 61  |                                 INDEX RANGE SCAN             | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 62  |                             TABLE ACCESS BY ROWID            | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 63  |                               ROWID SCAN                     |       |                       |      |      |       |        |
| 64  |                       TABLE ACCESS BY INDEX ROWID            | SYS   | BMSQL_STOCK           |      |      |       |        |
| 65  |                         INDEX UNIQUE SCAN                    | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 66  |                 AGGR                                         |       |                       |      |      |       |        |
| 67  |                   NESTED LOOPS                               |       |                       |      |      |       |        |
| 68  |                     SUBSELECT                                |       |                       |      |      |       |        |
| 69  |                       HASH DISTINCT                          |       |                       |      |      |       |        |
| 70  |                         NESTED LOOPS                         |       |                       |      |      |       |        |
| 71  |                           NESTED LOOPS                       |       |                       |      |      |       |        |
| 72  |                             TABLE ACCESS BY INDEX ROWID      | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 73  |                               INDEX UNIQUE SCAN              | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 74  |                             TABLE ACCESS BY INDEX ONLY       | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 75  |                               INDEX RANGE SCAN               | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 76  |                           TABLE ACCESS BY ROWID              | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 77  |                             ROWID SCAN                       |       |                       |      |      |       |        |
| 78  |                     TABLE ACCESS BY INDEX ROWID              | SYS   | BMSQL_STOCK           |      |      |       |        |
| 79  |                       INDEX UNIQUE SCAN                      | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 80  |                 AGGR                                         |       |                       |      |      |       |        |
| 81  |                   NESTED LOOPS                               |       |                       |      |      |       |        |
| 82  |                     SUBSELECT                                |       |                       |      |      |       |        |
| 83  |                       HASH DISTINCT                          |       |                       |      |      |       |        |
| 84  |                         NESTED LOOPS                         |       |                       |      |      |       |        |
| 85  |                           NESTED LOOPS                       |       |                       |      |      |       |        |
| 86  |                             TABLE ACCESS BY INDEX ROWID      | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 87  |                               INDEX UNIQUE SCAN              | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 88  |                             TABLE ACCESS BY INDEX ONLY       | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 89  |                               INDEX RANGE SCAN               | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 90  |                           TABLE ACCESS BY ROWID              | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 91  |                             ROWID SCAN                       |       |                       |      |      |       |        |
| 92  |                     TABLE ACCESS BY INDEX ROWID              | SYS   | BMSQL_STOCK           |      |      |       |        |
| 93  |                       INDEX UNIQUE SCAN                      | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 94  |               AGGR                                           |       |                       |      |      |       |        |
| 95  |                 NESTED LOOPS                                 |       |                       |      |      |       |        |
| 96  |                   SUBSELECT                                  |       |                       |      |      |       |        |
| 97  |                     HASH DISTINCT                            |       |                       |      |      |       |        |
| 98  |                       NESTED LOOPS                           |       |                       |      |      |       |        |
| 99  |                         NESTED LOOPS                         |       |                       |      |      |       |        |
| 100 |                           TABLE ACCESS BY INDEX ROWID        | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 101 |                             INDEX UNIQUE SCAN                | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 102 |                           TABLE ACCESS BY INDEX ONLY         | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 103 |                             INDEX RANGE SCAN                 | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 104 |                         TABLE ACCESS BY ROWID                | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 105 |                           ROWID SCAN                         |       |                       |      |      |       |        |
| 106 |                   TABLE ACCESS BY INDEX ROWID                | SYS   | BMSQL_STOCK           |      |      |       |        |
| 107 |                     INDEX UNIQUE SCAN                        | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
| 108 |             AGGR                                             |       |                       |      |      |       |        |
| 109 |               NESTED LOOPS                                   |       |                       |      |      |       |        |
| 110 |                 SUBSELECT                                    |       |                       |      |      |       |        |
| 111 |                   HASH DISTINCT                              |       |                       |      |      |       |        |
| 112 |                     NESTED LOOPS                             |       |                       |      |      |       |        |
| 113 |                       NESTED LOOPS                           |       |                       |      |      |       |        |
| 114 |                         TABLE ACCESS BY INDEX ROWID          | SYS   | BMSQL_DISTRICT        |      |      |       |        |
| 115 |                           INDEX UNIQUE SCAN                  | SYS   | BMSQL_DISTRICT_PKEY   |      |      |       |        |
| 116 |                         TABLE ACCESS BY INDEX ONLY           | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 117 |                           INDEX RANGE SCAN                   | SYS   | BMSQL_ORDER_LINE_PKEY |      |      |       |        |
| 118 |                       TABLE ACCESS BY ROWID                  | SYS   | BMSQL_ORDER_LINE      |      |      |       |        |
| 119 |                         ROWID SCAN                           |       |                       |      |      |       |        |
| 120 |                 TABLE ACCESS BY INDEX ROWID                  | SYS   | BMSQL_STOCK           |      |      |       |        |
| 121 |                   INDEX UNIQUE SCAN                          | SYS   | BMSQL_STOCK_PKEY      |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   17 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   19 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   22 - filter: S_QUANTITY < 11                                 
   23 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   31 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   33 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   36 - filter: S_QUANTITY < 11                                 
   37 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   45 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   47 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   50 - filter: S_QUANTITY < 11                                 
   51 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   59 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   61 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   64 - filter: S_QUANTITY < 11                                 
   65 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   73 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   75 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   78 - filter: S_QUANTITY < 11                                 
   79 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   87 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID       
   89 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   92 - filter: S_QUANTITY < 11                                 
   93 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   101 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID      
   103 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   106 - filter: S_QUANTITY < 11                                
   107 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID
   115 - access: D_W_ID = 2 AND D_ID = 2 AND D_W_ID = D_ID      
   117 - access: OL_D_ID = 2 AND OL_O_ID >= D_NEXT_O_ID - 20 AND D_W_ID = OL_W_ID AND OL_D_ID = D_ID AND 
               OL_W_ID = 2 AND OL_O_ID < D_NEXT_O_ID AND OL_W_ID = D_ID AND D_W_ID = OL_D_ID AND OL_D_ID = OL_W_ID
   120 - filter: S_QUANTITY < 11                                
   121 - access: S_W_ID = 2 AND S_I_ID = BMSQL_ORDER_LINE.OL_I_ID

168 rows fetched.

SQL> 
SQL> drop table if exists explain_t1;

Succeed.

SQL> drop table if exists explain_t2;

Succeed.

SQL> drop table if exists explain_t3;

Succeed.

SQL> create table explain_t1(a int, b int);

Succeed.

SQL> create table explain_t2(f1 int, f2 int);

Succeed.

SQL> create table explain_t3(f3 int, f4 int);

Succeed.

SQL> explain plan for select a from explain_t1 where a in (select f1 from explain_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |            |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |            |      |      |       |        |
| 2   |     SUBSELECT            |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: EXPLAIN_T2.F1 = A                                

12 rows fetched.

SQL> explain plan for select a from explain_t1 where a not in (select f1 from explain_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |            |      |      |       |        |
| 1   |   HASH JOIN ANTI NA(R)   |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     SUBSELECT            |       |            |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A = F1                                           

12 rows fetched.

SQL> explain plan for select * from explain_t1 where exists(select f1 from explain_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |            |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)      |       |            |      |      |       |        |
| 2   |     SUBSELECT            |       |            |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: NA = NA                                          

12 rows fetched.

SQL> explain plan for select a from explain_t1 where exists(select * from explain_t2) group by a having a in (select f3 from explain_t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |            |      |      |       |        |
| 1   |   HAVING                     |       |            |      |      |       |        |
| 2   |     HASH GROUP BY            |       |            |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |            |      |      |       |        |
| 4   |         SUBSELECT            |       |            |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
| 7   |   TABLE ACCESS FULL          | SYS   | EXPLAIN_T3 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: A IN((SELECT F3 FROM EXPLAIN_T3))                
   3 - access: NA = NA                                          

16 rows fetched.

SQL> explain plan for select * from (select a from explain_t1 where b=(select f1 from explain_t2));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = (SELECT F1 FROM EXPLAIN_T2)                  

11 rows fetched.

SQL> explain plan for select a from explain_t1 where b=(select f1 from explain_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = (SELECT F1 FROM EXPLAIN_T2)                  

11 rows fetched.

SQL> explain plan for select a from explain_t1 where (select f1 from explain_t2)=b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: (SELECT F1 FROM EXPLAIN_T2) = B                  

11 rows fetched.

SQL> explain plan for select * from explain_t1 where exists(select f1 from explain_t2 GROUP BY f1 HAVING f1 IN (select f3 from explain_t3));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |            |      |      |       |        |
| 1   |   HASH JOIN SEMI(L)          |       |            |      |      |       |        |
| 2   |     SUBSELECT                |       |            |      |      |       |        |
| 3   |       HAVING                 |       |            |      |      |       |        |
| 4   |         HASH GROUP BY        |       |            |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 6   |       TABLE ACCESS FULL      | SYS   | EXPLAIN_T3 |      |      |       |        |
| 7   |     TABLE ACCESS FULL        | SYS   | EXPLAIN_T1 |      |      |       |        |
------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: NA = NA                                          
   3 - filter: F1 IN((SELECT F3 FROM EXPLAIN_T3))               

16 rows fetched.

SQL> explain plan for  select * from explain_t1 where A = 1 + (select f1 from explain_t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: A = 1 + (SELECT F1 FROM EXPLAIN_T2)              

11 rows fetched.

SQL> explain plan for select t.a, (select f1 from explain_t2) from explain_t1 t;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |              |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T2   |      |      |       |        |
| 2   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 T |      |      |       |        |
------------------------------------------------------------------------------------

7 rows fetched.

SQL> explain plan for select t.a, (case when exists(select f1 from explain_t2 where f1 = 1) then 1 end) from explain_t1 t;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |              |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T2   |      |      |       |        |
| 2   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 T |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: F1 = 1                                           

10 rows fetched.

SQL> explain plan for select t.a  from explain_t1 t where t.b = (case when exists(select f1 from explain_t2 where f1 = 1) then 1 end);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |              |      |      |       |        |
| 1   |   KERNEL FILTER        |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 T |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2   |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T.B = CASE  WHEN EXISTS(SELECT 1 FROM EXPLAIN_T2 WHERE F1 = 1) THEN 1 END
   3 - filter: F1 = 1                                           

12 rows fetched.

SQL> explain plan for select t.a  from explain_t1 t where t.a = (select f1 from explain_t2) - 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |              |      |      |       |        |
| 1   |   KERNEL FILTER        |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 T |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2   |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T.A = (SELECT F1 FROM EXPLAIN_T2) - 1            

11 rows fetched.

SQL> explain plan for select t.a  from explain_t1 t where t.a = (select f1 from explain_t2 where f2 = (select f3 from explain_t3)) + 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |              |      |      |       |        |
| 1   |   KERNEL FILTER          |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 T |      |      |       |        |
| 3   |     KERNEL FILTER        |       |              |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2   |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T3   |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T.A = (SELECT F1 FROM EXPLAIN_T2 WHERE F2 = (SELECT F3 FROM EXPLAIN_T3)) + 1
   4 - filter: F2 = (SELECT F3 FROM EXPLAIN_T3)                 

14 rows fetched.

SQL> explain plan for delete from explain_t1 where a = (select f1 from explain_t2 where f1 = (select f3 from explain_t3));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT         |       |            |      |      |       |        |
| 1   |   KERNEL FILTER          |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     KERNEL FILTER        |       |            |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: A = (SELECT F1 FROM EXPLAIN_T2 WHERE F1 = (SELECT F3 FROM EXPLAIN_T3))
   4 - filter: F1 = (SELECT F3 FROM EXPLAIN_T3)                 

14 rows fetched.

SQL> explain plan for update explain_t1 set a = 1 where b = (select f1 from explain_t2 where f1 = (select f3 from explain_t3));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT         |       |            |      |      |       |        |
| 1   |   KERNEL FILTER          |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     KERNEL FILTER        |       |            |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 5   |       TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
--------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = (SELECT F1 FROM EXPLAIN_T2 WHERE F1 = (SELECT F3 FROM EXPLAIN_T3))
   4 - filter: F1 = (SELECT F3 FROM EXPLAIN_T3)                 

14 rows fetched.

SQL> explain plan for update explain_t1 set a = 1 where b = (select f1 from explain_t2 where f1 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = (SELECT F1 FROM EXPLAIN_T2 WHERE F1 = 1)     
   3 - filter: F1 = 1                                           

12 rows fetched.

SQL> explain plan for update explain_t1 set a = (select f3 from explain_t3) where b = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------
| Id  | Description          | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT     |       |            |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 2   |   TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: B = 1                                            

10 rows fetched.

SQL> explain plan for update explain_t1 set a = (select f3 from explain_t3) where b = (select f1 from explain_t2 where f1 = 1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT       |       |            |      |      |       |        |
| 1   |   KERNEL FILTER        |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 4   |   TABLE ACCESS FULL    | SYS   | EXPLAIN_T3 |      |      |       |        |
------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: B = (SELECT F1 FROM EXPLAIN_T2 WHERE F1 = 1)     
   3 - filter: F1 = 1                                           

13 rows fetched.

SQL> explain plan for merge into explain_t1 using (select * from explain_t2 where f1 = (select f3 from explain_t3)) tt2 on (explain_t1.a = tt2.f1) 
  2 when matched then update set b = tt2.f2 + 1 where tt2.f2 = 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | MERGE STATEMENT(HASH JOIN) |       |            |      |      |       |        |
| 1   |   USING TABLE              |       |            |      |      |       |        |
| 2   |     SUBSELECT              |       | TT2        |      |      |       |        |
| 3   |       KERNEL FILTER        |       |            |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
| 6   |   MERGE TABLE              |       |            |      |      |       |        |
| 7   |     TABLE ACCESS FULL      | SYS   | EXPLAIN_T1 |      |      |       |        |
| 8   |   ON CONDITION             |       |            |      |      |       |        |
| 9   |     FILTER                 |       |            |      |      |       |        |
| 10  |       UPDATE STATEMENT     |       |            |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: F1 = (SELECT F3 FROM EXPLAIN_T3)                 
   8 - access: EXPLAIN_T1.A = TT2.F1                            
   9 - filter: TT2.F2 = 2                                       

20 rows fetched.

SQL> EXPLAIN PLAN FOR MERGE INTO explain_t1 USING explain_t2 ON (explain_t1.a = explain_t2.f1)
  2 WHEN MATCHED THEN UPDATE SET b = (select f1 from explain_t1) WHERE explain_t2.f2 = (select f3 from explain_t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | MERGE STATEMENT(HASH JOIN) |       |            |      |      |       |        |
| 1   |   USING TABLE              |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL      | SYS   | EXPLAIN_T2 |      |      |       |        |
| 3   |   MERGE TABLE              |       |            |      |      |       |        |
| 4   |     TABLE ACCESS FULL      | SYS   | EXPLAIN_T1 |      |      |       |        |
| 5   |   ON CONDITION             |       |            |      |      |       |        |
| 6   |     FILTER                 |       |            |      |      |       |        |
| 7   |       UPDATE STATEMENT     |       |            |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T1 |      |      |       |        |
| 9   |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: EXPLAIN_T1.A = EXPLAIN_T2.F1                     
   6 - filter: EXPLAIN_T2.F2 = (SELECT F3 FROM EXPLAIN_T3)      

18 rows fetched.

SQL> explain plan for merge into explain_t1 using explain_t2 on (explain_t1.a = explain_t2.f1)
  2 when matched then update set b = (select f1 from explain_t2) where explain_t2.f2 = (select f3 from explain_t3)
  3 when not matched then insert (a, b) values (explain_t2.f1, explain_t2.f1) where explain_t2.f1 = (select f3 from explain_t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name       | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | MERGE STATEMENT(HASH JOIN) |       |            |      |      |       |        |
| 1   |   USING TABLE              |       |            |      |      |       |        |
| 2   |     TABLE ACCESS FULL      | SYS   | EXPLAIN_T2 |      |      |       |        |
| 3   |   MERGE TABLE              |       |            |      |      |       |        |
| 4   |     TABLE ACCESS FULL      | SYS   | EXPLAIN_T1 |      |      |       |        |
| 5   |   ON CONDITION             |       |            |      |      |       |        |
| 6   |     FILTER                 |       |            |      |      |       |        |
| 7   |       INSERT STATEMENT     |       |            |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
| 9   |     FILTER                 |       |            |      |      |       |        |
| 10  |       UPDATE STATEMENT     |       |            |      |      |       |        |
| 11  |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T2 |      |      |       |        |
| 12  |         TABLE ACCESS FULL  | SYS   | EXPLAIN_T3 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: EXPLAIN_T1.A = EXPLAIN_T2.F1                     
   6 - filter: EXPLAIN_T2.F1 = (SELECT F3 FROM EXPLAIN_T3)      
   9 - filter: EXPLAIN_T2.F2 = (SELECT F3 FROM EXPLAIN_T3)      

22 rows fetched.

SQL> 
SQL> EXPLAIN PLAN FOR
  2 SELECT I.NAME, M.USER_NAME, T.NAME, NULL::VARCHAR(64), NULL::NUMBER,
  3 'TABLE', I.BLEVEL, I.LEVEL_BLOCKS, I.DISTINCT_KEYS, I.AVG_LEAF_BLOCKS_PER_KEY, I.AVG_DATA_BLOCKS_PER_KEY,
  4 NULL::NUMBER, T.SAMPLESIZE, T.ANALYZETIME
  5 FROM SYS.V$ME M JOIN SYS.SYS_TABLES T ON T.USER# = M.USER_ID
  6 JOIN SYS.SYS_INDEXES I ON T.USER# = I.USER# AND T.ID = I.TABLE#
  7 UNION ALL
  8 SELECT IP.NAME, M.USER_NAME, T.NAME, TP.NAME,
  9 ROW_NUMBER() OVER (PARTITION BY TP.USER#, TP.TABLE# ORDER BY TP.PART#),
 10 'PARTITION', IP.BLEVEL, IP.LEVEL_BLOCKS, IP.DISTKEY, IP.LBLKKEY, IP.DBLKKEY,
 11 NULL::NUMBER, TP.SAMPLESIZE, TP.ANALYZETIME
 12 FROM SYS.V$ME M JOIN SYS.SYS_TABLES T ON T.USER# = M.USER_ID
 13 JOIN SYS.SYS_TABLE_PARTS TP ON T.USER# = TP.USER# AND T.ID = TP.TABLE#
 14 JOIN SYS.SYS_INDEX_PARTS IP ON TP.USER# = IP.USER# AND TP.TABLE# = IP.TABLE# AND TP.PART# = IP.PART#;

EXPLAIN PLAN OUTPUT
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                              | Owner | Name               | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                         |       |                    |      |      |       |        |
| 1   |   UNION ALL                              |       |                    |      |      |       |        |
| 2   |     NESTED LOOPS                         |       |                    |      |      |       |        |
| 3   |       NESTED LOOPS                       |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL                | SYS   | DV_ME              |      |      |       |        |
| 5   |         TABLE ACCESS BY INDEX ROWID      | SYS   | SYS_TABLES T       |      |      |       |        |
| 6   |           INDEX RANGE SCAN               | SYS   | IX_TABLE$001       |      |      |       |        |
| 7   |       TABLE ACCESS BY INDEX ROWID        | SYS   | SYS_INDEXES I      |      |      |       |        |
| 8   |         INDEX RANGE SCAN                 | SYS   | IX_INDEX$001       |      |      |       |        |
| 9   |     WINDOW SORT                          |       |                    |      |      |       |        |
| 10  |       NESTED LOOPS                       |       |                    |      |      |       |        |
| 11  |         NESTED LOOPS                     |       |                    |      |      |       |        |
| 12  |           NESTED LOOPS                   |       |                    |      |      |       |        |
| 13  |             VIEW                         | SYS   | V$ME M             |      |      |       |        |
| 14  |               TABLE ACCESS FULL          | SYS   | DV_ME              |      |      |       |        |
| 15  |             TABLE ACCESS BY INDEX ROWID  | SYS   | SYS_TABLES T       |      |      |       |        |
| 16  |               INDEX RANGE SCAN           | SYS   | IX_TABLE$001       |      |      |       |        |
| 17  |           TABLE ACCESS BY INDEX ROWID    | SYS   | SYS_TABLE_PARTS TP |      |      |       |        |
| 18  |             INDEX RANGE SCAN             | SYS   | IX_TABLEPART$001   |      |      |       |        |
| 19  |         TABLE ACCESS BY INDEX ROWID      | SYS   | SYS_INDEX_PARTS IP |      |      |       |        |
| 20  |           INDEX RANGE SCAN               | SYS   | IX_INDEXPART$001   |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - access: T.USER# = DV_ME.USER_ID                          
   8 - access: DV_ME.USER_ID = I.USER# AND T.ID = I.TABLE# AND T.USER# = I.USER#
   16 - access: T.USER# = M.USER_ID                             
   18 - access: T.USER# = TP.USER# AND TP.TABLE# = T.ID AND M.USER_ID = TP.USER#
   20 - access: IP.TABLE# = T.ID AND M.USER_ID = IP.USER# AND TP.PART# = IP.PART# AND T.USER# = IP.USER# AND 
               TP.USER# = IP.USER# AND TP.TABLE# = IP.TABLE#    

33 rows fetched.

SQL> EXPLAIN PLAN FOR
  2 SELECT U.NAME, T.NAME, C.NAME, ROW_NUMBER() OVER (PARTITION BY T.NAME, C.NAME ORDER BY H.BUCKET), H.ENDPOINT, H.BUCKET
  3 FROM SYS.SYS_USERS U JOIN SYS.SYS_TABLES T ON T.USER# = U.ID
  4 JOIN SYS.SYS_COLUMNS C ON T.USER# = C.USER# AND T.ID = C.TABLE#
  5 JOIN SYS.SYS_HISTGRAM H ON C.USER# = H.USER# AND C.TABLE# = H.TABLE# AND C.ID = H.COL#;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name           | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                |      |      |       |        |
| 1   |   WINDOW SORT                          |       |                |      |      |       |        |
| 2   |     NESTED LOOPS                       |       |                |      |      |       |        |
| 3   |       NESTED LOOPS                     |       |                |      |      |       |        |
| 4   |         NESTED LOOPS                   |       |                |      |      |       |        |
| 5   |           TABLE ACCESS FULL            | SYS   | SYS_USERS U    |      |      |       |        |
| 6   |           TABLE ACCESS BY INDEX ROWID  | SYS   | SYS_TABLES T   |      |      |       |        |
| 7   |             INDEX RANGE SCAN           | SYS   | IX_TABLE$001   |      |      |       |        |
| 8   |         TABLE ACCESS BY INDEX ROWID    | SYS   | SYS_COLUMNS C  |      |      |       |        |
| 9   |           INDEX RANGE SCAN             | SYS   | IX_COLUMN$001  |      |      |       |        |
| 10  |       TABLE ACCESS BY INDEX ROWID      | SYS   | SYS_HISTGRAM H |      |      |       |        |
| 11  |         INDEX RANGE SCAN               | SYS   | IX_HIST_003    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - access: T.USER# = U.ID                                   
   9 - access: T.USER# = C.USER# AND C.TABLE# = T.ID AND U.ID = C.USER#
   11 - access: T.USER# = H.USER# AND C.USER# = H.USER# AND H.TABLE# = T.ID AND C.ID = H.COL# AND U.ID = H.USER# AND 
               C.TABLE# = H.TABLE#                              

22 rows fetched.

SQL> 
SQL> drop table if exists WF_T_TASKTALK;

Succeed.

SQL> drop table if exists WF_T_PROCESSINSTANCE;

Succeed.

SQL> drop table if exists tm_t_jhseattrack;

Succeed.

SQL> drop table if exists TM_T_JHSEATTRACK_TELESALE;

Succeed.

SQL> create table WF_T_TASKTALK
  2 (
  3   talkid            VARCHAR2(30) not null,
  4   taskid            VARCHAR2(30),
  5   activityid        VARCHAR2(30),
  6   nodeid            VARCHAR2(30),
  7   comid             VARCHAR2(8) not null,
  8   inserttimeforhis  DATE,
  9   operatetimeforhis DATE,
 10   updatercode       VARCHAR2(20),
 11   comcode           VARCHAR2(8),
 12   contactid         VARCHAR2(50),
 13   clienttype        VARCHAR2(10) default '-1',
 14   processid         VARCHAR2(30),
 15   piid              VARCHAR2(30)
 16 );

Succeed.

SQL> create index IDX_TASKTALK_ACTIVITYID on WF_T_TASKTALK (ACTIVITYID);

Succeed.

SQL> create index IDX_TASKTALK_PIID on WF_T_TASKTALK (PIID);

Succeed.

SQL> create index IDX_TASKTALK_PROCESSID on WF_T_TASKTALK (PROCESSID);

Succeed.

SQL> create index IDX_TASKTALK_TASKID on WF_T_TASKTALK (TASKID);

Succeed.

SQL> alter table WF_T_TASKTALK add constraint PK_WF_T_TASKTALK primary key (TALKID, COMID) using index pctfree 10;

Succeed.

SQL> 
SQL> create table WF_T_PROCESSINSTANCE
  2 (
  3   piid                  VARCHAR2(30) not null,
  4   processid             VARCHAR2(30),
  5   activityid            VARCHAR2(30),
  6   validstatus           VARCHAR2(10),
  7   finishstatus          VARCHAR2(10),
  8   closestatus           VARCHAR2(10),
  9   inserttimeforhis      DATE,
 10   starttime             DATE,
 11   endtime               DATE,
 12   creatorcode           VARCHAR2(30),
 13   updatercode           VARCHAR2(30),
 14   updatetimeforhis      DATE,
 15   comid                 VARCHAR2(8),
 16   comcode               VARCHAR2(8),
 17   nextoperatorcode      VARCHAR2(30),
 18   tasktargetid          VARCHAR2(30),
 19   tasktargettype        VARCHAR2(10),
 20   activitybatch         NUMBER,
 21   batchtime             DATE,
 22   title                 VARCHAR2(100),
 23   assignstatus          VARCHAR2(2),
 24   claimstatus           VARCHAR2(2),
 25   custid                VARCHAR2(30),
 26   currentoperatorcode   VARCHAR2(30),
 27   tasktracestatusreason VARCHAR2(200),
 28   tasktracestatus       VARCHAR2(20),
 29   operatetimeforhis     DATE,
 30   customercname         VARCHAR2(200),
 31   statustype            VARCHAR2(2),
 32   licenseno             VARCHAR2(40),
 33   carid                 VARCHAR2(30),
 34   policyno              VARCHAR2(30),
 35   enddate               DATE,
 36   monthday              VARCHAR2(8),
 37   carstatus             VARCHAR2(2),
 38   managername           VARCHAR2(300),
 39   enrolldate            DATE,
 40   policycomcode         VARCHAR2(24),
 41   monopolycode          VARCHAR2(40),
 42   uniqassist            VARCHAR2(30),
 43   reservationstatus     VARCHAR2(1),
 44   lastestcontacttime    DATE,
 45   lastestremarktime     DATE
 46 );

Succeed.

SQL> create index IDX_PROCESSINSTANCE_ACTIV7 on WF_T_PROCESSINSTANCE (ACTIVITYID);

Succeed.

SQL> create index IDX_PROCESSINSTANCE_CUSTID7 on WF_T_PROCESSINSTANCE (CUSTID);

Succeed.

SQL> create index IDX_PROCESSINSTANCE_PROCID7 on WF_T_PROCESSINSTANCE (PROCESSID);

Succeed.

SQL> create index IDX_PROCESSINST_NEXTOPR7 on WF_T_PROCESSINSTANCE (NEXTOPERATORCODE);

Succeed.

SQL> create index IDX_PROCESSINST_TATID7 on WF_T_PROCESSINSTANCE (TASKTARGETID);

Succeed.

SQL> create index IDX_PROCESSINST_TRACESTATUS7 on WF_T_PROCESSINSTANCE (TASKTRACESTATUS);

Succeed.

SQL> create index IDX_PROCESSINST_UPDATER7 on WF_T_PROCESSINSTANCE (UPDATERCODE);

Succeed.

SQL> create unique index IDX_UNIQ_PROCESSINSTANCE7 on WF_T_PROCESSINSTANCE (TASKTARGETID, ACTIVITYID, UNIQASSIST, COMID);

Succeed.

SQL> alter table WF_T_PROCESSINSTANCE add constraint PK_WF_T_PROCESSINSTANCE_7 primary key (PIID) using index  pctfree 10;

Succeed.

SQL> 
SQL> create table tm_t_jhseattrack 
  2 (
  3   calltrackid       VARCHAR2(30) not null,
  4   miscallid         VARCHAR2(30),
  5   ucid              VARCHAR2(309),
  6   recordid          VARCHAR2(200),
  7   starttime         DATE,
  8   endtime           DATE,
  9   operatorcode      VARCHAR2(50),
 10   intervaltime      NUMBER,
 11   type              VARCHAR2(1),
 12   seattelephone     VARCHAR2(30),
 13   custtelephone     VARCHAR2(30),
 14   qualityflag       VARCHAR2(2),
 15   validstatus       VARCHAR2(1),
 16   comid             VARCHAR2(8) not null,
 17   creatorcode       VARCHAR2(50),
 18   inserttimeforhis  DATE,
 19   updatercode       VARCHAR2(50),
 20   operatetimeforhis DATE,
 21   recordobtainflag  VARCHAR2(1),
 22   suppliercode      VARCHAR2(10),
 23   comcode           VARCHAR2(10),
 24   usercode          VARCHAR2(50),
 25   longdistanceflag  VARCHAR2(1),
 26   source            VARCHAR2(1),
 27   seatcode          VARCHAR2(30),
 28   ringtime          DATE,
 29   callresult        VARCHAR2(8),
 30   exeremk           VARCHAR2(100), -- 
 31   customercname     VARCHAR2(200),   
 32   licenseno         VARCHAR2(40),  
 33   enddate           DATE,
 34   taskid            VARCHAR2(30),
 35   activityid        VARCHAR2(30),
 36   nodeid            VARCHAR2(30),
 37   clienttype        VARCHAR2(10) default '-1',
 38   processid         VARCHAR2(30),
 39   piid              VARCHAR2(30),
 40   tradeStatus       VARCHAR2(20),
 41   tradeStatusReason VARCHAR2(50)
 42 );

Succeed.

SQL> 
SQL> create table TM_T_JHSEATTRACK_TELESALE
  2 (
  3   calltrackid VARCHAR2(30) not null,
  4   comid varchar(30)
  5 );

Succeed.

SQL> 
SQL> alter table TM_T_JHSEATTRACK_TELESALE add constraint PK_TM_T_JHSEATTRACKTELESALE primary key (CALLTRACKID) using index pctfree 10 initrans 2;

Succeed.

SQL> 
SQL> explain update tm_t_jhseattrack a
  2    set (a.customercname,
  3         a.licenseno,
  4         a.enddate,
  5         a.taskid,
  6         a.activityid,
  7         a.nodeid,
  8         a.clienttype,
  9         a.processid,
 10         a.piid) =
 11        (select c.customercname,
 12                c.licenseno,
 13                c.enddate,
 14                x.taskid,
 15                x.activityid,
 16                x.nodeid,
 17                x.clienttype,
 18                x.processid,
 19                x.piid
 20           from wf_t_tasktalk x, wf_t_processinstance c
 21          where a.calltrackid = x.talkid
 22            and c.piid = x.piid
 23            and c.comid = x.comid);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name                      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | UPDATE STATEMENT                     |       |                           |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |                           |      |      |       |        |
| 2   |     TABLE ACCESS FULL                | SYS   | TM_T_JHSEATTRACK A        |      |      |       |        |
| 3   |     SUBSELECT                        |       |                           |      |      |       |        |
| 4   |       NESTED LOOPS                   |       |                           |      |      |       |        |
| 5   |         TABLE ACCESS FULL            | SYS   | WF_T_TASKTALK X           |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | WF_T_PROCESSINSTANCE C    |      |      |       |        |
| 7   |           INDEX UNIQUE SCAN          | SYS   | PK_WF_T_PROCESSINSTANCE_7 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.CALLTRACKID = X.TALKID                         
   6 - filter: C.COMID = X.COMID                                
   7 - access: C.PIID = X.PIID                                  

17 rows fetched.

SQL> 
SQL> explain insert into tm_t_jhseattrack_telesale(calltrackid,comid) values((select t.calltrackid from tm_t_jhseattrack t where t.calltrackid='#{calltrackid}' and t.starttime<t.endtime and not exists(select 1 from tm_t_jhseattrack_telesale ts where ts.calltrackid='#{calltrackid}')),'#{comid}');

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------
| Id  | Description                       | Owner | Name                         | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                  |       |                              |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL         | SYS   | TM_T_JHSEATTRACK_TELESALE    |      |      |       |        |
| 2   |     KERNEL FILTER                 |       |                              |      |      |       |        |
| 3   |       TABLE ACCESS FULL           | SYS   | TM_T_JHSEATTRACK T           |      |      |       |        |
| 4   |       TABLE ACCESS BY INDEX ONLY  | SYS   | TM_T_JHSEATTRACK_TELESALE TS |      |      |       |        |
| 5   |         INDEX UNIQUE SCAN         | SYS   | PK_TM_T_JHSEATTRACKTELESALE  |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: T.CALLTRACKID = '#{calltrackid}' AND NOT EXISTS(SELECT 1 FROM TM_T_JHSEATTRACK_TELESALE TS WHERE TS.CALLTRACKID = '#{calltrackid}') AND 
               T.STARTTIME < T.ENDTIME                          
   5 - access: TS.CALLTRACKID = '#{calltrackid}'                

15 rows fetched.

SQL> 
SQL> --INDEX UNIQUE SCAN
SQL> drop table if exists test_index_scan;

Succeed.

SQL> create table test_index_scan(id int not null,c_int int,c_varchar varchar(20));

Succeed.

SQL> alter table test_index_scan add constraint ind_001 primary key(c_int);

Succeed.

SQL> explain select * from test_index_scan where c_int = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | TEST_INDEX_SCAN |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN          | SYS   | IND_001         |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = 1                                        

10 rows fetched.

SQL> 
SQL> drop table if exists um_t_user;

Succeed.

SQL> drop table if exists um_t_teamuser;

Succeed.

SQL> 
SQL> create table um_t_user(usercode int, username varchar(64));

Succeed.

SQL> create table um_t_teamuser(usercode int, username varchar(64));

Succeed.

SQL> explain select * from um_t_user u left join um_t_teamuser tu on tu.usercode = u.usercode where u.usercode = '111' and (u.usercode = '222' or (1 = 0));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                  |      |      |       |        |
| 1   |   ROWNUM COUNT           |       |                  |      |      |       |        |
| 2   |     HASH JOIN OUTER(R)   |       |                  |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | UM_T_USER U      |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | UM_T_TEAMUSER TU |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NULL IS NOT NULL                                 
   2 - access: U.USERCODE = TU.USERCODE                         

13 rows fetched.

SQL> 
SQL> 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_002;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> 
SQL> create table t_join_base_001(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10),c_vchar2 varchar2(100),c_clob clob,
  4 c_long clob,c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp)
  5 PARTITION BY RANGE(id)
  6 (
  7 PARTITION id1 VALUES LESS than(10),
  8 PARTITION id2 VALUES LESS than(100),
  9 PARTITION id3 VALUES LESS than(1000),
 10 PARTITION id4 VALUES LESS than(MAXVALUE)
 11 );

Succeed.

SQL> insert into t_join_base_001 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-01-01 10:51:47.123456'),'yyyy-mm-dd hh24:mi:ss.FF6'));

1 rows affected.

SQL> insert into t_join_base_001 values(0,null,null,null,null,null,null,null,null,null,null,null,null,null,null);

1 rows affected.

SQL> create table t_join_base_002 as select * from t_join_base_001;

Succeed.

SQL> create table t_join_base_101 as select * from t_join_base_001;

Succeed.

SQL> 
SQL> explain plan for select count(*) from t_join_base_001 t1 join t_join_base_002 t2 on t1.id=t2.id where exists(select * from t_join_base_101 t11 where (select t11.c_number+1 from dual)=t1.c_number and (select t11.c_int+1 from dual)=t1.c_int and t11.c_vchar=t1.c_vchar and t11.c_timestamp=t1.c_timestamp);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name                | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                     |      |      |       |        |
| 1   |   AGGR                                 |       |                     |      |      |       |        |
| 2   |     HASH JOIN(L)                       |       |                     |      |      |       |        |
| 3   |       KERNEL FILTER                    |       |                     |      |      |       |        |
| 4   |         TABLE ACCESS FULL Filter:[0,4) | SYS   | T_JOIN_BASE_001 T1  |      |      |       |        |
| 5   |         KERNEL FILTER                  |       |                     |      |      |       |        |
| 6   |           TABLE ACCESS FULL            | SYS   | T_JOIN_BASE_101 T11 |      |      |       |        |
| 7   |           TABLE ACCESS FULL            | SYS   | SYS_DUMMY           |      |      |       |        |
| 8   |           TABLE ACCESS FULL            | SYS   | SYS_DUMMY           |      |      |       |        |
| 9   |       KERNEL FILTER                    |       |                     |      |      |       |        |
| 10  |         TABLE ACCESS FULL              | SYS   | T_JOIN_BASE_002 T2  |      |      |       |        |
| 11  |         KERNEL FILTER                  |       |                     |      |      |       |        |
| 12  |           TABLE ACCESS FULL            | SYS   | T_JOIN_BASE_101 T11 |      |      |       |        |
| 13  |           TABLE ACCESS FULL            | SYS   | SYS_DUMMY           |      |      |       |        |
| 14  |           TABLE ACCESS FULL            | SYS   | SYS_DUMMY           |      |      |       |        |
-------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T1.ID = T2.ID                                    
       filter: EXISTS(SELECT 1 FROM T_JOIN_BASE_101 T11 WHERE T11.C_VCHAR = T1.C_VCHAR AND T11.C_TIMESTAMP = T1.C_TIMESTAMP AND 
               (SELECT T11.C_NUMBER + 1 FROM DUAL) = T1.C_NUMBER AND (SELECT T11.C_INT + 1 FROM DUAL) = T1.C_INT)
   6 - filter: T11.C_VCHAR = T1.C_VCHAR AND (SELECT T11.C_NUMBER + 1 FROM DUAL) = T1.C_NUMBER AND T11.C_TIMESTAMP = T1.C_TIMESTAMP AND 
               (SELECT T11.C_INT + 1 FROM DUAL) = T1.C_INT      
   12 - filter: T11.C_VCHAR = T1.C_VCHAR AND (SELECT T11.C_NUMBER + 1 FROM DUAL) = T1.C_NUMBER AND T11.C_TIMESTAMP = T1.C_TIMESTAMP AND 
               (SELECT T11.C_INT + 1 FROM DUAL) = T1.C_INT      

28 rows fetched.

SQL> 
SQL> drop table if exists t_join_base_001;

Succeed.

SQL> drop table if exists t_join_base_002;

Succeed.

SQL> drop table if exists t_join_base_101;

Succeed.

SQL> 
SQL> 
SQL> drop table if exists tbl_explain_hash;

Succeed.

SQL> drop table if exists tbl_explain_interval;

Succeed.

SQL> drop table if exists tbl_explain_list;

Succeed.

SQL> create table tbl_explain_hash(
  2 col_int int,
  3 col_integer integer,
  4 col_BINARY_INTEGER BINARY_INTEGER,
  5 col_smallint smallint not null default '7',
  6 col_bigint bigint not null default '3',
  7 col_BINARY_BIGINT BINARY_BIGINT,
  8 col_real real,
  9 col_double double,
 10 col_float float,
 11 col_BINARY_DOUBLE BINARY_DOUBLE,
 12 col_decimal decimal,
 13 col_number1 number,
 14 col_number2 number(38),
 15 col_number3 number(38,-84),
 16 col_number4 number(38,127),
 17 col_number5 number(38,7),
 18 col_numeric numeric,
 19 col_char1 char(100),
 20 col_char2 char(8000),
 21 col_nchar1 nchar(100),
 22 col_nchar2 nchar(8000),
 23 col_varchar_200 varchar(100),
 24 col_varchar_8000 varchar(8000) default 'aaaabbbb',
 25 col_varchar2_1000 varchar2(100) not null default 'aaaabbbb' comment 'varchar2(1000)',
 26 col_varchar2_8000 varchar2(8000),
 27 col_nvarchar1 nvarchar(100),
 28 col_nvarchar2 nvarchar(8000),
 29 col_nvarchar2_1000 nvarchar2(100),
 30 col_nvarchar2_8000 nvarchar2(8000),
 31 col_clob clob,
 32 col_text text,
 33 col_longtext longtext,
 34 col_image image,
 35 col_binary1 binary(100),
 36 col_binary2 binary(8000),
 37 col_varbinary1 varbinary(100),
 38 col_varbinary2 varbinary(8000),
 39 col_raw1 raw(100),
 40 col_raw2 raw(8000),
 41 col_blob blob,
 42 col_date date not null default '2018-01-07 08:08:08',
 43 col_datetime datetime default '2018-01-07 08:08:08',
 44 col_timestamp1 timestamp ,
 45 col_timestamp2 timestamp(6),
 46 col_timestamp3 TIMESTAMP WITH TIME ZONE,
 47 col_timestamp4 TIMESTAMP WITH LOCAL TIME ZONE,
 48 col_bool bool,
 49 col_boolean boolean,
 50 col_interval1 INTERVAL YEAR TO MONTH,
 51 col_interval2 INTERVAL DAY TO SECOND
 52 )
 53 partition by hash(col_BINARY_INTEGER,col_float,col_numeric,col_raw1,col_varchar2_1000,col_interval1,col_date)
 54 (
 55   partition p_hash_01  ,
 56   partition p_hash_02  ,
 57   partition p_hash_03  ,
 58   partition p_hash_04  ,
 59   partition p_hash_05  ,
 60   partition p_hash_06  ,
 61   partition p_hash_07  
 62 )  ;

Succeed.

SQL> create table tbl_explain_interval(
  2 col_int int ,
  3 col_integer integer,
  4 col_BINARY_INTEGER BINARY_INTEGER,
  5 col_smallint smallint not null default '7',
  6 col_bigint bigint not null default '3',
  7 col_BINARY_BIGINT BINARY_BIGINT,
  8 col_real real,
  9 col_double double comment 'double',
 10 col_float float,
 11 col_BINARY_DOUBLE BINARY_DOUBLE,
 12 col_decimal decimal,
 13 col_number1 number,
 14 col_number2 number(38),
 15 col_number3 number(38,-84),
 16 col_number4 number(38,127),
 17 col_number5 number(38,7),
 18 col_numeric numeric,
 19 col_char1 char(100),
 20 col_char2 char(8000),
 21 col_nchar1 nchar(100),
 22 col_nchar2 nchar(8000),
 23 col_varchar_200 varchar(100),
 24 col_varchar_8000 varchar(8000) not null default 'abcd',
 25 col_varchar2_1000 varchar2(100),
 26 col_varchar2_8000 varchar2(8000),
 27 col_nvarchar1 nvarchar(100),
 28 col_nvarchar2 nvarchar(8000),
 29 col_nvarchar2_1000 nvarchar2(100),
 30 col_nvarchar2_8000 nvarchar2(8000),
 31 col_clob clob,
 32 col_text text,
 33 col_longtext longtext not null,
 34 col_image image,
 35 col_binary1 binary(100),
 36 col_binary2 binary(8000),
 37 col_varbinary1 varbinary(100),
 38 col_varbinary2 varbinary(8000) not null,
 39 col_raw1 raw(100),
 40 col_raw2 raw(8000),
 41 col_blob blob,
 42 col_date date not null default to_date('2018-06-01','yyyy-mm-dd'),
 43 col_datetime datetime default '2018-01-07 08:08:08',
 44 col_timestamp1 timestamp default to_timestamp('2018-01-07 08:08:08', 'YYYY-MM-DD HH24:MI:SS:FF'),
 45 col_timestamp2 timestamp(6),
 46 col_timestamp3 TIMESTAMP WITH TIME ZONE,
 47 col_timestamp4 TIMESTAMP WITH LOCAL TIME ZONE,
 48 col_bool bool,
 49 col_boolean boolean,
 50 col_interval1 INTERVAL YEAR TO MONTH,
 51 col_interval2 INTERVAL DAY TO SECOND
 52 )
 53 partition by range(col_date) interval (numtoyminterval(1, 'month'))
 54 (
 55   partition p_interval_01 values less than (to_date('2018-02-01','yyyy-mm-dd'))  ,
 56   partition p_interval_02 values less than (to_date('2018-03-01','yyyy-mm-dd'))  ,
 57   partition p_interval_03 values less than (to_date('2018-05-01','yyyy-mm-dd'))  ,
 58   partition p_interval_04 values less than (to_date('2018-07-01','yyyy-mm-dd'))  ,
 59   partition p_interval_05 values less than (to_date('2018-09-01','yyyy-mm-dd'))  ,
 60   partition p_interval_06 values less than (to_date('2018-10-01','yyyy-mm-dd'))  ,
 61   partition p_interval_07 values less than (to_date('2018-12-01','yyyy-mm-dd'))  
 62  );

Succeed.

SQL> create table tbl_explain_list(
  2 col_int int,
  3 col_integer integer,
  4 col_BINARY_INTEGER BINARY_INTEGER,
  5 col_smallint smallint not null default '7',
  6 col_bigint bigint not null default '3',
  7 col_BINARY_BIGINT BINARY_BIGINT,
  8 col_real real,
  9 col_double double,
 10 col_float float,
 11 col_BINARY_DOUBLE BINARY_DOUBLE,
 12 col_decimal decimal,
 13 col_number1 number,
 14 col_number2 number(38),
 15 col_number3 number(38,-84),
 16 col_number4 number(38,127),
 17 col_number5 number(38,7),
 18 col_numeric numeric,
 19 col_char1 char(100),
 20 col_char2 char(8000),
 21 col_nchar1 nchar(100),
 22 col_nchar2 nchar(8000),
 23 col_varchar_200 varchar(100),
 24 col_varchar_8000 varchar(8000) default 'aaaabbbb',
 25 col_varchar2_1000 varchar2(100),
 26 col_varchar2_8000 varchar2(8000),
 27 col_nvarchar1 nvarchar(100),
 28 col_nvarchar2 nvarchar(8000),
 29 col_nvarchar2_1000 nvarchar2(100),
 30 col_nvarchar2_8000 nvarchar2(8000),
 31 col_clob clob,
 32 col_text text,
 33 col_longtext longtext,
 34 col_image image,
 35 col_binary1 binary(100),
 36 col_binary2 binary(8000),
 37 col_varbinary1 varbinary(100),
 38 col_varbinary2 varbinary(8000),
 39 col_raw1 raw(100),
 40 col_raw2 raw(8000),
 41 col_blob blob,
 42 col_date date default to_date('2018-01-07','yyyy-mm-dd'),
 43 col_datetime datetime default '2018-01-07 08:08:08',
 44 col_timestamp1 timestamp not null default '2018-01-07 08:08:08',
 45 col_timestamp2 timestamp(6),
 46 col_timestamp3 TIMESTAMP WITH TIME ZONE,
 47 col_timestamp4 TIMESTAMP WITH LOCAL TIME ZONE,
 48 col_bool bool,
 49 col_boolean boolean,
 50 col_interval1 INTERVAL YEAR TO MONTH,
 51 col_interval2 INTERVAL DAY TO SECOND
 52 )
 53 partition by list(col_bigint,col_char1,col_timestamp1)
 54 (
 55    partition p_list_01 values ((1,'aaaabbbbccc1','2018-01-07 08:08:08'),(2,'aaaabbbbccc2','2018-01-08 08:08:08'),(3,'aaaabbbbccc3','2018-01-09 08:08:08'),(4,'aaaabbbbccc4','2018-01-10 08:08:08'),(5,'aaaabbbbccc5','2018-01-11 08:08:08'))  ,
 56    partition p_list_02 values ((101,'aaaabbbbccc6','2018-02-07 08:08:08'),(102,'aaaabbbbccc7','2018-02-08 08:08:08'),(103,'aaaabbbbccc8','2018-02-09 08:08:08'),(104,'aaaabbbbccc9','2018-02-10 08:08:08'),(105,'aaaabbbbccc10','2018-02-11 08:08:08'))  ,
 57    partition p_list_03 values ((1010,'aaaabbbbccc11','2018-03-07 08:08:08'),(1020,'aaaabbbbccc12','2018-03-08 08:08:08'),(1030,'aaaabbbbccc13','2018-03-09 08:08:08'),(1040,'aaaabbbbccc14','2018-03-10 08:08:08'),(1050,'aaaabbbbccc15','2018-03-11 08:08:08'))  ,
 58    partition p_list_04 values ((10010,'aaaabbbbccc16','2018-04-07 08:08:08'),(10020,'aaaabbbbccc17','2018-04-08 08:08:08'),(10030,'aaaabbbbccc18','2018-04-09 08:08:08'),(10040,'aaaabbbbccc19','2018-04-10 08:08:08'),(10050,'aaaabbbbccc20','2018-04-11 08:08:08'))  ,
 59    partition p_list_05 values ((100010,'aaaabbbbccc21','2018-05-07 08:08:08'),(100020,'aaaabbbbccc22','2018-05-08 08:08:08'),(100030,'aaaabbbbccc23','2018-05-09 08:08:08'),(100040,'aaaabbbbccc24','2018-05-10 08:08:08'),(100050,'aaaabbbbccc25','2018-05-11 08:08:08'))  ,
 60    partition p_list_06 values ((200010,'aaaabbbbccc26','2018-06-07 08:08:08'),(200020,'aaaabbbbccc27','2018-06-08 08:08:08'),(200030,'aaaabbbbccc28','2018-06-09 08:08:08'),(200040,'aaaabbbbccc29','2018-06-10 08:08:08'),(200050,'aaaabbbbccc30','2018-06-11 08:08:08'))  ,
 61    partition p_list_07 values (default)  
 62 );

Succeed.

SQL> explain merge into tbl_explain_list t1 using(select * from tbl_explain_interval where col_int<=50) t2 on(t1.COL_RAW1!=t2.col_raw1) 
  2 when matched then update set COL_IMAGE=t2.col_image where t1.col_int<=10
  3 when not matched then insert (COL_INT,COL_SMALLINT,COL_BIGINT,COL_TIMESTAMP1) values(t2.col_int*100000,t2.col_int,t2.col_bigint,t2.col_timestamp2) 
  4 where exists(select distinct st1.col_int from tbl_explain_hash st1 left join tbl_explain_list st2 on st1.col_int=st2.col_int and st1.col_int<=50 
  5 and st2.col_int<=50 where st2.col_timestamp1<=(select distinct max(distinct col_timestamp1) 
  6 from tbl_explain_interval where col_timestamp1=t2.COL_TIMESTAMP1));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                 | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------------
| 0   | MERGE STATEMENT(NESTED LOOPS)                |       |                      |      |      |       |        |
| 1   |   USING TABLE                                |       |                      |      |      |       |        |
| 2   |     SUBSELECT                                |       | T2                   |      |      |       |        |
| 3   |       TABLE ACCESS FULL Filter:[0,7)         | SYS   | TBL_EXPLAIN_INTERVAL |      |      |       |        |
| 4   |   MERGE TABLE                                |       |                      |      |      |       |        |
| 5   |     TABLE ACCESS FULL Filter:[0,7)           | SYS   | TBL_EXPLAIN_LIST T1  |      |      |       |        |
| 6   |   ON CONDITION                               |       |                      |      |      |       |        |
| 7   |     FILTER                                   |       |                      |      |      |       |        |
| 8   |       INSERT STATEMENT                       |       |                      |      |      |       |        |
| 9   |         HASH JOIN(L)                         |       |                      |      |      |       |        |
| 10  |           KERNEL FILTER                      |       |                      |      |      |       |        |
| 11  |             TABLE ACCESS FULL Filter:[0,7)   | SYS   | TBL_EXPLAIN_HASH ST1 |      |      |       |        |
| 12  |             AGGR                             |       |                      |      |      |       |        |
| 13  |               TABLE ACCESS FULL Filter:[0,7) | SYS   | TBL_EXPLAIN_INTERVAL |      |      |       |        |
| 14  |           KERNEL FILTER                      |       |                      |      |      |       |        |
| 15  |             TABLE ACCESS FULL Filter:[0,7)   | SYS   | TBL_EXPLAIN_LIST ST2 |      |      |       |        |
| 16  |             AGGR                             |       |                      |      |      |       |        |
| 17  |               TABLE ACCESS FULL Filter:[0,7) | SYS   | TBL_EXPLAIN_INTERVAL |      |      |       |        |
| 18  |     FILTER                                   |       |                      |      |      |       |        |
| 19  |       UPDATE STATEMENT                       |       |                      |      |      |       |        |
--------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: COL_INT <= 50                                    
   5 - filter: T1.COL_RAW1 != T2.COL_RAW1                       
   7 - filter: EXISTS(SELECT 1 FROM TBL_EXPLAIN_HASH ST1 INNER JOIN TBL_EXPLAIN_LIST ST2 WHERE ST2.COL_TIMESTAMP1 <= (SELECT 
               MAX(COL_TIMESTAMP1) FROM TBL_EXPLAIN_INTERVAL WHERE COL_TIMESTAMP1 = T2.COL_TIMESTAMP1))
   9 - access: ST1.COL_INT = ST2.COL_INT                        
       filter: ST2.COL_TIMESTAMP1 <= (SELECT MAX(COL_TIMESTAMP1) FROM TBL_EXPLAIN_INTERVAL WHERE COL_TIMESTAMP1 = T2.COL_TIMESTAMP1)
   11 - filter: ST1.COL_INT <= 50                               
   13 - filter: COL_TIMESTAMP1 = T2.COL_TIMESTAMP1              
   15 - filter: ST2.COL_INT <= 50                               
   17 - filter: COL_TIMESTAMP1 = T2.COL_TIMESTAMP1              
   18 - filter: T1.COL_INT <= 10                                

37 rows fetched.

SQL> drop table tbl_explain_hash;

Succeed.

SQL> drop table tbl_explain_interval;

Succeed.

SQL> drop table tbl_explain_list;

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "I_FIXEDNETWORKLTP";

Succeed.

SQL> CREATE TABLE "I_FIXEDNETWORKLTP"
  2 (
  3   "id" VARBINARY(16) NOT NULL,
  4   "class_Name" VARCHAR(384 BYTE) NOT NULL,
  5   "class_Id" BINARY_BIGINT NOT NULL,
  6   "collectorId" VARCHAR(36 BYTE),
  7   "reportSn" BINARY_BIGINT,
  8   "last_Modified" BINARY_BIGINT NOT NULL,
  9   "regionId" VARBINARY(16),
 10   "createTime" BINARY_BIGINT,
 11   "name" VARCHAR(765 BYTE) NOT NULL,
 12   "remark" VARCHAR(3072 BYTE),
 13   "nativeId" VARCHAR(765 BYTE),
 14   "ownerId" BINARY_BIGINT,
 15   "bandwidth" BINARY_DOUBLE,
 16   "frameId" VARCHAR(96 BYTE),
 17   "portId" VARCHAR(96 BYTE),
 18   "cardNativeId" VARCHAR(765 BYTE),
 19   "portIndex" VARCHAR(765 BYTE),
 20   "ltpTypeName" VARCHAR(384 BYTE) NOT NULL,
 21   "adminState" VARCHAR(96 BYTE),
 22   "layerRate" VARCHAR(192 BYTE),
 23   "tenantId" VARCHAR(192 BYTE),
 24   "alias" VARCHAR(765 BYTE),
 25   "slotId" VARCHAR(96 BYTE),
 26   "daughterSlotId" VARCHAR(96 BYTE),
 27   "neNativeId" VARCHAR(765 BYTE),
 28   "direction" VARCHAR(96 BYTE),
 29   "Access__ponType" VARCHAR(96 BYTE),
 30   "Eth__portCableType" VARCHAR(96 BYTE),
 31   "nativeId2" VARCHAR(765 BYTE),
 32   "refParentCard" VARBINARY(16),
 33   "Eth__mtu" BINARY_INTEGER,
 34   "Optical__sfpTransLength" VARCHAR(96 BYTE),
 35   "ltpRole" VARCHAR(96 BYTE),
 36   "PonUNI__maxDistance" BINARY_DOUBLE,
 37   "IP__addrv4Mask" BINARY_INTEGER,
 38   "refTrunkLTP" VARBINARY(16),
 39   "operateState" VARCHAR(48 BYTE),
 40   "Microwave__guaranteedModulaMode" VARCHAR(96 BYTE),
 41   "Access__supportService" VARCHAR(96 BYTE),
 42   "OTN__workBandParity" VARCHAR(96 BYTE),
 43   "Optical__txReference" VARCHAR(24 BYTE),
 44   "FanVoipUser__telNumber" VARCHAR(384 BYTE),
 45   "Eth__tunnelId" BINARY_INTEGER,
 46   "tags" VARCHAR(6144 BYTE),
 47   "SDH__highPath" BINARY_INTEGER,
 48   "portType" BINARY_INTEGER,
 49   "ATM__vpiVci" CLOB,
 50   "deleteTime" BINARY_BIGINT,
 51   "OTN__pathId" VARCHAR(96 BYTE),
 52   "refTrunkLTPNativeId" VARCHAR(765 BYTE),
 53   "SAP__refServiceType" VARCHAR(96 BYTE),
 54   "Trunk__trunkId" VARCHAR(96 BYTE),
 55   "Plan__role" VARCHAR(96 BYTE),
 56   "nativeName" VARCHAR(192 BYTE),
 57   "Vdsl__xTUR_serialNumber" VARCHAR(192 BYTE),
 58   "workMode" VARCHAR(192 BYTE),
 59   "Vdsl__xTUR_vendorId" VARCHAR(192 BYTE),
 60   "OTN__flexFreq" VARCHAR(96 BYTE),
 61   "LAG__lagType" VARCHAR(48 BYTE),
 62   "Eth__ingressPIR" BINARY_DOUBLE,
 63   "Eth__vlanType" VARCHAR(96 BYTE),
 64   "MPLSTE__reservedBandwidthRatio" BINARY_DOUBLE,
 65   "OTN__maxWaveNum" BINARY_INTEGER,
 66   "isSubLTP" BOOLEAN,
 67   "SAP__refService" VARBINARY(16),
 68   "Optical__sfpPortType" VARCHAR(96 BYTE),
 69   "protectionRole" VARCHAR(96 BYTE),
 70   "PonUNI__opticsModuleSubType" VARCHAR(96 BYTE),
 71   "PonNNI__unknownUnicastTrafficSuppression" BINARY_INTEGER,
 72   "NVE__sourceIP" VARCHAR(192 BYTE),
 73   "Optical__rxHighThreshold" VARCHAR(24 BYTE),
 74   "PonUNI__minDistance" BINARY_DOUBLE,
 75   "capabilityURI" VARCHAR(384 BYTE),
 76   "signalTypeCapability" VARCHAR(1536 BYTE),
 77   "Eth__vlan" CLOB,
 78   "Eth__egressCIR" BINARY_DOUBLE,
 79   "refParentNE" VARBINARY(16),
 80   "PonUNI__pgGroupId" BINARY_INTEGER,
 81   "C64K__timeslot" VARCHAR(300 BYTE),
 82   "PonUNI__remainingGuaranteedBandwidth" BINARY_DOUBLE,
 83   "FlexEth__groupId" BINARY_INTEGER,
 84   "Adsl__extendProfile" VARCHAR(192 BYTE),
 85   "Eth__mac" VARCHAR(192 BYTE),
 86   "OTN__refAccessTPNativeIdList" CLOB,
 87   "OTN__freqWidth" VARCHAR(96 BYTE),
 88   "Eth__ipv6Mtu" BINARY_INTEGER,
 89   "Eth__autoNegotiation" VARCHAR(96 BYTE),
 90   "Vdsl__alarmProfile" VARCHAR(192 BYTE),
 91   "Eth__ingressCIR" BINARY_DOUBLE,
 92   "Eth__enableChannelMode" BOOLEAN,
 93   "LAG__loadBalanceMode" VARCHAR(96 BYTE),
 94   "Vdsl__linkProfile" VARCHAR(192 BYTE),
 95   "MPLSTE__availableBandwidth" BINARY_DOUBLE,
 96   "Optical__rxReference" VARCHAR(24 BYTE),
 97   "Vdsl__xTUR_systemVendorId" VARCHAR(192 BYTE),
 98   "refDaughterSlotNativeId" VARCHAR(765 BYTE),
 99   "Microwave__amStatus" VARCHAR(3 BYTE),
100   "MPLSTE__maxReservedBandwidth" BINARY_DOUBLE,
101   "OTN__workBand" VARCHAR(96 BYTE),
102   "PonUNI__onuAutoDiscovery" VARCHAR(96 BYTE),
103   "Eth__egressPIR" BINARY_DOUBLE,
104   "Optical__fiberMode" VARCHAR(96 BYTE),
105   "Optical__opticalModule" VARCHAR(96 BYTE),
106   "LAG__protectionRatio" VARCHAR(24 BYTE),
107   "Access__refParentONU" VARBINARY(16),
108   "Vdsl__xTUR_versionNumber" VARCHAR(192 BYTE),
109   "scLtpType" VARCHAR(96 BYTE),
110   "Adsl__linkProfile" VARCHAR(192 BYTE),
111   "IP__unnumberedNativeId" VARCHAR(765 BYTE),
112   "level" VARCHAR(192 BYTE),
113   "OTN__waveNo" VARCHAR(96 BYTE),
114   "IP__backupAddrv4" CLOB,
115   "Optical__txHighThreshold" VARCHAR(24 BYTE),
116   "Microwave__fullModulaMode" VARCHAR(96 BYTE),
117   "SDH__lowPath" BINARY_INTEGER,
118   "IP__addrv6" CLOB,
119   "Physical__powerToBeReceived" VARCHAR(30 BYTE),
120   "Plan__usageState" VARCHAR(96 BYTE),
121   "OTN__pathMapModeId" BINARY_INTEGER,
122   "AgentIntegrate__resTypeName" VARCHAR(96 BYTE),
123   "PonUNI__maxOnuNumber" BINARY_INTEGER,
124   "IP__addrv4" VARCHAR(96 BYTE),
125   "userLabel" VARCHAR(768 BYTE),
126   "refSlotNativeId" VARCHAR(765 BYTE),
127   "FanVoipAG__mgId" BINARY_INTEGER,
128   "LAG__maxActiveLinkNumber" BINARY_INTEGER,
129   "description" VARCHAR(765 BYTE),
130   "refParentLTPNativeId" VARCHAR(765 BYTE),
131   "PonNNI__multicastTrafficSuppression" BINARY_INTEGER,
132   "OTN__pathLayerInfo" VARCHAR(765 BYTE),
133   "PonNNI__broadcastTrafficSuppression" BINARY_INTEGER,
134   "LAG__revertiveMode" VARCHAR(48 BYTE),
135   "OTN__aggPoint" VARCHAR(765 BYTE),
136   "equivalentFBNativeId" VARCHAR(765 BYTE),
137   "VNI__vniId" BINARY_INTEGER,
138   "isPhysical" BOOLEAN,
139   "SAP__refServiceNativeId" VARCHAR(765 BYTE),
140   "Access__isUplinkPort" BINARY_INTEGER,
141   "ownerId2" BINARY_BIGINT,
142   "Physical__mediumType" VARCHAR(96 BYTE),
143   "Access__isInOnt" BINARY_INTEGER,
144   "layerRateCapability" VARCHAR(3072 BYTE),
145   "Eth__defaultVlanId" BINARY_INTEGER,
146   "controllerSubType" BINARY_INTEGER,
147   "Optical__txLowThreshold" VARCHAR(24 BYTE),
148   "Optical__rxLowThreshold" VARCHAR(24 BYTE),
149   "refParentLTP" VARBINARY(16),
150   "Adsl__alarmProfile" VARCHAR(192 BYTE),
151   "Optical__sfpWaveLength" VARCHAR(96 BYTE)
152 );

Succeed.

SQL> CREATE UNIQUE INDEX "IDXFIXEDNETWORKLTP_PRIMARY_KEY"           ON "I_FIXEDNETWORKLTP"("id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKLTP_FANVOIPUSER_TELNUMBER_2130"   ON "I_FIXEDNETWORKLTP"("FanVoipUser__telNumber", "id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKLTP_IP_ADDRV4_2130"               ON "I_FIXEDNETWORKLTP"("IP__addrv4", "id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKLTP_PARENTLTP_2130"               ON "I_FIXEDNETWORKLTP"("refParentLTP", "id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKLTP_PARENTNE_2130"                ON "I_FIXEDNETWORKLTP"("refParentNE", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKLTP_ALIAS"                     ON "I_FIXEDNETWORKLTP"("alias", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKLTP_CLASS_ID"                  ON "I_FIXEDNETWORKLTP"("class_Id", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKLTP_COLLECTORID"               ON "I_FIXEDNETWORKLTP"("collectorId", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKLTP_NAME"                      ON "I_FIXEDNETWORKLTP"("name", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKLTP_NATIVEID_OWNERID_REGIONID" ON "I_FIXEDNETWORKLTP"("nativeId", "ownerId", "regionId", "id");

Succeed.

SQL> 
SQL> DROP TABLE IF EXISTS "I_FIXEDNETWORKELEMENT" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "I_FIXEDNETWORKELEMENT"
  2 (
  3   "id" VARBINARY(16) NOT NULL,
  4   "class_Name" VARCHAR(384 BYTE) NOT NULL,
  5   "class_Id" BINARY_BIGINT NOT NULL,
  6   "collectorId" VARCHAR(36 BYTE),
  7   "reportSn" BINARY_BIGINT,
  8   "last_Modified" BINARY_BIGINT NOT NULL,
  9   "regionId" VARBINARY(16),
 10   "createTime" BINARY_BIGINT,
 11   "name" VARCHAR(765 BYTE) NOT NULL,
 12   "remark" VARCHAR(3072 BYTE),
 13   "nativeId" VARCHAR(765 BYTE),
 14   "ownerId" BINARY_BIGINT,
 15   "container" BOOLEAN NOT NULL,
 16   "commuState" VARCHAR(48 BYTE),
 17   "refParentSubnet" VARBINARY(16),
 18   "latitude" BINARY_DOUBLE,
 19   "ipAddress" VARCHAR(765 BYTE),
 20   "timeZone" VARCHAR(768 BYTE),
 21   "language" VARCHAR(762 BYTE),
 22   "version" VARCHAR(1536 BYTE),
 23   "mac" VARCHAR(384 BYTE),
 24   "productName" VARCHAR(384 BYTE),
 25   "manufacturer" VARCHAR(384 BYTE),
 26   "refParentNE" VARBINARY(16),
 27   "codeset" VARCHAR(765 BYTE),
 28   "adminState" VARCHAR(96 BYTE),
 29   "tenantId" VARCHAR(192 BYTE),
 30   "manufactureDate" VARCHAR(384 BYTE),
 31   "alias" VARCHAR(765 BYTE),
 32   "isVNF" BOOLEAN,
 33   "typeId" VARCHAR(384 BYTE) NOT NULL,
 34   "location" VARCHAR(1500 BYTE),
 35   "parentNeNativeId" VARCHAR(765 BYTE),
 36   "sn" VARCHAR(384 BYTE),
 37   "interfaceId" VARCHAR(1536 BYTE),
 38   "longitude" BINARY_DOUBLE,
 39   "__plat_ipfield_ipAddress" VARBINARY(16),
 40   "Qx__physicalId" BINARY_INTEGER,
 41   "userLabel" VARCHAR(768 BYTE),
 42   "ASON__enableAson" BINARY_INTEGER,
 43   "ONE__devList" CLOB,
 44   "workMode" VARCHAR(192 BYTE),
 45   "ipv6Address" VARCHAR(192 BYTE),
 46   "ASON__isInACDomain" BOOLEAN,
 47   "roles" VARCHAR(1536 BYTE),
 48   "nativeId2" VARCHAR(765 BYTE),
 49   "fiberCount" BINARY_INTEGER,
 50   "refParentONENativeId" VARCHAR(765 BYTE),
 51   "detailDevTypeName" VARCHAR(96 BYTE),
 52   "Qx__masterGateway" VARBINARY(16),
 53   "tenantName" VARCHAR(765 BYTE),
 54   "Access__playMode" VARCHAR(96 BYTE),
 55   "refParentSubnetNativeId" VARCHAR(765 BYTE),
 56   "Plan__roles" VARCHAR(1536 BYTE),
 57   "Qx__port" BINARY_INTEGER,
 58   "IP__asNumber" BINARY_BIGINT,
 59   "equivalentNum" BINARY_DOUBLE,
 60   "ownerId2" BINARY_BIGINT,
 61   "capabilityURI" VARCHAR(384 BYTE),
 62   "IP__devLsrId" VARCHAR(192 BYTE),
 63   "startupTime" BINARY_BIGINT,
 64   "IP__bgpRouterId" VARCHAR(96 BYTE),
 65   "SNMP__devSysName" VARCHAR(765 BYTE),
 66   "detailDevType" BINARY_INTEGER,
 67   "tags" VARCHAR(6144 BYTE),
 68   "Qx__refGatewayNEList" VARCHAR(765 BYTE),
 69   "hardVersion" VARCHAR(384 BYTE),
 70   "preConfig" BINARY_INTEGER,
 71   "deleteTime" BINARY_BIGINT,
 72   "Qx__isGateway" BINARY_INTEGER,
 73   "patchVersion" VARCHAR(384 BYTE),
 74   "refParentONE" VARBINARY(16),
 75   "frameType" VARCHAR(96 BYTE),
 76   "isVirtual" BOOLEAN
 77 );

Succeed.

SQL> CREATE UNIQUE INDEX "I_FIXEDNETWORKELEMENT_PRIMARY_KEY"   ON "I_FIXEDNETWORKELEMENT"("id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKELEMENT_IP_BGPROUTERID_2100" ON "I_FIXEDNETWORKELEMENT"("IP__bgpRouterId", "id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKELEMENT_NAME_IPADDRESS_QX__PHYSICALID_2100" ON "I_FIXEDNETWORKELEMENT"("name", "ipAddress", "Qx__physicalId", "id");

Succeed.

SQL> CREATE INDEX "IDXFIXEDNETWORKELEMENT_QX_PHYSICALID_2100" ON "I_FIXEDNETWORKELEMENT"("Qx__physicalId", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT_CLASS_ID" ON "I_FIXEDNETWORKELEMENT"("class_Id", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT_COLLECTORID" ON "I_FIXEDNETWORKELEMENT"("collectorId", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT_IPADDRESS" ON "I_FIXEDNETWORKELEMENT"("ipAddress", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT_NAME" ON "I_FIXEDNETWORKELEMENT"("name", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT_NATIVEID_OWNERID_REGIONID" ON "I_FIXEDNETWORKELEMENT"("nativeId", "ownerId", "regionId", "id");

Succeed.

SQL> CREATE INDEX "IDX_I_FIXEDNETWORKELEMENT___PLAT_IPFIELD_IPADDRESS" ON "I_FIXEDNETWORKELEMENT"("__plat_ipfield_ipAddress", "id");

Succeed.

SQL> 
SQL> --sort index
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) ORDER BY I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I            |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | IDXFIXEDNETWORKLTP_PRIMARY_KEY |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: I.deleteTime IS NULL OR I.deleteTime = 0         

11 rows fetched.

SQL> 
SQL> EXPLAIN SELECT  * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND I.`name` like '%LISHUITUAN%' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I        |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_NAME |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: I.deleteTime IS NULL OR I.deleteTime = 0         
   3 - access: I.name LIKE '%LISHUITUAN%' AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND I.id > '0x01'

12 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcde' AND I.`id` > '0x01')) AND I.`name` like '%LISHUITUAN%' ORDER BY I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                           | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                                |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I            |      |      |       |        |
| 3   |       INDEX FULL SCAN            | SYS   | IDXFIXEDNETWORKLTP_PRIMARY_KEY |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: I.name LIKE '%LISHUITUAN%' AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcde' AND 
               I.id > '0x01' AND I.deleteTime IS NULL OR I.deleteTime = 0

12 rows fetched.

SQL> 
SQL> --filter index
SQL> EXPLAIN SELECT * 
  2 FROM I_FIXEDNETWORKELEMENT I 
  3 WHERE ((((((I.`__plat_ipfield_ipAddress` BETWEEN UNHEX('01020305') AND UNHEX('9bfffffe')) AND LENGTH(I.`__plat_ipfield_ipAddress`) = 4)))))
  4 order by `id` LIMIT 21 OFFSET 0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                                               | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                                    |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                                    |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                                    |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKELEMENT I                            |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKELEMENT___PLAT_IPFIELD_IPADDRESS |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: LENGTH(I.__plat_ipfield_ipAddress) = 4           
   4 - access: I.__plat_ipfield_ipAddress BETWEEN '01020305' AND '9BFFFFFE'

13 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `collectorId` = '12354' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                              | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                   |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                   |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                   |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I               |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_COLLECTORID |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.deleteTime IS NULL OR I.deleteTime = 0 AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND 
               I.id > '0x01'                                    
   4 - access: collectorId = '12354'                            

14 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `collectorId` = '12354' ORDER BY I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                              | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                                   |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                                   |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I               |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_COLLECTORID |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: I.deleteTime IS NULL OR I.deleteTime = 0 AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND 
               I.id > '0x01'                                    
   3 - access: collectorId = '12354'                            

13 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `FanVoipUser__telNumber` = '12354' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                                          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                               |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                               |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                               |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I                           |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDXFIXEDNETWORKLTP_FANVOIPUSER_TELNUMBER_2130 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.deleteTime IS NULL OR I.deleteTime = 0 AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND 
               I.id > '0x01'                                    
   4 - access: FanVoipUser__telNumber = '12354'                 

14 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `IP__addrv4` = '12354' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                              | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                   |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                   |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                   |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I               |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDXFIXEDNETWORKLTP_IP_ADDRV4_2130 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.deleteTime IS NULL OR I.deleteTime = 0 AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND 
               I.id > '0x01'                                    
   4 - access: IP__addrv4 = '12354'                             

14 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `IP__addrv4` between '12354' and '1235466' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I        |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_NAME |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: IP__addrv4 BETWEEN '12354' AND '1235466' AND I.deleteTime IS NULL OR I.deleteTime = 0
   3 - access: I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND I.id > '0x01'

12 rows fetched.

SQL> 
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > '0x01')) AND `nativeId` = '12354' and `ownerId` = '12354' and `regionId` = '12354' ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name                                            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                   |       |                                                 |      |      |       |        |
| 1   |   QUERY LIMIT                      |       |                                                 |      |      |       |        |
| 2   |     QUERY SORT ORDER BY ROWNUM     |       |                                                 |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I                             |      |      |       |        |
| 4   |         INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_NATIVEID_OWNERID_REGIONID |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: I.deleteTime IS NULL OR I.deleteTime = 0 AND I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND 
               I.id > '0x01'                                    
   4 - access: regionId = '12354' AND nativeId = '12354' AND ownerId = 12354 AND nativeId = regionId

14 rows fetched.

SQL> 
SQL> --filter and sort index
SQL> EXPLAIN SELECT * FROM I_FIXEDNETWORKLTP I WHERE ((((((I.`deleteTime` IS NULL ) OR (I.`deleteTime`=0)))))) AND ((I.`name` > 'abc' OR I.`name` IS NULL) OR (I.`name` = 'abcd' AND I.`id` > :p2)) ORDER BY I.`name` ASC, I.`id` ASC limit 1000;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                            |      |      |       |        |
| 1   |   QUERY LIMIT                    |       |                            |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | I_FIXEDNETWORKLTP I        |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | IDX_I_FIXEDNETWORKLTP_NAME |      |      |       |        |
--------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: I.deleteTime IS NULL OR I.deleteTime = 0         
   3 - access: I.name > 'abc' OR I.name IS NULL OR I.name = 'abcd' AND I.id > ?

12 rows fetched.

SQL> 
SQL> 
SQL> --subselect in hash join
SQL> DROP TABLE IF EXISTS T_OUTER_JOIN_1;

Succeed.

SQL> DROP TABLE IF EXISTS T_OUTER_JOIN_2;

Succeed.

SQL> DROP TABLE IF EXISTS T_OUTER_JOIN_3;

Succeed.

SQL> CREATE TABLE T_OUTER_JOIN_1(F_INT1 INT);

Succeed.

SQL> CREATE TABLE T_OUTER_JOIN_2(F_INT1 INT);

Succeed.

SQL> CREATE TABLE T_OUTER_JOIN_3(F_INT1 INT);

Succeed.

SQL> CREATE INDEX IND_T_OUTER_JOIN_3 ON T_OUTER_JOIN_3(F_INT1);

Succeed.

SQL> INSERT INTO T_OUTER_JOIN_1 VALUES(1);

1 rows affected.

SQL> INSERT INTO T_OUTER_JOIN_2 VALUES(1),(2);

2 rows affected.

SQL> INSERT INTO T_OUTER_JOIN_3 VALUES(1);

1 rows affected.

SQL> EXPLAIN SELECT COUNT(1) FROM T_OUTER_JOIN_1 T1 LEFT JOIN T_OUTER_JOIN_2 T2 ON T1.F_INT1 = T2.F_INT1 JOIN T_OUTER_JOIN_3 T3 ON T1.F_INT1 = T3.F_INT1 
  2 WHERE (T1.F_INT1 <> 2 OR  T1.F_INT1 IS NULL) AND EXISTS(SELECT 1 FROM T_OUTER_JOIN_3 T4 WHERE T4.F_INT1 = T1.F_INT1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name               | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |                    |      |      |       |        |
| 1   |   AGGR                              |       |                    |      |      |       |        |
| 2   |     KERNEL FILTER                   |       |                    |      |      |       |        |
| 3   |       HASH JOIN(L)                  |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS BY INDEX ONLY  | SYS   | T_OUTER_JOIN_3 T3  |      |      |       |        |
| 5   |           INDEX FAST FULL SCAN      | SYS   | IND_T_OUTER_JOIN_3 |      |      |       |        |
| 6   |         HASH JOIN OUTER(R)          |       |                    |      |      |       |        |
| 7   |           TABLE ACCESS FULL         | SYS   | T_OUTER_JOIN_1 T1  |      |      |       |        |
| 8   |           TABLE ACCESS FULL         | SYS   | T_OUTER_JOIN_2 T2  |      |      |       |        |
| 9   |       TABLE ACCESS BY INDEX ONLY    | SYS   | T_OUTER_JOIN_3 T4  |      |      |       |        |
| 10  |         INDEX RANGE SCAN            | SYS   | IND_T_OUTER_JOIN_3 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T3.F_INT1 = T1.F_INT1                            
       filter: EXISTS(SELECT 1 FROM T_OUTER_JOIN_3 T4)          
   6 - access: T1.F_INT1 = T2.F_INT1                            
   7 - filter: T1.F_INT1 != 2 OR T1.F_INT1 IS NULL              
   10 - access: T4.F_INT1 = T1.F_INT1                           

22 rows fetched.

SQL> 
SQL> --subselect in column
SQL> drop table if exists customer_address;

Succeed.

SQL> drop table if exists customer_demographics;

Succeed.

SQL> create table customer_address
  2 (
  3     ca_address_sk             integer               not null,
  4     ca_address_id             char(16)              not null,
  5     ca_street_number          char(10)                      ,
  6     ca_street_name            varchar(60)                   ,
  7     ca_street_type            char(15)                      ,
  8     ca_suite_number           char(10)                      ,
  9     ca_city                   varchar(60)                   ,
 10     ca_county                 varchar(30)                   ,
 11     ca_state                  char(2)                       ,
 12     ca_zip                    char(10)                      ,
 13     ca_country                varchar(20)                   ,
 14     ca_gmt_offset             decimal(5,2)                  ,
 15     ca_location_type          char(20)
 16 ); 

Succeed.

SQL> create table customer_demographics
  2 (
  3     cd_demo_sk                integer               not null,
  4     cd_gender                 char(1)                       ,
  5     cd_marital_status         char(1)                       ,
  6     cd_education_status       char(20)                      ,
  7     cd_purchase_estimate      integer                       ,
  8     cd_credit_rating          char(10)                      ,
  9     cd_dep_count              integer                       ,
 10     cd_dep_employed_count     integer                       ,
 11     cd_dep_college_count      integer
 12 )
 13 partition by range (cd_demo_sk)
 14 (
 15 partition customer_demographics_1 values less than (1000),
 16 partition customer_demographics_2 values less than (7700),
 17 partition customer_demographics_3 values less than (33700),
 18 partition customer_demographics_4 values less than (57300),
 19 partition customer_demographics_5 values less than (135700),
 20 partition customer_demographics_6 values less than (203300),
 21 partition customer_demographics_7 values less than (208700),
 22 partition customer_demographics_8 values less than (238700),
 23 partition customer_demographics_9 values less than (268700),
 24 partition customer_demographics_10 values less than (298700),
 25 partition customer_demographics_11 values less than (338700),
 26 partition customer_demographics_12 values less than (368700),
 27 partition customer_demographics_13 values less than (398700),
 28 partition customer_demographics_14 values less than (438700),
 29 partition customer_demographics_15 values less than (maxvalue)
 30 );

Succeed.

SQL> create index customer_address_index on customer_address(ca_address_sk);

Succeed.

SQL> create index customer_demographics_index on customer_demographics(cd_demo_sk) local;

Succeed.

SQL> --DTS2019030703066
SQL> explain select trim(ca_street_number) from customer_address;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                  |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | CUSTOMER_ADDRESS |      |      |       |        |
----------------------------------------------------------------------------------------

6 rows fetched.

SQL> --function column
SQL> explain select to_number((select nvl(ca_street_number, '888') from customer_demographics WHERE cd_demo_sk = ca_address_sk)) / 2 c1
  2 from customer_address
  3 WHERE ca_gmt_offset > -10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                        | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY Filter:[0,15) | SYS   | CUSTOMER_DEMOGRAPHICS       |      |      |       |        |
| 2   |     INDEX RANGE SCAN                       | SYS   | CUSTOMER_DEMOGRAPHICS_INDEX |      |      |       |        |
| 3   |   TABLE ACCESS FULL                        | SYS   | CUSTOMER_ADDRESS            |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: CD_DEMO_SK = CA_ADDRESS_SK                       
   3 - filter: CA_GMT_OFFSET > -10                              

12 rows fetched.

SQL> --aggr function column
SQL> explain select count((select ca_street_number from customer_demographics WHERE cd_demo_sk = ca_address_sk)) / 2 c1
  2 from customer_address
  3 WHERE ca_gmt_offset > -10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                             |       |                             |      |      |       |        |
| 1   |   AGGR                                       |       |                             |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,15) | SYS   | CUSTOMER_DEMOGRAPHICS       |      |      |       |        |
| 3   |       INDEX RANGE SCAN                       | SYS   | CUSTOMER_DEMOGRAPHICS_INDEX |      |      |       |        |
| 4   |     TABLE ACCESS FULL                        | SYS   | CUSTOMER_ADDRESS            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: CD_DEMO_SK = CA_ADDRESS_SK                       
   4 - filter: CA_GMT_OFFSET > -10                              

13 rows fetched.

SQL> --function cond arg
SQL> explain select if((select ca_street_name from customer_demographics)='888', '888', '999') c1
  2 from customer_address
  3 WHERE ca_gmt_offset > -10;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                | Owner | Name                        | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                           |       |                             |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY Filter:[0,15) | SYS   | CUSTOMER_DEMOGRAPHICS       |      |      |       |        |
| 2   |     INDEX FAST FULL SCAN                   | SYS   | CUSTOMER_DEMOGRAPHICS_INDEX |      |      |       |        |
| 3   |   TABLE ACCESS FULL                        | SYS   | CUSTOMER_ADDRESS            |      |      |       |        |
-------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: CA_GMT_OFFSET > -10                              

11 rows fetched.

SQL> --QUERY SORT ORDER BY
SQL> explain select to_number((select nvl(ca_street_number, '888') from customer_demographics WHERE cd_demo_sk = ca_address_sk)) / 2 c1
  2 from customer_address
  3 WHERE ca_gmt_offset > -10
  4 ORDER BY 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                             |       |                             |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                        |       |                             |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,15) | SYS   | CUSTOMER_DEMOGRAPHICS       |      |      |       |        |
| 3   |       INDEX RANGE SCAN                       | SYS   | CUSTOMER_DEMOGRAPHICS_INDEX |      |      |       |        |
| 4   |     TABLE ACCESS FULL                        | SYS   | CUSTOMER_ADDRESS            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: CD_DEMO_SK = CA_ADDRESS_SK                       
   4 - filter: CA_GMT_OFFSET > -10                              

13 rows fetched.

SQL> --HASH DISTINCT
SQL> explain select distinct sum(ca_gmt_offset) + to_number((select nvl(ca_street_number, '888') from customer_demographics WHERE cd_demo_sk = ca_address_sk)) / 2 c1
  2 from customer_address
  3 WHERE ca_gmt_offset > -10
  4 group by ca_street_number, ca_city, ca_address_sk
  5 ORDER BY 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------
| Id  | Description                                  | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                             |       |                             |      |      |       |        |
| 1   |   SORT DISTINCT                              |       |                             |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY Filter:[0,15) | SYS   | CUSTOMER_DEMOGRAPHICS       |      |      |       |        |
| 3   |       INDEX RANGE SCAN                       | SYS   | CUSTOMER_DEMOGRAPHICS_INDEX |      |      |       |        |
| 4   |     HASH GROUP BY                            |       |                             |      |      |       |        |
| 5   |       TABLE ACCESS FULL                      | SYS   | CUSTOMER_ADDRESS            |      |      |       |        |
---------------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: CD_DEMO_SK = CA_ADDRESS_SK                       
   5 - filter: CA_GMT_OFFSET > -10                              

14 rows fetched.

SQL> drop table if exists customer_address;

Succeed.

SQL> drop table if exists customer_demographics;

Succeed.

SQL> 
SQL> drop table test_explain1;

Succeed.

SQL> drop table test_explain2;

Succeed.

SQL> drop table test_explain3;

Succeed.

SQL> drop table test_explain4;

Succeed.

SQL> drop table test_explain5;

Succeed.

SQL> 
SQL> drop table if exists t_siblings_order;

Succeed.

SQL> create table t_siblings_order(EMPNO NUMBER(4) NOT NULL,ENAME VARCHAR2(10),MGR NUMBER(4));

Succeed.

SQL> explain select ENAME,EMPNO,MGR from t_siblings_order start with MGR is null connect by PRIOR empno = mgr order siblings by ename;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  |      |      |       |        |
| 1   |   QUERY SORT SIBLINGS ORDER BY |       |                  |      |      |       |        |
| 2   |     CONNECT BY MATERIALIZE     |       |                  |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | T_SIBLINGS_ORDER |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: PRIOR EMPNO = MGR                                
       filter: MGR IS NULL                                      

12 rows fetched.

SQL> create index idx_sibling_order_name on t_siblings_order(ename);

Succeed.

SQL> explain select ENAME,EMPNO,MGR from t_siblings_order start with MGR is null connect by PRIOR empno = mgr order siblings by ename;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                  |      |      |       |        |
| 1   |   QUERY SORT SIBLINGS ORDER BY |       |                  |      |      |       |        |
| 2   |     CONNECT BY MATERIALIZE     |       |                  |      |      |       |        |
| 3   |       TABLE ACCESS FULL        | SYS   | T_SIBLINGS_ORDER |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: PRIOR EMPNO = MGR                                
       filter: MGR IS NULL                                      

12 rows fetched.

SQL> drop table t_siblings_order;

Succeed.

SQL> 
SQL> drop table if exists sub_group_1;

Succeed.

SQL> create table sub_group_1 (
  2   f1        integer        not null, 
  3   f2        integer        not null,  
  4   f3        varchar(16),
  5   f4        varchar(16)
  6 );

Succeed.

SQL> create index sub_group_1_idx1 on  sub_group_1 (f1);

Succeed.

SQL> create index sub_group_1_idx2 on  sub_group_1 (f2);

Succeed.

SQL> create index sub_group_1_idx3 on  sub_group_1 (f3);

Succeed.

SQL> create index sub_group_1_idx4 on  sub_group_1 (f4);

Succeed.

SQL> 
SQL> drop table if exists sub_group_2;

Succeed.

SQL> create table sub_group_2 (
  2   f1        integer        not null, 
  3   f2        integer        not null,  
  4   f3        varchar(16),
  5   f4        varchar(16)
  6 );

Succeed.

SQL> create index sub_group_2_idx1 on  sub_group_2 (f1);

Succeed.

SQL> create index sub_group_2_idx2 on  sub_group_2 (f2);

Succeed.

SQL> create index sub_group_2_idx3 on  sub_group_2 (f3);

Succeed.

SQL> create index sub_group_2_idx4 on  sub_group_2 (f4);

Succeed.

SQL> 
SQL> explain select a.f1, a.f2 from sub_group_1 a left join (select f3 from sub_group_2 where f4 like 'w%' group by f3) b on a.f3 = b.f3 where a.f1 > 90;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                  |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID      | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 3   |       INDEX RANGE SCAN               | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                        |       | B                |      |      |       |        |
| 5   |       HASH GROUP BY                  |       |                  |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX4 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.F3 = B.F3                                      
   3 - access: A.F1 > 90                                        
   7 - access: F4 LIKE 'w%'                                     

17 rows fetched.

SQL> explain select a.f1, a.f2 from sub_group_1 a left join (select f3 from sub_group_2 where f4 like 'w%' group by f3) b on a.f3 = b.f3 and a.f1 < 100 where a.f1 > 90;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                  |      |      |       |        |
| 1   |   HASH JOIN OUTER(R)                 |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID      | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 3   |       INDEX RANGE SCAN               | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                        |       | B                |      |      |       |        |
| 5   |       HASH GROUP BY                  |       |                  |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX4 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: A.F3 = B.F3                                      
       filter: A.F1 < 100                                       
   3 - access: A.F1 > 90                                        
   7 - access: F4 LIKE 'w%'                                     

18 rows fetched.

SQL> explain select a.f1, a.f2 from sub_group_1 a left join (select f3 from sub_group_2 where f4 like 'w%' group by f3) b on a.f3 = b.f3 or a.f1 < 100 where a.f1 > 90;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                          | Owner | Name             | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                     |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                 |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID      | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 3   |       INDEX RANGE SCAN               | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                        |       | B                |      |      |       |        |
| 5   |       HASH GROUP BY                  |       |                  |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |           INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX4 |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: A.F1 > 90                                        
   4 - filter: A.F3 = B.F3 OR A.F1 < 100                        
   7 - access: F4 LIKE 'w%'                                     

17 rows fetched.

SQL> explain select a.f1, a.f2 from sub_group_1 a left join (select f3 from sub_group_2 group by f3) b on a.f3 = b.f3 or a.f1 < 100 and a.f1 != a.f2 where a.f1 > 90 group by a.f1,a.f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name             | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                  |      |      |       |        |
| 1   |   HASH GROUP BY                       |       |                  |      |      |       |        |
| 2   |     NESTED LOOPS OUTER                |       |                  |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID     | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 4   |         INDEX RANGE SCAN              | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 5   |       SUBSELECT                       |       | B                |      |      |       |        |
| 6   |         INDEX GROUP BY                |       |                  |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 8   |             INDEX FULL SCAN           | SYS   | SUB_GROUP_2_IDX3 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: A.F1 > 90                                        
   5 - filter: A.F3 = B.F3 OR A.F1 < 100 AND A.F1 != A.F2       

17 rows fetched.

SQL> explain select a.f1, /* subselect */(select f3 from sub_group_2 where f2 > 100 group by f3) from sub_group_1 a where a.f1 > 90 group by a.f1,a.f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX2 |      |      |       |        |
| 4   |   HASH GROUP BY                  |       |                  |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 6   |       INDEX RANGE SCAN           | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F2 > 100                                         
   6 - access: A.F1 > 90                                        

15 rows fetched.

SQL> create or replace view sub_group_1_view as select f1,f2 from sub_group_1;

Succeed.

SQL> create or replace view sub_group_2_view as select f1,f2 from sub_group_2;

Succeed.

SQL> explain select f1 from sub_group_1_view group by f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name             | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                  |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_1      |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
---------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> explain select f1 from sub_group_1_view where f2 > 10 group by f1;  

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_1      |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | SUB_GROUP_1_IDX2 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F2 > 10                                          

11 rows fetched.

SQL> explain select a.f1 from sub_group_1_view a left join (select f1 from sub_group_2_view group by f1) on a.f1 < 100;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                         | Owner | Name             | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                    |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS OUTER                |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY      | SYS   | SUB_GROUP_1      |      |      |       |        |
| 3   |       INDEX FAST FULL SCAN          | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 4   |     SUBSELECT                       |       |                  |      |      |       |        |
| 5   |       INDEX GROUP BY                |       |                  |      |      |       |        |
| 6   |         TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |           INDEX FULL SCAN           | SYS   | SUB_GROUP_2_IDX1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - filter: SUB_GROUP_1.F1 < 100                             

15 rows fetched.

SQL> explain select a.f1, a.f2 from sub_group_1_view a left join (select f2 from sub_group_2_view group by f2) b on a.f2 = b.f2 or a.f1 < 100 and a.f1 != a.f2 where a.f1 > 90 group by a.f1,a.f2; 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                           | Owner | Name             | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                      |       |                  |      |      |       |        |
| 1   |   HASH GROUP BY                       |       |                  |      |      |       |        |
| 2   |     NESTED LOOPS OUTER                |       |                  |      |      |       |        |
| 3   |       TABLE ACCESS BY INDEX ROWID     | SYS   | SUB_GROUP_1      |      |      |       |        |
| 4   |         INDEX RANGE SCAN              | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 5   |       SUBSELECT                       |       | B                |      |      |       |        |
| 6   |         INDEX GROUP BY                |       |                  |      |      |       |        |
| 7   |           TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 8   |             INDEX FULL SCAN           | SYS   | SUB_GROUP_2_IDX2 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: SUB_GROUP_1.F1 > 90                              
   5 - filter: SUB_GROUP_1.F2 = B.F2 OR SUB_GROUP_1.F1 < 100 AND SUB_GROUP_1.F1 != SUB_GROUP_1.F2

17 rows fetched.

SQL> explain select a.f1, /* subselect */(select f1 from sub_group_2_view where f2 > 100 group by f1) from sub_group_1_view a where a.f1 > 90 group by a.f1,a.f2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                  |      |      |       |        |
| 1   |   HASH GROUP BY                  |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 3   |       INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX2 |      |      |       |        |
| 4   |   HASH GROUP BY                  |       |                  |      |      |       |        |
| 5   |     TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_1      |      |      |       |        |
| 6   |       INDEX RANGE SCAN           | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: F2 > 100                                         
   6 - access: SUB_GROUP_1.F1 > 90                              

15 rows fetched.

SQL> explain select a.f1 from sub_group_1 a where a.f1 in (select (select f1 from sub_group_2 where f1 > 0 group by f1) from sub_group_2 where f2 > 100 group by f3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
| Id  | Description                            | Owner | Name             | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                       |       |                  |      |      |       |        |
| 1   |   NESTED LOOPS                         |       |                  |      |      |       |        |
| 2   |     SUBSELECT                          |       |                  |      |      |       |        |
| 3   |       HASH DISTINCT                    |       |                  |      |      |       |        |
| 4   |         INDEX GROUP BY                 |       |                  |      |      |       |        |
| 5   |           TABLE ACCESS BY INDEX ONLY   | SYS   | SUB_GROUP_2      |      |      |       |        |
| 6   |             INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX1 |      |      |       |        |
| 7   |         HASH GROUP BY                  |       |                  |      |      |       |        |
| 8   |           TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 9   |             INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX2 |      |      |       |        |
| 10  |     TABLE ACCESS BY INDEX ONLY         | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 11  |       INDEX RANGE SCAN                 | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - access: F1 > 0                                           
   9 - access: F2 > 100                                         
   11 - access: A.F1 = (SELECT F1 FROM SUB_GROUP_2 WHERE F1 > 0 GROUP BY F1)

21 rows fetched.

SQL> explain select a.f1, a.f2 from sub_group_1 a right join (select distinct f3 from sub_group_2 group by f3) b on a.f3 = b.f3 or a.f1 < 200 where a.f1 > 90 order by a.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                             | Owner | Name             | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                        |       |                  |      |      |       |        |
| 1   |   QUERY SORT ORDER BY                   |       |                  |      |      |       |        |
| 2   |     NESTED LOOPS                        |       |                  |      |      |       |        |
| 3   |       SUBSELECT                         |       | B                |      |      |       |        |
| 4   |         HASH DISTINCT                   |       |                  |      |      |       |        |
| 5   |           INDEX GROUP BY                |       |                  |      |      |       |        |
| 6   |             TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |               INDEX FULL SCAN           | SYS   | SUB_GROUP_2_IDX3 |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ROWID       | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 9   |         INDEX RANGE SCAN                | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   8 - filter: A.F3 = B.F3 OR A.F1 < 200                        
   9 - access: A.F1 > 90                                        

18 rows fetched.

SQL> explain 
  2 select a.f4 from sub_group_1 a where a.f2 in (select case when f2 > 11 Then f2+1 else f2-1 end from sub_group_2 where f1 < 1000 group by f2) group by f4 having f4 > 0
  3 union all 
  4 select a.f4 from sub_group_1 a left join (select f3 from sub_group_2 group by f3) b on a.f3 like '%lin' where a.f1 > 90;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------
| Id  | Description                                    | Owner | Name             | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                               |       |                  |      |      |       |        |
| 1   |   UNION ALL                                    |       |                  |      |      |       |        |
| 2   |     HAVING                                     |       |                  |      |      |       |        |
| 3   |       HASH GROUP BY                            |       |                  |      |      |       |        |
| 4   |         NESTED LOOPS                           |       |                  |      |      |       |        |
| 5   |           NESTED LOOPS                         |       |                  |      |      |       |        |
| 6   |             SUBSELECT                          |       |                  |      |      |       |        |
| 7   |               HASH DISTINCT                    |       |                  |      |      |       |        |
| 8   |                 HASH GROUP BY                  |       |                  |      |      |       |        |
| 9   |                   TABLE ACCESS BY INDEX ROWID  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 10  |                     INDEX RANGE SCAN           | SYS   | SUB_GROUP_2_IDX1 |      |      |       |        |
| 11  |             TABLE ACCESS BY INDEX ONLY         | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 12  |               INDEX RANGE SCAN                 | SYS   | SUB_GROUP_1_IDX2 |      |      |       |        |
| 13  |           TABLE ACCESS BY ROWID                | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 14  |             ROWID SCAN                         |       |                  |      |      |       |        |
| 15  |     NESTED LOOPS OUTER                         |       |                  |      |      |       |        |
| 16  |       TABLE ACCESS BY INDEX ROWID              | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 17  |         INDEX RANGE SCAN                       | SYS   | SUB_GROUP_1_IDX1 |      |      |       |        |
| 18  |       SUBSELECT                                |       | B                |      |      |       |        |
| 19  |         INDEX GROUP BY                         |       |                  |      |      |       |        |
| 20  |           TABLE ACCESS BY INDEX ONLY           | SYS   | SUB_GROUP_2      |      |      |       |        |
| 21  |             INDEX FULL SCAN                    | SYS   | SUB_GROUP_2_IDX3 |      |      |       |        |
------------------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: F4 > 0                                           
   10 - access: F1 < 1000                                       
   12 - access: A.F2 = CASE  WHEN F2 > 11 THEN F2 + 1 ELSE F2 - 1 END
   17 - access: A.F1 > 90                                       
   18 - filter: A.F3 LIKE '%lin'                                

33 rows fetched.

SQL> explain
  2 select a.f1, a.f2, a.f3 from sub_group_1 a right join (select distinct f3 from sub_group_2 group by f3) b on a.f3 = b.f3
  3 minus
  4 select a.f1, a.f2, a.f3 from sub_group_1 a left join (select distinct f1 from sub_group_2 group by f1) b on a.f1 > b.f1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------
| Id  | Description                             | Owner | Name             | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                        |       |                  |      |      |       |        |
| 1   |   HASH MINUS                            |       |                  |      |      |       |        |
| 2   |     NESTED LOOPS OUTER                  |       |                  |      |      |       |        |
| 3   |       SUBSELECT                         |       | B                |      |      |       |        |
| 4   |         HASH DISTINCT                   |       |                  |      |      |       |        |
| 5   |           INDEX GROUP BY                |       |                  |      |      |       |        |
| 6   |             TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 7   |               INDEX FULL SCAN           | SYS   | SUB_GROUP_2_IDX3 |      |      |       |        |
| 8   |       TABLE ACCESS BY INDEX ROWID       | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 9   |         INDEX RANGE SCAN                | SYS   | SUB_GROUP_1_IDX3 |      |      |       |        |
| 10  |     NESTED LOOPS OUTER                  |       |                  |      |      |       |        |
| 11  |       TABLE ACCESS FULL                 | SYS   | SUB_GROUP_1 A    |      |      |       |        |
| 12  |       SUBSELECT                         |       | B                |      |      |       |        |
| 13  |         HASH DISTINCT                   |       |                  |      |      |       |        |
| 14  |           INDEX GROUP BY                |       |                  |      |      |       |        |
| 15  |             TABLE ACCESS BY INDEX ONLY  | SYS   | SUB_GROUP_2      |      |      |       |        |
| 16  |               INDEX RANGE SCAN          | SYS   | SUB_GROUP_2_IDX1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   9 - access: A.F3 = B.F3                                      
   12 - filter: A.F1 > B.F1                                     
   16 - access: A.F1 > F1                                       

26 rows fetched.

SQL> drop table if exists sub_group_1;

Succeed.

SQL> drop table if exists sub_group_2;

Succeed.

SQL> --DTS2019100806027
SQL> drop table if exists explain_core;

Succeed.

SQL> create table explain_core(id1 int not null,num1 float,char1 varchar(500) default '字符串kjdsgfkj') 
  2 partition by range(id1)	
  3 (
  4 	partition p1 values less than (5),
  5 	partition p2 values less than (16),
  6 	partition p3 values less than (maxvalue)
  7 );

Succeed.

SQL> 
SQL> insert into explain_core values(1,0.094785,'rjhcgrhjkg');

1 rows affected.

SQL> insert into explain_core values(3,78.85,'的脚后跟');

1 rows affected.

SQL> insert into explain_core values(6,497947.85,'预告发热护4gvhj');

1 rows affected.

SQL> insert into explain_core values(14,4785,'rjhjkg');

1 rows affected.

SQL> insert into explain_core values(87,-4785,'rj零食就打开过hjkg');

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain plan for delete from explain_core where id1 = (select 87 from dual);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> explain plan for delete from explain_core where id1 = (select 87 from dual); 

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------
| Id  | Description                        | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------
| 0   | DELETE STATEMENT                   |       |              |      |      |       |        |
| 1   |   KERNEL FILTER                    |       |              |      |      |       |        |
| 2   |     TABLE ACCESS FULL Filter:[2,3) | SYS   | EXPLAIN_CORE |      |      |       |        |
| 3   |     TABLE ACCESS FULL              | SYS   | SYS_DUMMY    |      |      |       |        |
--------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: ID1 = (SELECT 87 FROM DUAL)                      

11 rows fetched.

SQL> drop table explain_core;

Succeed.

SQL> 
SQL> 
SQL> DROP TABLE IF EXISTS f_TNN000005_NodeBCell_H;

Succeed.

SQL> CREATE TABLE f_TNN000005_NodeBCell_H(
  2     NodeBCellId NUMBER(20),
  3     StartTime DATE,
  4     Hour NUMBER(20),
  5     DSTOffset NUMBER(20),
  6     Period NUMBER(20),
  7     Integrity NUMBER(20),
  8     PreIntegrity NUMBER(20)
  9 );

Succeed.

SQL> DROP TABLE IF EXISTS d_NodeBCellGrpObject;

Succeed.

SQL> CREATE TABLE d_NodeBCellGrpObject(
  2     NodeBCellGrpId NUMBER(20),
  3     NodeBCellId NUMBER(20)
  4 );

Succeed.

SQL> 
SQL> explain select ObjId,
  2        DSTOffset,
  3        Hour,
  4        T0.StartTime,
  5        (Period) Period,
  6        (Integrity) Integrity,
  7        (PreIntegrity) PreIntegrity,
  8        (RecordNum) RecordNum
  9   from (select (d0.NodeBCellGrpId) ObjId,
 10                T0.StartTime,
 11                T0.Hour,
 12                T0.DSTOffset,
 13                AVG(T0.Period) Period,
 14                0 Period_cond,
 15                AVG(Integrity) Integrity,
 16                Max(PreIntegrity) PreIntegrity,
 17                count(1) RecordNum
 18           from f_TNN000005_NodeBCell_H T0, d_NodeBCellGrpObject d0
 19          where T0.NodeBCellId = d0.NodeBCellId
 20            and ((d0.NodeBCellGrpId >= 298 and d0.NodeBCellGrpId <= 397))
 21            and ((T0.StartTime = to_date('2019/09/28', 'yyyy/mm/dd')))
 22          group by (d0.NodeBCellGrpId), T0.StartTime, T0.Hour, T0.DSTOffset) T0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name                       | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                            |      |      |       |        |
| 1   |   HASH GROUP BY          |       |                            |      |      |       |        |
| 2   |     HASH JOIN(L)         |       |                            |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | F_TNN000005_NODEBCELL_H T0 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | D_NODEBCELLGRPOBJECT D0    |      |      |       |        |
------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T0.NODEBCELLID = D0.NODEBCELLID                  
   3 - filter: T0.STARTTIME = to_date('2019-09-28 00:00:00', 'YYYY-MM-DD HH24:MI:SS')
   4 - filter: D0.NODEBCELLGRPID >= 298 AND D0.NODEBCELLGRPID <= 397

14 rows fetched.

SQL> 
SQL> explain select ObjId,
  2        DSTOffset,
  3        Hour,
  4        T0.StartTime,
  5        (Period) Period,
  6        (Integrity) Integrity,
  7        (PreIntegrity) PreIntegrity,
  8        (RecordNum) RecordNum
  9   from (select (d0.NodeBCellGrpId) ObjId,
 10                T0.StartTime,
 11                T0.Hour,
 12                T0.DSTOffset,
 13                AVG(T0.Period) Period,
 14                0 Period_cond,
 15                AVG(Integrity) Integrity,
 16                Max(PreIntegrity) PreIntegrity,
 17                count(1) RecordNum
 18           from f_TNN000005_NodeBCell_H T0, d_NodeBCellGrpObject d0
 19          where T0.NodeBCellId = d0.NodeBCellId
 20            and ((d0.NodeBCellGrpId >= 298 and d0.NodeBCellGrpId <= 397))
 21            and ((T0.StartTime = to_date('2019/09/28', 'yyyy/mm/dd')))
 22          group by (d0.NodeBCellGrpId), T0.StartTime, T0.Hour, T0.DSTOffset) T0
 23     WHERE T0.Period>0;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                       | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                            |      |      |       |        |
| 1   |   SUBSELECT                |       | T0                         |      |      |       |        |
| 2   |     HASH GROUP BY          |       |                            |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                            |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | F_TNN000005_NODEBCELL_H T0 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | D_NODEBCELLGRPOBJECT D0    |      |      |       |        |
--------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: T0.PERIOD > 0                                    
   3 - access: T0.NODEBCELLID = D0.NODEBCELLID                  
   4 - filter: T0.STARTTIME = to_date('2019-09-28 00:00:00', 'YYYY-MM-DD HH24:MI:SS')
   5 - filter: D0.NODEBCELLGRPID >= 298 AND D0.NODEBCELLGRPID <= 397

16 rows fetched.

SQL> 
SQL> drop table if exists t_or2union_1;

Succeed.

SQL> drop table if exists t_or2union_2;

Succeed.

SQL> drop table if exists t_or2union_3;

Succeed.

SQL> drop table if exists t_or2union_4;

Succeed.

SQL> drop table if exists t_or2union_5;

Succeed.

SQL> drop table if exists t_or2union_6;

Succeed.

SQL> create table t_or2union_1(a int, b int, c int, d int, e int);

Succeed.

SQL> create table t_or2union_2(a int, b int, c int, d int, e int);

Succeed.

SQL> create table t_or2union_3(a int, b int, c int, d int, e int);

Succeed.

SQL> create table t_or2union_4(a int, b int, c int, d int, e int);

Succeed.

SQL> create table t_or2union_5(a int, b int, c int, d int, e int);

Succeed.

SQL> create table t_or2union_6(a int, b int, c int, d int, e int);

Succeed.

SQL> 
SQL> --Not Rewrite
SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = 10 or t1.b = t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS         |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: T1.A = 10 OR T1.B = T2.B                         

11 rows fetched.

SQL> explain select * from t_or2union_1 t1 where t1.a = 10 or exists (select 1 from t_or2union_2 t2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   KERNEL FILTER        |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.A = 10 OR EXISTS(SELECT 1 FROM T_OR2UNION_2 T2)

11 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on exists (select 1 from t_or2union_3 t3) or t1.a = t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS           |       |                 |      |      |       |        |
| 2   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 6   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - filter: EXISTS(SELECT 1 FROM T_OR2UNION_3 T3) OR T1.A = T2.A

15 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a and (t1.b = t2.b or t1.c = t2.c);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
       filter: T1.B = T2.B OR T1.C = T2.C                       

12 rows fetched.

SQL> explain select * from t_or2union_1 t1, t_or2union_2 t2, t_or2union_3 t3 where t1.a = t2.a or t1.b = t2.b or t1.c = t3.c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS           |       |                 |      |      |       |        |
| 2   |     NESTED LOOPS         |       |                 |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 5   |     TABLE ACCESS FULL    | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: T1.A = T2.A OR T1.B = T2.B OR T1.C = T3.C        

13 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on exists (select 1 from t_or2union_3 t3) and (t1.a = t2.a or t1.b = t2.b);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS             |       |                 |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 3   |       SUBSELECT            |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |     TABLE ACCESS FULL      | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NA = NA                                          
       filter: T1.A = T2.A OR T1.B = T2.B                       

15 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on (exists (select 1 from t_or2union_3 t3) or t1.a = 100) and (t1.a = t2.a or t1.b = t2.b);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS           |       |                 |      |      |       |        |
| 2   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 6   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - filter: EXISTS(SELECT 1 FROM T_OR2UNION_3 T3) OR T1.A = 100
   6 - filter: T1.A = T2.A OR T1.B = T2.B                       

16 rows fetched.

SQL> explain select * from t_or2union_1 t1 where exists (select 1 from t_or2union_2 t2) or exists (select 1 from t_or2union_3 t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   KERNEL FILTER        |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM T_OR2UNION_2 T2) OR EXISTS(SELECT 1 FROM T_OR2UNION_3 T3)

12 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on exists (select 1 from t_or2union_3 t3) or (t1.a = t2.a and (t1.b = t2.b or t1.c = t2.c));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |                 |      |      |       |        |
| 1   |   NESTED LOOPS           |       |                 |      |      |       |        |
| 2   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |     KERNEL FILTER        |       |                 |      |      |       |        |
| 6   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |       TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   6 - filter: EXISTS(SELECT 1 FROM T_OR2UNION_3 T3) OR T1.A = T2.A AND T1.B = T2.B OR T1.C = T2.C

15 rows fetched.

SQL> explain select * from t_or2union_1 t1 where (t1.c in (select t2.c from t_or2union_2 t2) or t1.a in (select t3.a from t_or2union_3 t3)) and (t1.d in (select t4.d from t_or2union_4 t4) or t1.b in (select t5.b from t_or2union_5 t5));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   KERNEL FILTER        |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_4 T4 |      |      |       |        |
| 6   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_5 T5 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.C IN((SELECT C FROM T_OR2UNION_2 T2)) OR T1.A IN((SELECT A FROM T_OR2UNION_3 T3)) AND 
               T1.D IN((SELECT D FROM T_OR2UNION_4 T4)) OR T1.B IN((SELECT B FROM T_OR2UNION_5 T5))

15 rows fetched.

SQL> explain select * from t_or2union_1 t1 where exists (select 1 from t_or2union_2 t2) or (t1.a = 100 and (t1.b in (select t3.b from t_or2union_3 t3) or t1.c in (select t4.c from t_or2union_4 t4)));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   KERNEL FILTER        |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 5   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_4 T4 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: EXISTS(SELECT 1 FROM T_OR2UNION_2 T2) OR T1.A = 100 AND T1.B IN((SELECT B FROM T_OR2UNION_3 T3)) OR 
               T1.C IN((SELECT C FROM T_OR2UNION_4 T4))         

14 rows fetched.

SQL> --Rewrite
SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
   6 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

18 rows fetched.

SQL> explain select * from t_or2union_1 t1 where t1.a in (select t2.a from t_or2union_2 t2) or t1.b in (select t3.b from t_or2union_3 t3);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   SUBSELECT                  |       |                 |      |      |       |        |
| 2   |     HASH UNION               |       |                 |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 4   |         SUBSELECT            |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 7   |       HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 8   |         SUBSELECT            |       |                 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 10  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T2.A = T1.A                                      
   7 - access: T3.B = T1.B                                      

19 rows fetched.

SQL> explain select * from t_or2union_1 t1 where exists (select 1 from t_or2union_2 t2) or exists (select 1 from t_or2union_3 t3 where t3.a = t1.a);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   SUBSELECT                  |       |                 |      |      |       |        |
| 2   |     HASH UNION               |       |                 |      |      |       |        |
| 3   |       HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 4   |         SUBSELECT            |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 7   |       HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 8   |         SUBSELECT            |       |                 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 10  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: NA = NA                                          
   7 - access: T3.A = T1.A                                      

19 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on t1.d = t2.d and (t1.a in (select t3.a from t_or2union_3 t3) or t2.c in (select t4.c from t_or2union_4 t4));

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   SUBSELECT                    |       |                 |      |      |       |        |
| 2   |     HASH UNION                 |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)             |       |                 |      |      |       |        |
| 4   |         HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 5   |           SUBSELECT            |       |                 |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 7   |           TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL      | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 9   |       HASH JOIN(L)             |       |                 |      |      |       |        |
| 10  |         HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 11  |           SUBSELECT            |       |                 |      |      |       |        |
| 12  |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_4 T4 |      |      |       |        |
| 13  |           TABLE ACCESS FULL    | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 14  |         TABLE ACCESS FULL      | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.D = T2.D                                      
   4 - access: T3.A = T1.A                                      
   9 - access: T2.D = T1.D                                      
   10 - access: T4.C = T2.C                                     

25 rows fetched.

SQL> explain select * from t_or2union_1 t1 join t_or2union_2 t2 on t1.d = t2.d join t_or2union_3 t3 on t2.d = t3.d where t1.a in (select t4.a from t_or2union_4 t4) or t3.b in (select t5.b from t_or2union_5 t5);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                 |      |      |       |        |
| 1   |   SUBSELECT                      |       |                 |      |      |       |        |
| 2   |     HASH UNION                   |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)               |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)             |       |                 |      |      |       |        |
| 5   |           HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 6   |             SUBSELECT            |       |                 |      |      |       |        |
| 7   |               TABLE ACCESS FULL  | SYS   | T_OR2UNION_4 T4 |      |      |       |        |
| 8   |             TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL      | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 10  |         TABLE ACCESS FULL        | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 11  |       HASH JOIN(L)               |       |                 |      |      |       |        |
| 12  |         HASH JOIN(L)             |       |                 |      |      |       |        |
| 13  |           HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 14  |             SUBSELECT            |       |                 |      |      |       |        |
| 15  |               TABLE ACCESS FULL  | SYS   | T_OR2UNION_5 T5 |      |      |       |        |
| 16  |             TABLE ACCESS FULL    | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 17  |           TABLE ACCESS FULL      | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 18  |         TABLE ACCESS FULL        | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.D = T3.D AND T2.D = T3.D                      
   4 - access: T1.D = T2.D                                      
   5 - access: T4.A = T1.A                                      
   11 - access: T1.D = T2.D AND T3.D = T2.D                     
   12 - access: T3.D = T1.D                                     
   13 - access: T5.B = T3.B                                     

31 rows fetched.

SQL> explain select sum(t1.a+t2.b) from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   AGGR                       |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select distinct t1.a,t2.a,t1.b,t2.b from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   HASH DISTINCT              |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select distinct t1.a,t2.a,t1.b,t2.b from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b order by t1.b,t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |                 |      |      |       |        |
| 2   |     HASH DISTINCT              |       |                 |      |      |       |        |
| 3   |       SUBSELECT                |       |                 |      |      |       |        |
| 4   |         UNION ALL              |       |                 |      |      |       |        |
| 5   |           HASH JOIN(L)         |       |                 |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 8   |           HASH JOIN(L)         |       |                 |      |      |       |        |
| 9   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 10  |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.A = T2.A                                      
   8 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

20 rows fetched.

SQL> explain select t1.a,t2.a,t1.b,t2.b from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b order by t2.a,t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   QUERY SORT ORDER BY        |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select t1.a,t2.b, sum(t1.b) over (partition by t2.a) from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   WINDOW SORT                |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select t1.a,t2.b, sum(t1.b) over (partition by t2.a) from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b order by t1.b,t2.c;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   QUERY SORT ORDER BY          |       |                 |      |      |       |        |
| 2   |     WINDOW SORT                |       |                 |      |      |       |        |
| 3   |       SUBSELECT                |       |                 |      |      |       |        |
| 4   |         UNION ALL              |       |                 |      |      |       |        |
| 5   |           HASH JOIN(L)         |       |                 |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 7   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 8   |           HASH JOIN(L)         |       |                 |      |      |       |        |
| 9   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 10  |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - access: T1.A = T2.A                                      
   8 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

20 rows fetched.

SQL> explain select t1.a,t2.a,t1.b,t2.b, sum(t2.c) from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b group by t1.a,t2.a,t1.b,t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   HASH GROUP BY              |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select t1.a,t2.a,t1.b,t2.b, sum(t2.c) from t_or2union_1 t1 join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b group by t1.a,t2.a,t1.b,t2.b order by t1.a,t2.b;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   SORT GROUP BY              |       |                 |      |      |       |        |
| 2   |     SUBSELECT                |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   7 - access: T1.B = T2.B                                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      

19 rows fetched.

SQL> explain select * from t_or2union_1 t1 where exists (select 1 from t_or2union_2 t2 where t1.a = t2.a) or exists (select 1 from t_or2union_3 t3 where t3.a = t1.a) or exists(select 1 from t_or2union_4 t4 where t4.a = t1.a);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   SUBSELECT                    |       |                 |      |      |       |        |
| 2   |     HASH UNION                 |       |                 |      |      |       |        |
| 3   |       UNION ALL                |       |                 |      |      |       |        |
| 4   |         HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 5   |           SUBSELECT            |       |                 |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |           TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         HASH JOIN SEMI(L)      |       |                 |      |      |       |        |
| 9   |           SUBSELECT            |       |                 |      |      |       |        |
| 10  |             TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
| 11  |           TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 12  |       HASH JOIN SEMI(L)        |       |                 |      |      |       |        |
| 13  |         SUBSELECT              |       |                 |      |      |       |        |
| 14  |           TABLE ACCESS FULL    | SYS   | T_OR2UNION_4 T4 |      |      |       |        |
| 15  |         TABLE ACCESS FULL      | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T2.A = T1.A                                      
   8 - access: T3.A = T1.A                                      
   12 - access: T4.A = T1.A                                     

25 rows fetched.

SQL> 
SQL> --or to union all Not Rewrite (lnnvl not support)
SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on (t1.a = t2.a and t1.a between 10 and 20) or (t1.b = t2.b and t1.c > t2.d)  or t1.c = t2.c where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   SUBSELECT                  |       |                 |      |      |       |        |
| 2   |     HASH UNION               |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 10  |       HASH JOIN(L)           |       |                 |      |      |       |        |
| 11  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 12  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   5 - filter: T1.A = 1 AND T1.A BETWEEN 10 AND 20              
   6 - filter: T2.A = 1                                         
   7 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: T1.C > T2.D                                      
   8 - filter: T1.A = 1                                         
   9 - filter: T2.A = 1                                         
   10 - access: T1.C = T2.C AND T1.A = T2.A                     
   11 - filter: T1.A = 1                                        
   12 - filter: T2.A = 1                                        

29 rows fetched.

SQL> explain select * from t_or2union_1 t1 where t1.a > any (select a from t_or2union_2 t2 where t2.a = t1.a) or exists (select 1 from t_or2union_3 t3 where t3.a = t1.a);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   KERNEL FILTER        |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 4   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_3 T3 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T1.A > ANY((SELECT A FROM T_OR2UNION_2 T2 WHERE T2.A = T1.A)) OR EXISTS(SELECT 1 FROM T_OR2UNION_3 T3 WHERE T3.A = T1.A)
   3 - filter: T2.A = T1.A                                      
   4 - filter: T3.A = T1.A                                      

14 rows fetched.

SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on (t1.a = t2.a and t1.a in(1,2,3,4,5)) or (t1.b = t2.b and t1.c > t2.d)  or t1.c = t2.c where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |                 |      |      |       |        |
| 1   |   SUBSELECT                  |       |                 |      |      |       |        |
| 2   |     HASH UNION               |       |                 |      |      |       |        |
| 3   |       UNION ALL              |       |                 |      |      |       |        |
| 4   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 6   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 7   |         HASH JOIN(L)         |       |                 |      |      |       |        |
| 8   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 9   |           TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 10  |       HASH JOIN(L)           |       |                 |      |      |       |        |
| 11  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 12  |         TABLE ACCESS FULL    | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   4 - access: T1.A = T2.A                                      
   5 - filter: T1.A = 1 AND T1.A IN(1, 2, 3, 4, 5)              
   6 - filter: T2.A = 1                                         
   7 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: T1.C > T2.D                                      
   8 - filter: T1.A = 1                                         
   9 - filter: T2.A = 1                                         
   10 - access: T1.C = T2.C AND T1.A = T2.A                     
   11 - filter: T1.A = 1                                        
   12 - filter: T2.A = 1                                        

29 rows fetched.

SQL> --or to union all Not Rewrite (has equal join cond)
SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b where t1.a = t2.a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name            | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                 |      |      |       |        |
| 1   |   HASH JOIN(L)         |       |                 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 3   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: T1.A = T2.A                                      
       filter: T1.A = T2.A OR T1.B = T2.B                       

12 rows fetched.

SQL> 
SQL> --or to union all can rewrite
SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on t1.a = t2.a or t1.b = t2.b where t1.a = t2.a and t1.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
   4 - filter: T1.A = 1                                         
   5 - filter: T2.A = 1                                         
   6 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      
   7 - filter: T1.A = 1                                         
   8 - filter: T2.A = 1                                         

22 rows fetched.

SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on (t1.a = t2.a) or (t1.b = t2.b)  or t1.c = t2.c where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 9   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 10  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 11  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
   4 - filter: T1.A = 1                                         
   5 - filter: T2.A = 1                                         
   6 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: FALSE != LNNVL(T1.A = T2.A)                      
   7 - filter: T1.A = 1                                         
   8 - filter: T2.A = 1                                         
   9 - access: T1.A = T2.A AND T1.C = T2.C                      
       filter: FALSE != LNNVL(T1.B = T2.B) AND FALSE != LNNVL(T1.A = T2.A)
   10 - filter: T1.A = 1                                        
   11 - filter: T2.A = 1                                        

29 rows fetched.

SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on (t1.a = t2.a and t1.a > t2.b and t1.b >= t2.c) or (t1.b = t2.b and t1.c < t2.d and t1.d != t2.c)  or t1.c = t2.c where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 9   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 10  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 11  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
       filter: T1.A > T2.B AND T1.B >= T2.C                     
   4 - filter: T1.A = 1                                         
   5 - filter: T2.A = 1                                         
   6 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: T1.C < T2.D AND T1.D != T2.C AND FALSE != LNNVL(T1.A = T2.A) OR FALSE != LNNVL(T1.A > T2.B) OR 
               FALSE != LNNVL(T1.B >= T2.C)                     
   7 - filter: T1.A = 1                                         
   8 - filter: T2.A = 1                                         
   9 - access: T1.C = T2.C AND T1.A = T2.A                      
       filter: FALSE != LNNVL(T1.B = T2.B) OR FALSE != LNNVL(T1.C < T2.D) OR FALSE != LNNVL(T1.D != T2.C) AND 
               FALSE != LNNVL(T1.A = T2.A) OR FALSE != LNNVL(T1.A > T2.B) OR FALSE != LNNVL(T1.B >= T2.C)
   10 - filter: T1.A = 1                                        
   11 - filter: T2.A = 1                                        

32 rows fetched.

SQL> explain select * from t_or2union_1 t1 left join t_or2union_2 t2 on (t1.a = t2.a and t1.a like to_char('%' || t2.b || '%') and t1.b is not null and t1.d regexp 1) or (t1.b = t2.b and t1.d != t2.c)  or t1.c = t2.c where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 9   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 10  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 11  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
       filter: T1.A LIKE TO_CHAR('%' || T2.B || '%')            
   4 - filter: T1.A = 1 AND T1.B IS NOT NULL AND T1.D REGEXP 1  
   5 - filter: T2.A = 1                                         
   6 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: T1.D != T2.C AND FALSE != LNNVL(T1.A = T2.A) OR FALSE != LNNVL(T1.A LIKE TO_CHAR('%' || 
               T2.B || '%')) OR FALSE != LNNVL(T1.B IS NOT NULL) OR FALSE != LNNVL(T1.D REGEXP 1)
   7 - filter: T1.A = 1                                         
   8 - filter: T2.A = 1                                         
   9 - access: T1.C = T2.C AND T1.A = T2.A                      
       filter: FALSE != LNNVL(T1.B = T2.B) OR FALSE != LNNVL(T1.D != T2.C) AND FALSE != LNNVL(T1.A = T2.A) OR 
               FALSE != LNNVL(T1.A LIKE TO_CHAR('%' || T2.B || '%')) OR FALSE != LNNVL(T1.B IS NOT NULL) OR 
               FALSE != LNNVL(T1.D REGEXP 1)                    
   10 - filter: T1.A = 1                                        
   11 - filter: T2.A = 1                                        

33 rows fetched.

SQL> explain select * from t_or2union_1 t1 full join t_or2union_2 t2 on (t1.a = t2.a and t1.a > t2.b and 1=1) or (t1.b = t2.b and t1.c < t2.d and t1.d != t2.c)  or t1.c = t2.c or 1!=1 where t1.a = 1 and t2.a = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                 |      |      |       |        |
| 1   |   SUBSELECT                |       |                 |      |      |       |        |
| 2   |     UNION ALL              |       |                 |      |      |       |        |
| 3   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 5   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 6   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 7   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 8   |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
| 9   |       HASH JOIN(L)         |       |                 |      |      |       |        |
| 10  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 T1 |      |      |       |        |
| 11  |         TABLE ACCESS FULL  | SYS   | T_OR2UNION_2 T2 |      |      |       |        |
---------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   3 - access: T1.A = T2.A                                      
       filter: T1.A > T2.B                                      
   4 - filter: T1.A = 1                                         
   5 - filter: T2.A = 1                                         
   6 - access: T1.A = T2.A AND T1.B = T2.B                      
       filter: T1.C < T2.D AND T1.D != T2.C AND FALSE != LNNVL(T1.A = T2.A) OR FALSE != LNNVL(T1.A > T2.B)
   7 - filter: T1.A = 1                                         
   8 - filter: T2.A = 1                                         
   9 - access: T1.C = T2.C AND T1.A = T2.A                      
       filter: FALSE != LNNVL(T1.B = T2.B) OR FALSE != LNNVL(T1.C < T2.D) OR FALSE != LNNVL(T1.D != T2.C) AND 
               FALSE != LNNVL(T1.A = T2.A) OR FALSE != LNNVL(T1.A > T2.B)
   10 - filter: T1.A = 1                                        
   11 - filter: T2.A = 1                                        

31 rows fetched.

SQL> 
SQL> 
SQL> drop table if exists t_or2union_2;

Succeed.

SQL> drop table if exists t_or2union_3;

Succeed.

SQL> drop table if exists t_or2union_4;

Succeed.

SQL> drop table if exists t_or2union_5;

Succeed.

SQL> drop table if exists t_or2union_6;

Succeed.

SQL> 
SQL> --view with scn
SQL> create view v_or2union_1 as select * from t_or2union_1;

Succeed.

SQL> explain select * from v_or2union_1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name         | Rows | Cost | Bytes | Remark |
------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |              |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 |      |      |       |        |
------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain select * from v_or2union_1 as of scn 2194944746815489;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |              |      |      |       |        |
| 1   |   VIEW                 | SYS   | V_OR2UNION_1 |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | T_OR2UNION_1 |      |      |       |        |
--------------------------------------------------------------------------------------

7 rows fetched.

SQL> drop view v_or2union_1;

Succeed.

SQL> drop table if exists t_or2union_1;

Succeed.

SQL> 
SQL> --DTS2019110503063
SQL> drop table if exists explain_t1;

Succeed.

SQL> drop table if exists explain_t2;

Succeed.

SQL> create table explain_t1(f_int1 int, f_int2 int);

Succeed.

SQL> create table explain_t2(f_int1 int, f_int2 int);

Succeed.

SQL> insert into explain_t1(f_int1, f_int2) values(1,1);

1 rows affected.

SQL> insert into explain_t2(f_int1, f_int2) values(1,2);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> select t2.f_int1,
  2       (select x
  3          from (select abs(t2.f_int1 - t1.f_int1) x, t1.f_int2
  4                  from explain_t1 t1 order by 1,2)) as F_INT2
  5  from (select t2.f_int1
  6          from explain_t2 t2
  7         group by t2.f_int1) t2
  8 group by t2.f_int1;

F_INT1       F_INT2                                  
------------ ----------------------------------------
1            0                                       

1 rows fetched.

SQL> drop table explain_t1;

Succeed.

SQL> drop table explain_t2;

Succeed.

SQL> --DTS2019110600846
SQL> drop table if exists t_dense_rank;

Succeed.

SQL> create table t_dense_rank(a int constraint cons1_dense_rank primary key,b int);

Succeed.

SQL> insert into t_dense_rank values(1,1);

1 rows affected.

SQL> insert into t_dense_rank values(2,3);

1 rows affected.

SQL> insert into t_dense_rank values(3,7);

1 rows affected.

SQL> insert into t_dense_rank values(4,5);

1 rows affected.

SQL> insert into t_dense_rank values(5,2);

1 rows affected.

SQL> explain select dense_rank(2) within group(order by a) from t_dense_rank group by a;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------
| Id  | Description                     | Owner | Name             | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                |       |                  |      |      |       |        |
| 1   |   INDEX GROUP BY                |       |                  |      |      |       |        |
| 2   |     TABLE ACCESS BY INDEX ONLY  | SYS   | T_DENSE_RANK     |      |      |       |        |
| 3   |       INDEX FULL SCAN           | SYS   | CONS1_DENSE_RANK |      |      |       |        |
---------------------------------------------------------------------------------------------------

8 rows fetched.

SQL> select dense_rank(2) within group(order by a) from t_dense_rank group by a;

DENSE_RANK(2) WITHIN GROUP(ORDER BY A)
--------------------------------------
2                                     
1                                     
1                                     
1                                     
1                                     

5 rows fetched.

SQL> --DTS2020021107784
SQL> drop table if exists t_DTS2020021107784;

Succeed.

SQL> create table t_DTS2020021107784(
  2 id int,c_int int,c_real real,c_float float,c_decimal decimal,c_number number,
  3 c_char char(10),c_vchar varchar(10) not null,c_vchar2 varchar2(100),c_clob clob,
  4 c_long varchar(200),c_blob blob,c_raw raw(100),c_date date,c_timestamp timestamp);

Succeed.

SQL> insert into t_DTS2020021107784 values(1,1000,100.123,100.456,100.789,100.123,'abc123','abcdefg',lpad('123abc',50,'abc'),lpad('123abc',50,'abc'),lpad('11100000',50,'1100'),lpad('11100001',50,'1100'),lpad('11100011',50,'1100'),to_timestamp(to_char('1800-01-01 10:51:47'),'yyyy-mm-dd hh24:mi:ss'),to_timestamp(to_char('1800-03-05 10:51:47'),'yyyy-mm-dd hh24:mi:ss'));

1 rows affected.

SQL> insert into t_DTS2020021107784 values(-1,null,null,null,null,null,null,'M',null,null,null,null,null,null,null);

1 rows affected.

SQL> CREATE or replace procedure proc_insert(tname varchar,startall int,endall int) as
  2 sqlst varchar(500);
  3 BEGIN
  4   FOR i IN startall..endall LOOP
  5                 sqlst := 'insert into ' || tname ||' select id+'||i||',c_int+'||i||',c_real+'||i||',c_float+'||i||',c_decimal+'||i||',c_number+'||i||',c_char'||',c_vchar||'||i||',c_vchar2||'||i||',c_clob||'||i||',c_long||'||i||',c_blob'||',c_raw,ADD_MONTHS(c_date,'||i||'),ADD_MONTHS(c_timestamp,'||i||') from '||tname|| ' where id=1';
  6         execute immediate sqlst;
  7   END LOOP;
  8 END;
  9 /

Succeed.

SQL> exec proc_insert('t_DTS2020021107784',1,20);

PL/SQL procedure successfully completed.

SQL> commit;

Succeed.

SQL> explain with w_1 as(select sum(id) over(partition by id) id,to_char(c_clob) c_clob from t_DTS2020021107784)select count(*) from w_1 t1 join w_1 t2 on t1.c_clob>t2.c_clob or t1.id=t2.id,w_1 t3 left join w_1 t4 on t4.id=t3.id where exists(select id from w_1 where t2.id=id);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                 | Owner | Name               | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT            |       |                    |      |      |       |        |
| 1   |   TEMP TABLE TRANSFORMATION |       |                    |      |      |       |        |
| 2   |     LOAD AS SELECT          |       | VW_FWQ_0           |      |      |       |        |
| 3   |       WINDOW SORT           |       |                    |      |      |       |        |
| 4   |         TABLE ACCESS FULL   | SYS   | T_DTS2020021107784 |      |      |       |        |
| 5   |   AGGR                      |       |                    |      |      |       |        |
| 6   |     NESTED LOOPS            |       |                    |      |      |       |        |
| 7   |       HASH JOIN SEMI(R)     |       |                    |      |      |       |        |
| 8   |         NESTED LOOPS        |       |                    |      |      |       |        |
| 9   |           TABLE ACCESS FULL |       | VW_FWQ_0 T1        |      |      |       |        |
| 10  |           TABLE ACCESS FULL |       | VW_FWQ_0 T2        |      |      |       |        |
| 11  |         SUBSELECT           |       |                    |      |      |       |        |
| 12  |           TABLE ACCESS FULL |       | VW_FWQ_0           |      |      |       |        |
| 13  |       HASH JOIN OUTER(R)    |       |                    |      |      |       |        |
| 14  |         TABLE ACCESS FULL   |       | VW_FWQ_0 T3        |      |      |       |        |
| 15  |         TABLE ACCESS FULL   |       | VW_FWQ_0 T4        |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   7 - access: T2.ID = ID                                       
   11 - filter: T1.C_CLOB > T2.C_CLOB OR T1.ID = T2.ID          
   13 - access: T3.ID = T4.ID                                   

25 rows fetched.

SQL> with w_1 as(select sum(id) over(partition by id) id,to_char(c_clob) c_clob from t_DTS2020021107784)select count(*) from w_1 t1 join w_1 t2 on t1.c_clob>t2.c_clob or t1.id=t2.id,w_1 t3 left join w_1 t4 on t4.id=t3.id where exists(select id from w_1 where t2.id=id);

COUNT(*)            
--------------------
5104                

1 rows fetched.

SQL> --DTS2020021211230
SQL> create index idx_DTS2020021211230_1 on t_DTS2020021107784(c_int,c_vchar,c_vchar2,c_date);

Succeed.

SQL> create unique index idx_DTS2020021211230_2 on t_DTS2020021107784(c_real,c_vchar);

Succeed.

SQL> create index idx_DTS2020021211230_3 on t_DTS2020021107784(to_char(c_number));

Succeed.

SQL> explain with w_1 as(select sum(id) over(partition by id) id from t_DTS2020021107784)select count(*) from t_DTS2020021107784 t1 inner join w_1 t2 on t1.id>t2.id where exists(select id from t_DTS2020021107784 where t2.id=id);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                  | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                       |      |      |       |        |
| 1   |   AGGR                         |       |                       |      |      |       |        |
| 2   |     MERGE JOIN                 |       |                       |      |      |       |        |
| 3   |       HASH JOIN SEMI(R)        |       |                       |      |      |       |        |
| 4   |         SUBSELECT              |       | W_1 T2                |      |      |       |        |
| 5   |           WINDOW SORT          |       |                       |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | T_DTS2020021107784    |      |      |       |        |
| 7   |         SUBSELECT              |       |                       |      |      |       |        |
| 8   |           TABLE ACCESS FULL    | SYS   | T_DTS2020021107784    |      |      |       |        |
| 9   |       TABLE ACCESS FULL        | SYS   | T_DTS2020021107784 T1 |      |      |       |        |
-------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.ID < T1.ID                                    
   3 - access: T2.ID = ID                                       

18 rows fetched.

SQL> with w_1 as(select sum(id) over(partition by id) id from t_DTS2020021107784)select count(*) from t_DTS2020021107784 t1 inner join w_1 t2 on t1.id>t2.id where exists(select id from t_DTS2020021107784 where t2.id=id);

COUNT(*)            
--------------------
231                 

1 rows fetched.

SQL> drop table t_DTS2020021107784;

Succeed.

SQL> 
SQL> drop table if exists no_scan_1;

Succeed.

SQL> drop table if exists no_scan_2;

Succeed.

SQL> create table no_scan_1 (a int not null, b int, c varchar(10));

Succeed.

SQL> create table no_scan_2 (a int not null, b int, c varchar(10));

Succeed.

SQL> 
SQL> explain select * from no_scan_1 where 1<>1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------
| Id  | Description            | Owner | Name      | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |           |      |      |       |        |
| 1   |   ROWNUM COUNT         |       |           |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | NO_SCAN_1 |      |      |       |        |
-----------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NULL IS NOT NULL                                 

10 rows fetched.

SQL> explain select t1.a, t2.b from no_scan_1 t1 join no_scan_2 t2 on t1.a = t2.a where rownum = -1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name         | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |              |      |      |       |        |
| 1   |   ROWNUM FILTER          |       |              |      |      |       |        |
| 2   |     NESTED LOOPS         |       |              |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | NO_SCAN_1 T1 |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | NO_SCAN_2 T2 |      |      |       |        |
----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NULL IS NOT NULL                                 

12 rows fetched.

SQL> explain select * from no_scan_1 where 1<>1 union select * from no_scan_2 ;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name      | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |           |      |      |       |        |
| 1   |   HASH UNION             |       |           |      |      |       |        |
| 2   |     ROWNUM COUNT         |       |           |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | NO_SCAN_1 |      |      |       |        |
| 4   |     TABLE ACCESS FULL    | SYS   | NO_SCAN_2 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: NULL IS NOT NULL                                 

12 rows fetched.

SQL> explain select count(*) from no_scan_1 t1 where a in (select b from no_scan_2 t2 where t2.a = t1.a and 1<>1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description                  | Owner | Name         | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT             |       |              |      |      |       |        |
| 1   |   AGGR                       |       |              |      |      |       |        |
| 2   |     HASH JOIN SEMI(L)        |       |              |      |      |       |        |
| 3   |       SUBSELECT              |       |              |      |      |       |        |
| 4   |         ROWNUM COUNT         |       |              |      |      |       |        |
| 5   |           TABLE ACCESS FULL  | SYS   | NO_SCAN_2 T2 |      |      |       |        |
| 6   |       TABLE ACCESS FULL      | SYS   | NO_SCAN_1 T1 |      |      |       |        |
--------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: T2.B = A                                         
   4 - filter: NULL IS NOT NULL                                 

15 rows fetched.

SQL> drop table no_scan_1;

Succeed.

SQL> drop table no_scan_2;

Succeed.

SQL> 
SQL> drop table if exists t_const2num_1;

Succeed.

SQL> drop table if exists t_const2num_2;

Succeed.

SQL> create table t_const2num_1(
  2 c_int int, c_binary_uint binary_uint32, c_int_unsigned integer unsigned, c_bigint bigint,
  3 c_double double, c_float float, c_real real,
  4 c_number number, c_dec decimal(20,5),
  5 c_varchar varchar(50)
  6 ) ;

Succeed.

SQL> create table t_const2num_2(
  2 c_int int, c_binary_uint binary_uint32, c_int_unsigned integer unsigned, c_bigint bigint,
  3 c_double double, c_float float, c_real real,
  4 c_number number, c_dec decimal(20,5),
  5 c_varchar varchar(50)
  6 ) ;

Succeed.

SQL> insert into t_const2num_1 values(
  2 1, 5, 4294967295, 9223372036854775807,
  3 1.12345, 0.001, 123.456,
  4 1.234, 123456.12345,
  5 'hello'
  6 );

1 rows affected.

SQL> insert into t_const2num_2 values(
  2 1, 100, 4294967295, 9223372036854775807,
  3 1.12345, 10.00001, 1234.567,
  4 1.234, 123456.12345,
  5 'nihao'
  6 );

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> explain select c_int, c_varchar from t_const2num_1 where c_int = '1';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_INT = 1                                        

9 rows fetched.

SQL> explain select c_int, c_varchar from t_const2num_1 where c_bigint = '9223372036854775807';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_BIGINT = 9223372036854775807                   

9 rows fetched.

SQL> explain select c_int, c_varchar from t_const2num_1 where '-1.001' < c_real;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: -1.001 < C_REAL                                  

9 rows fetched.

SQL> explain select c_int, c_varchar from t_const2num_1 where abs(c_number) = '+1.234';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: ABS(C_NUMBER) = 1.234                            

9 rows fetched.

SQL> explain select c_int, c_varchar from t_const2num_1 where c_dec + 1 = '123457.12345';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name          | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |               |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: C_DEC + 1 = 123457.12345                         

9 rows fetched.

SQL> explain select c_int, count(c_int) from t_const2num_1 group by c_int having count(c_int) = '1.0';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |               |      |      |       |        |
| 1   |   HAVING                 |       |               |      |      |       |        |
| 2   |     HASH GROUP BY        |       |               |      |      |       |        |
| 3   |       TABLE ACCESS FULL  | SYS   | T_CONST2NUM_1 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: COUNT(C_INT) = 1                                 

11 rows fetched.

SQL> explain select c_int, c_varchar from t_const2num_1 where '1' = (select count(*) from t_const2num_2);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------
| Id  | Description              | Owner | Name          | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT         |       |               |      |      |       |        |
| 1   |   KERNEL FILTER          |       |               |      |      |       |        |
| 2   |     TABLE ACCESS FULL    | SYS   | T_CONST2NUM_1 |      |      |       |        |
| 3   |     AGGR                 |       |               |      |      |       |        |
| 4   |       TABLE ACCESS FULL  | SYS   | T_CONST2NUM_2 |      |      |       |        |
-----------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: 1 = (SELECT COUNT(*) FROM T_CONST2NUM_2)         

12 rows fetched.

SQL> 
SQL> drop table t_const2num_1;

Succeed.

SQL> drop table t_const2num_2;

Succeed.

SQL> 
SQL> --
SQL> drop table if exists hint_index_t1;

Succeed.

SQL> create table hint_index_t1(a int, b int, c int);

Succeed.

SQL> create index hint_index_a on hint_index_t1(a);

Succeed.

SQL> create index hint_index_b on hint_index_t1(b);

Succeed.

SQL> create index hint_index_c on hint_index_t1(c);

Succeed.

SQL> alter index hint_index_a on hint_index_t1 unusable;

Succeed.

SQL> explain select /*+INDEX(i, hint_index_b)*/ i.a from hint_index_t1 i where i.b = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name            | Rows | Cost | Bytes | Remark |
-------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | HINT_INDEX_T1 I |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | HINT_INDEX_B    |      |      |       |        |
-------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: I.B = 1                                          

10 rows fetched.

SQL> explain select /*+INDEX(i, hint_index_a)*/ i.a from hint_index_t1 i where i.b = 1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name            | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                 |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | HINT_INDEX_T1 I |      |      |       |        |
---------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: I.B = 1                                          

9 rows fetched.

SQL> drop table hint_index_t1;

Succeed.

SQL> 
SQL> drop table if exists t_explain_index;

Succeed.

SQL> create table t_explain_index(id varchar(10), name varchar(10));

Succeed.

SQL> create unique index t_explain_index_idx1 on t_explain_index(id, name);

Succeed.

SQL> explain select * from t_explain_index where id='000001';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                 | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | T_EXPLAIN_INDEX      |      |      |       |        |
| 2   |     INDEX RANGE SCAN          | SYS   | T_EXPLAIN_INDEX_IDX1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: ID = '000001'                                    

10 rows fetched.

SQL> explain select * from t_explain_index where id='000001' and name='index';

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                   | Owner | Name                 | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT              |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ONLY  | SYS   | T_EXPLAIN_INDEX      |      |      |       |        |
| 2   |     INDEX UNIQUE SCAN         | SYS   | T_EXPLAIN_INDEX_IDX1 |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: NAME = 'index' AND ID = '000001'                 

10 rows fetched.

SQL> drop table t_explain_index;

Succeed.

SQL> 
SQL> -- reserved word false/true/null is const expr node
SQL> drop table if exists res_as_const_node_t1;

Succeed.

SQL> create table res_as_const_node_t1
  2 (
  3     id number(4) not null
  4 );

Succeed.

SQL> 
SQL> explain select * from res_as_const_node_t1 where false;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                 | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                      |      |      |       |        |
| 1   |   ROWNUM COUNT         |       |                      |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | RES_AS_CONST_NODE_T1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NULL IS NOT NULL                                 

10 rows fetched.

SQL> explain select * from res_as_const_node_t1 where true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
--------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name                 | Rows | Cost | Bytes | Remark |
--------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                      |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | RES_AS_CONST_NODE_T1 |      |      |       |        |
--------------------------------------------------------------------------------------------

6 rows fetched.

SQL> explain select * from res_as_const_node_t1 where null;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------
| Id  | Description            | Owner | Name                 | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT       |       |                      |      |      |       |        |
| 1   |   ROWNUM COUNT         |       |                      |      |      |       |        |
| 2   |     TABLE ACCESS FULL  | SYS   | RES_AS_CONST_NODE_T1 |      |      |       |        |
----------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - filter: NULL IS NOT NULL                                 

10 rows fetched.

SQL> drop table res_as_const_node_t1;

Succeed.

SQL> 
SQL> -- Longest table name + alias + parallel information
SQL> drop table if exists AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;

Succeed.

SQL> create table AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA(id number(8));

Succeed.

SQL> explain plan for select /*+parallel(16)*/ * from AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| Id  | Description          | Owner | Name                                                                                                                                     | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT     |       |                                                                                                                                          |      |      |       |        |
| 1   |   TABLE ACCESS FULL  | SYS   | AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB(p  16) |      |      |       |        |
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6 rows fetched.

SQL> drop table AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;

Succeed.

SQL> --20201031
SQL> drop table if exists  t_stack_or_001; 

Succeed.

SQL> create table t_stack_or_001 (id int,c1 varchar(8000),c2 varchar(8000),c3 varchar(8000)); 

Succeed.

SQL> declare 
  2 begin 
  3 for i in 1..2000 loop 
  4 insert into t_stack_or_001 values (i,rpad('12',20,2),rpad('12',20,i),rpad('23',20,i)); 
  5 end loop; 
  6 for i in 2001..4000 loop 
  7 insert into t_stack_or_001 values (i,rpad('abc',20,i),rpad('23',20,2),rpad('12',20,i)); 
  8 end loop; 
  9 for i in 4001..8000 loop 
 10 insert into t_stack_or_001 values (i,rpad('ab',20,2),rpad('45',20,2),rpad('12',20,2)); 
 11 end loop;
 12 commit; 
 13 end; 
 14 / 

PL/SQL procedure successfully completed.

SQL> drop table if exists t_stack_or_002; 

Succeed.

SQL> create table t_stack_or_002 (id int,c1 varchar(8000),c2 varchar(8000),c3 varchar(8000)); 

Succeed.

SQL> declare 
  2 begin 
  3 for i in 1..2000 loop 
  4 insert into t_stack_or_002 values (i,rpad('12',20,2),rpad('12',20,i),rpad('23',20,i)); 
  5 end loop; 
  6 for i in 2001..4000 loop 
  7 insert into t_stack_or_002 values (i,rpad('abc',20,i),rpad('23',20,2),rpad('12',20,i)); 
  8 end loop; 
  9 for i in 4001..8000 loop 
 10 insert into t_stack_or_002 values (i,rpad('ab',20,2),rpad('45',20,2),rpad('12',20,2)); 
 11 end loop; 
 12 commit; 
 13 end; 
 14 /

PL/SQL procedure successfully completed.

SQL> explain SELECT * FROM ( SELECT ROWNUM rn,  t.* FROM ( SELECT  * FROM(
  2             SELECT id,c1,c2 from t_stack_or_001 p join (select 1100 from sys_dummy
  3  MINUS select 1212 from sys_dummy MINUS select 1000 from sys_dummy MINUS select 1001 from sys_dummy MINUS select 1002 from sys_dummy MINUS select 1003 from sys_dummy
  4  MINUS select 1004 from sys_dummy MINUS select 1005 from sys_dummy MINUS select 1006 from sys_dummy MINUS select 1007 from sys_dummy MINUS select 1008 from sys_dummy
  5  MINUS select 1009 from sys_dummy MINUS select 1010 from sys_dummy MINUS select 1011 from sys_dummy MINUS select 1012 from sys_dummy MINUS select 1013 from sys_dummy
  6  MINUS select 1014 from sys_dummy MINUS select 1015 from sys_dummy MINUS select 1016 from sys_dummy MINUS select 1017 from sys_dummy MINUS select 1018 from sys_dummy
  7  MINUS select 1019 from sys_dummy MINUS select 1020 from sys_dummy MINUS select 1021 from sys_dummy MINUS select 1022 from sys_dummy MINUS select 1023 from sys_dummy
  8  MINUS select 1024 from sys_dummy MINUS select 1025 from sys_dummy MINUS select 1026 from sys_dummy MINUS select 1027 from sys_dummy MINUS select 1028 from sys_dummy
  9  MINUS select 1029 from sys_dummy MINUS select 1030 from sys_dummy MINUS select 1031 from sys_dummy MINUS select 1032 from sys_dummy MINUS select 1033 from sys_dummy
 10  MINUS select 1034 from sys_dummy MINUS select 1035 from sys_dummy MINUS select 1036 from sys_dummy MINUS select 1037 from sys_dummy MINUS select 1038 from sys_dummy
 11  MINUS select 1039 from sys_dummy MINUS select 1040 from sys_dummy MINUS select 1041 from sys_dummy MINUS select 1042 from sys_dummy MINUS select 1043 from sys_dummy
 12  MINUS select 1044 from sys_dummy MINUS select 1045 from sys_dummy MINUS select 1046 from sys_dummy MINUS select 1047 from sys_dummy MINUS select 1048 from sys_dummy
 13  MINUS select 1049 from sys_dummy MINUS select 1050 from sys_dummy MINUS select 1051 from sys_dummy MINUS select 1052 from sys_dummy MINUS select 1053 from sys_dummy
 14  MINUS select 1054 from sys_dummy MINUS select 1055 from sys_dummy MINUS select 1056 from sys_dummy MINUS select 1057 from sys_dummy MINUS select 1058 from sys_dummy
 15  MINUS select 1059 from sys_dummy MINUS select 1060 from sys_dummy MINUS select 1061 from sys_dummy MINUS select 1062 from sys_dummy MINUS select 1063 from sys_dummy
 16  MINUS select 1064 from sys_dummy MINUS select 1065 from sys_dummy MINUS select 1066 from sys_dummy MINUS select 1067 from sys_dummy MINUS select 1068 from sys_dummy
 17  MINUS select 1069 from sys_dummy MINUS select 1070 from sys_dummy MINUS select 1071 from sys_dummy MINUS select 1072 from sys_dummy MINUS select 1073 from sys_dummy
 18  MINUS select 1074 from sys_dummy MINUS select 1075 from sys_dummy MINUS select 1076 from sys_dummy MINUS select 1077 from sys_dummy MINUS select 1078 from sys_dummy
 19  MINUS select 1079 from sys_dummy MINUS select 1080 from sys_dummy MINUS select 1081 from sys_dummy MINUS select 1082 from sys_dummy MINUS select 1083 from sys_dummy
 20  MINUS select 1084 from sys_dummy MINUS select 1085 from sys_dummy MINUS select 1086 from sys_dummy MINUS select 1087 from sys_dummy MINUS select 1088 from sys_dummy
 21  MINUS select 1089 from sys_dummy MINUS select 1090 from sys_dummy MINUS select 1091 from sys_dummy MINUS select 1092 from sys_dummy MINUS select 1093 from sys_dummy
 22  MINUS select 1094 from sys_dummy MINUS select 1095 from sys_dummy MINUS select 1096 from sys_dummy MINUS select 1097 from sys_dummy MINUS select 1098 from sys_dummy
 23  MINUS select 1099 from sys_dummy MINUS select 1100 from sys_dummy MINUS select 1101 from sys_dummy MINUS select 1102 from sys_dummy MINUS select 1103 from sys_dummy
 24  MINUS select 1104 from sys_dummy MINUS select 1105 from sys_dummy MINUS select 1106 from sys_dummy MINUS select 1107 from sys_dummy MINUS select 1108 from sys_dummy
 25  MINUS select 1109 from sys_dummy MINUS select 1110 from sys_dummy MINUS select 1111 from sys_dummy MINUS select 1112 from sys_dummy MINUS select 1113 from sys_dummy
 26  MINUS select 1114 from sys_dummy MINUS select 1115 from sys_dummy MINUS select 1116 from sys_dummy MINUS select 1117 from sys_dummy MINUS select 1118 from sys_dummy
 27  MINUS select 1119 from sys_dummy MINUS select 1120 from sys_dummy MINUS select 1121 from sys_dummy MINUS select 1122 from sys_dummy MINUS select 1123 from sys_dummy
 28  MINUS select 1124 from sys_dummy MINUS select 1125 from sys_dummy MINUS select 1126 from sys_dummy MINUS select 1127 from sys_dummy MINUS select 1128 from sys_dummy
 29  MINUS select 1129 from sys_dummy MINUS select 1130 from sys_dummy MINUS select 1131 from sys_dummy MINUS select 1132 from sys_dummy MINUS select 1133 from sys_dummy
 30  MINUS select 1134 from sys_dummy MINUS select 1135 from sys_dummy MINUS select 1136 from sys_dummy MINUS select 1137 from sys_dummy MINUS select 1138 from sys_dummy
 31  MINUS select 1139 from sys_dummy MINUS select 1140 from sys_dummy MINUS select 1141 from sys_dummy MINUS select 1142 from sys_dummy MINUS select 1143 from sys_dummy
 32  MINUS select 1144 from sys_dummy MINUS select 1145 from sys_dummy MINUS select 1146 from sys_dummy MINUS select 1147 from sys_dummy MINUS select 1148 from sys_dummy
 33  MINUS select 1149 from sys_dummy MINUS select 1150 from sys_dummy MINUS select 1151 from sys_dummy MINUS select 1152 from sys_dummy MINUS select 1153 from sys_dummy
 34  MINUS select 1154 from sys_dummy MINUS select 1155 from sys_dummy MINUS select 1156 from sys_dummy MINUS select 1157 from sys_dummy MINUS select 1158 from sys_dummy
 35  MINUS select 1159 from sys_dummy MINUS select 1160 from sys_dummy MINUS select 1161 from sys_dummy MINUS select 1162 from sys_dummy MINUS select 1163 from sys_dummy
 36  MINUS select 1164 from sys_dummy MINUS select 1165 from sys_dummy MINUS select 1166 from sys_dummy MINUS select 1167 from sys_dummy MINUS select 1168 from sys_dummy
 37  MINUS select 1169 from sys_dummy MINUS select 1170 from sys_dummy MINUS select 1171 from sys_dummy MINUS select 1172 from sys_dummy MINUS select 1173 from sys_dummy
 38  MINUS select 1174 from sys_dummy MINUS select 1175 from sys_dummy MINUS select 1176 from sys_dummy MINUS select 1177 from sys_dummy MINUS select 1178 from sys_dummy
 39  MINUS select 1179 from sys_dummy MINUS select 1180 from sys_dummy MINUS select 1181 from sys_dummy MINUS select 1182 from sys_dummy MINUS select 1183 from sys_dummy
 40  MINUS select 1184 from sys_dummy MINUS select 1185 from sys_dummy MINUS select 1186 from sys_dummy MINUS select 1187 from sys_dummy MINUS select 1188 from sys_dummy
 41  MINUS select 1189 from sys_dummy MINUS select 1190 from sys_dummy MINUS select 1191 from sys_dummy MINUS select 1192 from sys_dummy MINUS select 1193 from sys_dummy
 42  MINUS select 1194 from sys_dummy MINUS select 1195 from sys_dummy MINUS select 1196 from sys_dummy MINUS select 1197 from sys_dummy MINUS select 1198 from sys_dummy
 43  MINUS select 1199 from sys_dummy MINUS select 1200 from sys_dummy MINUS select 1201 from sys_dummy MINUS select 1202 from sys_dummy MINUS select 1203 from sys_dummy
 44  MINUS select 1204 from sys_dummy MINUS select 1205 from sys_dummy MINUS select 1206 from sys_dummy MINUS select 1207 from sys_dummy MINUS select 1208 from sys_dummy
 45  MINUS select 1209 from sys_dummy MINUS select 1210 from sys_dummy MINUS select 1211 from sys_dummy MINUS select 1212 from sys_dummy MINUS select 1213 from sys_dummy
 46  MINUS select 1214 from sys_dummy MINUS select 1215 from sys_dummy MINUS select 1216 from sys_dummy MINUS select 1217 from sys_dummy MINUS select 1218 from sys_dummy
 47  MINUS select 1219 from sys_dummy MINUS select 1220 from sys_dummy MINUS select 1221 from sys_dummy MINUS select 1222 from sys_dummy MINUS select 1223 from sys_dummy
 48  MINUS select 1224 from sys_dummy MINUS select 1225 from sys_dummy MINUS select 1226 from sys_dummy MINUS select 1227 from sys_dummy MINUS select 1228 from sys_dummy
 49  MINUS select 1229 from sys_dummy MINUS select 1230 from sys_dummy MINUS select 1231 from sys_dummy MINUS select 1232 from sys_dummy MINUS select 1233 from sys_dummy
 50  MINUS select 1234 from sys_dummy MINUS select 1235 from sys_dummy MINUS select 1236 from sys_dummy MINUS select 1237 from sys_dummy MINUS select 1238 from sys_dummy
 51  MINUS select 1239 from sys_dummy MINUS select 1240 from sys_dummy MINUS select 1241 from sys_dummy MINUS select 1242 from sys_dummy MINUS select 1243 from sys_dummy
 52  MINUS select 1244 from sys_dummy MINUS select 1245 from sys_dummy MINUS select 1246 from sys_dummy MINUS select 1247 from sys_dummy MINUS select 1248 from sys_dummy
 53  MINUS select 1249 from sys_dummy MINUS select 1250 from sys_dummy MINUS select 1251 from sys_dummy MINUS select 1252 from sys_dummy MINUS select 1253 from sys_dummy
 54  MINUS select 1254 from sys_dummy MINUS select 1255 from sys_dummy MINUS select 1256 from sys_dummy MINUS select 1257 from sys_dummy MINUS select 1258 from sys_dummy
 55  MINUS select 1259 from sys_dummy MINUS select 1260 from sys_dummy MINUS select 1261 from sys_dummy MINUS select 1262 from sys_dummy MINUS select 1263 from sys_dummy
 56  MINUS select 1264 from sys_dummy MINUS select 1265 from sys_dummy MINUS select 1266 from sys_dummy MINUS select 1267 from sys_dummy MINUS select 1268 from sys_dummy
 57  MINUS select 1269 from sys_dummy MINUS select 1270 from sys_dummy MINUS select 1271 from sys_dummy MINUS select 1272 from sys_dummy MINUS select 1273 from sys_dummy
 58  MINUS select 1274 from sys_dummy MINUS select 1275 from sys_dummy MINUS select 1276 from sys_dummy MINUS select 1277 from sys_dummy MINUS select 1278 from sys_dummy
 59  MINUS select 1279 from sys_dummy MINUS select 1280 from sys_dummy MINUS select 1281 from sys_dummy MINUS select 1282 from sys_dummy MINUS select 1283 from sys_dummy
 60  MINUS select 1284 from sys_dummy MINUS select 1285 from sys_dummy MINUS select 1286 from sys_dummy MINUS select 1287 from sys_dummy MINUS select 1288 from sys_dummy
 61  MINUS select 1289 from sys_dummy MINUS select 1290 from sys_dummy MINUS select 1291 from sys_dummy MINUS select 1292 from sys_dummy MINUS select 1293 from sys_dummy
 62  MINUS select 1294 from sys_dummy MINUS select 1295 from sys_dummy MINUS select 1296 from sys_dummy MINUS select 1297 from sys_dummy MINUS select 1298 from sys_dummy
 63  MINUS select 1299 from sys_dummy MINUS select 1300 from sys_dummy MINUS select 1301 from sys_dummy MINUS select 1302 from sys_dummy MINUS select 1303 from sys_dummy
 64  MINUS select 1304 from sys_dummy MINUS select 1305 from sys_dummy MINUS select 1306 from sys_dummy MINUS select 1307 from sys_dummy MINUS select 1308 from sys_dummy
 65  MINUS select 1309 from sys_dummy MINUS select 1310 from sys_dummy MINUS select 1311 from sys_dummy MINUS select 1312 from sys_dummy MINUS select 1313 from sys_dummy
 66  MINUS select 1314 from sys_dummy MINUS select 1315 from sys_dummy MINUS select 1316 from sys_dummy MINUS select 1317 from sys_dummy MINUS select 1318 from sys_dummy
 67  MINUS select 1319 from sys_dummy MINUS select 1320 from sys_dummy MINUS select 1321 from sys_dummy MINUS select 1322 from sys_dummy MINUS select 1323 from sys_dummy
 68  MINUS select 1324 from sys_dummy MINUS select 1325 from sys_dummy MINUS select 1326 from sys_dummy MINUS select 1327 from sys_dummy MINUS select 1328 from sys_dummy
 69  MINUS select 1329 from sys_dummy MINUS select 1330 from sys_dummy MINUS select 1331 from sys_dummy MINUS select 1332 from sys_dummy MINUS select 1333 from sys_dummy
 70  MINUS select 1334 from sys_dummy MINUS select 1335 from sys_dummy MINUS select 1336 from sys_dummy MINUS select 1337 from sys_dummy MINUS select 1338 from sys_dummy
 71  MINUS select 1339 from sys_dummy MINUS select 1340 from sys_dummy MINUS select 1341 from sys_dummy MINUS select 1342 from sys_dummy MINUS select 1343 from sys_dummy
 72  MINUS select 1344 from sys_dummy MINUS select 1345 from sys_dummy MINUS select 1346 from sys_dummy MINUS select 1347 from sys_dummy MINUS select 1348 from sys_dummy
 73  MINUS select 1349 from sys_dummy MINUS select 1350 from sys_dummy MINUS select 1351 from sys_dummy MINUS select 1352 from sys_dummy MINUS select 1353 from sys_dummy
 74  MINUS select 1354 from sys_dummy MINUS select 1399 from sys_dummy MINUS select 1384 from sys_dummy MINUS select 1444 from sys_dummy MINUS select 1748 from sys_dummy
 75  MINUS select 1355 from sys_dummy MINUS select 1400 from sys_dummy MINUS select 1385 from sys_dummy MINUS select 1445 from sys_dummy MINUS select 1749 from sys_dummy
 76  MINUS select 1356 from sys_dummy MINUS select 1401 from sys_dummy MINUS select 1386 from sys_dummy MINUS select 1446 from sys_dummy MINUS select 1750 from sys_dummy
 77  MINUS select 1357 from sys_dummy MINUS select 1402 from sys_dummy MINUS select 1387 from sys_dummy MINUS select 1447 from sys_dummy MINUS select 1751 from sys_dummy
 78  MINUS select 1358 from sys_dummy MINUS select 1403 from sys_dummy MINUS select 1388 from sys_dummy MINUS select 1448 from sys_dummy MINUS select 1752 from sys_dummy
 79  MINUS select 1359 from sys_dummy MINUS select 1404 from sys_dummy MINUS select 1389 from sys_dummy MINUS select 1449 from sys_dummy MINUS select 1753 from sys_dummy
 80  MINUS select 1360 from sys_dummy MINUS select 1405 from sys_dummy MINUS select 1390 from sys_dummy MINUS select 1450 from sys_dummy MINUS select 1754 from sys_dummy
 81  MINUS select 1361 from sys_dummy MINUS select 1406 from sys_dummy MINUS select 1391 from sys_dummy MINUS select 1451 from sys_dummy MINUS select 1755 from sys_dummy
 82  MINUS select 1362 from sys_dummy MINUS select 1407 from sys_dummy MINUS select 1392 from sys_dummy MINUS select 1452 from sys_dummy MINUS select 1756 from sys_dummy
 83  MINUS select 1363 from sys_dummy MINUS select 1408 from sys_dummy MINUS select 1393 from sys_dummy MINUS select 1453 from sys_dummy MINUS select 1757 from sys_dummy
 84  MINUS select 1364 from sys_dummy MINUS select 1409 from sys_dummy MINUS select 1394 from sys_dummy MINUS select 1454 from sys_dummy MINUS select 1758 from sys_dummy
 85  MINUS select 1365 from sys_dummy MINUS select 1410 from sys_dummy MINUS select 1395 from sys_dummy MINUS select 1455 from sys_dummy MINUS select 1759 from sys_dummy
 86  MINUS select 1366 from sys_dummy MINUS select 1411 from sys_dummy MINUS select 1396 from sys_dummy MINUS select 1456 from sys_dummy MINUS select 1760 from sys_dummy
 87  MINUS select 1367 from sys_dummy MINUS select 1412 from sys_dummy MINUS select 1397 from sys_dummy MINUS select 1457 from sys_dummy MINUS select 1761 from sys_dummy
 88  MINUS select 1368 from sys_dummy MINUS select 1413 from sys_dummy MINUS select 1398 from sys_dummy MINUS select 1458 from sys_dummy MINUS select 1762 from sys_dummy
 89  MINUS select 1369 from sys_dummy MINUS select 1414 from sys_dummy MINUS select 1429 from sys_dummy MINUS select 1459 from sys_dummy MINUS select 1763 from sys_dummy
 90  MINUS select 1370 from sys_dummy MINUS select 1415 from sys_dummy MINUS select 1430 from sys_dummy MINUS select 1460 from sys_dummy MINUS select 1764 from sys_dummy
 91  MINUS select 1371 from sys_dummy MINUS select 1416 from sys_dummy MINUS select 1431 from sys_dummy MINUS select 1461 from sys_dummy MINUS select 1765 from sys_dummy
 92  MINUS select 1372 from sys_dummy MINUS select 1417 from sys_dummy MINUS select 1432 from sys_dummy MINUS select 1462 from sys_dummy MINUS select 1766 from sys_dummy
 93  MINUS select 1373 from sys_dummy MINUS select 1418 from sys_dummy MINUS select 1433 from sys_dummy MINUS select 1463 from sys_dummy MINUS select 1767 from sys_dummy
 94  MINUS select 1374 from sys_dummy MINUS select 1419 from sys_dummy MINUS select 1434 from sys_dummy MINUS select 1464 from sys_dummy MINUS select 1768 from sys_dummy
 95  MINUS select 1375 from sys_dummy MINUS select 1420 from sys_dummy MINUS select 1435 from sys_dummy MINUS select 1465 from sys_dummy MINUS select 1733 from sys_dummy
 96  MINUS select 1376 from sys_dummy MINUS select 1421 from sys_dummy MINUS select 1436 from sys_dummy MINUS select 1466 from sys_dummy MINUS select 1734 from sys_dummy
 97  MINUS select 1377 from sys_dummy MINUS select 1422 from sys_dummy MINUS select 1437 from sys_dummy MINUS select 1467 from sys_dummy MINUS select 1735 from sys_dummy
 98  MINUS select 1378 from sys_dummy MINUS select 1423 from sys_dummy MINUS select 1438 from sys_dummy MINUS select 1468 from sys_dummy MINUS select 1736 from sys_dummy
 99  MINUS select 1379 from sys_dummy MINUS select 1424 from sys_dummy MINUS select 1439 from sys_dummy MINUS select 1469 from sys_dummy MINUS select 1737 from sys_dummy
100  MINUS select 1380 from sys_dummy MINUS select 1425 from sys_dummy MINUS select 1440 from sys_dummy MINUS select 1470 from sys_dummy MINUS select 1738 from sys_dummy
101  MINUS select 1381 from sys_dummy MINUS select 1426 from sys_dummy MINUS select 1441 from sys_dummy MINUS select 1471 from sys_dummy MINUS select 1739 from sys_dummy
102  MINUS select 1382 from sys_dummy MINUS select 1427 from sys_dummy MINUS select 1442 from sys_dummy MINUS select 1472 from sys_dummy MINUS select 1740 from sys_dummy
103  MINUS select 1383 from sys_dummy MINUS select 1428 from sys_dummy MINUS select 1443 from sys_dummy MINUS select 1473 from sys_dummy MINUS select 1741 from sys_dummy
104  MINUS select 1474 from sys_dummy MINUS select 1769 from sys_dummy MINUS select 1636 from sys_dummy MINUS select 1931 from sys_dummy MINUS select 1742 from sys_dummy
105  MINUS select 1475 from sys_dummy MINUS select 1770 from sys_dummy MINUS select 1637 from sys_dummy MINUS select 1932 from sys_dummy MINUS select 1743 from sys_dummy
106  MINUS select 1476 from sys_dummy MINUS select 1771 from sys_dummy MINUS select 1638 from sys_dummy MINUS select 1933 from sys_dummy MINUS select 1744 from sys_dummy
107  MINUS select 1477 from sys_dummy MINUS select 1772 from sys_dummy MINUS select 1639 from sys_dummy MINUS select 1934 from sys_dummy MINUS select 1745 from sys_dummy
108  MINUS select 1478 from sys_dummy MINUS select 1773 from sys_dummy MINUS select 1640 from sys_dummy MINUS select 1935 from sys_dummy MINUS select 1746 from sys_dummy
109  MINUS select 1479 from sys_dummy MINUS select 1774 from sys_dummy MINUS select 1641 from sys_dummy MINUS select 1936 from sys_dummy MINUS select 1704 from sys_dummy
110  MINUS select 1480 from sys_dummy MINUS select 1775 from sys_dummy MINUS select 1642 from sys_dummy MINUS select 1937 from sys_dummy MINUS select 1705 from sys_dummy
111  MINUS select 1481 from sys_dummy MINUS select 1776 from sys_dummy MINUS select 1643 from sys_dummy MINUS select 1938 from sys_dummy MINUS select 1706 from sys_dummy
112  MINUS select 1482 from sys_dummy MINUS select 1777 from sys_dummy MINUS select 1644 from sys_dummy MINUS select 1939 from sys_dummy MINUS select 1707 from sys_dummy
113  MINUS select 1483 from sys_dummy MINUS select 1778 from sys_dummy MINUS select 1645 from sys_dummy MINUS select 1940 from sys_dummy MINUS select 1708 from sys_dummy
114  MINUS select 1484 from sys_dummy MINUS select 1779 from sys_dummy MINUS select 1646 from sys_dummy MINUS select 1941 from sys_dummy MINUS select 1709 from sys_dummy
115  MINUS select 1485 from sys_dummy MINUS select 1780 from sys_dummy MINUS select 1647 from sys_dummy MINUS select 1942 from sys_dummy MINUS select 1710 from sys_dummy
116  MINUS select 1486 from sys_dummy MINUS select 1781 from sys_dummy MINUS select 1648 from sys_dummy MINUS select 1943 from sys_dummy MINUS select 1711 from sys_dummy
117  MINUS select 1487 from sys_dummy MINUS select 1782 from sys_dummy MINUS select 1649 from sys_dummy MINUS select 1944 from sys_dummy MINUS select 1712 from sys_dummy
118  MINUS select 1488 from sys_dummy MINUS select 1783 from sys_dummy MINUS select 1650 from sys_dummy MINUS select 1945 from sys_dummy MINUS select 1713 from sys_dummy
119  MINUS select 1489 from sys_dummy MINUS select 1784 from sys_dummy MINUS select 1651 from sys_dummy MINUS select 1946 from sys_dummy MINUS select 1714 from sys_dummy
120  MINUS select 1490 from sys_dummy MINUS select 1785 from sys_dummy MINUS select 1652 from sys_dummy MINUS select 1947 from sys_dummy MINUS select 1715 from sys_dummy
121  MINUS select 1491 from sys_dummy MINUS select 1786 from sys_dummy MINUS select 1653 from sys_dummy MINUS select 1948 from sys_dummy MINUS select 1716 from sys_dummy
122  MINUS select 1492 from sys_dummy MINUS select 1787 from sys_dummy MINUS select 1654 from sys_dummy MINUS select 1949 from sys_dummy MINUS select 1717 from sys_dummy
123  MINUS select 1493 from sys_dummy MINUS select 1788 from sys_dummy MINUS select 1655 from sys_dummy MINUS select 1950 from sys_dummy MINUS select 1718 from sys_dummy
124  MINUS select 1494 from sys_dummy MINUS select 1789 from sys_dummy MINUS select 1656 from sys_dummy MINUS select 1951 from sys_dummy MINUS select 1719 from sys_dummy
125  MINUS select 1495 from sys_dummy MINUS select 1790 from sys_dummy MINUS select 1657 from sys_dummy MINUS select 1952 from sys_dummy MINUS select 1720 from sys_dummy
126  MINUS select 1496 from sys_dummy MINUS select 1791 from sys_dummy MINUS select 1658 from sys_dummy MINUS select 1953 from sys_dummy MINUS select 1721 from sys_dummy
127  MINUS select 1497 from sys_dummy MINUS select 1792 from sys_dummy MINUS select 1659 from sys_dummy MINUS select 1954 from sys_dummy MINUS select 1722 from sys_dummy
128  MINUS select 1498 from sys_dummy MINUS select 1793 from sys_dummy MINUS select 1660 from sys_dummy MINUS select 1955 from sys_dummy MINUS select 1723 from sys_dummy
129  MINUS select 1499 from sys_dummy MINUS select 1794 from sys_dummy MINUS select 1661 from sys_dummy MINUS select 1956 from sys_dummy MINUS select 1724 from sys_dummy
130  MINUS select 1500 from sys_dummy MINUS select 1795 from sys_dummy MINUS select 1662 from sys_dummy MINUS select 1957 from sys_dummy MINUS select 1725 from sys_dummy
131  MINUS select 1501 from sys_dummy MINUS select 1796 from sys_dummy MINUS select 1663 from sys_dummy MINUS select 1958 from sys_dummy MINUS select 1726 from sys_dummy
132  MINUS select 1502 from sys_dummy MINUS select 1797 from sys_dummy MINUS select 1664 from sys_dummy MINUS select 1959 from sys_dummy MINUS select 1727 from sys_dummy
133  MINUS select 1503 from sys_dummy MINUS select 1798 from sys_dummy MINUS select 1665 from sys_dummy MINUS select 1960 from sys_dummy MINUS select 1728 from sys_dummy
134  MINUS select 1504 from sys_dummy MINUS select 1799 from sys_dummy MINUS select 1666 from sys_dummy MINUS select 1961 from sys_dummy MINUS select 1729 from sys_dummy
135  MINUS select 1505 from sys_dummy MINUS select 1800 from sys_dummy MINUS select 1667 from sys_dummy MINUS select 1962 from sys_dummy MINUS select 1730 from sys_dummy
136  MINUS select 1506 from sys_dummy MINUS select 1801 from sys_dummy MINUS select 1668 from sys_dummy MINUS select 1963 from sys_dummy MINUS select 1731 from sys_dummy
137  MINUS select 1507 from sys_dummy MINUS select 1802 from sys_dummy MINUS select 1673 from sys_dummy MINUS select 1968 from sys_dummy MINUS select 1732 from sys_dummy
138  MINUS select 1508 from sys_dummy MINUS select 1803 from sys_dummy MINUS select 1674 from sys_dummy MINUS select 1969 from sys_dummy MINUS select 1747 from sys_dummy
139  MINUS select 1509 from sys_dummy MINUS select 1804 from sys_dummy MINUS select 1675 from sys_dummy MINUS select 1970 from sys_dummy MINUS select 1999 from sys_dummy
140  MINUS select 1510 from sys_dummy MINUS select 1805 from sys_dummy MINUS select 1676 from sys_dummy MINUS select 1971 from sys_dummy MINUS select 1601 from sys_dummy
141  MINUS select 1511 from sys_dummy MINUS select 1806 from sys_dummy MINUS select 1677 from sys_dummy MINUS select 1972 from sys_dummy MINUS select 1896 from sys_dummy
142  MINUS select 1512 from sys_dummy MINUS select 1807 from sys_dummy MINUS select 1678 from sys_dummy MINUS select 1973 from sys_dummy MINUS select 1602 from sys_dummy
143  MINUS select 1513 from sys_dummy MINUS select 1808 from sys_dummy MINUS select 1679 from sys_dummy MINUS select 1974 from sys_dummy MINUS select 1897 from sys_dummy
144  MINUS select 1514 from sys_dummy MINUS select 1809 from sys_dummy MINUS select 1680 from sys_dummy MINUS select 1975 from sys_dummy
145  MINUS select 1515 from sys_dummy MINUS select 1810 from sys_dummy MINUS select 1681 from sys_dummy MINUS select 1976 from sys_dummy
146  MINUS select 1516 from sys_dummy MINUS select 1811 from sys_dummy MINUS select 1682 from sys_dummy MINUS select 1977 from sys_dummy
147  MINUS select 1517 from sys_dummy MINUS select 1812 from sys_dummy MINUS select 1683 from sys_dummy MINUS select 1978 from sys_dummy
148  MINUS select 1518 from sys_dummy MINUS select 1813 from sys_dummy MINUS select 1684 from sys_dummy MINUS select 1979 from sys_dummy
149  MINUS select 1519 from sys_dummy MINUS select 1814 from sys_dummy MINUS select 1685 from sys_dummy MINUS select 1980 from sys_dummy
150  MINUS select 1520 from sys_dummy MINUS select 1815 from sys_dummy MINUS select 1686 from sys_dummy MINUS select 1981 from sys_dummy
151  MINUS select 1521 from sys_dummy MINUS select 1816 from sys_dummy MINUS select 1687 from sys_dummy MINUS select 1982 from sys_dummy
152  MINUS select 1522 from sys_dummy MINUS select 1817 from sys_dummy MINUS select 1688 from sys_dummy MINUS select 1983 from sys_dummy
153  MINUS select 1523 from sys_dummy MINUS select 1818 from sys_dummy MINUS select 1689 from sys_dummy MINUS select 1984 from sys_dummy
154  MINUS select 1524 from sys_dummy MINUS select 1819 from sys_dummy MINUS select 1690 from sys_dummy MINUS select 1985 from sys_dummy
155  MINUS select 1525 from sys_dummy MINUS select 1820 from sys_dummy MINUS select 1691 from sys_dummy MINUS select 1986 from sys_dummy
156  MINUS select 1526 from sys_dummy MINUS select 1821 from sys_dummy MINUS select 1692 from sys_dummy MINUS select 1987 from sys_dummy
157  MINUS select 1527 from sys_dummy MINUS select 1822 from sys_dummy MINUS select 1693 from sys_dummy MINUS select 1988 from sys_dummy
158  MINUS select 1528 from sys_dummy MINUS select 1823 from sys_dummy MINUS select 1694 from sys_dummy MINUS select 1989 from sys_dummy
159  MINUS select 1529 from sys_dummy MINUS select 1824 from sys_dummy MINUS select 1695 from sys_dummy MINUS select 1990 from sys_dummy
160  MINUS select 1530 from sys_dummy MINUS select 1825 from sys_dummy MINUS select 1696 from sys_dummy MINUS select 1991 from sys_dummy
161  MINUS select 1531 from sys_dummy MINUS select 1826 from sys_dummy MINUS select 1697 from sys_dummy MINUS select 1992 from sys_dummy
162  MINUS select 1532 from sys_dummy MINUS select 1827 from sys_dummy MINUS select 1698 from sys_dummy MINUS select 1993 from sys_dummy
163  MINUS select 1533 from sys_dummy MINUS select 1828 from sys_dummy MINUS select 1699 from sys_dummy MINUS select 1994 from sys_dummy
164  MINUS select 1534 from sys_dummy MINUS select 1829 from sys_dummy MINUS select 1700 from sys_dummy MINUS select 1995 from sys_dummy
165  MINUS select 1535 from sys_dummy MINUS select 1830 from sys_dummy MINUS select 1701 from sys_dummy MINUS select 1996 from sys_dummy
166  MINUS select 1536 from sys_dummy MINUS select 1831 from sys_dummy MINUS select 1702 from sys_dummy MINUS select 1997 from sys_dummy
167  MINUS select 1537 from sys_dummy MINUS select 1832 from sys_dummy MINUS select 1703 from sys_dummy MINUS select 1998 from sys_dummy
168  MINUS select 1538 from sys_dummy MINUS select 1833 from sys_dummy MINUS select 1603 from sys_dummy MINUS select 1898 from sys_dummy
169  MINUS select 1539 from sys_dummy MINUS select 1834 from sys_dummy MINUS select 1604 from sys_dummy MINUS select 1899 from sys_dummy
170  MINUS select 1540 from sys_dummy MINUS select 1835 from sys_dummy MINUS select 1605 from sys_dummy MINUS select 1900 from sys_dummy
171  MINUS select 1541 from sys_dummy MINUS select 1836 from sys_dummy MINUS select 1606 from sys_dummy MINUS select 1901 from sys_dummy
172  MINUS select 1542 from sys_dummy MINUS select 1837 from sys_dummy MINUS select 1607 from sys_dummy MINUS select 1902 from sys_dummy
173  MINUS select 1543 from sys_dummy MINUS select 1838 from sys_dummy MINUS select 1608 from sys_dummy MINUS select 1903 from sys_dummy
174  MINUS select 1544 from sys_dummy MINUS select 1839 from sys_dummy MINUS select 1609 from sys_dummy MINUS select 1904 from sys_dummy
175  MINUS select 1545 from sys_dummy MINUS select 1840 from sys_dummy MINUS select 1610 from sys_dummy MINUS select 1905 from sys_dummy
176  MINUS select 1546 from sys_dummy MINUS select 1841 from sys_dummy MINUS select 1611 from sys_dummy MINUS select 1906 from sys_dummy
177  MINUS select 1547 from sys_dummy MINUS select 1842 from sys_dummy MINUS select 1612 from sys_dummy MINUS select 1907 from sys_dummy
178  MINUS select 1548 from sys_dummy MINUS select 1843 from sys_dummy MINUS select 1613 from sys_dummy MINUS select 1908 from sys_dummy
179  MINUS select 1549 from sys_dummy MINUS select 1844 from sys_dummy MINUS select 1614 from sys_dummy MINUS select 1909 from sys_dummy
180  MINUS select 1550 from sys_dummy MINUS select 1845 from sys_dummy MINUS select 1615 from sys_dummy MINUS select 1910 from sys_dummy
181  MINUS select 1551 from sys_dummy MINUS select 1846 from sys_dummy MINUS select 1616 from sys_dummy MINUS select 1911 from sys_dummy
182  MINUS select 1552 from sys_dummy MINUS select 1847 from sys_dummy MINUS select 1617 from sys_dummy MINUS select 1912 from sys_dummy
183  MINUS select 1553 from sys_dummy MINUS select 1848 from sys_dummy MINUS select 1618 from sys_dummy MINUS select 1913 from sys_dummy
184  MINUS select 1554 from sys_dummy MINUS select 1849 from sys_dummy MINUS select 1619 from sys_dummy MINUS select 1914 from sys_dummy
185  MINUS select 1555 from sys_dummy MINUS select 1850 from sys_dummy MINUS select 1620 from sys_dummy MINUS select 1915 from sys_dummy
186  MINUS select 1556 from sys_dummy MINUS select 1851 from sys_dummy MINUS select 1621 from sys_dummy MINUS select 1916 from sys_dummy
187  MINUS select 1557 from sys_dummy MINUS select 1852 from sys_dummy MINUS select 1622 from sys_dummy MINUS select 1917 from sys_dummy
188  MINUS select 1558 from sys_dummy MINUS select 1853 from sys_dummy MINUS select 1623 from sys_dummy MINUS select 1918 from sys_dummy
189  MINUS select 1559 from sys_dummy MINUS select 1854 from sys_dummy MINUS select 1624 from sys_dummy MINUS select 1919 from sys_dummy
190  MINUS select 1560 from sys_dummy MINUS select 1855 from sys_dummy MINUS select 1625 from sys_dummy MINUS select 1920 from sys_dummy
191  MINUS select 1561 from sys_dummy MINUS select 1856 from sys_dummy MINUS select 1626 from sys_dummy MINUS select 1921 from sys_dummy
192  MINUS select 1562 from sys_dummy MINUS select 1857 from sys_dummy MINUS select 1627 from sys_dummy MINUS select 1922 from sys_dummy
193  MINUS select 1563 from sys_dummy MINUS select 1858 from sys_dummy MINUS select 1628 from sys_dummy MINUS select 1923 from sys_dummy
194  MINUS select 1564 from sys_dummy MINUS select 1859 from sys_dummy MINUS select 1629 from sys_dummy MINUS select 1924 from sys_dummy
195  MINUS select 1565 from sys_dummy MINUS select 1860 from sys_dummy MINUS select 1630 from sys_dummy MINUS select 1925 from sys_dummy
196  MINUS select 1566 from sys_dummy MINUS select 1861 from sys_dummy MINUS select 1631 from sys_dummy MINUS select 1926 from sys_dummy
197  MINUS select 1567 from sys_dummy MINUS select 1862 from sys_dummy MINUS select 1632 from sys_dummy MINUS select 1927 from sys_dummy
198  MINUS select 1568 from sys_dummy MINUS select 1863 from sys_dummy MINUS select 1633 from sys_dummy MINUS select 1928 from sys_dummy
199  MINUS select 1569 from sys_dummy MINUS select 1864 from sys_dummy MINUS select 1634 from sys_dummy MINUS select 1929 from sys_dummy
200  MINUS select 1570 from sys_dummy MINUS select 1865 from sys_dummy MINUS select 1635 from sys_dummy MINUS select 1930 from sys_dummy
201  MINUS select 1571 from sys_dummy MINUS select 1866 from sys_dummy MINUS select 1669 from sys_dummy MINUS select 1964 from sys_dummy
202  MINUS select 1572 from sys_dummy MINUS select 1867 from sys_dummy MINUS select 1670 from sys_dummy MINUS select 1965 from sys_dummy
203  MINUS select 1573 from sys_dummy MINUS select 1868 from sys_dummy MINUS select 1671 from sys_dummy MINUS select 1966 from sys_dummy
204  MINUS select 1574 from sys_dummy MINUS select 1869 from sys_dummy MINUS select 1672 from sys_dummy MINUS select 1967 from sys_dummy
205  MINUS select 1575 from sys_dummy MINUS select 1870 from sys_dummy MINUS select 1588 from sys_dummy MINUS select 1883 from sys_dummy
206  MINUS select 1576 from sys_dummy MINUS select 1871 from sys_dummy MINUS select 1589 from sys_dummy MINUS select 1884 from sys_dummy
207  MINUS select 1577 from sys_dummy MINUS select 1872 from sys_dummy MINUS select 1590 from sys_dummy MINUS select 1885 from sys_dummy
208  MINUS select 1578 from sys_dummy MINUS select 1873 from sys_dummy MINUS select 1591 from sys_dummy MINUS select 1886 from sys_dummy
209  MINUS select 1579 from sys_dummy MINUS select 1874 from sys_dummy MINUS select 1592 from sys_dummy MINUS select 1887 from sys_dummy
210  MINUS select 1580 from sys_dummy MINUS select 1875 from sys_dummy MINUS select 1593 from sys_dummy MINUS select 1888 from sys_dummy
211  MINUS select 1581 from sys_dummy MINUS select 1876 from sys_dummy MINUS select 1594 from sys_dummy MINUS select 1889 from sys_dummy
212  MINUS select 1582 from sys_dummy MINUS select 1877 from sys_dummy MINUS select 1595 from sys_dummy MINUS select 1890 from sys_dummy
213  MINUS select 1583 from sys_dummy MINUS select 1878 from sys_dummy MINUS select 1596 from sys_dummy MINUS select 1891 from sys_dummy
214  MINUS select 1584 from sys_dummy MINUS select 1879 from sys_dummy MINUS select 1597 from sys_dummy MINUS select 1892 from sys_dummy
215  MINUS select 1585 from sys_dummy MINUS select 1880 from sys_dummy MINUS select 1598 from sys_dummy MINUS select 1893 from sys_dummy
216  MINUS select 1586 from sys_dummy MINUS select 1881 from sys_dummy MINUS select 1599 from sys_dummy MINUS select 1894 from sys_dummy
217  MINUS select 1587 from sys_dummy MINUS select 1882 from sys_dummy MINUS select 1600 from sys_dummy MINUS select 1895 from sys_dummy
218 ) )C        WHERE            1 = 1        ORDER BY            id ) t    WHERE        ROWNUM <= 800 )WHERE    rn >= 1 order by 1,2,3,4;

CT-00027, Stack depth limit exceeded
SQL> drop table  t_stack_or_001; 

Succeed.

SQL> drop table t_stack_or_002; 

Succeed.

SQL> -- dv_sql_plan -> explain
SQL> DROP TABLE IF EXISTS "INF_OFFERS" CASCADE CONSTRAINTS;

Succeed.

SQL> CREATE TABLE "INF_OFFERS"
  2 (
  3   "OFFER_SEQ" NUMBER(16) NOT NULL,
  4   "OWNER_TYPE" VARCHAR(1 BYTE) NOT NULL,
  5   "CUST_ID" NUMBER(24) NOT NULL,
  6   "SUB_ID" NUMBER(24),
  7   "ACCT_ID" NUMBER(24),
  8   "OFFER_ID" VARCHAR(20 BYTE) NOT NULL,
  9   "PRIMARY_FLAG" VARCHAR(1 BYTE) NOT NULL,
 10   "BUNDLE_FLAG" VARCHAR(1 BYTE) NOT NULL,
 11   "P_OFFER_SEQ" NUMBER(16),
 12   "PRI_OFFER_SEQ" NUMBER(16),
 13   "FOR_MEMBER_FLAG" VARCHAR(1 BYTE),
 14   "STATUS" VARCHAR(5 BYTE),
 15   "M_STATUS" VARCHAR(1 BYTE),
 16   "CREATE_DATE" DATE,
 17   "AMOUNT" NUMBER(3),
 18   "EFF_DATE" DATE,
 19   "EXP_DATE" DATE,
 20   "REASON" VARCHAR(24 BYTE),
 21   "REMARK" VARCHAR(256 BYTE),
 22   "BUSI_SEQ" VARCHAR(16 BYTE),
 23   "BUSI_TYPE" VARCHAR(5 BYTE),
 24   "PARTITION_ID" NUMBER(8) NOT NULL,
 25   "SUBSCRIBE_CHANNEL" VARCHAR(10 BYTE),
 26   "UNSUBSCRIBE_CHANNEL" VARCHAR(10 BYTE),
 27   "BE_ID" VARCHAR(32 BYTE),
 28   "EFF_MODE" VARCHAR(3 BYTE),
 29   "EXTERNAL_OFFER_SEQ" VARCHAR(32 BYTE) DEFAULT '',
 30   "TRIAL_S_DATE" DATE,
 31   "TRIAL_E_DATE" DATE,
 32   "EXP_MODE" VARCHAR(3 BYTE),
 33   "ACTIVE_MODE" VARCHAR(3 BYTE),
 34   "LATEST_ACTIVE_DATE" DATE,
 35   "ACTIVE_TIME" DATE,
 36   "OFFER_CATE" VARCHAR(10 BYTE),
 37   "STATE_REASON_DETAIL" VARCHAR(24 BYTE),
 38   "ACTION_TYPE" VARCHAR(6 BYTE),
 39   "PROMOTION_SEQ" NUMBER(16),
 40   "PROMOTION_ID" VARCHAR(10 BYTE),
 41   "GROUP_SUB_ID" NUMBER(24),
 42   "MOD_DATE" DATE,
 43   "BUNDLE_OFFER_ID" VARCHAR(32 BYTE),
 44   "RESERVE_SEQ" VARCHAR(64 BYTE),
 45   "ORIG_EXP_DATE" DATE,
 46   "COLUMN1" VARCHAR(256 BYTE),
 47   "COLUMN2" VARCHAR(256 BYTE),
 48   "COLUMN3" VARCHAR(256 BYTE),
 49   "COLUMN4" VARCHAR(256 BYTE),
 50   "COLUMN5" VARCHAR(256 BYTE),
 51   "PACKAGE_ID" VARCHAR(20 BYTE),
 52   "GROUP_ID" VARCHAR(20 BYTE)
 53 )
 54 PARTITION BY RANGE ("PARTITION_ID")
 55 (
 56     PARTITION P_00 VALUES LESS THAN (1)  INITRANS 1 PCTFREE 10,
 57     PARTITION P_01 VALUES LESS THAN (2)  INITRANS 1 PCTFREE 10,
 58     PARTITION P_02 VALUES LESS THAN (MAXVALUE)  INITRANS 1 PCTFREE 10
 59 )
 60 INITRANS 1
 61 MAXTRANS 255
 62 PCTFREE 10;

Succeed.

SQL> ALTER TABLE "INF_OFFERS" ADD CONSTRAINT "PK_INF_OFFERS" PRIMARY KEY("OFFER_SEQ");

Succeed.

SQL> 
SQL> create or replace function FCALPID(CALNUMBER IN NUMBER) RETURN NUMBER IS
  2 BEGIN
  3   RETURN 0;
  4 END;
  5 /

Succeed.

SQL> alter system flush sqlpool;

Succeed.

SQL> explain insert INTO INF_OFFERS NOLOGGING (OFFER_SEQ , OWNER_TYPE , CUST_ID , SUB_ID , ACCT_ID , OFFER_ID , PRIMARY_FLAG , BUNDLE_FLAG , P_OFFER_SEQ , PRI_OFFER_SEQ , FOR_MEMBER_FLAG , STATUS , M_STATUS , CREATE_DATE , AMOUNT , TRIAL_S_DATE , TRIAL_E_DATE , EFF_DATE , EXP_DATE , REASON , REMARK , BUSI_SEQ , BUSI_TYPE , PARTITION_ID , SUBSCRIBE_CHANNEL , UNSUBSCRIBE_CHANNEL , BE_ID , EFF_MODE , ACTIVE_MODE , LATEST_ACTIVE_DATE , ACTIVE_TIME , OFFER_CATE , ACTION_TYPE , MOD_DATE ) VALUES(:1 ,'2',:2 ,:3 ,:4 ,:5 ,:6 ,'0',NULL,NULL,NULL,'C01','',:7 ,1,:8 ,:9 ,:10 ,:11 ,NULL,NULL,:12 ,'CO015',FCALPID(:13 ),NULL,NULL,101,'0','A',:14 ,:15 ,'0','1',:16 );

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                             | Owner | Name                 | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                        |       |                      |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:id=0) | SYS   | INF_OFFERS NOLOGGING |      |      |       |        |
---------------------------------------------------------------------------------------------------------------

6 rows fetched.

SQL> select PLAN_TEXT from dv_sql_plan where sql_id = 2445080300;

PLAN_TEXT                                                       
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
| Id  | Description                             | Owner | Name                 | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                        |       |                      |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:id=0) | SYS   | INF_OFFERS NOLOGGING |      |      |       |        |
---------------------------------------------------------------------------------------------------------------

1 rows fetched.

SQL> 
SQL> drop table if exists tb_test;

Succeed.

SQL> create table tb_test
  2 (
  3 c_id int,
  4 CAOC clob default '123456789',
  5 CAOB blob default '123456789'
  6 ) 
  7 partition by range(c_id) interval(50)
  8 (partition part_1 values less than(10),
  9 partition part_2 values less than(30));

Succeed.

SQL> explain insert into tb_test(c_id) values(:1);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
----------------------------------------------------------------------------------------------------
| Id  | Description                               | Owner | Name    | Rows | Cost | Bytes | Remark |
----------------------------------------------------------------------------------------------------
| 0   | INSERT STATEMENT                          |       |         |      |      |       |        |
| 1   |   LOAD TABLE CONVENTIONAL (Filter:id=N/A) | SYS   | TB_TEST |      |      |       |        |
----------------------------------------------------------------------------------------------------

6 rows fetched.

SQL> drop table if exists tb_test;

Succeed.

SQL> 
SQL> drop table if exists expr_node_certain_t;

Succeed.

SQL> create table expr_node_certain_t(id int, c_int int not null, c_bool boolean);

Succeed.

SQL> create index idx_expr_node_certain_t on expr_node_certain_t(c_int);

Succeed.

SQL> explain select * from expr_node_certain_t where c_int = if(10 > 5, 10, 5);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | EXPR_NODE_CERTAIN_T     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_EXPR_NODE_CERTAIN_T |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = IF(TRUE, 10, 5)                          

10 rows fetched.

SQL> explain select * from expr_node_certain_t where c_int = lnnvl(10 > 5);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | EXPR_NODE_CERTAIN_T     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_EXPR_NODE_CERTAIN_T |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = LNNVL(TRUE)                              

10 rows fetched.

SQL> explain select * from expr_node_certain_t where c_int = case when 10 > 5 then 5 else 10 end;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   TABLE ACCESS BY INDEX ROWID  | SYS   | EXPR_NODE_CERTAIN_T     |      |      |       |        |
| 2   |     INDEX RANGE SCAN           | SYS   | IDX_EXPR_NODE_CERTAIN_T |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - access: C_INT = CASE  WHEN TRUE THEN 5 ELSE 10 END       

10 rows fetched.

SQL> drop table expr_node_certain_t;

Succeed.

SQL> 
SQL> drop table if exists nl_convert_to_hash_t1;

Succeed.

SQL> drop table if exists nl_convert_to_hash_t2;

Succeed.

SQL> create table nl_convert_to_hash_t1(f1 int, f2 int, f3 int);

Succeed.

SQL> create table nl_convert_to_hash_t2(f1 int, f2 int, f3 int);

Succeed.

SQL> 
SQL> explain
  2 select
  3   subq_1.c0 as c1
  4 from
  5   ((nl_convert_to_hash_t1 as ref_0)
  6   right join nl_convert_to_hash_t1 as ref_1 on 1=1)
  7   left join (
  8     ((
  9         select
 10             ref_3.f1 as c0,
 11             ref_3.f2 as c1
 12         from
 13             nl_convert_to_hash_t1 as ref_3
 14         where ref_3.f3 < 10) as subq_1)
 15     cross join (nl_convert_to_hash_t2 as ref_4))
 16    on (ref_4.f1 = case when ref_0.f2 != ref_0.f3 then 1 else 2 end)
 17 where ref_4.f2 <> subq_1.c1;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                             |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |                             |      |      |       |        |
| 2   |     NESTED LOOPS           |       |                             |      |      |       |        |
| 3   |       SUBSELECT            |       | SUBQ_1                      |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | NL_CONVERT_TO_HASH_T1 REF_3 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T2 REF_4 |      |      |       |        |
| 6   |     NESTED LOOPS OUTER     |       |                             |      |      |       |        |
| 7   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_1 |      |      |       |        |
| 8   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_0 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: REF_4.F1 = CASE  WHEN REF_0.F2 != REF_0.F3 THEN 1 ELSE 2 END
   4 - filter: REF_3.F3 < 10                                    
   5 - filter: REF_4.F2 != SUBQ_1.C1                            

18 rows fetched.

SQL> 
SQL> explain
  2 select
  3   subq_1.c0 as c1
  4 from
  5   ((nl_convert_to_hash_t1 as ref_0)
  6   right join nl_convert_to_hash_t1 as ref_1 on 1=1)
  7   left join (
  8     ((
  9         select
 10             ref_3.f1 as c0,
 11             ref_3.f2 as c1
 12         from
 13             nl_convert_to_hash_t1 as ref_3
 14         where ref_3.f3 < 10) as subq_1)
 15     cross join (nl_convert_to_hash_t2 as ref_4))
 16    on (ref_4.f1 = case when ref_0.f2 != ref_0.f3 then 1 else 2 end)
 17 where ref_4.f2 <> subq_1.c1 and ref_4.rowid != subq_1.rowid;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                             |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |                             |      |      |       |        |
| 2   |     NESTED LOOPS           |       |                             |      |      |       |        |
| 3   |       SUBSELECT            |       | SUBQ_1                      |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | NL_CONVERT_TO_HASH_T1 REF_3 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T2 REF_4 |      |      |       |        |
| 6   |     NESTED LOOPS OUTER     |       |                             |      |      |       |        |
| 7   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_1 |      |      |       |        |
| 8   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_0 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: REF_4.F1 = CASE  WHEN REF_0.F2 != REF_0.F3 THEN 1 ELSE 2 END
   4 - filter: REF_3.F3 < 10                                    
   5 - filter: REF_4.F2 != SUBQ_1.C1 AND ROWID != SUBQ_1.ROWID  

18 rows fetched.

SQL> 
SQL> explain
  2 select
  3   subq_1.c0 as c1
  4 from
  5   ((nl_convert_to_hash_t1 as ref_0)
  6   right join nl_convert_to_hash_t1 as ref_1 on 1=1)
  7   left join (
  8     ((
  9         select
 10             ref_3.f1 as c0,
 11             ref_3.f2 as c1
 12         from
 13             nl_convert_to_hash_t1 as ref_3
 14         where ref_3.f3 < 10) as subq_1)
 15     cross join (nl_convert_to_hash_t2 as ref_4))
 16    on (ref_4.f1 = case when ref_0.f2 != ref_0.f3 then 1 else 2 end)
 17 where ref_4.f2 <> subq_1.c1 and ref_4.f3 = true;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                | Owner | Name                        | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT           |       |                             |      |      |       |        |
| 1   |   HASH JOIN(L)             |       |                             |      |      |       |        |
| 2   |     NESTED LOOPS           |       |                             |      |      |       |        |
| 3   |       SUBSELECT            |       | SUBQ_1                      |      |      |       |        |
| 4   |         TABLE ACCESS FULL  | SYS   | NL_CONVERT_TO_HASH_T1 REF_3 |      |      |       |        |
| 5   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T2 REF_4 |      |      |       |        |
| 6   |     NESTED LOOPS OUTER     |       |                             |      |      |       |        |
| 7   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_1 |      |      |       |        |
| 8   |       TABLE ACCESS FULL    | SYS   | NL_CONVERT_TO_HASH_T1 REF_0 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   1 - access: REF_4.F1 = CASE  WHEN REF_0.F2 != REF_0.F3 THEN 1 ELSE 2 END
   4 - filter: REF_3.F3 < 10                                    
   5 - filter: REF_4.F2 != SUBQ_1.C1 AND REF_4.F3 = TRUE        

18 rows fetched.

SQL> 
SQL> drop table nl_convert_to_hash_t1;

Succeed.

SQL> drop table nl_convert_to_hash_t2;

Succeed.

SQL> 
SQL> drop table if exists delete_ancestor_t;

Succeed.

SQL> create table delete_ancestor_t(col_1 int, col_2 int, col_3 int, col_4 int);

Succeed.

SQL> explain 
  2 select 
  3     1 as c0
  4 from delete_ancestor_t as ref_0
  5     cross join (
  6         select 
  7             null as c0,
  8             col_1 as c1,
  9             col_2 as c2,
 10             col_3 as c3,
 11             col_4 as c4
 12         from delete_ancestor_t as ref_1
 13     ) as subq_0
 14 where 
 15     subq_0.c2 > any(
 16         select subq_0.c2 as c0
 17         from delete_ancestor_t as ref_2
 18         where 
 19             exists(
 20                 select
 21                     max(subq_0.c1) over(partition by subq_0.c3 order by subq_0.c0) as c0
 22                 from delete_ancestor_t as ref_3
 23             )
 24     )
 25 group by rollup(subq_0.c4);

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
| Id  | Description                    | Owner | Name                    | Rows | Cost | Bytes | Remark |
---------------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT               |       |                         |      |      |       |        |
| 1   |   GENERATE CUBE                |       |                         |      |      |       |        |
| 2   |     HASH GROUP BY              |       |                         |      |      |       |        |
| 3   |       NESTED LOOPS             |       |                         |      |      |       |        |
| 4   |         KERNEL FILTER          |       |                         |      |      |       |        |
| 5   |           SUBSELECT            |       | SUBQ_0                  |      |      |       |        |
| 6   |             TABLE ACCESS FULL  | SYS   | DELETE_ANCESTOR_T REF_1 |      |      |       |        |
| 7   |           KERNEL FILTER        |       |                         |      |      |       |        |
| 8   |             TABLE ACCESS FULL  | SYS   | DELETE_ANCESTOR_T REF_2 |      |      |       |        |
| 9   |             TABLE ACCESS FULL  | SYS   | DELETE_ANCESTOR_T REF_3 |      |      |       |        |
| 10  |         KERNEL FILTER          |       |                         |      |      |       |        |
| 11  |           TABLE ACCESS FULL    | SYS   | DELETE_ANCESTOR_T REF_0 |      |      |       |        |
| 12  |           KERNEL FILTER        |       |                         |      |      |       |        |
| 13  |             TABLE ACCESS FULL  | SYS   | DELETE_ANCESTOR_T REF_2 |      |      |       |        |
| 14  |             TABLE ACCESS FULL  | SYS   | DELETE_ANCESTOR_T REF_3 |      |      |       |        |
---------------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   5 - filter: SUBQ_0.C2 > ANY((SELECT SUBQ_0.C2 AS C0 FROM DELETE_ANCESTOR_T REF_2 WHERE EXISTS(SELECT 1 FROM 
               DELETE_ANCESTOR_T REF_3)))                       
   8 - filter: EXISTS(SELECT 1 FROM DELETE_ANCESTOR_T REF_3)    
   13 - filter: EXISTS(SELECT 1 FROM DELETE_ANCESTOR_T REF_3)   

25 rows fetched.

SQL> 
SQL> drop table delete_ancestor_t;
Succeed.
SQL> 
SQL> drop table if exists t_winsort_elim;

Succeed.

SQL> create table t_winsort_elim(a int, b number, c varchar(10), d int);

Succeed.

SQL> insert into t_winsort_elim values(1, 1.1, 'aaa', 200);

1 rows affected.

SQL> insert into t_winsort_elim values(2, 2.2, 'bbb', 100);

1 rows affected.

SQL> insert into t_winsort_elim values(3, 1.1, null, 200);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> drop view if exists v_eliminate;

Succeed.

SQL> CREATE VIEW v_eliminate(a,b,c,d,ss,cc) 
  2 AS
  3 SELECT 
  4 t1.a,
  5 t2.b,
  6 t1.c,
  7 t2.d,
  8 sum(t1.a)over(partition by t1.b) as ss,
  9 (select count(1) from sys_dummy) as cc
 10 FROM t_winsort_elim t1 join t_winsort_elim t2 on t1.a = t2.a join t_winsort_elim t3 join t_winsort_elim t4
 11 order by t1.a,t2.b;

Succeed.

SQL> 
SQL> explain select distinct a from v_eliminate where b < 2;

EXPLAIN PLAN OUTPUT                                             
----------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
| Id  | Description                      | Owner | Name              | Rows | Cost | Bytes | Remark |
-----------------------------------------------------------------------------------------------------
| 0   | SELECT STATEMENT                 |       |                   |      |      |       |        |
| 1   |   HASH DISTINCT                  |       |                   |      |      |       |        |
| 2   |     VIEW                         | SYS   | V_ELIMINATE       |      |      |       |        |
| 3   |       AGGR                       |       |                   |      |      |       |        |
| 4   |         TABLE ACCESS FULL        | SYS   | SYS_DUMMY         |      |      |       |        |
| 5   |       WINDOW SORT                |       |                   |      |      |       |        |
| 6   |         NESTED LOOPS             |       |                   |      |      |       |        |
| 7   |           NESTED LOOPS           |       |                   |      |      |       |        |
| 8   |             HASH JOIN(L)         |       |                   |      |      |       |        |
| 9   |               TABLE ACCESS FULL  | SYS   | T_WINSORT_ELIM T1 |      |      |       |        |
| 10  |               TABLE ACCESS FULL  | SYS   | T_WINSORT_ELIM T2 |      |      |       |        |
| 11  |             TABLE ACCESS FULL    | SYS   | T_WINSORT_ELIM T3 |      |      |       |        |
| 12  |           TABLE ACCESS FULL      | SYS   | T_WINSORT_ELIM T4 |      |      |       |        |
-----------------------------------------------------------------------------------------------------
Predicate Information (identified by id):                       
-----------------------------------------                       
   2 - filter: T2.B < 2                                         
   8 - access: T1.A = T2.A                                      

21 rows fetched.

SQL> drop table t_winsort_elim;
Succeed.




