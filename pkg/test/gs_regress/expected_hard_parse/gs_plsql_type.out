

SQL> -----------------------
SQL> -- USER DEFINED TYPE --
SQL> -----------------------
SQL> --init
SQL> set serveroutput on;

ON
SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> drop user if exists gs_plsql_type cascade;

Succeed.

SQL> create user gs_plsql_type identified by Cantian_234;

Succeed.

SQL> grant all privileges to gs_plsql_type;

Succeed.

SQL> conn gs_plsql_type/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> --assignment for table type
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  i int;
  5 begin
  6  var_C1.delete(2);
  7  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  8  var_C1(2) := null;
  9  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 10  i := var_C1.first();
 11  LOOP  
 12     if i is null then
 13        exit;
 14     end if;  
 15     dbe_output.print_line(i || '.' || var_C1(i));
 16     i := var_C1.next(i);
 17  END LOOP;
 18  
 19  i := var_C1.last();
 20  LOOP 
 21     if i is null then
 22        exit;
 23     end if;   
 24     dbe_output.print_line(i || '.' || var_C1(i));
 25     i := var_C1.prior(i);
 26  END LOOP;
 27 end;
 28 /

COUNT:2
COUNT:3
1.123
2.
3.345
3.345
2.
1.123

PL/SQL procedure successfully completed.

SQL> 
SQL> --forward/reverse traversal for table type
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  i int;
  5 begin
  6  var_C1.delete(2);
  7  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  8  i := var_C1.first();
  9  LOOP  
 10     if i is null then
 11        exit;
 12     end if;  
 13     dbe_output.print_line(i || '.' || var_C1(i));
 14     i := var_C1.next(i);
 15  END LOOP;
 16  
 17  i := var_C1.last();
 18  LOOP 
 19     if i is null then
 20        exit;
 21     end if;   
 22     dbe_output.print_line(i || '.' || var_C1(i));
 23     i := var_C1.prior(i);
 24  END LOOP;
 25 end;
 26 /

COUNT:2
1.123
3.345
3.345
1.123

PL/SQL procedure successfully completed.

SQL> 
SQL> -- table of number test
SQL> DECLARE
  2 TYPE nt_type IS TABLE OF NUMBER;
  3 nt nt_type := nt_type(18, NULL, 36, 45, 54, 63);
  4 BEGIN
  5 dbe_output.print('nt.count() = ' || nt.count());
  6 nt.DELETE(4);
  7 dbe_output.print('nt.count() = ' || nt.count());
  8 dbe_output.print_line('nt(4) was deleted.');
  9 dbe_output.print('nt.NEXT(' || 0 || ') = ' || nt.NEXT(0));
 10 FOR i IN 1..7 LOOP
 11 dbe_output.print('nt.PRIOR(' || i || ') = ' || nt.PRIOR(i));
 12 dbe_output.print('nt.NEXT(' || i || ') = ' || nt.NEXT(i));
 13 END LOOP;
 14 nt.DELETE(3);
 15 dbe_output.print_line('nt(3)nt(4) was deleted.');
 16 FOR i IN 1..7 LOOP
 17 dbe_output.print('nt.PRIOR(' || i || ') = ' || nt.PRIOR(i));
 18 dbe_output.print('nt.NEXT(' || i || ') = ' || nt.NEXT(i));
 19 END LOOP;
 20 END;
 21 /

nt.count() = 6
nt.count() = 5
nt(4) was deleted.
nt.NEXT(0) = 1
nt.PRIOR(1) = 
nt.NEXT(1) = 2
nt.PRIOR(2) = 1
nt.NEXT(2) = 3
nt.PRIOR(3) = 2
nt.NEXT(3) = 5
nt.PRIOR(4) = 3
nt.NEXT(4) = 5
nt.PRIOR(5) = 3
nt.NEXT(5) = 6
nt.PRIOR(6) = 5
nt.NEXT(6) = 
nt.PRIOR(7) = 6
nt.NEXT(7) = 
nt(3)nt(4) was deleted.
nt.PRIOR(1) = 
nt.NEXT(1) = 2
nt.PRIOR(2) = 1
nt.NEXT(2) = 5
nt.PRIOR(3) = 2
nt.NEXT(3) = 5
nt.PRIOR(4) = 2
nt.NEXT(4) = 5
nt.PRIOR(5) = 2
nt.NEXT(5) = 6
nt.PRIOR(6) = 5
nt.NEXT(6) = 
nt.PRIOR(7) = 6
nt.NEXT(7) = 

PL/SQL procedure successfully completed.

SQL> 
SQL> -- expression for table type
SQL> drop table if exists coll_tbl1;

Succeed.

SQL> create table coll_tbl1(a1 int);

Succeed.

SQL> insert into coll_tbl1 values(1);

1 rows affected.

SQL> commit;

Succeed.

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  select a1 + var_C1(1) into a from coll_tbl1 order by a1;
  7  dbe_output.print_line(a);
  8  select a1 + var_C1(1) into a from coll_tbl1 order by a1 + var_C1(1);
  9  dbe_output.print_line(a);
 10  select a1 + var_C1(1) into a from coll_tbl1 order by var_C1(1);
 11  dbe_output.print_line(a);
 12 end;
 13 /

124
124
124

PL/SQL procedure successfully completed.

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  select a1 + var_C1(1) into a from coll_tbl1 group by a1;
  7  dbe_output.print_line(a);
  8 end;
  9 /

124

PL/SQL procedure successfully completed.

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  select a1 + var_C1(1) into a from coll_tbl1 order by var_C1;
  7  dbe_output.print_line(a);
  8 end;
  9 /

CT-00932, [6:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[6:2] CT-00607, Invalid datatype for unexpected user define type

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  select a1 + var_C1(1) into a from coll_tbl1 group by a1 + var_C1(1);
  7  dbe_output.print_line(a);
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[6:9] PLC-00609 Expression not in group list

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  select var_C1(2) into a from dual;
  7  dbe_output.print_line(a);
  8 end;
  9 /

234

PL/SQL procedure successfully completed.

SQL> declare
  2  a varchar(20);
  3  TYPE C1 IS TABLE OF varchar(20);
  4  var_C1 C1 := C1('abc', 'bcd', 'cdf');
  5 begin 
  6  select var_C1(2) into a from dual;
  7  dbe_output.print_line(a);
  8 end;
  9 /

bcd

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  TYPE C2 IS TABLE OF C1;
  4  var_C2 C2 := C2(C1(123, 234, 345));
  5  a int;
  6 begin 
  7  select var_C2(1)(3) into a from dual;
  8  dbe_output.print_line(a);
  9 end;
 10 /

345

PL/SQL procedure successfully completed.

SQL> declare
  2  TYPE C1 IS TABLE OF varchar(20);
  3  TYPE C2 IS TABLE OF C1;
  4  var_C2 C2 := C2(C1('abc', 'bcd', 'cdf'));
  5  a varchar(20);
  6 begin 
  7  select var_C2(1)(3) into a from dual;
  8  dbe_output.print_line(a);
  9 end;
 10 /

cdf

PL/SQL procedure successfully completed.

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  -- raise error
  7  select a1 + var_C1(1) into a from coll_tbl1 group by var_C1(1); 
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[7:9] PLC-00609 Expression not in group list

SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  a int;
  5 begin 
  6  -- raise error
  7  select a1 + var_C1(1) into a from coll_tbl1 group by var_C1; 
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[7:9] PLC-00609 Expression not in group list

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  v_lower int;
  5  v_upper int;
  6  v_prev int;
  7  v_next int;
  8 begin
  9  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 10  v_lower := var_C1.first();
 11  v_prev  := var_C1.PRIOR(v_lower);
 12  dbe_output.print_line('prev of head:' || v_prev);
 13  v_upper := var_C1.last();
 14  v_next  := var_C1.next(v_upper);
 15  dbe_output.print_line('next of tail:' || v_next);
 16  
 17  dbe_output.print_line(v_lower || '.' || var_C1(v_lower));
 18  v_next := var_C1.next(v_lower);
 19  dbe_output.print_line(v_next || '.' || var_C1(v_next));
 20  v_next := var_C1.next(v_next);
 21  dbe_output.print_line(v_next || '.' || var_C1(v_next));
 22  
 23  dbe_output.print_line(v_upper || '.' || var_C1(v_upper));
 24  v_prev := var_C1.PRIOR(v_upper);
 25  dbe_output.print_line(v_prev || '.' || var_C1(v_prev));
 26  v_prev := var_C1.PRIOR(v_prev);
 27  dbe_output.print_line(v_prev || '.' || var_C1(v_prev));
 28 end;
 29 /

COUNT:3
prev of head:
next of tail:
1.123
2.234
3.345
3.345
2.234
1.123

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  v_prev int;
  5  v_next int;
  6 begin
  7  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  8  v_prev  := var_C1.PRIOR(var_C1.first());
  9  dbe_output.print_line('prev of head:' || v_prev);
 10  v_next  := var_C1.next(var_C1.last());
 11  dbe_output.print_line('next of tail:' || v_next);
 12  
 13  dbe_output.print_line(var_C1.first() || '.' || var_C1(var_C1.first()));
 14  v_next := var_C1.next(var_C1.first());
 15  dbe_output.print_line(v_next || '.' || var_C1(v_next));
 16  v_next := var_C1.next(v_next);
 17  dbe_output.print_line(v_next || '.' || var_C1(v_next));
 18  
 19  dbe_output.print_line(var_C1.last() || '.' || var_C1(var_C1.last()));
 20  v_prev := var_C1.PRIOR(var_C1.last());
 21  dbe_output.print_line(v_prev || '.' || var_C1(v_prev));
 22  v_prev := var_C1.PRIOR(v_prev);
 23  dbe_output.print_line(v_prev || '.' || var_C1(v_prev));
 24 end;
 25 /

COUNT:3
prev of head:
next of tail:
1.123
2.234
3.345
3.345
2.234
1.123

PL/SQL procedure successfully completed.

SQL> 
SQL> -- for-loop for table type
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  dbe_output.print_line('LIMIT:' || var_C1.LIMIT());
  6  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  7  FOR i IN var_C1.first() .. var_C1.last()  LOOP
  8     dbe_output.print_line(i || '.' || var_C1(i));
  9  END LOOP;
 10 end;
 11 /

LIMIT:
COUNT:3
1.123
2.234
3.345

PL/SQL procedure successfully completed.

SQL> 
SQL> -- exists for table type
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  dbe_output.print_line('exists[0]:' || var_C1.exists(0));
  6  dbe_output.print_line('exists[100]:' || var_C1.exists(100));
  7  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  8  FOR i IN var_C1.first() .. var_C1.last()  LOOP
  9     dbe_output.print_line('exists[' || i || ']:' || var_C1.exists(i));
 10  END LOOP;
 11  dbe_output.print_line('exists[' || (var_C1.last()+1) || ']:' || var_C1.exists(var_C1.last()+1));
 12 end;
 13 /

exists[0]:FALSE
exists[100]:FALSE
COUNT:3
exists[1]:TRUE
exists[2]:TRUE
exists[3]:TRUE
exists[4]:FALSE

PL/SQL procedure successfully completed.

SQL> 
SQL> -- record type
SQL> declare
  2  TYPE C1 IS VARRAY(4) OF varchar(100);
  3  TYPE C2 IS TABLE OF INTEGER;
  4  TYPE R1 IS RECORD(
  5   F1 C1,
  6   F2 C2);
  7  var_C1 C1 := C1('123', 234, 345);
  8  var_C2 C2;
  9  var_R1 R1;
 10 begin
 11  var_C2 := C2();
 12  var_C2.EXTEND;
 13  var_C2(1) := '456';
 14  var_C2.EXTEND;
 15  var_C2(2) := '567';
 16  var_R1.F1 := var_C1;
 17  var_R1.F2 := var_C2;
 18  FOR i IN 1 .. var_R1.F1.COUNT() LOOP
 19   dbe_output.print_line(i || '.' || var_R1.F1(i));
 20  END LOOP;
 21  FOR i IN 1 .. var_C1.COUNT() LOOP
 22   dbe_output.print_line(i || '.' || var_C1(i));
 23  END LOOP;
 24  FOR i IN 1 .. var_R1.F2.COUNT() LOOP
 25   dbe_output.print_line(i || '.' || var_R1.F2(i));
 26  END LOOP;
 27  FOR i IN 1 .. var_C2.COUNT() LOOP
 28   dbe_output.print_line(i || '.' || var_C2(i));
 29  END LOOP;
 30  var_C1 := C1('NEW_123', 1234, 1345);
 31 
 32  FOR i IN 1 .. var_R1.F1.COUNT() LOOP
 33   dbe_output.print_line(i || '.' || var_R1.F1(i));
 34  END LOOP;
 35  FOR i IN 1 .. var_C1.COUNT() LOOP
 36   dbe_output.print_line(i || '.' || var_C1(i));
 37  END LOOP;
 38  FOR i IN 1 .. var_C2.COUNT() LOOP
 39   var_C2(i) := i;
 40  END LOOP;
 41  FOR i IN 1 .. var_R1.F2.COUNT() LOOP
 42   dbe_output.print_line(i || '.' || var_R1.F2(i));
 43  END LOOP;
 44  FOR i IN 1 .. var_C2.COUNT() LOOP
 45   dbe_output.print_line(i || '.' || var_C2(i));
 46  END LOOP;
 47  end;
 48  /

1.123
2.234
3.345
1.123
2.234
3.345
1.456
2.567
1.456
2.567
1.123
2.234
3.345
1.NEW_123
2.1234
3.1345
1.456
2.567
1.1
2.2

PL/SQL procedure successfully completed.

SQL> 
SQL> -- only record fields can be compared
SQL> Declare
  2     Type EmpType is Record(
  3        EMPNO number(4),
  4        ENAME  varchar2(10),
  5        JOB varchar2(15),
  6        SAL number(7,2),
  7        DEPTNO number(2)
  8     );
  9     EmpRec1  EmpType;
 10     EmpRec2  EmpType;
 11 Begin
 12     EmpRec1.Empno:=7369;
 13     EmpRec1.Ename:='SMITH';
 14     EmpRec1.Job:='CLERK';
 15     EmpRec1.Sal:=800;
 16     EmpRec1.Deptno:=10;
 17     -- record types can be assigned as a whole
 18     EmpRec2 := EmpRec1;
 19     
 20     if EmpRec1.sal <= EmpRec2.sal then
 21        dbe_output.print_line('CantianDB');
 22     end if;
 23 	-- only record fields can be judged
 24     if EmpRec2.JOB is not null then
 25        dbe_output.print_line('Huawei');
 26 	end if;
 27 End;
 28 /

CantianDB
Huawei

PL/SQL procedure successfully completed.

SQL> --unsupport use record to update table info
SQL> drop table if exists t_422311;

Succeed.

SQL> create table t_422311(EMPNO int, b varchar(100));

Succeed.

SQL> insert into t_422311 values(123, 'test422311'),(234, 'test1123224');

2 rows affected.

SQL> commit;

Succeed.

SQL> --DECLARE
SQL> --vEmp t_422311%RowType;
SQL> --Begin
SQL> --select * InTo vEmp From t_422311 Where t_422311.EMPNO = 123;
SQL> --update t_422311 set ROW = vEmp Where EMPNO = 234;
SQL> --commit;
SQL> --End;
SQL> --/
SQL> --unsupport
SQL> Declare
  2 Type RecType Is Record
  3 (
  4   rno t_422311.EMPNO%type,
  5   rname t_422311.b%type
  6 );
  7 Type TabType Is Table Of RecType Index By Binary_Integer;
  8 MyTab TabType;
  9 vN Number;
 10 Begin
 11 vN := 1;
 12 For varR In (Select * From t_422311 Order By EMPNO ASC)
 13 Loop
 14   MyTab(vN).rno  := varR.EMPNO;
 15   MyTab(vN).rname := varR.b;
 16   vN := vN + 1;
 17 End Loop;
 18 vN := MyTab.First;
 19 For varR In vN..MyTab.count
 20 Loop
 21   dbe_output.print_line(vN ||'   '||MyTab(vN).rno||'   '||MyTab(vN).rname);
 22   vN := vN + 1;
 23 End Loop;
 24 End;
 25 /

1   123   test422311
2   234   test1123224

PL/SQL procedure successfully completed.

SQL> drop table t_422311;

Succeed.

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  6  FOR i IN 1 .. var_C1.COUNT() LOOP
  7     dbe_output.print_line(i || '.' || var_C1(i));
  8  END LOOP;
  9  
 10  var_C1.EXTEND;
 11  var_C1(4) := 456;
 12  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 13  FOR i IN 1 .. var_C1.COUNT() LOOP
 14     dbe_output.print_line(i || '.' || var_C1(i));
 15  END LOOP;
 16  
 17  var_C1.EXTEND(2,3);
 18  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 19  FOR i IN 1 .. var_C1.COUNT() LOOP
 20     dbe_output.print_line(i || '.' || var_C1(i));
 21  END LOOP;
 22 end;
 23 /

COUNT:3
1.123
2.234
3.345
COUNT:4
1.123
2.234
3.345
4.456
COUNT:6
1.123
2.234
3.345
4.456
5.345
6.345

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  6  FOR i IN 1 .. var_C1.COUNT() LOOP
  7     dbe_output.print_line(i || '.' || var_C1(i));
  8  END LOOP;
  9  
 10  var_C1.TRIM(3);
 11  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 12  FOR i IN 1 .. var_C1.COUNT() LOOP
 13     dbe_output.print_line(i || '.' || var_C1(i));
 14  END LOOP;
 15  
 16  var_C1 := C1(123, 234, 345);
 17  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 18  FOR i IN 1 .. var_C1.COUNT() LOOP
 19     dbe_output.print_line(i || '.' || var_C1(i));
 20  END LOOP;
 21  var_C1.TRIM;
 22  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 23  FOR i IN 1 .. var_C1.COUNT() LOOP
 24     dbe_output.print_line(i || '.' || var_C1(i));
 25  END LOOP;
 26 end;
 27 /

COUNT:3
1.123
2.234
3.345
COUNT:0
COUNT:3
1.123
2.234
3.345
COUNT:2
1.123
2.234

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  6  FOR i IN 1 .. var_C1.COUNT() LOOP
  7     dbe_output.print_line(i || '.' || var_C1(i));
  8  END LOOP;
  9  
 10  var_C1.TRIM(3);
 11  dbe_output.print_line('COUNT:' || var_C1.COUNT());
 12  FOR i IN 1 .. var_C1.COUNT() LOOP
 13     dbe_output.print_line(i || '.' || var_C1(i));
 14  END LOOP;
 15 
 16  dbe_output.print_line(0 || '.' || var_C1(0));
 17 end;
 18 /

COUNT:3
1.123
2.234
3.345
COUNT:0
CT-00932, [16:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[16:2] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00912, Subscript beyond count

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4 begin
  5  var_C1.delete(2);
  6  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  7  FOR i IN 1 .. var_C1.count() LOOP
  8     dbe_output.print_line(i || '.' || var_C1(i));
  9  END LOOP;
 10 end;
 11 /

COUNT:2
1.123
CT-00932, [8:5] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:5] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-02604, no data found

SQL> 
SQL> declare
  2  TYPE C1 IS TABLE OF INTEGER;
  3  var_C1 C1 := C1(123, 234, 345);
  4  lower int;
  5  upper int;
  6 begin
  7  dbe_output.print_line('COUNT:' || var_C1.COUNT());
  8  lower := var_C1.first();
  9  upper := var_C1.last();
 10  FOR i IN lower .. upper  LOOP
 11     dbe_output.print_line(i || '.' || var_C1(i));
 12  END LOOP;
 13 end;
 14 /

COUNT:3
1.123
2.234
3.345

PL/SQL procedure successfully completed.

SQL> 
SQL> -- nested type
SQL> CREATE OR REPLACE TYPE ATTR_TYPE2 FORCE AS OBJECT
  2 ( month int,
  3   month int
  4 );
  5 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_TYPE.ATTR_TYPE2) terminated with compiling errors
[3:3] PLC-00604 Duplicate attribute name month


SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE2 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE FORCE AS OBJECT
  2 ( year int,
  3   month ATTR_TYPE2
  4 );
  5 /

Succeed.

SQL> 
SQL> drop type ATTR_TYPE2;

CT-00916, PL/SQL:syntax error(type is used in other type, expect FORCE)
SQL> 
SQL> --
SQL> CREATE OR REPLACE TYPE ATTR_SUPER_TYPE FORCE AS OBJECT
  2 ( year int,
  3   MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4   FINAL MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER,
  5   NOT FINAL NOT INSTANTIABLE MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER,
  6   STATIC PROCEDURE prod4(invent NUMBER)
  7 ) not final not instantiable;
  8 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature


SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where type_name='ATTR_SUPER_TYPE';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ATTR_SUPER_TYPE                                                  OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where type_name='ATTR_SUPER_TYPE' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> select TYPE_NAME,METHOD_NAME,METHOD_NO,METHOD_TYPE,PARAMETERS,RESULTS,FINAL,INSTANTIABLE,OVERRIDING,INHERITED from SYS.SYS_TYPE_METHODS where type_name='ATTR_SUPER_TYPE' ORDER BY METHOD_NO;

TYPE_NAME                                                        METHOD_NAME                                                      METHOD_NO    METHOD_TYPE  PARAMETERS   RESULTS      FINAL        INSTANTIABLE OVERRIDING   INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> CREATE OR REPLACE TYPE ALL_ATTR_TYPE FORCE UNDER ATTR_SUPER_TYPE
  2 ( a int,
  3   b number(8),
  4   c number(10,2),
  5   d char(20),
  6   e varchar(30),
  7   f clob,
  8   g blob,
  9   h ATTR_TYPE,
 10   OVERRIDING MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
 11   OVERRIDING FINAL MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER,
 12   MEMBER PROCEDURE prod5(invent NUMBER)
 13 );
 14 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_TYPE.ALL_ATTR_TYPE) terminated with compiling errors
[1:50] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature



SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where type_name='ALL_ATTR_TYPE';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ALL_ATTR_TYPE                                                    OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where type_name='ALL_ATTR_TYPE' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> select TYPE_NAME,METHOD_NAME,METHOD_NO,METHOD_TYPE,PARAMETERS,RESULTS,FINAL,INSTANTIABLE,OVERRIDING,INHERITED from SYS.SYS_TYPE_METHODS where type_name='ALL_ATTR_TYPE' ORDER BY METHOD_NO;

TYPE_NAME                                                        METHOD_NAME                                                      METHOD_NO    METHOD_TYPE  PARAMETERS   RESULTS      FINAL        INSTANTIABLE OVERRIDING   INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> declare
  2 v1 ALL_ATTR_TYPE;
  3 v2 ALL_ATTR_TYPE;
  4 begin
  5   v2.a := v1.a;
  6   dbe_output.print_line(v2.a);
  7 end;
  8 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ALL_ATTR_TYPE) terminated with compiling errors
[1:8] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature



SQL> 
SQL> declare
  2 v1 ALL_ATTR_TYPE;
  3 v2 ALL_ATTR_TYPE;
  4 begin
  5   v1 := ALL_ATTR_TYPE(2, 3, 4, 5.1, 'abc', 'def', 'ghi', 'abc123', ATTR_TYPE(1, ATTR_TYPE2(2)));
  6   v2 := v1;
  7   dbe_output.print_line(v2.a);
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ALL_ATTR_TYPE) terminated with compiling errors
[1:8] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature



SQL> 
SQL> create or replace type yyy is VARRAY(10) OF NUMBER(10, 2);
  2 /

Succeed.

SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where type_name='YYY';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
YYY                                                              COLLECTION 0            0            0            0            1            1                                                                             0                0            

1 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where type_name='YYY';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------
YYY                                                              VARYING ARRAY                                                    10                         NUMBER                                                                        10           2                                      1           

1 rows fetched.

SQL> 
SQL> create or replace type zzz is VARRAY(20) OF ALL_ATTR_TYPE;
  2 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_TYPE.ZZZ) terminated with compiling errors
[1:45] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ALL_ATTR_TYPE) terminated with compiling errors
[1:8] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature




SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where type_name='ZZZ';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ZZZ                                                              OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where type_name='ZZZ';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> declare
  2 type xxx is VARRAY(10) OF NUMBER;
  3 v1 xxx;
  4 v2 yyy;
  5 begin
  6   v1 := xxx(1,2,3);
  7   dbe_output.print_line(v1(1));
  8   v2 := yyy(1,2,3);
  9   dbe_output.print_line(v2(1));
 10   dbe_output.print_line(v2(2));
 11   dbe_output.print_line(v2(3));
 12 end;
 13 /

1
1
2
3

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> -- test type privilege
SQL> drop user if exists gs_plsql_type2 cascade;

Succeed.

SQL> create user gs_plsql_type2 identified by Cantian_234;

Succeed.

SQL> grant execute any type to gs_plsql_type2;

Succeed.

SQL> grant create session to gs_plsql_type2;

Succeed.

SQL> conn gs_plsql_type2/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_NOT_USE FORCE AS OBJECT
  2 ( month int
  3 ) not final;
  4 /

CT-01001, Permissions were insufficient
SQL> 
SQL> declare
  2 v1 gs_plsql_type.ALL_ATTR_TYPE;
  3 begin
  4   v1 := gs_plsql_type.ALL_ATTR_TYPE(2, 3, 4, 5.1, 'abc', 'def', 'ghi', 'abc123', gs_plsql_type.ATTR_TYPE(1, gs_plsql_type.ATTR_TYPE2(2)));
  5   dbe_output.print_line(v1.a);
  6 end;
  7 /

CT-00944, PL/SQL(GS_PLSQL_TYPE2.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ALL_ATTR_TYPE) terminated with compiling errors
[1:8] PLC-00944 PL/SQL(GS_PLSQL_TYPE.ATTR_SUPER_TYPE) terminated with compiling errors
[3:3] PLC-00958 Unsupported feature



SQL> 
SQL> conn gs_plsql_type/Cantian_234@127.0.0.1:1611

connected.

SQL> grant create type to gs_plsql_type2;

Succeed.

SQL> conn gs_plsql_type2/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_NOT_USE FORCE AS OBJECT
  2 ( month int
  3 ) not final;
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_NOT_USE_SUB FORCE UNDER ATTR_TYPE_NOT_USE
  2 ( day int
  3 );
  4 /

Succeed.

SQL> 
SQL> conn gs_plsql_type/Cantian_234@127.0.0.1:1611

connected.

SQL> drop user if exists gs_plsql_type3 cascade;

Succeed.

SQL> create user gs_plsql_type3 identified by Cantian_234;

Succeed.

SQL> grant create any type to gs_plsql_type3;

Succeed.

SQL> grant create session to gs_plsql_type3;

Succeed.

SQL> conn gs_plsql_type3/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_NOT_USE FORCE AS OBJECT
  2 ( month int
  3 ) not final;
  4 /

Succeed.

SQL> 
SQL> declare
  2 v1 gs_plsql_type.ALL_ATTR_TYPE;
  3 begin
  4   v1 := gs_plsql_type.ALL_ATTR_TYPE(2, 3, 4, 5.1, 'abc', 'def', 'ghi', 'abc123', gs_plsql_type.ATTR_TYPE(1, gs_plsql_type.ATTR_TYPE2(2)));
  5   dbe_output.print_line(v1.a);
  6 end;
  7 /

CT-00944, PL/SQL(GS_PLSQL_TYPE3.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-01001 Permissions were insufficient

SQL> --DTS2019112301103
SQL> CREATE OR REPLACE TYPE gs_plsql_type2.ATTR_TYPE_NOT_USE_SUB FORCE UNDER gs_plsql_type2.ATTR_TYPE_NOT_USE
  2 ( day int
  3 );
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_NOT_USE_SUB FORCE UNDER gs_plsql_type2.ATTR_TYPE_NOT_USE
  2 ( day int
  3 );
  4 /

Succeed.
Warning:
PL/SQL(GS_PLSQL_TYPE3.ATTR_TYPE_NOT_USE_SUB) terminated with compiling errors
[1:58] PLC-00916 PL/SQL:syntax error(supertype and subtype are not in same schema)


SQL> 
SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> drop user gs_plsql_type cascade;

Succeed.

SQL> drop user gs_plsql_type2 cascade;

Succeed.

SQL> drop user gs_plsql_type3 cascade;

Succeed.

SQL> 
SQL> drop user if exists gs_plsql_type cascade;

Succeed.

SQL> create user gs_plsql_type identified by Cantian_234;

Succeed.

SQL> grant all privileges to gs_plsql_type;

Succeed.

SQL> conn gs_plsql_type/Cantian_234@127.0.0.1:1611

connected.

SQL> 
SQL> DECLARE 
  2     type xxxx is record(a int, b int);
  3     type yyyy is record(a xxxx, b int, c xxxx);
  4     v1 yyyy;
  5 BEGIN
  6     v1.a.a :=3; 
  7 	dbe_output.print_line (v1.a.a);
  8     dbe_output.print_line (v1.a.b);
  9     dbe_output.print_line (v1.b);
 10     dbe_output.print_line (v1.c.a);
 11     dbe_output.print_line (v1.c.b);
 12     v1.b:=4;
 13     dbe_output.print_line (v1.b);
 14 END;
 15 /

3




4

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxx is VARRAY(10) OF int;
  3 type yyy is VARRAY(10) OF xxx;
  4 v1 xxx;
  5 v2 yyy;
  6 begin
  7   v2 := yyy(xxx(1,2),xxx(2,3));
  8   dbe_output.print_line(v2(1)(2));
  9 end;
 10 /

2

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxx is VARRAY(10) OF int;
  3 type yyy is VARRAY(10) OF xxx;
  4 v1 xxx;
  5 begin
  6   v1 := yyy(xxx(1,2),xxx(2,3));
  7   dbe_output.print_line(v1(1)(2));
  8 end;
  9 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[6:9] PLC-00965 Expression is of wrong type
[7:25] PLC-00916 PL/SQL:syntax error(object 'v1' must be of type function or array to be used this way)

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE_SET_NULL FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> 
SQL> DECLARE 
  2     v1 ATTR_TYPE_SET_NULL;
  3 BEGIN
  4     v1 := ATTR_TYPE_SET_NULL(3);
  5  dbe_output.print_line (v1.month);
  6     v1 := NULL;
  7     dbe_output.print_line(v1.month || 'null');
  8 END;
  9 /

3
null

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE TYPE TABLE_TYPE_SET_NULL IS TABLE OF VARCHAR(10);
  2 /

Succeed.

SQL> 
SQL> 
SQL> DECLARE
  2  v1 TABLE_TYPE_SET_NULL;
  3 BEGIN
  4  v1 := TABLE_TYPE_SET_NULL('ABC', 'def');
  5  dbe_output.print_line(v1(1));
  6  dbe_output.print_line(v1(2));
  7  v1 := null;
  8  dbe_output.print_line(v1(1));
  9 END;
 10 /

ABC
def
CT-00932, [8:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:2] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00903, Reference to uninitialized collection

SQL> 
SQL> CREATE OR REPLACE TYPE TABLE_TYPE_SET_NULL_VARRAY IS VARRAY(10) OF VARCHAR(10);
  2 /

Succeed.

SQL> 
SQL> DECLARE
  2  v1 TABLE_TYPE_SET_NULL_VARRAY;
  3 BEGIN
  4  v1 := TABLE_TYPE_SET_NULL_VARRAY('ABC', 'def');
  5  dbe_output.print_line(v1(1));
  6  dbe_output.print_line(v1(2));
  7  v1 := null;
  8  dbe_output.print_line(v1(2));
  9 END;
 10 /

ABC
def
CT-00932, [8:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:2] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
CT-00903, Reference to uninitialized collection

SQL> 
SQL> DECLARE
  2  type xxxx is record(
  3   a int,
  4   b int);
  5  v1 xxxx;
  6  v2 xxxx;
  7 BEGIN
  8  v1.a := 3;
  9  v2   := v1;
 10  dbe_output.print_line(v2.a);
 11  dbe_output.print_line(v2.b);
 12 END;
 13 /

3


PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE2 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> 
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 ATTR_TYPE2;
  4 v3 int;
  5 begin
  6   v3 := v1.month;
  7   dbe_output.print_line(v3 ||'null');
  8   v2.month := v1.month;
  9   dbe_output.print_line(v2.month);
 10 end;
 11 /

null
CT-00932, [8:3] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:3] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> create or replace type yyyy is VARRAY(10) OF ATTR_TYPE2;
  2 /

Succeed.

SQL> 
SQL> declare
  2 v1 yyyy;
  3 v2 int;
  4 begin
  5   v1 := yyyy();
  6   v1.EXTEND(2);
  7   v2 := v1(1).month;
  8   dbe_output.print_line(v2 ||'null');
  9 end;
 10 /

null

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v1 yyyy;
  3 v2 int;
  4 begin
  5   v1 := yyyy();
  6   v2 := v1(1).month;
  7   dbe_output.print_line(v2);
  8   v1.EXTEND(2);
  9   v2 := v1(1).month;
 10   dbe_output.print_line(v2);
 11 end;
 12 /

CT-00932, [6:3] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00912, Subscript beyond count

SQL> 
SQL> declare
  2 v1 yyyy;
  3 v2 yyyy;
  4 begin
  5   v1 := yyyy();
  6   v2 := v1;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 v1 yyyy;
  3 v2 yyyy;
  4 begin
  5   v2 := v1;
  6 end;
  7 /

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace type yyyy FORCE is VARRAY(10) OF int;
  2 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE2 FORCE AS OBJECT
  2 ( a yyyy,
  3   b int
  4 );
  5 /

Succeed.

SQL> 
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 ATTR_TYPE2;
  4 begin
  5   v1 := ATTR_TYPE2(null);
  6   v2 := ATTR_TYPE2(yyyy(2));
  7   v2.a := v1.a;
  8   dbe_output.print_line(v2.a(1));
  9 end;
 10 /

CT-00944, PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with compiling errors
[5:9] PLC-02601 Wrong number or types of arguments in call to 'ATTR_TYPE2'
[6:9] PLC-02601 Wrong number or types of arguments in call to 'ATTR_TYPE2'

SQL> 
SQL> declare
  2  v1 ATTR_TYPE2;
  3  v2 ATTR_TYPE2;
  4  type ZZZ is record(
  5   f1 int,
  6   f2 varchar(100));
  7  v3 zzz;
  8 begin
  9  dbe_output.print_line(v3.f1 || 'null');
 10  v3.f1 := '123';
 11  dbe_output.print_line(v3.f1);
 12  dbe_output.print_line(v1.b || 'null');
 13  v1.b := '123';
 14 end;
 15 /

null
123
null
CT-00932, [13:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[13:2] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> declare
  2  v1 ATTR_TYPE2;
  3  v2 ATTR_TYPE2;
  4  type ZZZ is record(
  5   f1 int,
  6   f2 varchar(100));
  7  v3 zzz;
  8 begin
  9  dbe_output.print_line(v3.f1 || 'null');
 10  v3.f1 := '123';
 11  dbe_output.print_line(v3.f1);
 12  dbe_output.print_line(v1.a.count);
 13 end;
 14 /

null
123
CT-00932, [12:2] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[12:2] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
[12:24] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 INT;
  4 begin
  5   v2 := v1.a(1);
  6   dbe_output.print_line(v1.a(1));
  7 end;
  8 /

CT-00932, [5:3] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[5:3] CT-00903, Reference to uninitialized collection

SQL> 
SQL> drop table if exists  for_record_var_table;

Succeed.

SQL> create table for_record_var_table(a varchar(10), b int);

Succeed.

SQL> declare
  2 type xxxx is record(b int, c varchar(20));
  3 v1 xxxx;
  4 v2 for_record_var_table%rowtype;
  5 begin
  6   v1.b := 2;
  7   v1.c := '3';
  8   v2 := v1;
  9   dbe_output.print_line(v2.a);
 10   dbe_output.print_line(v2.b);
 11 end;
 12 /

2
3

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxxx is record(b varchar(20), c int);
  3 v1 xxxx;
  4 v2 for_record_var_table%rowtype;
  5 begin
  6   v1.b := '3ddddddddddd';
  7   v1.c := 2;
  8   v2 := v1;
  9   dbe_output.print_line(v2.a);
 10   dbe_output.print_line(v2.b);
 11 end;
 12 /

CT-00932, [8:3] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:3] CT-00635, Value error: character string buffer too small

SQL> 
SQL> declare
  2 type xxxx is record(b char(20), c int);
  3 v1 xxxx;
  4 v2 for_record_var_table%rowtype;
  5 begin
  6   v1.b := '10';
  7   v1.c := 2;
  8   v2 := v1;
  9   dbe_output.print_line(v2.a);
 10   dbe_output.print_line(v2.b);
 11 end;
 12 /

CT-00932, [8:3] PL/SQL(GS_PLSQL_TYPE.ANONYMOUS BLOCK) terminated with execute errors
[8:3] CT-00635, Value error: character string buffer too small

SQL> 
SQL> declare
  2 type xxxx is record(b raw(10), c int);
  3 v1 xxxx;
  4 v2 for_record_var_table%rowtype;
  5 begin
  6   v1.b := '10';
  7   v1.c := 2;
  8   v2 := v1;
  9   dbe_output.print_line(v2.a);
 10   dbe_output.print_line(v2.b);
 11 end;
 12 /

10
2

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 type xxxx is record(b for_record_var_table%rowtype, c int);
  3 v1 xxxx;
  4 begin
  5   v1.b.a := '10';
  6   v1.b.b := 5;
  7   v1.c := 2;
  8   dbe_output.print_line(v1.b.a);
  9   dbe_output.print_line(v1.b.b);
 10   dbe_output.print_line(v1.c);
 11 end;
 12 /

10
5
2

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists  for_record_var_table;

Succeed.

SQL> create table for_record_var_table(a int, b int);

Succeed.

SQL> declare
  2 type xxxx is record(b number(8,2), c int);
  3 v1 xxxx;
  4 v2 for_record_var_table%rowtype;
  5 begin
  6   v1.b := 2.5;
  7   v1.c := 3;
  8   v2 := v1;
  9   dbe_output.print_line(v2.a);
 10   dbe_output.print_line(v2.b);
 11 end;
 12 /

3
3

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table for_record_var_table purge;

Succeed.

SQL> 
SQL> conn sys/sys@127.0.0.1:1611

connected.

SQL> drop user gs_plsql_type cascade;

Succeed.

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(3) OF VARCHAR2(15); 
  3  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
  4 BEGIN
  5  FOR i IN 1 .. 4 LOOP
  6   dbe_output.print_line(i || '.' || team(i));
  7  END LOOP;
  8 END;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[3:19] PLC-02601 Wrong number or types of arguments in call to 'FOURSOME'

SQL> 
SQL> DECLARE
  2 TYPE t1 IS VARRAY(10) OF INTEGER; -- varray of integer
  3 va t1 := t1(2,3,5);
  4 TYPE nt1 IS VARRAY(10) OF t1;  -- varray of varray of integer
  5 nva nt1 := nt1(t1(55,6,73), 2,t1(55,6,73), t1(2,4));
  6 i INTEGER;
  7 BEGIN
  8  FOR i IN 1 .. 3 LOOP
  9   dbe_output.print_line(i);
 10  END LOOP;
 11 END;
 12 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:12] PLC-02601 Wrong number or types of arguments in call to 'NT1'

SQL> 
SQL> DECLARE
  2 TYPE rec_type IS RECORD ( -- RECORD type
  3 f1 INTEGER,
  4 f2 VARCHAR2(15)
  5 );
  6 value1 rec_type;
  7 value2 rec_type;
  8 TYPE nt1 IS VARRAY(10) OF rec_type;  -- varray of RECORD
  9 nva nt1 := nt1(value1, value2, 2);
 10 BEGIN
 11   value1.f1 := 10;
 12   value1.f2 := 'John';
 13   value2.f1 := 20;
 14   value2.f2 := 'Smith';
 15 END;
 16 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[9:12] PLC-02601 Wrong number or types of arguments in call to 'NT1'

SQL> 
SQL> --test nested constructor 
SQL> DECLARE
  2 TYPE t1 IS VARRAY(10) OF INTEGER; -- varray of integer
  3 TYPE Roster IS TABLE OF t1; -- nested table type
  4 ro Roster := Roster(t1(55,6,73),2,t1(55,6,73), t1(2,4));
  5 BEGIN
  6  FOR i IN 1 .. 3 LOOP
  7   dbe_output.print_line(i);
  8  END LOOP;
  9 END;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[4:14] PLC-02601 Wrong number or types of arguments in call to 'ROSTER'

SQL> 
SQL> DECLARE
  2 TYPE rec_type IS RECORD ( -- RECORD type
  3 f1 INTEGER,
  4 f2 VARCHAR2(15)
  5 );
  6 value1 rec_type;
  7 value2 rec_type;
  8 TYPE Roster IS TABLE OF rec_type;  -- varray of RECORD
  9 ro Roster := Roster(value1, value2, 2);
 10 BEGIN
 11   value1.f1 := 10;
 12   value1.f2 := 'John';
 13   value2.f1 := 20;
 14   value2.f2 := 'Smith';
 15 END;
 16 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[9:14] PLC-02601 Wrong number or types of arguments in call to 'ROSTER'

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF char(16); 
  3  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
  4 BEGIN
  5  FOR i IN 1 .. 4 LOOP
  6   dbe_output.print_line(i || '.' || team(i));
  7  END LOOP;
  8 END;
  9 /

1.John            
2.Mary            
3.Alberto         
4.Juanita         

PL/SQL procedure successfully completed.

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF integer; 
  3  team Foursome := Foursome(1, 2, 3, 4);
  4 BEGIN
  5  FOR i IN 1 .. 4 LOOP
  6   dbe_output.print_line(i || '.' || team(i));
  7  END LOOP;
  8 END;
  9 /

1.1
2.2
3.3
4.4

PL/SQL procedure successfully completed.

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF BIGINT; 
  3  team Foursome := Foursome(9223372036854775807, 9223372036854775806, 9223372036854775802, 9223372036854775800);
  4 BEGIN
  5  FOR i IN 1 .. 4 LOOP
  6   dbe_output.print_line(i || '.' || team(i));
  7  END LOOP;
  8 END;
  9 /

1.9223372036854775807
2.9223372036854775806
3.9223372036854775802
4.9223372036854775800

PL/SQL procedure successfully completed.

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF NUMBER; 
  3  team Foursome := Foursome(3.1415926, 31.415926, 314.15926, 3141.5926);
  4 BEGIN
  5  FOR i IN 1 .. 4 LOOP
  6   dbe_output.print_line(i || '.' || team(i));
  7  END LOOP;
  8 END;
  9 /

1.3.1415926
2.31.415926
3.314.15926
4.3141.5926

PL/SQL procedure successfully completed.

SQL> 
SQL> --test varray constructor
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15); -- VARRAY type
  3  -- varray variable initialized with constructor:
  4  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
  5  
  6 BEGIN
  7  dbe_output.print_line('2001 Team:');
  8  FOR i IN 1 .. 4 LOOP
  9   dbe_output.print_line(i || '.' || team(i));
 10  END LOOP;
 11  dbe_output.print_line('---');
 12  team(3) := 'Pierre'; -- Change values of two elements
 13  team(4) := 'Yvonne'; 
 14  
 15  dbe_output.print_line('2005 Team:');
 16  FOR i IN 1 .. 4 LOOP
 17   dbe_output.print_line(i || '.' || team(i));
 18  END LOOP;
 19  dbe_output.print_line('---');
 20  
 21  -- Invoke constructor to assign new values to varray variable:
 22  team := Foursome('Arun', 'Amitha', 'Allan', 'Mae');
 23   dbe_output.print_line('2009 Team:');
 24  FOR i IN 1 .. 4 LOOP
 25   dbe_output.print_line(i || '.' || team(i));
 26  END LOOP;
 27  dbe_output.print_line('---');
 28 END;
 29 /

2001 Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
2005 Team:
1.John
2.Mary
3.Pierre
4.Yvonne
---
2009 Team:
1.Arun
2.Amitha
3.Allan
4.Mae
---

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15); -- VARRAY type
  3  -- varray variable initialized with constructor:
  4  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
  5 BEGIN
  6  dbe_output.print_line('2001 Team:');
  7  FOR i IN 1 .. team.count() LOOP
  8   dbe_output.print_line(i || '.' || team(i));
  9  END LOOP;
 10  team(3) := 'Pierre'; -- Change values of two elements
 11  team(4) := 'Yvonne';
 12  
 13  dbe_output.print_line('2005 Team:');
 14  FOR i IN 1 .. team.count() LOOP
 15   dbe_output.print_line(i || '.' || team(i));
 16  END LOOP; 
 17  -- Invoke constructor to assign new values to varray variable:
 18  team := Foursome('Arun', 'Amitha', 'Allan', 'Mae');
 19  dbe_output.print_line('2009 Team:');
 20   FOR i IN 1 .. team.count() LOOP
 21   dbe_output.print_line(i || '.' || team(i));
 22  END LOOP; 
 23 END;
 24 /

2001 Team:
1.John
2.Mary
3.Alberto
4.Juanita
2005 Team:
1.John
2.Mary
3.Pierre
4.Yvonne
2009 Team:
1.Arun
2.Amitha
3.Allan
4.Mae

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);
  3  team Foursome := Foursome(); -- initialize to empty
  4 
  5 BEGIN
  6  dbe_output.print_line('Team:');
  7  IF team.COUNT() = 0 THEN
  8   dbe_output.print_line('Empty');
  9  ELSE
 10   FOR i IN 1 .. team.COUNT() LOOP
 11    dbe_output.print_line(i || '.' || team(i));
 12   END LOOP;
 13  END IF;
 14  dbe_output.print_line('---');
 15  team := Foursome('John', 'Mary', 'Alberto', 'Juanita');
 16  dbe_output.print_line('Team:');
 17   IF team.COUNT() = 0 THEN
 18    dbe_output.print_line('Empty');
 19   ELSE
 20    FOR i IN 1 .. team.COUNT() LOOP
 21     dbe_output.print_line(i || '.' || team(i));
 22    END LOOP;
 23   END IF;
 24   dbe_output.print_line('---');
 25 END;
 26 /

Team:
Empty
---
Team:
1.John
2.Mary
3.Alberto
4.Juanita
---

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> 
SQL> DECLARE
  2  TYPE Foursome IS table OF VARCHAR2(15); -- VARRAY type
  3  -- varray variable initialized with constructor:
  4  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
  5  
  6 BEGIN
  7  dbe_output.print_line('2001 Team:');
  8  FOR i IN 1 .. 4 LOOP
  9   dbe_output.print_line(i || '.' || team(i));
 10  END LOOP;
 11  dbe_output.print_line('---');
 12  team(3) := 'Pierre'; -- Change values of two elements
 13  team(4) := 'Yvonne'; 
 14  
 15  dbe_output.print_line('2005 Team:');
 16  FOR i IN 1 .. 4 LOOP
 17   dbe_output.print_line(i || '.' || team(i));
 18  END LOOP;
 19  dbe_output.print_line('---');
 20  
 21  -- Invoke constructor to assign new values to varray variable:
 22  team := Foursome('Arun', 'Amitha', 'Allan', 'Mae');
 23  dbe_output.print_line('2009 Team:');
 24  FOR i IN 1 .. 4 LOOP
 25   dbe_output.print_line(i || '.' || team(i));
 26  END LOOP;
 27  dbe_output.print_line('---');
 28  dbe_output.print_line(team.count());
 29  team.extend();
 30  team(5) := 'what';
 31  dbe_output.print_line('2010 Team:');
 32  dbe_output.print_line(team.first());
 33  dbe_output.print_line(team.last());
 34  FOR i IN team.first() .. team.last() LOOP
 35   dbe_output.print_line(i || '.' || team(i));
 36  END LOOP;
 37  dbe_output.print_line('---');
 38 END;
 39 /

2001 Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
2005 Team:
1.John
2.Mary
3.Pierre
4.Yvonne
---
2009 Team:
1.Arun
2.Amitha
3.Allan
4.Mae
---
4
2010 Team:
1
5
1.Arun
2.Amitha
3.Allan
4.Mae
5.what
---

PL/SQL procedure successfully completed.

SQL> 
SQL> declare
  2 TYPE R1 IS RECORD(F1 INTEGER, F2 VARCHAR2(15));
  3 var_r1 R1;
  4 TYPE C1 IS VARRAY(4) OF R1;
  5 var_c1 C1 :=C1(var_r1);
  6 begin
  7   var_c1:= C1(var_r1);
  8   var_r1.F1:=3;
  9   var_r1.F2:='123';
 10   var_c1.EXTEND;
 11   var_c1(1) := var_r1;
 12   dbe_output.print_line(var_r1.F1);
 13   dbe_output.print_line(var_r1.F2);
 14   dbe_output.print_line(var_c1(1).F1);
 15   dbe_output.print_line(var_c1(1).F2);
 16   SELECT 1 INTO var_c1(1).F1 FROM DUAL;
 17   SELECT '456' INTO var_c1(1).F2 FROM DUAL;
 18   dbe_output.print_line(var_r1.F1);
 19   dbe_output.print_line(var_r1.F2);
 20   dbe_output.print_line(var_c1(1).F1);
 21   dbe_output.print_line(var_c1(1).F2);
 22 end;
 23 /

3
123
3
123
3
123
1
456

PL/SQL procedure successfully completed.

SQL> 
SQL> --core
SQL> declare
  2  TYPE C1 IS VARRAY(4) OF varchar(100);
  3  TYPE C2 IS TABLE OF INTEGER;
  4  TYPE R1 IS RECORD(
  5   F1 C1,
  6   F2 C2);
  7  var_C1 C1 := C1('123', 234, 345);
  8  var_C2 C2;
  9  var_R1 R1;
 10 begin
 11  var_C2 := C2();
 12  var_C2.EXTEND;
 13  var_C2(1) := '456';
 14  var_C2.EXTEND;
 15  var_C2(2) := '567';
 16  var_R1.F1 := var_C1;
 17  var_R1.F2 := var_C2;
 18  FOR i IN 1 .. var_R1.F1.COUNT() LOOP
 19   dbe_output.print_line(i || '.' || var_R1.F1(i));
 20  END LOOP;
 21  FOR i IN 1 .. var_C2.COUNT() LOOP
 22   dbe_output.print_line(i || '.' || var_C2(i));
 23  END LOOP;
 24  FOR i IN 1 .. var_R1.F2.COUNT() LOOP
 25   dbe_output.print_line(i || '.' || var_R1.F2(i));
 26  END LOOP;
 27  FOR i IN 1 .. var_C2.COUNT() LOOP
 28   dbe_output.print_line(i || '.' || var_C2(i));
 29  END LOOP;
 30  var_C1 := C1('NEW_123', 1234, 1345);
 31  FOR i IN 1 .. var_C2.COUNT() LOOP
 32   var_C2(i) := i;
 33  END LOOP;
 34  FOR i IN 1 .. var_R1.F1.COUNT() LOOP
 35   dbe_output.print_line(i || '.' || var_R1.F1(i));
 36  END LOOP;
 37  FOR i IN 1 .. var_C1.COUNT() LOOP
 38   dbe_output.print_line(i || '.' || var_C1(i));
 39  END LOOP;
 40  FOR i IN 1 .. var_R1.F2.COUNT() LOOP
 41   dbe_output.print_line(i || '.' || var_R1.F2(i));
 42  END LOOP;
 43  FOR i IN 1 .. var_C2.COUNT() LOOP
 44   dbe_output.print_line(i || '.' || var_C2(i));
 45  END LOOP;
 46 
 47 end;
 48 /

1.123
2.234
3.345
1.456
2.567
1.456
2.567
1.456
2.567
1.123
2.234
3.345
1.NEW_123
2.1234
3.1345
1.456
2.567
1.1
2.2

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace type test_type_varchar1 is table of varchar2(24);  
  2 / 

Succeed.

SQL> 
SQL> create or replace type test_type_varchar2 is table of varchar2(20);
  2 /	 

Succeed.

SQL> 
SQL> create or replace type test_type_varchar3 is table of varchar2(26);
  2 /	 

Succeed.

SQL> 
SQL> create or replace type test_type_varchar4 is VARRAY(5) of varchar2(24);
  2 /

Succeed.

SQL> 
SQL> create or replace type test_type_varchar5 is VARRAY(5) of varchar2(10);
  2 /

Succeed.

SQL> 
SQL> create or replace type test_type_varchar6_1 is VARRAY(3) of varchar2(30);
  2 /

Succeed.

SQL> 
SQL> create or replace type test_type_varchar7 is VARRAY(3) of test_type_varchar6_1;
  2 /

Succeed.

SQL> 
SQL> create or replace type test_type_number1 is table of number;
  2 /	 	  

Succeed.

SQL> 
SQL> create or replace type dsh_record1 is object (f1 varchar2(10));
  2 /

Succeed.

SQL> 
SQL> create or replace type dsh_record2 is object (f1 varchar2(20));
  2 /

Succeed.

SQL> 
SQL> create or replace type dsh_type1 is VARRAY(3) of varchar2(30);
  2 /

Succeed.

SQL> 
SQL> 
SQL> create table if not exists test_t1(f1 varchar(30));

Succeed.

SQL> 
SQL> 
SQL> --test cast func 1st arg contains collection
SQL> DECLARE
  2     i_n1 test_type_varchar7;
  3 BEGIN
  4     i_n1 :=test_type_varchar7(test_type_varchar6_1('aaa','bbb'),test_type_varchar6_1('ccc','hjj'),test_type_varchar6_1('ddd','dff'));
  5     insert into test_t1 select * from table(cast(i_n1 as test_type_varchar4));
  6 END;
  7 /

CT-00932, [5:5] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[5:5] CT-00921, The PL/SQL values (the 1st-arg's data type in cast func is not supported) were incorrect.

SQL> 
SQL> --test cast func 2nd arg contains collection
SQL> DECLARE
  2     i_n1 test_type_varchar5;
  3 BEGIN
  4     i_n1 :=test_type_varchar5('abc','dge');
  5     insert into test_t1 select * from table(cast(i_n1 as test_type_varchar7));
  6 END;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:5] PLC-00921 The PL/SQL values (the 2nd-arg's data type in cast func is not supported) were incorrect.

SQL> 
SQL> DECLARE
  2     i_n1 test_type_varchar5;
  3 BEGIN
  4     i_n1 :=test_type_varchar5('abc','dge');
  5     insert into test_t1 select * from table(cast(i_n1 as test_type_varchar7));
  6 END;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:5] PLC-00921 The PL/SQL values (the 2nd-arg's data type in cast func is not supported) were incorrect.

SQL> 
SQL> --test cast 1st arg is local collection variant
SQL> DECLARE TYPE t_name IS TABLE OF varchar2(10); 
  2         i_n1 t_name := t_name(); 
  3 BEGIN
  4         i_n1.EXTEND(2); 
  5         i_n1(1):='aaa'; 
  6         i_n1(2):='bbb';
  7 	  dbe_output.print_line (i_n1(1));
  8 	  dbe_output.print_line (i_n1(2));
  9 	  insert  into test_t1 select column_value from table(cast(i_n1 as test_type_varchar1) ) ;
 10 END;
 11 /

aaa
bbb
CT-00932, [9:4] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[9:4] CT-00241, The argument 1 should be type global collection

SQL> 
SQL> --test cast 2nd arg is local collection variant
SQL> DECLARE 
  2 		TYPE t_name IS TABLE OF varchar2(30); 
  3         i_n1 test_type_varchar1:=test_type_varchar1();
  4 BEGIN
  5         i_n1.EXTEND(2); 
  6         i_n1(1):='jj'; 
  7         i_n1(2):='bbb';
  8 	  dbe_output.print_line (i_n1(1));
  9 	  dbe_output.print_line (i_n1(2));
 10 	  insert  into test_t1 select column_value from table(cast(i_n1 as t_name) ) ;
 11 END;
 12 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[10:4] PLC-00241 The argument 2 should be type global collection

SQL> 
SQL> 
SQL> ---test cast func precision
SQL>  declare
  2     a test_type_varchar1 := test_type_varchar1();
  3   begin 
  4      delete from test_t1;
  5          commit;
  6      a.extend(3);
  7          a(1) := '1';
  8          a(3) := '2';
  9        insert  into test_t1 select column_value from table(cast(a as test_type_varchar2 ) ) ;
 10          commit;
 11    end;
 12   /

PL/SQL procedure successfully completed.

SQL> 
SQL>   declare
  2     a test_type_varchar1 := test_type_varchar1();
  3   begin 
  4      delete from test_t1;
  5          commit;
  6      a.extend(3);
  7          a(1) := '1';
  8          a(2) := '123456789123456789123456';
  9        insert  into test_t1 select column_value from table(cast(a as test_type_varchar2 ) ) ;
 10          commit;
 11    end;
 12   /

CT-00932, [9:8] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[9:8] CT-00665, Value size(24) from cast operand is larger than cast target size(20)

SQL> 
SQL> --test cast transform type
SQL>  declare
  2     a test_type_varchar1 := test_type_varchar1();
  3   begin 
  4      delete from test_t1;
  5          commit;
  6      a.extend(3);
  7          a(1) := '1';
  8          a(3) := '2';
  9        insert  into test_t1 select column_value from table(cast(a as test_type_number1 ) ) ;
 10          commit;
 11    end;
 12   /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL>  --test cast func 1st arg is member of collection variant
SQL>  declare
  2     a test_type_varchar1 := test_type_varchar1();
  3   begin 
  4      delete from test_t1;
  5          commit;
  6      a.extend(3);
  7          a(1) := '1';
  8          a(3) := '2';
  9        insert  into test_t1 select column_value from table(cast(a(1) as test_type_number1 ) ) ;
 10          commit;
 11    end;
 12   /

CT-00932, [9:8] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[9:8] CT-00606, Inconsistent datatypes, expected COLLECTION - got VARCHAR

SQL> 
SQL> --test cast using scalar as 2nd arg  
SQL> DECLARE 
  2     i_n1 int := 1; 
  3 BEGIN
  4 	dbe_output.print_line (i_n1);
  5     insert into test_t1 select * from table(cast(i_n1 as varchar(10)) ) ;
  6 END;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:66] PLC-00601 Sql syntax error: expected end but 10 found

SQL> 
SQL> --test cast(varray as record)
SQL> DECLARE
  2     i_n1 dsh_type1 := dsh_type1();
  3 BEGIN
  4     i_n1.EXTEND(2);
  5     i_n1(1):='aaa';
  6     i_n1(2):='bbb';
  7     insert into test_t1 select * from table(cast(i_n1 as dsh_record2));
  8 END;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:5] PLC-00241 The argument 2 should be type global collection

SQL> 
SQL> --test cast(record as varray)
SQL> DECLARE
  2     i_n1 dsh_record1 ;
  3 BEGIN
  4 	i_n1 := dsh_record1('aaa');
  5     insert into test_t1 select * from table(cast(i_n1 as dsh_type3));
  6 END;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:5] PLC-00241 The argument 2 should be type global collection

SQL> 
SQL> --test cast success
SQL> DECLARE
  2     i_n1 test_type_varchar1 := test_type_varchar1();
  3 BEGIN
  4     i_n1.EXTEND(3);
  5     i_n1(1):='dda';
  6     i_n1(2):='bhb';
  7     i_n1(3):='brf';
  8     insert into test_t1 select * from table(cast(i_n1 as test_type_varchar3));
  9 END;
 10 /

PL/SQL procedure successfully completed.

SQL> 
SQL> drop type test_type_varchar1 force;

Succeed.

SQL> drop type test_type_varchar2 force;

Succeed.

SQL> drop type test_type_varchar3 force;

Succeed.

SQL> drop type test_type_varchar4 force;

Succeed.

SQL> drop type test_type_varchar5 force;

Succeed.

SQL> drop type test_type_varchar6_1 force;

Succeed.

SQL> drop type test_type_varchar7 force;

Succeed.

SQL> drop type dsh_record1 force;

Succeed.

SQL> drop type dsh_record2 force;

Succeed.

SQL> drop type test_type_number1 force;

Succeed.

SQL> drop type dsh_type1 force;

Succeed.

SQL> drop table test_t1 purge;

Succeed.

SQL> 
SQL> ----test record is null
SQL> create or replace type myrecord1 is object (a varchar2(10));
  2 /

Succeed.

SQL> 
SQL> DECLARE
  2     x myrecord1 ;
  3 BEGIN
  4 	x := myrecord1('aafa');
  5 	if x is NULL then
  6     dbe_output.print_line('x' || ' is null');
  7 	end if;
  8 END;
  9 /

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 	type xxxx is record(a int, b int);
  3 	v1 xxxx;
  4 	v2 xxxx;
  5 BEGIN
  6 	v1.a := 3;
  7 	if v1 is not NULL then
  8     dbe_output.print_line('v1' || v1.a||' is not null');
  9 	end if;
 10 END;
 11 /

v13 is not null

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  type xxxx is record(
  3   a int,
  4   b int);
  5  TYPE C1 IS VARRAY(4) OF xxxx;
  6  v1 C1;
  7 BEGIN
  8  v1 := C1();
  9  v1.EXTEND();
 10  v1(1) := NULL;
 11  v1(1).a := 3;
 12  v1(1).b := 5;
 13  dbe_output.print_line(v1(1).a);
 14  dbe_output.print_line(v1(1).b);
 15 END;
 16 /

3
5

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace type xxxx force is object (
  2   a int,
  3   b int);
  4 /

Succeed.

SQL> DECLARE
  2  TYPE C1 IS VARRAY(4) OF xxxx;
  3  v1 C1;
  4 BEGIN
  5  v1 := C1();
  6  v1.EXTEND();
  7  v1(1) := NULL;
  8  v1(1).a := 3;
  9  v1(1).b := 5;
 10  dbe_output.print_line(v1(1).a);
 11  dbe_output.print_line(v1(1).b);
 12 END;
 13 /

CT-00932, [8:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:2] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> DECLARE
  2  type xxxx is record(
  3   a int,
  4   b int);
  5  type yyyy is record(
  6   a xxxx);
  7  v1 yyyy;
  8  v2 xxxx;
  9 BEGIN
 10  v1.a := v2;
 11  v1.a.a := 3;
 12  v1.a.b := 5;
 13  dbe_output.print_line(v1.a.a);
 14  dbe_output.print_line(v1.a.b);
 15 END;
 16 /

3
5

PL/SQL procedure successfully completed.

SQL> 
SQL> -- test type table
SQL> drop TYPE if exists ATTR_TYPE10 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE11 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE12 force;

Succeed.

SQL> drop TYPE if exists zzz force;

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE12 FORCE AS OBJECT
  2 ( day int
  3 ) not final;
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE10 FORCE UNDER ATTR_TYPE12
  2 ( month ATTR_TYPE11
  3 );
  4 /

Succeed.
Warning:
PL/SQL(SYS.ATTR_TYPE10) terminated with compiling errors
[2:9] PLC-00828 type SYS.ATTR_TYPE11 does not exist


SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ATTR_TYPE10';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ATTR_TYPE10                                                      OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where TYPE_NAME='ATTR_TYPE10' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> create or replace type ZZZ FORCE is VARRAY(20) OF ATTR_TYPE11;
  2 /

Succeed.
Warning:
PL/SQL(SYS.ZZZ) terminated with compiling errors
[1:51] PLC-00601 Sql syntax error: datatype expected, but got 'ATTR_TYPE11'


SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ZZZ                                                              OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE11 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> 
SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where TYPE_NAME='ATTR_TYPE10' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> declare
  2 v1 ATTR_TYPE10;
  3 v2 ZZZ;
  4 begin
  5   v1 := ATTR_TYPE10(1, ATTR_TYPE11(5));
  6   v2 := ZZZ();
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where TYPE_NAME='ATTR_TYPE10' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------
ATTR_TYPE10                                                      DAY                                                              1                          BINARY_INTEGER                                                                             0            0                         1           
ATTR_TYPE10                                                      MONTH                                                            2                          ATTR_TYPE11                                                                                                                       0           

2 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------
ZZZ                                                              VARYING ARRAY                                                    20                         ATTR_TYPE11                                                                                                                       1           

1 rows fetched.

SQL> 
SQL> drop TYPE if exists ATTR_TYPE10 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE11 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE12 force;

Succeed.

SQL> drop TYPE if exists zzz force;

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE12 FORCE AS OBJECT
  2 ( day int
  3 ) not final;
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE11 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE10 FORCE UNDER ATTR_TYPE12
  2 ( month ATTR_TYPE11
  3 );
  4 /

Succeed.

SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ATTR_TYPE10';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ATTR_TYPE10                                                      OBJECT    2            0            0            0            1            1            ATTR_TYPE12                                                      1                0            

1 rows fetched.

SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where TYPE_NAME='ATTR_TYPE10' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------
ATTR_TYPE10                                                      DAY                                                              1                          BINARY_INTEGER                                                                             0            0                         1           
ATTR_TYPE10                                                      MONTH                                                            2                          ATTR_TYPE11                                                                                                                       0           

2 rows fetched.

SQL> 
SQL> create or replace type ZZZ FORCE is VARRAY(20) OF ATTR_TYPE11;
  2 /

Succeed.

SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ZZZ                                                              COLLECTION 0            0            0            0            1            1                                                                             0                0            

1 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------
ZZZ                                                              VARYING ARRAY                                                    20                         ATTR_TYPE11                                                                                                                       1           

1 rows fetched.

SQL> 
SQL> drop TYPE ATTR_TYPE11 force;

Succeed.

SQL> 
SQL> declare
  2 v1 ATTR_TYPE10;
  3 begin
  4   v1 := ATTR_TYPE10(1, ATTR_TYPE11(5));
  5 end;
  6 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00944 PL/SQL(SYS.ATTR_TYPE10) terminated with compiling errors
[2:9] PLC-00828 type SYS.ATTR_TYPE11 does not exist


SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ATTR_TYPE10';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ATTR_TYPE10                                                      OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,ATTR_NAME,ATTR_NO,ATTR_TYPE_MOD,ATTR_TYPE_NAME,ATTR_TYPE,LENGTH,PRECISION,SCALE,CHAR_SET,INHERITED from SYS.SYS_TYPE_ATTRS where TYPE_NAME='ATTR_TYPE10' ORDER BY ATTR_NO;

TYPE_NAME                                                        ATTR_NAME                                                        ATTR_NO      ATTR_TYPE_MOD ATTR_TYPE_NAME                                                   ATTR_TYPE    LENGTH       PRECISION    SCALE        CHAR_SET     INHERITED   
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> declare
  2 v2 ZZZ;
  3 begin
  4   v2 := ZZZ;
  5 end;
  6 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[2:4] PLC-00944 PL/SQL(SYS.ZZZ) terminated with compiling errors
[1:19] PLC-00601 Sql syntax error: datatype expected, but got 'ATTR_TYPE11'


SQL> 
SQL> select TYPE_NAME,TYPE_CODE,ATTRIBUTES,METHODS,PREDEFINED,INCOMPLETE,FINAL,INSTANTIABLE,SUPERTYPE_NAME,LOCAL_ATTRIBUTES,LOCAL_METHODS from SYS.SYS_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        TYPE_CODE ATTRIBUTES   METHODS      PREDEFINED   INCOMPLETE   FINAL        INSTANTIABLE SUPERTYPE_NAME                                                   LOCAL_ATTRIBUTES LOCAL_METHODS
---------------------------------------------------------------- --------- ------------ ------------ ------------ ------------ ------------ ------------ ---------------------------------------------------------------- ---------------- -------------
ZZZ                                                              OBJECT    0            0            0            1            1            1                                                                                                           

1 rows fetched.

SQL> select TYPE_NAME,COLL_TYPE,UPPER_BOUND,ELEM_TYPE_MOD,ELEM_TYPE_NAME,LENGTH,PRECISION,SCALE,CHAR_SET,ELEM_STORAGE,NULLS_STORED from SYS.SYS_COLL_TYPES where TYPE_NAME='ZZZ';

TYPE_NAME                                                        COLL_TYPE                                                        UPPER_BOUND  ELEM_TYPE_MOD ELEM_TYPE_NAME                                                   LENGTH       PRECISION    SCALE        CHAR_SET     ELEM_STORAGE NULLS_STORED
---------------------------------------------------------------- ---------------------------------------------------------------- ------------ ------------- ---------------------------------------------------------------- ------------ ------------ ------------ ------------ ------------ ------------

0 rows fetched.

SQL> 
SQL> drop TYPE if exists ATTR_TYPE10 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE11 force;

Succeed.

SQL> drop TYPE if exists ATTR_TYPE12 force;

Succeed.

SQL> drop TYPE if exists zzz force;

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE lv2_type FORCE AS OBJECT
  2 ( a NUMBER(6)
  3 , b VARCHAR2(20)
  4 ) ;
  5 /

Succeed.

SQL> CREATE OR REPLACE TYPE lv1_type FORCE AS OBJECT
  2 ( a NUMBER(6)
  3 , b VARCHAR2(20)
  4 , c lv2_type
  5 ) ;
  6 /

Succeed.

SQL> 
SQL> declare
  2 b lv1_type;
  3 BEGIN
  4 b := lv1_type(3,'abc', lv2_type(1, 'kkk'));
  5 b := lv1_type(3,'abc', null);
  6 dbe_output.print_line(b.a);
  7 dbe_output.print_line(b.b);
  8 b := null;
  9 dbe_output.print_line(b.a || 'null');
 10 dbe_output.print_line(b.b || 'null');
 11 dbe_output.print_line(b.c.a || 'null');
 12 dbe_output.print_line(b.c.b || 'null');
 13 END;
 14 /

3
abc
null
null
null
null

PL/SQL procedure successfully completed.

SQL> 
SQL> CREATE OR REPLACE TYPE data_typ_error AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 day NUMBER
  5 );
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_ERROR) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE sys force AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER
  4 );
  5 /

Succeed.
Warning:
PL/SQL(SYS.SYS) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> drop type sys;

Succeed.

SQL> 
SQL> CREATE OR REPLACE TYPE default_in_type FORCE AS OBJECT
  2 ( bbb int
  3 , aaa int := 12
  4 ) ;
  5 /

Succeed.
Warning:
PL/SQL(SYS.DEFAULT_IN_TYPE) terminated with compiling errors
[3:7] PLC-00607 Invalid datatype for type defining, object attribute must not have default value


SQL> 
SQL> CREATE OR REPLACE TYPE cursor_in_type FORCE AS OBJECT
  2 ( cursor idx is select a from for_cursor_record_t1
  3 ) ;
  4 /

Succeed.
Warning:
PL/SQL(SYS.CURSOR_IN_TYPE) terminated with compiling errors
[2:10] PLC-00828 type SYS.IDX does not exist


SQL> 
SQL> CREATE OR REPLACE TYPE cursor_in_type FORCE AS OBJECT
  2 ( ct SYS_REFCURSOR
  3 ) ;
  4 /

Succeed.
Warning:
PL/SQL(SYS.CURSOR_IN_TYPE) terminated with compiling errors
[2:6] PLC-00828 type SYS.SYS_REFCURSOR does not exist


SQL> 
SQL> CREATE OR REPLACE TYPE data_typ3 FORCE AS OBJECT
  2 ( year NUMBER,
  3   prod NUMBER,
  4 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  5 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  6 ) NOT FINAL;
  7 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP3) terminated with compiling errors
[4:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 ) NOT INSTANTIABLE;
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 ) NOT FINAL NOT INSTANTIABLE;
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_FINAL FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 ) NOT FINAL;
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_FINAL) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_FINAL FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 );
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_FINAL) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 FINAL MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 NOT INSTANTIABLE MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER,
  5 FINAL NOT INSTANTIABLE MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER
  6 ) NOT FINAL NOT INSTANTIABLE;
  7 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> -- STATIC conflicts with NOT INSTANTIABLE
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 NOT INSTANTIABLE STATIC FUNCTION prod2(invent NUMBER) RETURN NUMBER,
  5 NOT INSTANTIABLE MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER
  6 ) NOT FINAL NOT INSTANTIABLE;
  7 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> -- method does not override
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 OVERRIDING MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 NOT INSTANTIABLE MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER,
  5 NOT INSTANTIABLE MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER
  6 ) NOT FINAL NOT INSTANTIABLE;
  7 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> -- name of subproc cannot be duplicated
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 OVERRIDING MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  5 NOT INSTANTIABLE MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER,
  6 NOT INSTANTIABLE MEMBER FUNCTION prod3(invent NUMBER) RETURN NUMBER
  7 ) NOT FINAL NOT INSTANTIABLE;
  8 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE DATA_TYP_NOT_INSTANT FORCE AS OBJECT
  2 ( year NUMBER,
  3 FINAL MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 NOT INSTANTIABLE MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 ) NOT FINAL NOT INSTANTIABLE;
  6 /

Succeed.
Warning:
PL/SQL(SYS.DATA_TYP_NOT_INSTANT) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> -- TYPE_DAY->TYPE_MONTH->TYPE_DAY fail
SQL> CREATE OR REPLACE TYPE TYPE_DAY FORCE AS OBJECT
  2 ( day NUMBER
  3 );
  4 /

Succeed.

SQL> CREATE OR REPLACE TYPE TYPE_MONTH FORCE AS OBJECT
  2 ( month NUMBER,
  3   day TYPE_DAY
  4 );
  5 /

Succeed.

SQL> CREATE OR REPLACE TYPE TYPE_DAY FORCE AS OBJECT
  2 ( year NUMBER,
  3   month TYPE_MONTH
  4 );
  5 /

Succeed.
Warning:
PL/SQL(SYS.TYPE_DAY) terminated with compiling errors
[3:9] PLC-00944 PL/SQL(SYS.TYPE_MONTH) terminated with compiling errors
[3:7] PLC-00916 PL/SQL:syntax error(type SYS.TYPE_DAY cannot be recursive)



SQL> 
SQL> -- DATA_TYP_USING_REPLACE attr using, replace DATA_TYP_USING_REPLACE success
SQL> CREATE OR REPLACE TYPE DATA_TYP_USING_REPLACE FORCE AS OBJECT
  2 ( year NUMBER
  3 );
  4 /

Succeed.

SQL> create or replace function FVT_FUN_01_01(id int) return int 
  2 is
  3  count_row int := 0;
  4  kkk DATA_TYP_USING_REPLACE;
  5 begin
  6  kkk := DATA_TYP_USING_REPLACE(2);
  7  execute immediate 'CREATE OR REPLACE TYPE DATA_TYP_USING_REPLACE FORCE AS OBJECT
  8 ( year NUMBER,
  9 day NUMBER
 10 );';
 11  dbe_output.print_line(kkk.year);
 12  execute immediate 'declare xxx DATA_TYP_USING_REPLACE; begin xxx := DATA_TYP_USING_REPLACE(5,6); dbe_output.print_line(xxx.year); dbe_output.print_line(xxx.day); end;';
 13  return count_row;
 14 end;
 15 /

Succeed.

SQL> declare
  2 a int;
  3 begin
  4  a := FVT_FUN_01_01(3);
  5 end;
  6 /

2
5
6

PL/SQL procedure successfully completed.

SQL> 
SQL> -- object can not use %rowtype and %type
SQL> drop table if exists TYPE_TABLE;

Succeed.

SQL> CREATE TABLE TYPE_TABLE(a int, b int);

Succeed.

SQL> CREATE OR REPLACE TYPE TYPE_OF_TABLE FORCE AS OBJECT
  2 ( year TYPE_TABLE%rowtype
  3 );
  4 /

Succeed.
Warning:
PL/SQL(SYS.TYPE_OF_TABLE) terminated with compiling errors
[2:8] PLC-00607 Invalid datatype for type defining


SQL> CREATE OR REPLACE TYPE TYPE_OF_TABLE FORCE AS OBJECT
  2 ( day TYPE_TABLE.a%type
  3 );
  4 /

Succeed.
Warning:
PL/SQL(SYS.TYPE_OF_TABLE) terminated with compiling errors
[2:7] PLC-00607 Invalid datatype for type defining


SQL> 
SQL> -- different type construct setvalue fail
SQL> CREATE OR REPLACE TYPE CONSTRUCT_TYPE FORCE AS OBJECT
  2 ( year int
  3 );
  4 /

Succeed.

SQL> CREATE OR REPLACE TYPE OTHER_CONSTRUCT_TYPE FORCE AS OBJECT
  2 ( year int
  3 );
  4 /

Succeed.

SQL> CREATE OR REPLACE PROCEDURE USE_CONSTRUCT_PROC IS
  2 a CONSTRUCT_TYPE;
  3 BEGIN
  4   a := OTHER_CONSTRUCT_TYPE(5);
  5 END;
  6 /

Succeed.
Warning:
PL/SQL(SYS.USE_CONSTRUCT_PROC) terminated with compiling errors
[4:8] PLC-00965 Expression is of wrong type


SQL> 
SQL> -- success
SQL> CREATE OR REPLACE TYPE OVERRIDING_METHOD_TYPE FORCE AS OBJECT
  2 ( year NUMBER,
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 ) NOT INSTANTIABLE NOT FINAL;
  6 /

Succeed.
Warning:
PL/SQL(SYS.OVERRIDING_METHOD_TYPE) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> -- object must have attibute fail
SQL> CREATE OR REPLACE TYPE NO_ATTR_TYPE FORCE AS OBJECT
  2 (
  3 MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER,
  4 MEMBER FUNCTION prod2(invent NUMBER) RETURN NUMBER
  5 );
  6 /

Succeed.
Warning:
PL/SQL(SYS.NO_ATTR_TYPE) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> CREATE OR REPLACE TYPE ATTR_TYPE2 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> CREATE OR REPLACE TYPE ATTR_TYPE3 FORCE AS OBJECT
  2 ( month int
  3 );
  4 /

Succeed.

SQL> CREATE OR REPLACE TYPE ATTR_TYPE FORCE AS OBJECT
  2 ( year int,
  3   month ATTR_TYPE2
  4 );
  5 /

Succeed.

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE3;
  3 v2 ATTR_TYPE2;
  4 begin
  5   v1 := ATTR_TYPE2(2);
  6 end;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE3;
  3 v2 ATTR_TYPE2;
  4 begin
  5   v1 := ATTR_TYPE3(2);
  6   v2 := ATTR_TYPE2(3);
  7   v2 := v1;
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:9] PLC-00965 Expression is of wrong type

SQL> -- oracle success
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 ATTR_TYPE2;
  4 begin
  5   v1 := ATTR_TYPE2(2);
  6   v2 := v1;
  7   dbe_output.print_line(v2.month);
  8 end;
  9 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 ATTR_TYPE2;
  4 begin
  5   v1 := ATTR_TYPE2(2);
  6   v2 := v1;
  7   v2.month := 5;
  8   dbe_output.print_line(v2.month);
  9 end;
 10 /

5

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 ATTR_TYPE2;
  4 v3 int;
  5 begin
  6   v1 := null;
  7   v2 := v1;
  8   v3 := v1.month;
  9   dbe_output.print_line(v3 || 'null');
 10   v3 := v2.month;
 11   dbe_output.print_line(v3 || 'null');
 12 end;
 13 /

null
null

PL/SQL procedure successfully completed.

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v3 int := 0;
  4 begin
  5   v1 := null;
  6   v1.month := v3;
  7 end;
  8 /

CT-00932, [6:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00901, The referenced object type was not initialized.

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v3 int;
  4 begin
  5   v1 := v3;
  6 end;
  7 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[5:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE;
  3 begin
  4   v1 := ATTR_TYPE(2, 3);
  5 end;
  6 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[4:9] PLC-02601 Wrong number or types of arguments in call to 'ATTR_TYPE'

SQL> DROP TABLE IF EXISTS TYPE_TEST_TABLE;

Succeed.

SQL> CREATE TABLE TYPE_TEST_TABLE(a INT);

Succeed.

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 TYPE_TEST_TABLE%ROWTYPE;
  4 begin
  5   v1 := ATTR_TYPE2(2);
  6   v2.a := 4;
  7   v1 := v2;
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE2;
  3 v2 TYPE_TEST_TABLE%ROWTYPE;
  4 begin
  5   v1 := ATTR_TYPE2(2);
  6   v2 := v1;
  7 end;
  8 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[6:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error but cantian support
SQL> declare
  2 type zzz is record(a varchar(10)); 
  3 v1 zzz;
  4 v2 TYPE_TEST_TABLE%ROWTYPE;
  5 begin
  6   v1.a := '2';
  7   v2 := v1;
  8   dbe_output.print_line(v2.a);
  9 end;
 10 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle error
SQL> declare
  2 type zzz is record(a varchar(10)); 
  3 type yyy is record(a char(10)); 
  4 v1 zzz;
  5 v2 yyy;
  6 begin
  7   v1.a := '2';
  8   v2 := v1;
  9 end;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[8:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 type zzz is record(a varchar(10)); 
  3 v1 zzz;
  4 v2 ATTR_TYPE2;
  5 begin
  6   v2 := ATTR_TYPE2(2);
  7   v1 := v2;
  8 end;
  9 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 type zzz is record(a int); 
  3 type yyy is record(a int); 
  4 v1 zzz;
  5 v2 yyy;
  6 begin
  7   v1.a := 2;
  8   v2 := v1;
  9 end;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[8:9] PLC-00965 Expression is of wrong type

SQL> -- oracle error
SQL> declare
  2 type zzz is record(a ATTR_TYPE2); 
  3 type yyy is record(a ATTR_TYPE2); 
  4 v1 zzz;
  5 v2 yyy;
  6 begin
  7   v1.a := ATTR_TYPE2(3);
  8   v2 := v1;
  9 end;
 10 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[8:9] PLC-00965 Expression is of wrong type

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a int); 
  3 v1 zzz;
  4 v2 zzz;
  5 begin
  6   v1.a := 2;
  7   v2 := v1;
  8 end;
  9 /

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a varchar(10)); 
  3 type yyy is record(b char(10)); 
  4 v1 zzz;
  5 v2 yyy;
  6 begin
  7   v1.a := '2';
  8   v2.b := v1.a;
  9   dbe_output.print_line(v2.b);
 10 end;
 11 /

2         

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a varchar(10)); 
  3 v1 zzz;
  4 v2 TYPE_TEST_TABLE%ROWTYPE;
  5 begin
  6   v1.a := '2';
  7   v2.a := v1.a;
  8   dbe_output.print_line(v2.a);
  9 end;
 10 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a int); 
  3 v1 zzz;
  4 v2 TYPE_TEST_TABLE%ROWTYPE;
  5 begin
  6   v1.a := 2;
  7   v2 := v1;
  8   dbe_output.print_line(v2.a);
  9 end;
 10 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a int); 
  3 v1 zzz;
  4 v2 TYPE_TEST_TABLE%ROWTYPE;
  5 begin
  6   v2.a := 2;
  7   v1 := v2;
  8   dbe_output.print_line(v1.a);
  9 end;
 10 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 v1 TYPE_TEST_TABLE%ROWTYPE;
  3 v2 TYPE_TEST_TABLE%ROWTYPE;
  4 begin
  5   v1.a := 2;
  6   v2 := v1;
  7   dbe_output.print_line(v2.a);
  8 end;
  9 /

2

PL/SQL procedure successfully completed.

SQL> -- oracle error
SQL> declare
  2 v1 ATTR_TYPE;
  3 begin
  4   v1 := ATTR_TYPE(2, null);
  5   v1.month.month := 0;
  6 end;
  7 /

CT-00932, [5:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[5:3] CT-00901, The referenced object type was not initialized.

SQL> -- oracle success
SQL> declare
  2 v1 ATTR_TYPE;
  3 begin
  4   v1 := ATTR_TYPE(2, null);
  5   v1.month := ATTR_TYPE2(3);
  6   v1.month.month := 0;
  7 end;
  8 /

PL/SQL procedure successfully completed.

SQL> -- oracle success
SQL> declare
  2 type zzz is record(a number); 
  3 type yyy is record(a int, b zzz); 
  4 v1 yyy;
  5 v2 TYPE_TEST_TABLE%ROWTYPE;
  6 begin
  7   v1.b.a := 2;
  8   v2 := v1.b;
  9   dbe_output.print_line(v2.a);
 10 end;
 11 /

2

PL/SQL procedure successfully completed.

SQL> 
SQL> -- creating a FINAL NOT INSTANTIABLE type fail
SQL> CREATE OR REPLACE TYPE USING_ATTR_UPDATE_TYPE FORCE AS OBJECT
  2 ( year NUMBER,
  3 NOT INSTANTIABLE MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER
  4 ) NOT INSTANTIABLE;
  5 /

Succeed.
Warning:
PL/SQL(SYS.USING_ATTR_UPDATE_TYPE) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> -- type with NOT INSTANTIABLE methods must be declared NOT INSTANTIABLE
SQL> CREATE OR REPLACE TYPE USING_ATTR_UPDATE_TYPE FORCE AS OBJECT
  2 ( year NUMBER,
  3 NOT INSTANTIABLE MEMBER FUNCTION prod(invent NUMBER) RETURN NUMBER
  4 );
  5 /

Succeed.
Warning:
PL/SQL(SYS.USING_ATTR_UPDATE_TYPE) terminated with compiling errors
[3:1] PLC-00958 Unsupported feature


SQL> 
SQL> drop TYPE if exists c_v_s force;

Succeed.

SQL> drop TYPE if exists c_n_s force;

Succeed.

SQL> drop TYPE if exists c_n_v force;

Succeed.

SQL> drop TYPE if exists c_v_n force;

Succeed.

SQL> drop TYPE if exists r_s_s force;

Succeed.

SQL> drop TYPE if exists r_s_r_n_v force;

Succeed.

SQL> drop TYPE if exists c_v_r force;

Succeed.

SQL> drop TYPE if exists c_n_r force;

Succeed.

SQL> 
SQL> create type c_v_s is varray(3) of varchar(100);
  2 /      

Succeed.

SQL> create type c_n_s is table of number;
  2 /      

Succeed.

SQL> create type c_n_v is table of c_v_s;
  2 /      

Succeed.

SQL> create type c_v_n is varray(3) of c_n_s;
  2 /      

Succeed.

SQL> create type r_s_s FORCE AS OBJECT(a int, b int);
  2 /      

Succeed.

SQL> create type r_s_r_n_v FORCE AS OBJECT(a int, b r_s_s, c c_n_v, d c_v_n);
  2 /      

Succeed.

SQL> create type c_v_r is varray(3) of r_s_r_n_v;
  2 /      

Succeed.

SQL> create type c_n_r is table of r_s_r_n_v;
  2 /

Succeed.

SQL> 
SQL> DECLARE
  2 	v5 r_s_s;
  3 BEGIN
  4 	v5.b := 3;
  5 END;
  6 /

CT-00932, [4:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[4:2] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> DECLARE
  2 	v5 r_s_s;
  3 	v7 c_v_r;
  4 BEGIN
  5 	if v7(2).b is NULL then
  6       dbe_output.print_line('v7(2).b' ||' is null');
  7 	end if;
  8 END;
  9 /

CT-00932, [5:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[5:2] CT-00903, Reference to uninitialized collection

SQL> 
SQL> DECLARE
  2 	v5 r_s_s;
  3 	type l_r_s_r_n_v is record(a int, c c_v_r, d c_n_r);
  4 	v12 l_r_s_r_n_v:= l_r_s_r_n_v();
  5 BEGIN
  6     null;		
  7 END;
  8 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[4:20] PLC-00828 function SYS.L_R_S_R_N_V does not exist

SQL> 
SQL> DECLARE
  2 	v5 r_s_s;
  3 	type l_r_s_r_n_v is record(a int, c c_v_r, d c_n_r);
  4 	v12 l_r_s_r_n_v;
  5 BEGIN
  6 	if v12.c(1).a is NULL then
  7       dbe_output.print_line('v12.c(1).a' ||' is null');
  8 	end if;			
  9 END;
 10 /

CT-00932, [6:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:2] CT-00903, Reference to uninitialized collection

SQL> 
SQL> DECLARE
  2 	type l_r_s_s is record(a int, b int);
  3     type l_r_s_r_n_v is record(a int, b l_r_s_s, c c_v_r, d c_n_r);
  4 	type l_c_v_r is varray(3) of l_r_s_r_n_v;
  5 	v13 l_c_v_r := l_c_v_r();
  6 	v12 l_r_s_r_n_v;
  7 BEGIN
  8     v13.extend();
  9 	v13(1):= v12;
 10 	v13 := null;
 11 	dbe_output.print_line('v13.count' || v13.count());
 12 END;
 13 /

CT-00932, [11:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[11:2] PL/SQL(DBE_OUTPUT.PRINT_LINE) terminated with execute errors
[11:39] CT-00901, The referenced object type was not initialized.

SQL> 
SQL> DECLARE
  2 	
  3 	type l_c_n_v is table of c_v_s;
  4 	type l_c_v_n is varray(3) of c_n_s;
  5 	type l_r_s_s is record(a int, b int);
  6 	type l_r_s_r_n_v is record(a int, b l_r_s_s, c c_v_r, d c_n_r);
  7 	type l_c_v_r is varray(3) of l_r_s_r_n_v;
  8 	type l_c_n_r is table of l_r_s_r_n_v;
  9 	
 10 	v1 c_v_s := c_v_s(123, 456, 789);
 11 	v2 c_n_s := c_n_s(123, 456, 789);
 12 	v3 c_n_v := c_n_v(v1, c_v_s(111, 222, 333));
 13 	v4 c_v_n := c_v_n(v2, c_n_s(111, 222, 333));
 14 	v5 r_s_s := r_s_s(1,1);
 15 
 16 	v6 r_s_r_n_v := r_s_r_n_v(1, v5, v3, v4);
 17 	v61 r_s_r_n_v;
 18 	v7 c_v_r := c_v_r(v6, v6);
 19 	v8 c_n_r := c_n_r(v6, v6, v6);
 20 
 21     v11 l_r_s_s;
 22 	v12 l_r_s_r_n_v;
 23 	v121 l_r_s_r_n_v;
 24 	v13 l_c_v_r := l_c_v_r();
 25 	v14 l_c_n_r := l_c_n_r();
 26 	
 27 BEGIN
 28 	if v11.a is NULL then
 29       dbe_output.print_line('v11.a' ||' is null');
 30 	end if;
 31 	v11.b := 3;
 32 	if v11.b is not NULL then
 33       dbe_output.print_line('v11.b = ' || v11.b ||' is not null');
 34 	end if;
 35     v11:=null;
 36 	if v11.b is NULL then
 37       dbe_output.print_line('v11.b' ||' is null');
 38 	end if;
 39 	
 40 	-- local record assign
 41 	if v12.b.b is NULL then
 42       dbe_output.print_line('v12.b.b' ||' is null');
 43 	end if;
 44 	
 45 	v12.b.a:=3;
 46 	if v12.b.a is not NULL then
 47       dbe_output.print_line('v12.b.a = ' || v12.b.a ||' is not null');
 48 	end if;
 49 	
 50 	if v12.c is NULL then
 51       dbe_output.print_line('v12.c' ||' is null');
 52 	end if;
 53 	v12.c := v7;
 54 	v12.d := v8;
 55 	v121:= v12;
 56     v12 := null;
 57 	if v12.b.b is NULL then
 58       dbe_output.print_line('v12.b.b' ||' is null');
 59 	end if;
 60 	
 61 	if v12.c is NULL then
 62       dbe_output.print_line('v12.c' ||' is null');
 63 	end if;	
 64 	
 65 	-- object record assign
 66 	v61 := v6;
 67 	v6 :=null;
 68 	if v6 is NULL then
 69       dbe_output.print_line('v6' ||' is null');
 70 	end if;
 71 	
 72 	dbe_output.print_line('v61.a = ' || v61.a);
 73     dbe_output.print_line('v61.b.a = ' || v61.a);
 74 	dbe_output.print_line('v61.c(1)(1) = ' || v61.c(1)(1));
 75 	dbe_output.print_line('v61.d(1)(2) = ' || v61.d(1)(2));
 76 	
 77 	-- collection assign, record and object is same
 78 	v13.extend();
 79 	v13(1):= v121;
 80 	v13 := null;
 81 	
 82 	v14.extend();
 83 	v14(1):= v121;
 84     v14(1).a := 100;
 85 	v14(1).b.a := 100;
 86 	v14(1).b.b := 100;
 87 	dbe_output.print_line('v14(1).a = ' || v121.a);
 88 	dbe_output.print_line('v14(1).b.a = ' || v121.b.a);
 89 	dbe_output.print_line('v14(1).b.b = ' || v121.b.b);
 90 	v14 := null;
 91 	dbe_output.print_line('v121.a = ' || v121.a);
 92 	dbe_output.print_line('v121.b.a = ' || v121.b.a);
 93 	dbe_output.print_line('v121.b.b = ' || v121.b.b);
 94 	
 95 END;
 96 /

v11.a is null
v11.b = 3 is not null
v11.b is null
v12.b.b is null
v12.b.a = 3 is not null
v12.c is null
v12.b.b is null
v12.c is null
v6 is null
v61.a = 1
v61.b.a = 1
v61.c(1)(1) = 123
v61.d(1)(2) = 456
v14(1).a = 
v14(1).b.a = 3
v14(1).b.b = 
v121.a = 
v121.b.a = 3
v121.b.b = 

PL/SQL procedure successfully completed.

SQL> 
SQL> drop type c_v_s FORCE;

Succeed.

SQL> drop type c_n_s FORCE;

Succeed.

SQL> drop type c_n_v FORCE;

Succeed.

SQL> drop type c_v_n FORCE;

Succeed.

SQL> drop type r_s_s FORCE;

Succeed.

SQL> drop type r_s_r_n_v FORCE;

Succeed.

SQL> drop type c_v_r FORCE;

Succeed.

SQL> drop type c_n_r FORCE;

Succeed.

SQL> 
SQL> drop PROCEDURE if exists print;

Succeed.

SQL> CREATE PROCEDURE print (n INTEGER) IS
  2 BEGIN
  3 IF n IS NOT NULL THEN
  4 dbe_output.print_line(n);
  5 ELSE
  6 dbe_output.print_line('NULL');
  7 END IF;
  8 END print;
  9 /

Succeed.

SQL> 
SQL> drop TYPE if exists v_type;

Succeed.

SQL> CREATE TYPE v_type IS varray(100) OF NUMBER;
  2 /

Succeed.

SQL> drop PROCEDURE if exists print_va;

Succeed.

SQL> CREATE PROCEDURE print_va(va v_type) IS
  2  i NUMBER;
  3 BEGIN
  4  i := va.FIRST;
  5  IF i IS NULL THEN
  6   dbe_output.print_line('va is empty');
  7  ELSE
  8   WHILE i IS NOT NULL LOOP
  9    dbe_output.print_line('va.(' || i || ') = ');
 10    print(va(i));
 11    i := va.NEXT(i);
 12   END LOOP;
 13  END IF;
 14  dbe_output.print_line('---');
 15 END print_va;
 16 /

Succeed.

SQL> 
SQL> DECLARE
  2  va v_type := v_type(11, 22, 33, 44, 55, 66);
  3 BEGIN
  4  print_va(va);
  5  va.DELETE();
  6  print_va(va);
  7  va(1) := 1;
  8  va.extend(3, 1);
  9  print_va(va);
 10  va.TRIM; -- Trim last element
 11  print_va(va);
 12 END;
 13 /

va.(1) = 
11
va.(2) = 
22
va.(3) = 
33
va.(4) = 
44
va.(5) = 
55
va.(6) = 
66
---
va is empty
---
CT-00932, [7:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[7:2] CT-00912, Subscript beyond count

SQL> 
SQL> DECLARE
  2  va v_type := v_type(11, 22, 33, 44, 55, 66);
  3 BEGIN
  4  print_va(va);
  5  va.DELETE();
  6  print_va(va);
  7  va.extend();
  8  va(1) := 1;
  9  va.extend(3, 1);
 10  print_va(va);
 11  va.TRIM; -- Trim last element
 12  print_va(va);
 13 END;
 14 /

va.(1) = 
11
va.(2) = 
22
va.(3) = 
33
va.(4) = 
44
va.(5) = 
55
va.(6) = 
66
---
va is empty
---
va.(1) = 
1
va.(2) = 
1
va.(3) = 
1
va.(4) = 
1
---
va.(1) = 
1
va.(2) = 
1
va.(3) = 
1
---

PL/SQL procedure successfully completed.

SQL> 
SQL> drop TYPE if exists nt_type;

Succeed.

SQL> CREATE TYPE nt_type IS table OF NUMBER;
  2 /

Succeed.

SQL> drop PROCEDURE if exists print_nt;

Succeed.

SQL> CREATE PROCEDURE print_nt(nt nt_type) IS
  2  i NUMBER;
  3 BEGIN
  4  i := nt.FIRST;
  5  IF i IS NULL THEN
  6   dbe_output.print_line('nt is empty');
  7  ELSE
  8   WHILE i IS NOT NULL LOOP
  9    dbe_output.print_line('nt.(' || i || ') = ');
 10    print(nt(i));
 11    i := nt.NEXT(i);
 12   END LOOP;
 13  END IF;
 14  dbe_output.print_line('---');
 15 END print_nt;
 16 /

Succeed.

SQL> 
SQL> DECLARE
  2  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
  3 BEGIN
  4  print_nt(nt);
  5  nt.DELETE(2); -- Delete second element
  6  print_nt(nt);
  7  nt(2) := 2222; -- Restore second element
  8  print_nt(nt);
  9  nt.DELETE(2, 4); -- Delete range of elements
 10  print_nt(nt);
 11  nt(3) := 3333; -- Restore third element
 12  print_nt(nt);
 13  nt.DELETE; -- Delete all elements
 14  print_nt(nt);
 15 END;
 16 /

nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
44
nt.(5) = 
55
nt.(6) = 
66
---
nt.(1) = 
11
nt.(3) = 
33
nt.(4) = 
44
nt.(5) = 
55
nt.(6) = 
66
---
nt.(1) = 
11
nt.(2) = 
2222
nt.(3) = 
33
nt.(4) = 
44
nt.(5) = 
55
nt.(6) = 
66
---
nt.(1) = 
11
nt.(5) = 
55
nt.(6) = 
66
---
nt.(1) = 
11
nt.(3) = 
3333
nt.(5) = 
55
nt.(6) = 
66
---
nt is empty
---

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
  3 BEGIN
  4  print_nt(nt);
  5  nt.TRIM; -- Trim last element
  6  print_nt(nt);
  7  nt.DELETE(4); -- Delete fourth element
  8  print_nt(nt);
  9  nt.TRIM(2); -- Trim last two elements
 10  print_nt(nt);
 11 END;
 12 /

nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
44
nt.(5) = 
55
nt.(6) = 
66
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
44
nt.(5) = 
55
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(5) = 
55
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
---

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  nt nt_type := nt_type(11, 22, 33);
  3 BEGIN
  4  print_nt(nt);
  5  nt.EXTEND(2, 1); -- Append two copies of first element
  6  print_nt(nt);
  7  nt.DELETE(5); -- Delete fifth element
  8  print_nt(nt);
  9  nt.EXTEND; -- Append one null element
 10  print_nt(nt);
 11 END;
 12 /

nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
11
nt.(5) = 
11
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
11
---
nt.(1) = 
11
nt.(2) = 
22
nt.(3) = 
33
nt.(4) = 
11
nt.(6) = 
NULL
---

PL/SQL procedure successfully completed.

SQL> 
SQL> drop PROCEDURE print_nt;

Succeed.

SQL> 
SQL> drop PROCEDURE print_va;

Succeed.

SQL> 
SQL> drop type nt_type FORCE;

Succeed.

SQL> 
SQL> drop type v_type FORCE;

Succeed.

SQL> 
SQL> 
SQL> DECLARE
  2  TYPE NumList IS TABLE OF INTEGER;
  3  n NumList := NumList(1, 3, 5, 7);
  4 BEGIN
  5  n.DELETE(2); -- Delete second element
  6  FOR i IN 1 .. 6 LOOP
  7   IF n.EXISTS(i) THEN
  8    dbe_output.print_line('n(' || i || ') = ' || n(i));
  9   ELSE
 10    dbe_output.print_line('n(' || i || ') does not exist');
 11   END IF;
 12  END LOOP;
 13 END;
 14 /

n(1) = 1
n(2) does not exist
n(3) = 5
n(4) = 7
n(5) does not exist
n(6) does not exist

PL/SQL procedure successfully completed.

SQL> drop TYPE if exists team_type;

Succeed.

SQL> CREATE TYPE team_type IS VARRAY(4) OF VARCHAR2(15);
  2 /

Succeed.

SQL> drop PROCEDURE if exists print_team;

Succeed.

SQL>  CREATE PROCEDURE print_team(heading VARCHAR2, team team_type) IS
  2  BEGIN
  3   dbe_output.print_line(heading);
  4   IF team IS NULL THEN
  5    dbe_output.print_line('Does not exist');
  6   ELSIF team.FIRST IS NULL THEN
  7    dbe_output.print_line('Has no members');
  8   ELSE
  9    FOR i IN team.FIRST .. team.LAST LOOP
 10     dbe_output.print_line(i || '. ' || team(i));
 11    END LOOP;
 12   END IF;
 13   dbe_output.print_line('---');
 14  END;
 15  /

Succeed.

SQL> 
SQL> DECLARE
  2  team team_type;
  3 
  4 BEGIN
  5  print_team('Team Status:', team);
  6  team := team_type(); -- Team is funded, but nobody is on it.
  7  print_team('Team Status:', team);
  8  team := team_type('John', 'Mary'); -- PUT_LINE 2 members on team.
  9  print_team('Initial Team:', team);
 10  team := team_type('Arun', 'Amitha', 'Allan', 'Mae'); -- Change team.
 11  print_team('New Team:', team);
 12 END;
 13 /

Team Status:
Does not exist
---
Team Status:
Has no members
---
Initial Team:
1. John
2. Mary
---
New Team:
1. Arun
2. Amitha
3. Allan
4. Mae
---

PL/SQL procedure successfully completed.

SQL> drop TYPE team_type force;

Succeed.

SQL> 
SQL> 
SQL> drop PROCEDURE print_team;

Succeed.

SQL> 
SQL> drop TYPE if exists NumList;

Succeed.

SQL> CREATE  TYPE NumList IS VARRAY(10) OF INTEGER;
  2 /

Succeed.

SQL> 
SQL> drop PROCEDURE if exists print_count_and_last;

Succeed.

SQL> CREATE PROCEDURE print_count_and_last(n NumList) IS
  2  BEGIN
  3   dbe_output.print_line('n.COUNT = ' || n.COUNT || ', ');
  4   dbe_output.print_line('n.LAST = ' || n.LAST);
  5  END print_count_and_last;
  6 /

Succeed.

SQL> 
SQL> DECLARE
  2  n NumList := NumList(1, 3, 5, 7);
  3  
  4 BEGIN
  5  print_count_and_last(n);
  6  n.EXTEND(3);
  7  print_count_and_last(n);
  8  n.TRIM(5);
  9  print_count_and_last(n);
 10 END;
 11 /

n.COUNT = 4, 
n.LAST = 4
n.COUNT = 7, 
n.LAST = 7
n.COUNT = 2, 
n.LAST = 2

PL/SQL procedure successfully completed.

SQL> 
SQL> drop type NumList FORCE;

Succeed.

SQL> 
SQL> 
SQL> drop PROCEDURE print_count_and_last;

Succeed.

SQL> 
SQL> 
SQL> DECLARE
  2  TYPE va_type IS VARRAY(4) OF INTEGER;
  3  va va_type := va_type(2, 4); -- varray
  4  TYPE nt_type IS TABLE OF INTEGER;
  5  nt nt_type := nt_type(1, 3, 5); -- nested table
  6 BEGIN
  7  dbe_output.print_line('va.COUNT = ');
  8  print(va.COUNT);
  9  dbe_output.print_line('va.LIMIT = ');
 10  print(va.LIMIT);
 11  dbe_output.print_line('nt.COUNT = ');
 12  print(nt.COUNT);
 13  dbe_output.print_line('nt.LIMIT = ');
 14  print(nt.LIMIT);
 15 END;
 16 /

va.COUNT = 
2
va.LIMIT = 
4
nt.COUNT = 
3
nt.LIMIT = 
NULL

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE Arr_Type IS VARRAY(10) OF NUMBER;
  3  v_Numbers Arr_Type := Arr_Type();
  4 BEGIN
  5  v_Numbers.EXTEND(4);
  6  v_Numbers(1) := 10;
  7  v_Numbers(2) := 20;
  8  v_Numbers(3) := 30;
  9  v_Numbers(4) := 40;
 10  dbe_output.print_line(NVL(v_Numbers.prior(0), 1));
 11  dbe_output.print_line(NVL(v_Numbers.prior(5), 1));
 12  dbe_output.print_line(NVL(v_Numbers.next(5), 1));
 13  dbe_output.print_line(NVL(v_Numbers.prior(v_Numbers.first()), 1));
 14  dbe_output.print_line(NVL(v_Numbers.next(v_Numbers.last()), 1));
 15  dbe_output.print_line(NVL(v_Numbers.prior(3400), 1));
 16  dbe_output.print_line(NVL(v_Numbers.next(3400), 1));
 17 END;
 18 /

1
4
1
1
1
4
1

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE nt_Type IS table OF NUMBER;
  3  v_Numbers nt_Type := nt_Type();
  4 BEGIN
  5  v_Numbers.EXTEND(4);
  6  v_Numbers(1) := 10;
  7  v_Numbers(2) := 20;
  8  v_Numbers(3) := 30;
  9  v_Numbers(4) := 40;
 10  dbe_output.print_line(NVL(v_Numbers.prior(0), 1));
 11  dbe_output.print_line(NVL(v_Numbers.prior(5), 1));
 12  dbe_output.print_line(NVL(v_Numbers.next(5), 1));
 13  dbe_output.print_line(NVL(v_Numbers.prior(v_Numbers.first()), 1));
 14  dbe_output.print_line(NVL(v_Numbers.next(v_Numbers.last()), 1));
 15  dbe_output.print_line(NVL(v_Numbers.prior(3400), 1));
 16  dbe_output.print_line(NVL(v_Numbers.next(3400), 1));
 17 END;
 18 /

1
4
1
1
1
4
1

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> DECLARE
  2  TYPE nt_Type IS table OF NUMBER;
  3  v_Numbers nt_Type := nt_Type();
  4 BEGIN
  5  v_Numbers.EXTEND(4);
  6  v_Numbers(1) := 10;
  7  v_Numbers(2) := 20;
  8  v_Numbers(3) := 30;
  9  v_Numbers(4) := 40;
 10  v_Numbers.delete(4);
 11  v_Numbers.delete(1);
 12  v_Numbers(3) := null;
 13  dbe_output.print_line(v_Numbers.prior(0));
 14  dbe_output.print_line(v_Numbers.prior(5));
 15  dbe_output.print_line(v_Numbers.next(5));
 16  dbe_output.print_line(v_Numbers.next(-1));
 17  dbe_output.print_line(v_Numbers.next(1));
 18  dbe_output.print_line(v_Numbers.prior(3400));
 19  dbe_output.print_line(v_Numbers.next(0));
 20 END;
 21 /


3

2
2
3
2

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 TYPE NumList IS TABLE OF NUMBER;
  3 n NumList := NumList(1, 2, NULL, NULL, 5, NULL, 7, 8, 9, NULL);
  4 idx INTEGER;
  5 BEGIN
  6  dbe_output.print_line('First to last:');
  7  idx := n.FIRST;
  8  WHILE idx IS NOT NULL LOOP
  9   dbe_output.print_line('n(' || idx || ') = ');
 10   print(n(idx));
 11   idx := n.NEXT(idx);
 12  END LOOP;
 13  dbe_output.print_line('--------------');
 14  dbe_output.print_line('Last to first:');
 15  idx := n.LAST;
 16  WHILE idx IS NOT NULL LOOP
 17   dbe_output.print_line('n(' || idx || ') = ');
 18   print(n(idx));
 19   idx := n.PRIOR(idx);
 20  END LOOP;
 21 END;
 22 /

First to last:
n(1) = 
1
n(2) = 
2
n(3) = 
NULL
n(4) = 
NULL
n(5) = 
5
n(6) = 
NULL
n(7) = 
7
n(8) = 
8
n(9) = 
9
n(10) = 
NULL
--------------
Last to first:
n(10) = 
NULL
n(9) = 
9
n(8) = 
8
n(7) = 
7
n(6) = 
NULL
n(5) = 
5
n(4) = 
NULL
n(3) = 
NULL
n(2) = 
2
n(1) = 
1

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 TYPE nt_type IS TABLE OF NUMBER;
  3 nt nt_type := nt_type(18, NULL, 36, 45, 54, 63);
  4 BEGIN
  5 nt.DELETE(4);
  6 dbe_output.print_line('nt(4) was deleted.');
  7 FOR i IN 1..7 LOOP
  8 dbe_output.print_line('nt.PRIOR(' || i || ') = '); print(nt.PRIOR(i));
  9 dbe_output.print_line('nt.NEXT(' || i || ') = '); print(nt.NEXT(i));
 10 END LOOP;
 11 END;
 12 /

nt(4) was deleted.
nt.PRIOR(1) = 
NULL
nt.NEXT(1) = 
2
nt.PRIOR(2) = 
1
nt.NEXT(2) = 
3
nt.PRIOR(3) = 
2
nt.NEXT(3) = 
5
nt.PRIOR(4) = 
3
nt.NEXT(4) = 
5
nt.PRIOR(5) = 
3
nt.NEXT(5) = 
6
nt.PRIOR(6) = 
5
nt.NEXT(6) = 
NULL
nt.PRIOR(7) = 
6
nt.NEXT(7) = 
NULL

PL/SQL procedure successfully completed.

SQL> drop PROCEDURE print;

Succeed.

SQL> 
SQL> 
SQL> create or replace type body FLIGHT_SCH_TYPE as
  2     member function DAYS_FN(FLIGHT_DAY1 in number) return varchar2
  3 is
  4     disp_day varchar2(20) ;
  5 begin  
  6     if flight_day1 = 1 then
  7         disp_day := 'Sunday' ;       
  8     elsif flight_day1 = 2 then
  9         disp_day := 'Monday' ;        
 10     elsif flight_day1 = 3 then  
 11         disp_day := 'Tuesday' ;     
 12     elsif flight_day1 = 4 then  
 13         disp_day := 'Wednesday' ;     
 14     elsif flight_day1 = 5 then    
 15         disp_day := 'Thursday' ;         
 16     elsif flight_day1 = 6 then      
 17         disp_day := 'Friday   ' ;   
 18     elsif flight_day1 = 7 then
 19         disp_day := 'Saturday' ;  
 20     end if ;         
 21     return disp_day ; 
 22     end ;
 23 end ;
 24 /

CT-00958, [1:24]Unsupported feature
SQL> 
SQL> DECLARE
  2   TYPE ORG_TABLE_TYPE IS TABLE OF VARCHAR2(25)
  3   INDEX BY BINARY_INTEGER;
  4   V_ORG_TABLE ORG_TABLE_TYPE:= ORG_TABLE_TYPE('123', '234', '345');
  5 BEGIN
  6   dbe_output.print_line('ok');
  7 END;
  8 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
PLC-00916 PL/SQL:syntax error(associative arrays do not support constructor)

SQL> 
SQL> DECLARE
  2  TYPE ORG_TABLE_TYPE IS TABLE OF VARCHAR2(25);
  3  V_ORG_TABLE ORG_TABLE_TYPE:= '2';
  4 BEGIN
  5  dbe_output.print_line('ok');
  6 END;
  7 /

CT-00932, [4:1] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[3:31] CT-00965, Expression is of wrong type

SQL> 
SQL> DECLARE
  2  TYPE ORG_TABLE_TYPE IS TABLE OF VARCHAR2(25);
  3  V_ORG_TABLE1 ORG_TABLE_TYPE:= ORG_TABLE_TYPE('abc');
  4  V_ORG_TABLE2 ORG_TABLE_TYPE:= V_ORG_TABLE1;
  5 BEGIN
  6  dbe_output.print_line(V_ORG_TABLE1(1));
  7  dbe_output.print_line(V_ORG_TABLE2(1));
  8 END;
  9 /

abc
abc

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists record_table;

Succeed.

SQL> create table record_table(id int);

Succeed.

SQL> declare
  2 	type zzz is record(a int := 1);
  3 	a zzz;
  4 	b record_table%rowtype := a;
  5 begin
  6 	SYS.dbe_output.print_line(b.id);
  7 end;
  8 /

1

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2 TYPE t1 IS VARRAY(10) OF INTEGER; -- varray of integer
  3 va t1 := t1(2,3,5);
  4 TYPE nt1 IS VARRAY(10) OF t1; -- varray of varray of integer
  5 nva nt1 := nt1(va, t1(55,6,73), t1(2,4), va);
  6 i INTEGER;
  7 va1 t1;
  8 BEGIN
  9 i := nva(2)(3);
 10 dbe_output.print_line('i = ' || i);
 11 nva.EXTEND;
 12 nva(5) := t1(56, 32); -- replace inner varray elements
 13 nva(4) := t1(45,43,67,43345); -- replace an inner integer element
 14 nva(4)(4) := 1;
 15 nva(4).EXTEND;
 16 END;
 17 /

i = 73

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2   TYPE tb1 IS TABLE OF VARCHAR2(20); -- nested table of strings
  3   vtb1 tb1 := tb1('one', 'three');
  4   TYPE ntb1 IS TABLE OF tb1; -- nested table of nested tables of strings
  5   vntb1 ntb1 := ntb1(vtb1);
  6 BEGIN
  7   vntb1.EXTEND;
  8   vntb1(2) := vntb1(1);
  9   vntb1.DELETE(1); -- delete first element of vntb1
 10   vntb1(2).DELETE(1); -- delete first string from second table in nested table
 11 END;
 12 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --Data Type Compatibility for Collection Assignment
SQL> DECLARE
  2   TYPE triplet IS VARRAY(3) OF VARCHAR2(15);
  3   group1 triplet := triplet('Jones', 'Wong', 'Marceau');
  4   group2 triplet;
  5 BEGIN
  6   group2 := group1; -- succeeds
  7 END;
  8 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --%ROWTYPE Variable Represents Partial Database Table Row
SQL> DROP TABLE if exists t1;

Succeed.

SQL> create table t1 (a int, b int, c int,d VARCHAR2(10));

Succeed.

SQL> DECLARE
  2   CURSOR cc IS
  3     SELECT a, b, c
  4     FROM t1;
  5   friend cc%ROWTYPE;
  6 BEGIN
  7   friend.a := 1;
  8   friend.b := 2;
  9   friend.c := 3;
 10   dbe_output.print_line (
 11     friend.a || ', ' ||
 12     friend.b || ', ' ||
 13     friend.c
 14 );
 15 END;
 16 /

1, 2, 3

PL/SQL procedure successfully completed.

SQL> 
SQL> --Inserting %ROWTYPE Record into Table (Right)
SQL> DROP TABLE if exists plch_departure;

Succeed.

SQL> CREATE TABLE plch_departure (destination VARCHAR2(100),departure_time DATE,delay NUMBER(10));

Succeed.

SQL> DECLARE
  2 dep_rec plch_departure%rowtype;
  3 BEGIN
  4 dep_rec.destination := 'X';
  5 dep_rec.departure_time := SYSDATE;
  6 dep_rec.delay := 1500;
  7 INSERT INTO plch_departure (destination, departure_time, delay)
  8 VALUES (dep_rec.destination, dep_rec.departure_time, dep_rec.delay);
  9 END;
 10 /

PL/SQL procedure successfully completed.

SQL> 
SQL> --Assigning %ROWTYPE Record to RECORD Type Record
SQL> DROP TABLE if exists t1;

Succeed.

SQL> create table t1 (a int, b int, c int,d VARCHAR2(10));

Succeed.

SQL> DECLARE
  2   TYPE name_rec IS RECORD (
  3     first t1.a%TYPE ,
  4     last t1.b%TYPE
  5   );
  6   CURSOR c IS
  7     SELECT a, b
  8     FROM t1;
  9   target name_rec;
 10   source c%ROWTYPE;
 11 BEGIN
 12   source.a := 1; source.b := 2;
 13   dbe_output.print_line (
 14     'source: ' || source.a || ' ' || source.b
 15   );
 16   target := source;
 17   dbe_output.print_line (
 18     'target: ' || target.first || ' ' || target.last
 19   );
 20 END;
 21 /

source: 1 2
target: 1 2

PL/SQL procedure successfully completed.

SQL> 
SQL> --test default
SQL> DROP TABLE if exists t1;

Succeed.

SQL> create table t1 (a int);

Succeed.

SQL> DECLARE
  2   TYPE name_rec IS RECORD (
  3     first t1.a%TYPE DEFAULT 1
  4   );
  5   target name_rec;
  6     TYPE name_rec2 IS RECORD (
  7     rec2 t1%ROWTYPE DEFAULT target
  8   );
  9   target2 name_rec2;
 10     CURSOR c IS
 11     SELECT a
 12     FROM t1;
 13     target3 c%ROWTYPE DEFAULT target;
 14 BEGIN
 15   dbe_output.print_line ('target2: ' || target2.rec2.a);
 16   dbe_output.print_line ('target3: ' || target3.a);
 17 END;
 18 /

target2: 1
target3: 1

PL/SQL procedure successfully completed.

SQL> 
SQL> --test default
SQL> create or replace type vv1 is varray(4) of varchar2(15);
  2 /

Succeed.

SQL> DROP TABLE if exists t1;

Succeed.

SQL> create table t1 (a int, b int);

Succeed.

SQL> DECLARE
  2   TYPE name_rec1 IS RECORD (
  3     rec1 t1.a%TYPE DEFAULT 1,
  4     rec1_2 int DEFAULT 2
  5   );
  6   target1 name_rec1;
  7   TYPE name_rec2 IS RECORD (
  8     rec2 t1%ROWTYPE DEFAULT target1
  9   );
 10   target2 name_rec2;
 11   v_def_1 vv1 := vv1('aaaa');
 12   TYPE name_rec3 IS RECORD (
 13     rec3 name_rec2 DEFAULT target2,
 14     rec3_2 vv1 DEFAULT v_def_1,
 15     rec3_3 int DEFAULT 1
 16   );
 17   v_def_2 vv1 := vv1('bbbb');
 18   target3 name_rec3;
 19   TYPE name_rec4 IS RECORD (
 20     rec4 name_rec3 DEFAULT target3,
 21     rec4_2 vv1 DEFAULT v_def_2,
 22     rec4_3 int DEFAULT 1
 23   );
 24   target4 name_rec4;
 25   TYPE name_rec5 IS RECORD (
 26     rec5 name_rec4 DEFAULT target4
 27   );
 28   target5 name_rec5;
 29 BEGIN
 30   dbe_output.print_line ('DEFAULT: ' || target5.rec5.rec4.rec3.rec2.a);
 31 END;
 32 /

DEFAULT: 1

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> drop table if exists FVT_PRO_TAB_001_0008;

Succeed.

SQL> create table FVT_PRO_TAB_001_0008
  2 (
  3 	id int,
  4 	name varchar2(10),
  5 	time date,
  6 	age number
  7 );

Succeed.

SQL> insert into FVT_PRO_TAB_001_0008 values('1','feng',to_date('2018','yyyy'),25);

1 rows affected.

SQL> insert into FVT_PRO_TAB_001_0008 values('2','li',to_date('2017','yyyy'),24);

1 rows affected.

SQL> insert into FVT_PRO_TAB_001_0008 values('3','wang',to_date('2016','yyyy'),23);

1 rows affected.

SQL> insert into FVT_PRO_TAB_001_0008 values('4','zhang',to_date('2015','yyyy'),22);

1 rows affected.

SQL> create or replace procedure proc_for_in_loop19( a int,b out int ,c in out varchar2) as
  2   d int :=0;
  3   e int :=0;
  4 begin
  5   select a.id into d from FVT_PRO_TAB_001_0008 a;
  6   dbe_output.print_line('d='||d);
  7 end;
  8 /

Succeed.
Warning:
PL/SQL(SYS.PROC_FOR_IN_LOOP19) terminated with compiling errors
[5:41] PLC-00601 Sql syntax error: invalid word ':1' found


SQL> drop table if exists FVT_PRO_TAB_001_0008;

Succeed.

SQL> 
SQL> create or replace procedure v_d_n_001_p1(v_tmp int)
  2 is
  3 type c_t1 is ref cursor;
  4 type t_record2 is record
  5 (
  6     c c_t1,
  7 	d sys_refcursor
  8    );
  9 begin
 10 	dbe_output.print_line(' error ');
 11 end v_d_n_001_p1;
 12 /

Succeed.
Warning:
PL/SQL(SYS.V_D_N_001_P1) terminated with compiling errors
[6:7] PLC-00974 Unexpected pl variant


SQL> create or replace procedure v_d_n_001_p2(v_tmp int)
  2 is
  3 type t_record2 is record
  4 (
  5 	c c_t1,
  6 	d sys_refcursor
  7    );
  8 begin
  9 	dbe_output.print_line(' error ');
 10 end v_d_n_001_p2;
 11 /

Succeed.
Warning:
PL/SQL(SYS.V_D_N_001_P2) terminated with compiling errors
[5:4] PLC-00828 type SYS.C_T1 does not exist


SQL> 
SQL> drop table if exists fvt_table_returning_15;

Succeed.

SQL> create table fvt_table_returning_15(
  2 		c_id int,
  3 		c_clob clob,
  4 		c_time date,
  5 		c_num number(20,5),
  6 		c_name varchar(100) default 'default',
  7 		c_boolean boolean);

Succeed.

SQL> 
SQL> set serveroutput on;

ON
SQL> declare
  2   ret1 int;
  3   ret2 clob;
  4   ret3 date;
  5   ret4 number(20,5);
  6   ret5 varchar(100);
  7   ret6 varchar(10);
  8 begin
  9 insert into fvt_table_returning_15(c_id,c_clob,c_time,c_num) values('','','','') returning
 10 c_id+(select count(1) from dual)||c_num, c_clob||c_num,c_time,c_num,c_name,c_boolean into ret1, ret2,ret3,ret4,ret5,ret6;
 11 dbe_output.print_line(ret1||'-'||ret2||'-'||ret3||'-'||ret4||'-'||ret5||'-'||ret6);
 12 end;
 13 /

----default-

PL/SQL procedure successfully completed.

SQL> drop table if exists fvt_table_returning_15;

Succeed.

SQL> 
SQL> drop table if exists FVT_T_TEST_02_01_01;

Succeed.

SQL> create table FVT_T_TEST_02_01_01(id int,name varchar(100), firedate date,sex int,salary number(7,2));

Succeed.

SQL> insert into FVT_T_TEST_02_01_01 values(null,'harry',to_date('2019-07-23','yyyy-mm-dd'),1,50000);

1 rows affected.

SQL> create or replace package P_TEST_02_01_01
  2 as
  3 	procedure FVT_P_TEST_02_01_01;
  4 end;
  5 /

Succeed.

SQL> create or replace package body P_TEST_02_01_01
  2 as
  3 procedure FVT_P_TEST_02_01_01 is
  4 v_comm number(7,2);
  5 begin
  6 	execute immediate 'alter table FVT_T_TEST_02_01_01 add email varchar(50)';
  7 for i in (select * from FVT_T_TEST_02_01_01) loop
  8 if i.sex=1 then
  9 	v_comm:=0.1;
 10 else
 11 	v_comm:=0.2;
 12 end if;
 13 end loop;
 14 end;
 15 end;
 16 /

Succeed.

SQL> 
SQL> call P_TEST_02_01_01.FVT_P_TEST_02_01_01();

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:1] PL/SQL(SYS.P_TEST_02_01_01.FVT_P_TEST_02_01_01) terminated with execute errors
[6:1] CT-00926, PL/SQL: Return types of Result Set variables or query do not match

SQL> drop table if exists FVT_T_TEST_02_01_01;

Succeed.

SQL> 
SQL> drop table if exists FVT_T_TEST_02_01_02;

Succeed.

SQL> create table FVT_T_TEST_02_01_02(id int,name varchar(100), firedate date,sex int,salary number(7,2));

Succeed.

SQL> insert into FVT_T_TEST_02_01_02 values(null,'harry',to_date('2019-07-23','yyyy-mm-dd'),1,50000);

1 rows affected.

SQL> create or replace package P_TEST_02_01_02
  2 as
  3 	procedure FVT_P_TEST_02_01_02;
  4 end;
  5 /

Succeed.

SQL> create or replace package body P_TEST_02_01_02
  2 as
  3 procedure FVT_P_TEST_02_01_02 is
  4 v_comm number(7,2);
  5 begin
  6 	execute immediate 'alter table FVT_T_TEST_02_01_02 drop column salary';
  7 for i in (select * from FVT_T_TEST_02_01_02) loop
  8 if i.sex=1 then
  9 	v_comm:=0.1;
 10 else
 11 	v_comm:=0.2;
 12 end if;
 13 end loop;
 14 end;
 15 end;
 16 /

Succeed.

SQL> call P_TEST_02_01_02.FVT_P_TEST_02_01_02();

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:1] PL/SQL(SYS.P_TEST_02_01_02.FVT_P_TEST_02_01_02) terminated with execute errors
[6:1] CT-00926, PL/SQL: Return types of Result Set variables or query do not match

SQL> drop table if exists FVT_T_TEST_02_01_02;

Succeed.

SQL> 
SQL> drop table if exists FVT_T_TEST_02_01_03;

Succeed.

SQL> create table FVT_T_TEST_02_01_03(id int,name varchar(100), firedate date,sex int,salary number(7,2));

Succeed.

SQL> insert into FVT_T_TEST_02_01_03 values(null,'harry',to_date('2019-07-23','yyyy-mm-dd'),1,50000);

1 rows affected.

SQL> create or replace package P_TEST_02_01_03
  2 as
  3 	procedure FVT_P_TEST_02_01_03;
  4 end;
  5 /

Succeed.

SQL> create or replace package body P_TEST_02_01_03
  2 as
  3 procedure FVT_P_TEST_02_01_03 is
  4 v_comm number(7,2);
  5 begin
  6 	execute immediate 'alter table FVT_T_TEST_02_01_03 drop column salary';
  7 	execute immediate 'alter table FVT_T_TEST_02_01_03 add salary varchar(100)';
  8 	execute immediate 'insert into FVT_T_TEST_02_01_03 values(null,''harry'',to_date(''2019-07-23'',''yyyy-mm-dd''),1,''50a000'')';
  9 for i in (select * from FVT_T_TEST_02_01_03) loop
 10 if i.sex=1 then
 11 	v_comm:=0.1;
 12 else
 13 	v_comm:=0.2;
 14 end if;
 15 end loop;
 16 end;
 17 end;
 18 /

Succeed.

SQL> call P_TEST_02_01_03.FVT_P_TEST_02_01_03();

CT-00932, [1:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[8:1] PL/SQL(SYS.P_TEST_02_01_03.FVT_P_TEST_02_01_03) terminated with execute errors
[8:1] CT-00636, Invalid number -- unexpected character

SQL> drop table if exists FVT_T_TEST_02_01_03;

Succeed.

SQL> 
SQL> declare
  2 TYPE R1 IS RECORD(F1 INTEGER, F2 VARCHAR2(15));
  3 var_r1 R1;
  4 TYPE C1 IS VARRAY(4) OF R1;
  5 var_c1 C1 :=C1(var_r1);
  6 begin
  7   var_c1:= C1(var_r1);
  8   var_r1.F1:=3;
  9   var_r1.F2:='123';
 10   var_c1.EXTEND;
 11   var_c1(1) := var_r1;
 12   dbe_output.print_line(var_r1.F1);
 13   dbe_output.print_line(var_r1.F2);
 14   dbe_output.print_line(var_c1(1).F1);
 15   dbe_output.print_line(var_c1(1).F2);
 16   SELECT 1 INTO var_c1(1).F1 FROM DUAL;
 17   SELECT '456' INTO var_c1(1).F2 FROM DUAL;
 18   dbe_output.print_line(var_r1.F1);
 19   dbe_output.print_line(var_r1.F2);
 20   dbe_output.print_line(var_c1(1).F1);
 21   dbe_output.print_line(var_c1(1).F2);
 22 end;
 23 /

3
123
3
123
3
123
1
456

PL/SQL procedure successfully completed.

SQL> DROP TABLE IF EXISTS EMPLOYEES_UDT;

Succeed.

SQL> CREATE TABLE EMPLOYEES_UDT 
  2    (EMPLOYEE_ID NUMBER(6,0), 
  3 	FIRST_NAME VARCHAR2(20), 
  4 	LAST_NAME VARCHAR2(25) CONSTRAINT "EMP_LAST_NAME_NN" NOT NULL, 
  5 	EMAIL VARCHAR2(25) CONSTRAINT "EMP_EMAIL_NN" NOT NULL, 
  6 	PHONE_NUMBER VARCHAR2(20), 
  7 	HIRE_DATE DATE CONSTRAINT "EMP_HIRE_DATE_NN" NOT NULL, 
  8 	JOB_ID VARCHAR2(10) CONSTRAINT "EMP_JOB_NN" NOT NULL, 
  9 	SALARY NUMBER(8,2), 
 10 	COMMISSION_PCT NUMBER(2,2), 
 11 	MANAGER_ID NUMBER(6,0), 
 12 	DEPARTMENT_ID NUMBER(4,0)
 13    );

Succeed.

SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (198, 'Donald', 'OConnell', 'DOCONNEL', '650.507.9833', to_date('21-06-1999', 'dd-mm-yyyy'), 'SH_CLERK', 2600.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (199, 'Douglas', 'Grant', 'DGRANT', '650.507.9844', to_date('13-01-2000', 'dd-mm-yyyy'), 'SH_CLERK', 2600.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (200, 'Jennifer', 'Whalen', 'JWHALEN', '515.123.4444', to_date('17-09-1987', 'dd-mm-yyyy'), 'AD_ASST', 4400.00, null, 101, 10);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (201, 'Michael', 'Hartstein', 'MHARTSTE', '515.123.5555', to_date('17-02-1996', 'dd-mm-yyyy'), 'MK_MAN', 13000.00, null, 100, 20);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (202, 'Pat', 'Fay', 'PFAY', '603.123.6666', to_date('17-08-1997', 'dd-mm-yyyy'), 'MK_REP', 6000.00, null, 201, 20);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (203, 'Susan', 'Mavris', 'SMAVRIS', '515.123.7777', to_date('07-06-1994', 'dd-mm-yyyy'), 'HR_REP', 6500.00, null, 101, 40);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (204, 'Hermann', 'Baer', 'HBAER', '515.123.8888', to_date('07-06-1994', 'dd-mm-yyyy'), 'PR_REP', 10000.00, null, 101, 70);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (205, 'Shelley', 'Higgins', 'SHIGGINS', '515.123.8080', to_date('07-06-1994', 'dd-mm-yyyy'), 'AC_MGR', 12000.00, null, 101, 110);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (206, 'William', 'Gietz', 'WGIETZ', '515.123.8181', to_date('07-06-1994', 'dd-mm-yyyy'), 'AC_ACCOUNT', 8300.00, null, 205, 110);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (100, 'Steven', 'King', 'SKING', '515.123.4567', to_date('17-06-1987', 'dd-mm-yyyy'), 'AD_PRES', 24000.00, null, null, 90);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (101, 'Neena', 'Kochhar', 'NKOCHHAR', '515.123.4568', to_date('21-09-1989', 'dd-mm-yyyy'), 'AD_VP', 17000.00, null, 100, 90);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (102, 'Lex', 'De Haan', 'LDEHAAN', '515.123.4569', to_date('13-01-1993', 'dd-mm-yyyy'), 'AD_VP', 17000.00, null, 100, 90);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (103, 'Alexander', 'Hunold', 'AHUNOLD', '590.423.4567', to_date('03-01-1990', 'dd-mm-yyyy'), 'IT_PROG', 9000.00, null, 102, 60);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (104, 'Bruce', 'Ernst', 'BERNST', '590.423.4568', to_date('21-05-1991', 'dd-mm-yyyy'), 'IT_PROG', 6000.00, null, 103, 60);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (105, 'David', 'Austin', 'DAUSTIN', '590.423.4569', to_date('25-06-1997', 'dd-mm-yyyy'), 'IT_PROG', 4800.00, null, 103, 60);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (106, 'Valli', 'Pataballa', 'VPATABAL', '590.423.4560', to_date('05-02-1998', 'dd-mm-yyyy'), 'IT_PROG', 4800.00, null, 103, 60);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (107, 'Diana', 'Lorentz', 'DLORENTZ', '590.423.5567', to_date('07-02-1999', 'dd-mm-yyyy'), 'IT_PROG', 4200.00, null, 103, 60);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (108, 'Nancy', 'Greenberg', 'NGREENBE', '515.124.4569', to_date('17-08-1994', 'dd-mm-yyyy'), 'FI_MGR', 12000.00, null, 101, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (109, 'Daniel', 'Faviet', 'DFAVIET', '515.124.4169', to_date('16-08-1994', 'dd-mm-yyyy'), 'FI_ACCOUNT', 9000.00, null, 108, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (110, 'John', 'Chen', 'JCHEN', '515.124.4269', to_date('28-09-1997', 'dd-mm-yyyy'), 'FI_ACCOUNT', 8200.00, null, 108, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (111, 'Ismael', 'Sciarra', 'ISCIARRA', '515.124.4369', to_date('30-09-1997', 'dd-mm-yyyy'), 'FI_ACCOUNT', 7700.00, null, 108, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (112, 'Jose Manuel', 'Urman', 'JMURMAN', '515.124.4469', to_date('07-03-1998', 'dd-mm-yyyy'), 'FI_ACCOUNT', 7800.00, null, 108, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (113, 'Luis', 'Popp', 'LPOPP', '515.124.4567', to_date('07-12-1999', 'dd-mm-yyyy'), 'FI_ACCOUNT', 6900.00, null, 108, 100);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (114, 'Den', 'Raphaely', 'DRAPHEAL', '515.127.4561', to_date('07-12-1994', 'dd-mm-yyyy'), 'PU_MAN', 11000.00, null, 100, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (115, 'Alexander', 'Khoo', 'AKHOO', '515.127.4562', to_date('18-05-1995', 'dd-mm-yyyy'), 'PU_CLERK', 3100.00, null, 114, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (116, 'Shelli', 'Baida', 'SBAIDA', '515.127.4563', to_date('24-12-1997', 'dd-mm-yyyy'), 'PU_CLERK', 2900.00, null, 114, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (117, 'Sigal', 'Tobias', 'STOBIAS', '515.127.4564', to_date('24-07-1997', 'dd-mm-yyyy'), 'PU_CLERK', 2800.00, null, 114, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (118, 'Guy', 'Himuro', 'GHIMURO', '515.127.4565', to_date('15-11-1998', 'dd-mm-yyyy'), 'PU_CLERK', 2600.00, null, 114, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (119, 'Karen', 'Colmenares', 'KCOLMENA', '515.127.4566', to_date('10-08-1999', 'dd-mm-yyyy'), 'PU_CLERK', 2500.00, null, 114, 30);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (120, 'Matthew', 'Weiss', 'MWEISS', '650.123.1234', to_date('18-07-1996', 'dd-mm-yyyy'), 'ST_MAN', 8000.00, null, 100, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (121, 'Adam', 'Fripp', 'AFRIPP', '650.123.2234', to_date('10-04-1997', 'dd-mm-yyyy'), 'ST_MAN', 8200.00, null, 100, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (122, 'Payam', 'Kaufling', 'PKAUFLIN', '650.123.3234', to_date('01-05-1995', 'dd-mm-yyyy'), 'ST_MAN', 7900.00, null, 100, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (123, 'Shanta', 'Vollman', 'SVOLLMAN', '650.123.4234', to_date('10-10-1997', 'dd-mm-yyyy'), 'ST_MAN', 6500.00, null, 100, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (124, 'Kevin', 'Mourgos', 'KMOURGOS', '650.123.5234', to_date('16-11-1999', 'dd-mm-yyyy'), 'ST_MAN', 5800.00, null, 100, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (125, 'Julia', 'Nayer', 'JNAYER', '650.124.1214', to_date('16-07-1997', 'dd-mm-yyyy'), 'ST_CLERK', 3200.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (126, 'Irene', 'Mikkilineni', 'IMIKKILI', '650.124.1224', to_date('28-09-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2700.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (127, 'James', 'Landry', 'JLANDRY', '650.124.1334', to_date('14-01-1999', 'dd-mm-yyyy'), 'ST_CLERK', 2400.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (128, 'Steven', 'Markle', 'SMARKLE', '650.124.1434', to_date('08-03-2000', 'dd-mm-yyyy'), 'ST_CLERK', 2200.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (129, 'Laura', 'Bissot', 'LBISSOT', '650.124.5234', to_date('20-08-1997', 'dd-mm-yyyy'), 'ST_CLERK', 3300.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (130, 'Mozhe', 'Atkinson', 'MATKINSO', '650.124.6234', to_date('30-10-1997', 'dd-mm-yyyy'), 'ST_CLERK', 2800.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (131, 'James', 'Marlow', 'JAMRLOW', '650.124.7234', to_date('16-02-1997', 'dd-mm-yyyy'), 'ST_CLERK', 2500.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (132, 'TJ', 'Olson', 'TJOLSON', '650.124.8234', to_date('10-04-1999', 'dd-mm-yyyy'), 'ST_CLERK', 2100.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (133, 'Jason', 'Mallin', 'JMALLIN', '650.127.1934', to_date('14-06-1996', 'dd-mm-yyyy'), 'ST_CLERK', 3300.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (134, 'Michael', 'Rogers', 'MROGERS', '650.127.1834', to_date('26-08-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2900.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (135, 'Ki', 'Gee', 'KGEE', '650.127.1734', to_date('12-12-1999', 'dd-mm-yyyy'), 'ST_CLERK', 2400.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (136, 'Hazel', 'Philtanker', 'HPHILTAN', '650.127.1634', to_date('06-02-2000', 'dd-mm-yyyy'), 'ST_CLERK', 2200.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (137, 'Renske', 'Ladwig', 'RLADWIG', '650.121.1234', to_date('14-07-1995', 'dd-mm-yyyy'), 'ST_CLERK', 3600.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (138, 'Stephen', 'Stiles', 'SSTILES', '650.121.2034', to_date('26-10-1997', 'dd-mm-yyyy'), 'ST_CLERK', 3200.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (139, 'John', 'Seo', 'JSEO', '650.121.2019', to_date('12-02-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2700.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (140, 'Joshua', 'Patel', 'JPATEL', '650.121.1834', to_date('06-04-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2500.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (141, 'Trenna', 'Rajs', 'TRAJS', '650.121.8009', to_date('17-10-1995', 'dd-mm-yyyy'), 'ST_CLERK', 3500.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (142, 'Curtis', 'Davies', 'CDAVIES', '650.121.2994', to_date('29-01-1997', 'dd-mm-yyyy'), 'ST_CLERK', 3100.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (143, 'Randall', 'Matos', 'RMATOS', '650.121.2874', to_date('15-03-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2600.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (144, 'Peter', 'Vargas', 'PVARGAS', '650.121.2004', to_date('09-07-1998', 'dd-mm-yyyy'), 'ST_CLERK', 2500.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (145, 'John', 'Russell', 'JRUSSEL', '011.44.1344.429268', to_date('01-10-1996', 'dd-mm-yyyy'), 'SA_MAN', 14000.00, 0.40, 100, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (146, 'Karen', 'Partners', 'KPARTNER', '011.44.1344.467268', to_date('05-01-1997', 'dd-mm-yyyy'), 'SA_MAN', 13500.00, 0.30, 100, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (147, 'Alberto', 'Errazuriz', 'AERRAZUR', '011.44.1344.429278', to_date('10-03-1997', 'dd-mm-yyyy'), 'SA_MAN', 12000.00, 0.30, 100, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (148, 'Gerald', 'Cambrault', 'GCAMBRAU', '011.44.1344.619268', to_date('15-10-1999', 'dd-mm-yyyy'), 'SA_MAN', 11000.00, 0.30, 100, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (149, 'Eleni', 'Zlotkey', 'EZLOTKEY', '011.44.1344.429018', to_date('29-01-2000', 'dd-mm-yyyy'), 'SA_MAN', 10500.00, 0.20, 100, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (150, 'Peter', 'Tucker', 'PTUCKER', '011.44.1344.129268', to_date('30-01-1997', 'dd-mm-yyyy'), 'SA_REP', 10000.00, 0.30, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (151, 'David', 'Bernstein', 'DBERNSTE', '011.44.1344.345268', to_date('24-03-1997', 'dd-mm-yyyy'), 'SA_REP', 9500.00, 0.25, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (152, 'Peter', 'Hall', 'PHALL', '011.44.1344.478968', to_date('20-08-1997', 'dd-mm-yyyy'), 'SA_REP', 9000.00, 0.25, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (153, 'Christopher', 'Olsen', 'COLSEN', '011.44.1344.498718', to_date('30-03-1998', 'dd-mm-yyyy'), 'SA_REP', 8000.00, 0.20, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (154, 'Nanette', 'Cambrault', 'NCAMBRAU', '011.44.1344.987668', to_date('09-12-1998', 'dd-mm-yyyy'), 'SA_REP', 7500.00, 0.20, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (155, 'Oliver', 'Tuvault', 'OTUVAULT', '011.44.1344.486508', to_date('23-11-1999', 'dd-mm-yyyy'), 'SA_REP', 7000.00, 0.15, 145, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (156, 'Janette', 'King', 'JKING', '011.44.1345.429268', to_date('30-01-1996', 'dd-mm-yyyy'), 'SA_REP', 10000.00, 0.35, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (157, 'Patrick', 'Sully', 'PSULLY', '011.44.1345.929268', to_date('04-03-1996', 'dd-mm-yyyy'), 'SA_REP', 9500.00, 0.35, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (158, 'Allan', 'McEwen', 'AMCEWEN', '011.44.1345.829268', to_date('01-08-1996', 'dd-mm-yyyy'), 'SA_REP', 9000.00, 0.35, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (159, 'Lindsey', 'Smith', 'LSMITH', '011.44.1345.729268', to_date('10-03-1997', 'dd-mm-yyyy'), 'SA_REP', 8000.00, 0.30, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (160, 'Louise', 'Doran', 'LDORAN', '011.44.1345.629268', to_date('15-12-1997', 'dd-mm-yyyy'), 'SA_REP', 7500.00, 0.30, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (161, 'Sarath', 'Sewall', 'SSEWALL', '011.44.1345.529268', to_date('03-11-1998', 'dd-mm-yyyy'), 'SA_REP', 7000.00, 0.25, 146, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (162, 'Clara', 'Vishney', 'CVISHNEY', '011.44.1346.129268', to_date('11-11-1997', 'dd-mm-yyyy'), 'SA_REP', 10500.00, 0.25, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (163, 'Danielle', 'Greene', 'DGREENE', '011.44.1346.229268', to_date('19-03-1999', 'dd-mm-yyyy'), 'SA_REP', 9500.00, 0.15, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (164, 'Mattea', 'Marvins', 'MMARVINS', '011.44.1346.329268', to_date('24-01-2000', 'dd-mm-yyyy'), 'SA_REP', 7200.00, 0.10, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (165, 'David', 'Lee', 'DLEE', '011.44.1346.529268', to_date('23-02-2000', 'dd-mm-yyyy'), 'SA_REP', 6800.00, 0.10, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (166, 'Sundar', 'Ande', 'SANDE', '011.44.1346.629268', to_date('24-03-2000', 'dd-mm-yyyy'), 'SA_REP', 6400.00, 0.10, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (167, 'Amit', 'Banda', 'ABANDA', '011.44.1346.729268', to_date('21-04-2000', 'dd-mm-yyyy'), 'SA_REP', 6200.00, 0.10, 147, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (168, 'Lisa', 'Ozer', 'LOZER', '011.44.1343.929268', to_date('11-03-1997', 'dd-mm-yyyy'), 'SA_REP', 11500.00, 0.25, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (169, 'Harrison', 'Bloom', 'HBLOOM', '011.44.1343.829268', to_date('23-03-1998', 'dd-mm-yyyy'), 'SA_REP', 10000.00, 0.20, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (170, 'Tayler', 'Fox', 'TFOX', '011.44.1343.729268', to_date('24-01-1998', 'dd-mm-yyyy'), 'SA_REP', 9600.00, 0.20, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (171, 'William', 'Smith', 'WSMITH', '011.44.1343.629268', to_date('23-02-1999', 'dd-mm-yyyy'), 'SA_REP', 7400.00, 0.15, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (172, 'Elizabeth', 'Bates', 'EBATES', '011.44.1343.529268', to_date('24-03-1999', 'dd-mm-yyyy'), 'SA_REP', 7300.00, 0.15, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (173, 'Sundita', 'Kumar', 'SKUMAR', '011.44.1343.329268', to_date('21-04-2000', 'dd-mm-yyyy'), 'SA_REP', 6100.00, 0.10, 148, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (174, 'Ellen', 'Abel', 'EABEL', '011.44.1644.429267', to_date('11-05-1996', 'dd-mm-yyyy'), 'SA_REP', 11000.00, 0.30, 149, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (175, 'Alyssa', 'Hutton', 'AHUTTON', '011.44.1644.429266', to_date('19-03-1997', 'dd-mm-yyyy'), 'SA_REP', 8800.00, 0.25, 149, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (176, 'Jonathon', 'Taylor', 'JTAYLOR', '011.44.1644.429265', to_date('24-03-1998', 'dd-mm-yyyy'), 'SA_REP', 8600.00, 0.20, 149, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (177, 'Jack', 'Livingston', 'JLIVINGS', '011.44.1644.429264', to_date('23-04-1998', 'dd-mm-yyyy'), 'SA_REP', 8400.00, 0.20, 149, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (178, 'Kimberely', 'Grant', 'KGRANT', '011.44.1644.429263', to_date('24-05-1999', 'dd-mm-yyyy'), 'SA_REP', 7000.00, 0.15, 149, null);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (179, 'Charles', 'Johnson', 'CJOHNSON', '011.44.1644.429262', to_date('04-01-2000', 'dd-mm-yyyy'), 'SA_REP', 6200.00, 0.10, 149, 80);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (180, 'Winston', 'Taylor', 'WTAYLOR', '650.507.9876', to_date('24-01-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3200.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (181, 'Jean', 'Fleaur', 'JFLEAUR', '650.507.9877', to_date('23-02-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3100.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (182, 'Martha', 'Sullivan', 'MSULLIVA', '650.507.9878', to_date('21-06-1999', 'dd-mm-yyyy'), 'SH_CLERK', 2500.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (183, 'Girard', 'Geoni', 'GGEONI', '650.507.9879', to_date('03-02-2000', 'dd-mm-yyyy'), 'SH_CLERK', 2800.00, null, 120, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (184, 'Nandita', 'Sarchand', 'NSARCHAN', '650.509.1876', to_date('27-01-1996', 'dd-mm-yyyy'), 'SH_CLERK', 4200.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (185, 'Alexis', 'Bull', 'ABULL', '650.509.2876', to_date('20-02-1997', 'dd-mm-yyyy'), 'SH_CLERK', 4100.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (186, 'Julia', 'Dellinger', 'JDELLING', '650.509.3876', to_date('24-06-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3400.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (187, 'Anthony', 'Cabrio', 'ACABRIO', '650.509.4876', to_date('07-02-1999', 'dd-mm-yyyy'), 'SH_CLERK', 3000.00, null, 121, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (188, 'Kelly', 'Chung', 'KCHUNG', '650.505.1876', to_date('14-06-1997', 'dd-mm-yyyy'), 'SH_CLERK', 3800.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (189, 'Jennifer', 'Dilly', 'JDILLY', '650.505.2876', to_date('13-08-1997', 'dd-mm-yyyy'), 'SH_CLERK', 3600.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (190, 'Timothy', 'Gates', 'TGATES', '650.505.3876', to_date('11-07-1998', 'dd-mm-yyyy'), 'SH_CLERK', 2900.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (191, 'Randall', 'Perkins', 'RPERKINS', '650.505.4876', to_date('19-12-1999', 'dd-mm-yyyy'), 'SH_CLERK', 2500.00, null, 122, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (192, 'Sarah', 'Bell', 'SBELL', '650.501.1876', to_date('04-02-1996', 'dd-mm-yyyy'), 'SH_CLERK', 4000.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (193, 'Britney', 'Everett', 'BEVERETT', '650.501.2876', to_date('03-03-1997', 'dd-mm-yyyy'), 'SH_CLERK', 3900.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (194, 'Samuel', 'McCain', 'SMCCAIN', '650.501.3876', to_date('01-07-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3200.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (195, 'Vance', 'Jones', 'VJONES', '650.501.4876', to_date('17-03-1999', 'dd-mm-yyyy'), 'SH_CLERK', 2800.00, null, 123, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (196, 'Alana', 'Walsh', 'AWALSH', '650.507.9811', to_date('24-04-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3100.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> insert into EMPLOYEES_UDT (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
  2 values (197, 'Kevin', 'Feeney', 'KFEENEY', '650.507.9822', to_date('23-05-1998', 'dd-mm-yyyy'), 'SH_CLERK', 3000.00, null, 124, 50);

1 rows affected.

SQL> 
SQL> DROP TABLE IF EXISTS JOBS;

Succeed.

SQL> CREATE TABLE JOBS
  2 (	JOB_ID VARCHAR2(10), 
  3 	JOB_TITLE VARCHAR2(35) CONSTRAINT "JOB_TITLE_NN" NOT NULL, 
  4 	MIN_SALARY NUMBER(6,0), 
  5 	MAX_SALARY NUMBER(6,0), 
  6 	CONSTRAINT "JOB_ID_PK" PRIMARY KEY ("JOB_ID")
  7    );

Succeed.

SQL> 
SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('AD_PRES', 'President', 20000, 40000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('AD_VP', 'Administration Vice President', 15000, 30000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('AD_ASST', 'Administration Assistant', 3000, 6000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('FI_MGR', 'Finance Manager', 8200, 16000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('FI_ACCOUNT', 'Accountant', 4200, 9000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('AC_MGR', 'Accounting Manager', 8200, 16000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('AC_ACCOUNT', 'Public Accountant', 4200, 9000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('SA_MAN', 'Sales Manager', 10000, 20000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('SA_REP', 'Sales Representative', 6000, 12000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('PU_MAN', 'Purchasing Manager', 8000, 15000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('PU_CLERK', 'Purchasing Clerk', 2500, 5500);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('ST_MAN', 'Stock Manager', 5500, 8500);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('ST_CLERK', 'Stock Clerk', 2000, 5000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('SH_CLERK', 'Shipping Clerk', 2500, 5500);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('IT_PROG', 'Programmer', 4000, 10000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('MK_MAN', 'Marketing Manager', 9000, 15000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('MK_REP', 'Marketing Representative', 4000, 9000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('HR_REP', 'Human Resources Representative', 4000, 9000);

1 rows affected.

SQL> insert into JOBS (job_id, job_title, min_salary, max_salary) values ('PR_REP', 'Public Relations Representative', 4500, 10500);

1 rows affected.

SQL> commit;

Succeed.

SQL> 
SQL> 
SQL> drop type if exists EmpRecTyp force;

Succeed.

SQL> create type EmpRecTyp force as object(emp_id NUMBER(6,0), salary NUMBER(8,2));
  2 /

Succeed.

SQL> drop function if exists nth_highest_salary;

Succeed.

SQL> create FUNCTION nth_highest_salary(n INTEGER) RETURN EmpRecTyp IS
  2   c1 SYS_REFCURSOR;
  3   type rec is record(emp_id EMPLOYEES_UDT.employee_id%type, salary EMPLOYEES_UDT.salary%type);
  4   emp_rec rec;
  5   emp_obj EmpRecTyp;
  6  BEGIN
  7   OPEN c1 for SELECT employee_id, salary FROM EMPLOYEES_UDT ORDER BY salary DESC;
  8   FOR i IN 1 .. n LOOP
  9    FETCH c1 INTO emp_rec;
 10   END LOOP;
 11   CLOSE c1;
 12   emp_obj := EmpRecTyp(emp_rec.emp_id, emp_rec.salary);
 13   RETURN emp_obj;
 14  END nth_highest_salary;
 15 /

Succeed.

SQL> DECLARE
  2  highest_paid_emp      EmpRecTyp;
  3  next_highest_paid_emp EmpRecTyp;
  4 
  5 BEGIN
  6  highest_paid_emp      := nth_highest_salary(1);
  7  next_highest_paid_emp := nth_highest_salary(2);
  8  dbe_output.print_line('Highest Paid: #' || highest_paid_emp.emp_id ||
  9                       ', $' || highest_paid_emp.salary);
 10  dbe_output.print_line('Next Highest Paid: #' ||
 11                       next_highest_paid_emp.emp_id || ', $' ||
 12                       next_highest_paid_emp.salary);
 13 END;
 14 /

Highest Paid: #100, $24000
Next Highest Paid: #101, $17000

PL/SQL procedure successfully completed.

SQL> 
SQL> drop type  EmpRecTyp force;

Succeed.

SQL> 
SQL> DECLARE
  2  TYPE empcurtyp IS REF CURSOR;
  3  TYPE namelist IS TABLE OF VARCHAR(25);
  4  TYPE sallist IS TABLE OF NUMBER(8, 2);
  5  emp_cv empcurtyp;
  6  names  namelist;
  7  sals   sallist;
  8 BEGIN
  9  OPEN emp_cv FOR
 10   SELECT last_name, salary
 11     FROM EMPLOYEES_UDT
 12    WHERE job_id = 'SA_REP'
 13    ORDER BY salary DESC, last_name;
 14  FETCH emp_cv BULK COLLECT
 15  INTO names, sals;
 16  CLOSE emp_cv;
 17  -- loop through the names and sals collections
 18  FOR i IN names.FIRST .. names.LAST LOOP
 19   dbe_output.print_line('Name = ' || names(i) || ', salary = ' || sals(i));
 20  END LOOP;
 21   OPEN emp_cv FOR
 22   SELECT last_name, salary
 23     FROM EMPLOYEES_UDT;
 24  FETCH emp_cv BULK COLLECT
 25  INTO names, sals;
 26  CLOSE emp_cv;
 27  DBE_OUTPUT.PRINT_LINE('names.count ' || names.count);
 28 END;
 29 /

Name = Ozer, salary = 11500
Name = Abel, salary = 11000
Name = Vishney, salary = 10500
Name = Bloom, salary = 10000
Name = King, salary = 10000
Name = Tucker, salary = 10000
Name = Fox, salary = 9600
Name = Bernstein, salary = 9500
Name = Greene, salary = 9500
Name = Sully, salary = 9500
Name = Hall, salary = 9000
Name = McEwen, salary = 9000
Name = Hutton, salary = 8800
Name = Taylor, salary = 8600
Name = Livingston, salary = 8400
Name = Olsen, salary = 8000
Name = Smith, salary = 8000
Name = Cambrault, salary = 7500
Name = Doran, salary = 7500
Name = Smith, salary = 7400
Name = Bates, salary = 7300
Name = Marvins, salary = 7200
Name = Grant, salary = 7000
Name = Sewall, salary = 7000
Name = Tuvault, salary = 7000
Name = Lee, salary = 6800
Name = Ande, salary = 6400
Name = Banda, salary = 6200
Name = Johnson, salary = 6200
Name = Kumar, salary = 6100
names.count 107

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2   query VARCHAR2(4000) := 'SELECT first_name FROM EMPLOYEES_UDT';
  3    type c_1 is table of EMPLOYEES_UDT.first_name%type;
  4    var_c_1 c_1;
  5 BEGIN
  6   EXECUTE IMMEDIATE query BULK COLLECT INTO var_c_1;
  7     DBE_OUTPUT.PRINT_LINE('--------' || var_c_1.COUNT);
  8 END;
  9 /

--------107

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE empcurtyp IS REF CURSOR;
  3  TYPE namelist IS TABLE OF VARCHAR(25);
  4  TYPE sallist IS TABLE OF NUMBER(8, 2);
  5  emp_cv empcurtyp;
  6  names  namelist;
  7  sals   sallist;
  8 BEGIN
  9  OPEN emp_cv FOR
 10   SELECT last_name, salary
 11     FROM EMPLOYEES_UDT
 12    ORDER BY salary DESC, last_name;
 13  FETCH emp_cv BULK COLLECT
 14  INTO names, sals LIMIT 33;
 15  CLOSE emp_cv;
 16  -- loop through the names and sals collections
 17  FOR i IN names.FIRST .. names.LAST LOOP
 18   dbe_output.print_line('Name = ' || names(i) || ', salary = ' || sals(i));
 19  END LOOP;
 20 END;
 21 /

Name = King, salary = 24000
Name = De Haan, salary = 17000
Name = Kochhar, salary = 17000
Name = Russell, salary = 14000
Name = Partners, salary = 13500
Name = Hartstein, salary = 13000
Name = Errazuriz, salary = 12000
Name = Greenberg, salary = 12000
Name = Higgins, salary = 12000
Name = Ozer, salary = 11500
Name = Abel, salary = 11000
Name = Cambrault, salary = 11000
Name = Raphaely, salary = 11000
Name = Vishney, salary = 10500
Name = Zlotkey, salary = 10500
Name = Baer, salary = 10000
Name = Bloom, salary = 10000
Name = King, salary = 10000
Name = Tucker, salary = 10000
Name = Fox, salary = 9600
Name = Bernstein, salary = 9500
Name = Greene, salary = 9500
Name = Sully, salary = 9500
Name = Faviet, salary = 9000
Name = Hall, salary = 9000
Name = Hunold, salary = 9000
Name = McEwen, salary = 9000
Name = Hutton, salary = 8800
Name = Taylor, salary = 8600
Name = Livingston, salary = 8400
Name = Gietz, salary = 8300
Name = Chen, salary = 8200
Name = Fripp, salary = 8200

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE empcurtyp IS REF CURSOR;
  3  TYPE namelist IS TABLE OF VARCHAR(25);
  4  TYPE sallist IS TABLE OF NUMBER(8, 2);
  5  emp_cv empcurtyp;
  6  names  namelist;
  7  sals   sallist;
  8 BEGIN
  9  OPEN emp_cv FOR
 10   SELECT last_name, salary
 11     FROM EMPLOYEES_UDT
 12    ORDER BY salary DESC, last_name;
 13  FETCH emp_cv BULK COLLECT
 14  INTO names, sals LIMIT sleep(2);
 15  CLOSE emp_cv;
 16 END;
 17 /

CT-00932, [13:2] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[13:2] CT-00916, PL/SQL:syntax error(numberic or value error)

SQL> 
SQL> BEGIN
  2  FOR item IN (SELECT last_name, job_id
  3                 FROM EMPLOYEES_UDT
  4                WHERE job_id LIKE '%CLERK%'
  5                  AND manager_id > 120
  6                ORDER BY last_name) LOOP
  7   dbe_output.print_line('Name = ' || item.last_name || ', Job = ' ||
  8                        item.job_id);
  9  END LOOP;
 10 END;
 11 /

Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
Name = Bull, Job = SH_CLERK
Name = Cabrio, Job = SH_CLERK
Name = Chung, Job = SH_CLERK
Name = Davies, Job = ST_CLERK
Name = Dellinger, Job = SH_CLERK
Name = Dilly, Job = SH_CLERK
Name = Everett, Job = SH_CLERK
Name = Feeney, Job = SH_CLERK
Name = Gates, Job = SH_CLERK
Name = Gee, Job = ST_CLERK
Name = Grant, Job = SH_CLERK
Name = Jones, Job = SH_CLERK
Name = Ladwig, Job = ST_CLERK
Name = Mallin, Job = ST_CLERK
Name = Marlow, Job = ST_CLERK
Name = Matos, Job = ST_CLERK
Name = McCain, Job = SH_CLERK
Name = OConnell, Job = SH_CLERK
Name = Olson, Job = ST_CLERK
Name = Patel, Job = ST_CLERK
Name = Perkins, Job = SH_CLERK
Name = Philtanker, Job = ST_CLERK
Name = Rajs, Job = ST_CLERK
Name = Rogers, Job = ST_CLERK
Name = Sarchand, Job = SH_CLERK
Name = Seo, Job = ST_CLERK
Name = Stiles, Job = ST_CLERK
Name = Vargas, Job = ST_CLERK
Name = Walsh, Job = SH_CLERK

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE CURSOR c1 IS
  2  SELECT last_name, job_id
  3    FROM EMPLOYEES_UDT
  4   WHERE job_id LIKE '%CLERK%'
  5     AND manager_id > 120
  6   ORDER BY last_name;
  7 BEGIN
  8  FOR item IN c1 LOOP
  9   dbe_output.print_line('Name = ' || item.last_name || ', Job = ' ||
 10                        item.job_id);
 11  END LOOP;
 12 END;
 13 /

Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
Name = Bull, Job = SH_CLERK
Name = Cabrio, Job = SH_CLERK
Name = Chung, Job = SH_CLERK
Name = Davies, Job = ST_CLERK
Name = Dellinger, Job = SH_CLERK
Name = Dilly, Job = SH_CLERK
Name = Everett, Job = SH_CLERK
Name = Feeney, Job = SH_CLERK
Name = Gates, Job = SH_CLERK
Name = Gee, Job = ST_CLERK
Name = Grant, Job = SH_CLERK
Name = Jones, Job = SH_CLERK
Name = Ladwig, Job = ST_CLERK
Name = Mallin, Job = ST_CLERK
Name = Marlow, Job = ST_CLERK
Name = Matos, Job = ST_CLERK
Name = McCain, Job = SH_CLERK
Name = OConnell, Job = SH_CLERK
Name = Olson, Job = ST_CLERK
Name = Patel, Job = ST_CLERK
Name = Perkins, Job = SH_CLERK
Name = Philtanker, Job = ST_CLERK
Name = Rajs, Job = ST_CLERK
Name = Rogers, Job = ST_CLERK
Name = Sarchand, Job = SH_CLERK
Name = Seo, Job = ST_CLERK
Name = Stiles, Job = ST_CLERK
Name = Vargas, Job = ST_CLERK
Name = Walsh, Job = SH_CLERK

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  CURSOR c1 IS
  3   SELECT last_name, job_id
  4     FROM EMPLOYEES_UDT
  5    WHERE REGEXP_LIKE(job_id, 'S[HT]_CLERK')
  6    ORDER BY last_name;
  7  v_lastname EMPLOYEES_UDT.last_name%TYPE; -- variable for last_name
  8  v_jobid    EMPLOYEES_UDT.job_id%TYPE; -- variable for job_id
  9  CURSOR c2 IS
 10   SELECT *
 11     FROM EMPLOYEES_UDT
 12    WHERE REGEXP_LIKE(job_id, '[ACADFIMKSA]_M[ANGR]')
 13    ORDER BY job_id;
 14  v_EMPLOYEES_UDT EMPLOYEES_UDT%ROWTYPE; -- record variable for row of table
 15 BEGIN
 16  OPEN c1;
 17  LOOP
 18   -- Fetches 2 columns into variables
 19   FETCH c1
 20   INTO v_lastname, v_jobid;
 21   EXIT WHEN c1%NOTFOUND;
 22   dbe_output.print_line(RPAD(v_lastname, 25, ' ') || v_jobid);
 23  END LOOP;
 24  CLOSE c1;
 25  dbe_output.print_line('-------------------------------------');
 26  OPEN c2;
 27  LOOP
 28   -- Fetches entire row into the v_EMPLOYEES_UDT record
 29   FETCH c2
 30   INTO v_EMPLOYEES_UDT;
 31   EXIT WHEN c2%NOTFOUND;
 32   dbe_output.print_line(RPAD(v_EMPLOYEES_UDT.last_name, 25, ' ') ||
 33                        v_EMPLOYEES_UDT.job_id);
 34  END LOOP;
 35  CLOSE c2;
 36 END;
 37 /

Atkinson                 ST_CLERK
Bell                     SH_CLERK
Bissot                   ST_CLERK
Bull                     SH_CLERK
Cabrio                   SH_CLERK
Chung                    SH_CLERK
Davies                   ST_CLERK
Dellinger                SH_CLERK
Dilly                    SH_CLERK
Everett                  SH_CLERK
Feeney                   SH_CLERK
Fleaur                   SH_CLERK
Gates                    SH_CLERK
Gee                      ST_CLERK
Geoni                    SH_CLERK
Grant                    SH_CLERK
Jones                    SH_CLERK
Ladwig                   ST_CLERK
Landry                   ST_CLERK
Mallin                   ST_CLERK
Markle                   ST_CLERK
Marlow                   ST_CLERK
Matos                    ST_CLERK
McCain                   SH_CLERK
Mikkilineni              ST_CLERK
Nayer                    ST_CLERK
OConnell                 SH_CLERK
Olson                    ST_CLERK
Patel                    ST_CLERK
Perkins                  SH_CLERK
Philtanker               ST_CLERK
Rajs                     ST_CLERK
Rogers                   ST_CLERK
Sarchand                 SH_CLERK
Seo                      ST_CLERK
Stiles                   ST_CLERK
Sullivan                 SH_CLERK
Taylor                   SH_CLERK
Vargas                   ST_CLERK
Walsh                    SH_CLERK
-------------------------------------
Higgins                  AC_MGR
Greenberg                FI_MGR
Hartstein                MK_MAN
Russell                  SA_MAN
Partners                 SA_MAN
Errazuriz                SA_MAN
Cambrault                SA_MAN
Zlotkey                  SA_MAN

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  CURSOR c IS
  3   SELECT e.job_id, j.job_title
  4     FROM EMPLOYEES_UDT e, jobs j
  5    WHERE e.job_id = j.job_id
  6      AND e.manager_id = 100
  7    ORDER BY last_name;
  8  -- Record variables for rows of cursor result set:
  9  job1 c%ROWTYPE;
 10  job2 c%ROWTYPE;
 11  job3 c%ROWTYPE;
 12  job4 c%ROWTYPE;
 13  job5 c%ROWTYPE;
 14 BEGIN
 15  OPEN c;
 16  FETCH c
 17  INTO job1; -- fetches first row
 18  FETCH c
 19  INTO job2; -- fetches second row
 20  FETCH c
 21  INTO job3; -- fetches third row
 22  FETCH c
 23  INTO job4; -- fetches fourth row
 24  FETCH c
 25  INTO job5; -- fetches fifth row
 26  CLOSE c;
 27  dbe_output.print_line(job1.job_title || ' (' || job1.job_id || ')');
 28  dbe_output.print_line(job2.job_title || ' (' || job2.job_id || ')');
 29  dbe_output.print_line(job3.job_title || ' (' || job3.job_id || ')');
 30  dbe_output.print_line(job4.job_title || ' (' || job4.job_id || ')');
 31  dbe_output.print_line(job5.job_title || ' (' || job5.job_id || ')');
 32 END;
 33 /

Sales Manager (SA_MAN)
Administration Vice President (AD_VP)
Sales Manager (SA_MAN)
Stock Manager (ST_MAN)
Marketing Manager (MK_MAN)

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE EmpCurTyp IS REF CURSOR;
  3  v_emp_cursor EmpCurTyp;
  4  emp_record   EMPLOYEES_UDT%ROWTYPE;
  5  v_stmt_str   VARCHAR2(200);
  6 BEGIN
  7  -- Dynamic SQL statement with placeholder:
  8  v_stmt_str := 'SELECT * FROM EMPLOYEES_UDT  where job_id = :j ';
  9  -- Open cursor & specify bind variable in USING clause:
 10  OPEN v_emp_cursor FOR v_stmt_str USING 'PU_CLERK';
 11  -- Fetch rows from result set one at a time:
 12  LOOP
 13   FETCH v_emp_cursor
 14   INTO emp_record;
 15   EXIT WHEN v_emp_cursor%NOTFOUND;
 16  
 17   dbe_output.print_line('emp_record.EMPLOYEE_ID ' || emp_record.EMPLOYEE_ID);
 18   dbe_output.print_line('emp_record.FIRST_NAME ' || emp_record.FIRST_NAME);
 19   dbe_output.print_line('emp_record.LAST_NAME ' || emp_record.LAST_NAME);
 20   dbe_output.print_line('emp_record.EMAIL ' || emp_record.EMAIL);
 21   dbe_output.print_line('emp_record.PHONE_NUMBER ' ||
 22                        emp_record.PHONE_NUMBER);
 23   dbe_output.print_line('emp_record.HIRE_DATE ' || emp_record.HIRE_DATE);
 24   dbe_output.print_line('emp_record.JOB_ID ' || emp_record.JOB_ID);
 25   dbe_output.print_line('emp_record.SALARY ' || emp_record.SALARY);
 26   dbe_output.print_line('emp_record.COMMISSION_PCT ' ||
 27                        emp_record.COMMISSION_PCT);
 28   dbe_output.print_line('emp_record.MANAGER_ID ' || emp_record.MANAGER_ID);
 29   dbe_output.print_line('emp_record.DEPARTMENT_ID ' ||
 30                        emp_record.DEPARTMENT_ID);
 31   dbe_output.print_line('--------------------------------------');
 32  END LOOP;
 33  -- Close cursor:
 34  CLOSE v_emp_cursor;
 35 END;
 36 /

emp_record.EMPLOYEE_ID 115
emp_record.FIRST_NAME Alexander
emp_record.LAST_NAME Khoo
emp_record.EMAIL AKHOO
emp_record.PHONE_NUMBER 515.127.4562
emp_record.HIRE_DATE 1995-05-18 00:00:00
emp_record.JOB_ID PU_CLERK
emp_record.SALARY 3100
emp_record.COMMISSION_PCT 
emp_record.MANAGER_ID 114
emp_record.DEPARTMENT_ID 30
--------------------------------------
emp_record.EMPLOYEE_ID 116
emp_record.FIRST_NAME Shelli
emp_record.LAST_NAME Baida
emp_record.EMAIL SBAIDA
emp_record.PHONE_NUMBER 515.127.4563
emp_record.HIRE_DATE 1997-12-24 00:00:00
emp_record.JOB_ID PU_CLERK
emp_record.SALARY 2900
emp_record.COMMISSION_PCT 
emp_record.MANAGER_ID 114
emp_record.DEPARTMENT_ID 30
--------------------------------------
emp_record.EMPLOYEE_ID 117
emp_record.FIRST_NAME Sigal
emp_record.LAST_NAME Tobias
emp_record.EMAIL STOBIAS
emp_record.PHONE_NUMBER 515.127.4564
emp_record.HIRE_DATE 1997-07-24 00:00:00
emp_record.JOB_ID PU_CLERK
emp_record.SALARY 2800
emp_record.COMMISSION_PCT 
emp_record.MANAGER_ID 114
emp_record.DEPARTMENT_ID 30
--------------------------------------
emp_record.EMPLOYEE_ID 118
emp_record.FIRST_NAME Guy
emp_record.LAST_NAME Himuro
emp_record.EMAIL GHIMURO
emp_record.PHONE_NUMBER 515.127.4565
emp_record.HIRE_DATE 1998-11-15 00:00:00
emp_record.JOB_ID PU_CLERK
emp_record.SALARY 2600
emp_record.COMMISSION_PCT 
emp_record.MANAGER_ID 114
emp_record.DEPARTMENT_ID 30
--------------------------------------
emp_record.EMPLOYEE_ID 119
emp_record.FIRST_NAME Karen
emp_record.LAST_NAME Colmenares
emp_record.EMAIL KCOLMENA
emp_record.PHONE_NUMBER 515.127.4566
emp_record.HIRE_DATE 1999-08-10 00:00:00
emp_record.JOB_ID PU_CLERK
emp_record.SALARY 2500
emp_record.COMMISSION_PCT 
emp_record.MANAGER_ID 114
emp_record.DEPARTMENT_ID 30
--------------------------------------

PL/SQL procedure successfully completed.

SQL> 
SQL> create or replace type c1_obj FORCE AS OBJECT(last_name VARCHAR2(25), salary NUMBER(8,2));
  2 /

Succeed.

SQL> 
SQL> DECLARE
  2  CURSOR c1 IS
  3   SELECT last_name, salary
  4     FROM EMPLOYEES_UDT
  5    WHERE salary > 10000 and rownum <= 3
  6    ORDER BY last_name;
  7  c1_rec c1_obj;
  8  
  9 BEGIN
 10  dbe_output.print_line('--- Processing all results simultaneously ---');
 11 
 12  OPEN c1;
 13  LOOP
 14   FETCH c1 into c1_rec;
 15   EXIT WHEN c1%NOTFOUND;
 16  END LOOP;
 17  CLOSE c1;
 18 END;
 19 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[14:23] PLC-00916 PL/SQL:syntax error(type mismatch found at OBJECT type between anonymous record and INTO variables)

SQL> drop TYPE c1_obj force;

Succeed.

SQL> 
SQL> drop TYPE if exists NameList force;

Succeed.

SQL> create type NameList IS TABLE OF VARCHAR(25);
  2 /

Succeed.

SQL> drop TYPE if exists SalList force;

Succeed.

SQL> create type SalList IS TABLE OF NUMBER(8, 2);
  2 /

Succeed.

SQL> 
SQL> drop PROCEDURE if exists print_results;

Succeed.

SQL> create PROCEDURE print_results(names NameList, sals SalList) IS
  2  BEGIN
  3   -- Check if collections are empty:
  4   IF names IS NULL OR names.COUNT = 0 THEN
  5    dbe_output.print_line('No results!');
  6   ELSE
  7    dbe_output.print_line('Result: ');
  8    FOR i IN names.FIRST .. names.LAST LOOP
  9     dbe_output.print_line(' Employee ' || names(i) || ': $' || sals(i));
 10    END LOOP;
 11   END IF;
 12  END;
 13 /

Succeed.

SQL> 
SQL> DECLARE
  2  CURSOR c1 IS
  3   SELECT last_name, salary
  4     FROM EMPLOYEES_UDT
  5    WHERE salary > 10000
  6    ORDER BY last_name;
  7  names NameList;
  8  sals  SalList;
  9  type c1_rec is record (last_name EMPLOYEES_UDT.last_name%type, salary EMPLOYEES_UDT.salary%type);
 10  TYPE RecList IS TABLE OF c1_rec;
 11  recs RecList;
 12  v_limit INTEGER := 10;
 13  
 14 BEGIN
 15  dbe_output.print_line('--- Processing all results simultaneously ---');
 16  OPEN c1;
 17  FETCH c1 BULK COLLECT
 18  INTO names, sals;
 19  CLOSE c1;
 20  print_results(names, sals);
 21  dbe_output.print_line('--- Processing ' || v_limit ||
 22                       ' rows at a time ---');
 23  OPEN c1;
 24  LOOP
 25   FETCH c1 BULK COLLECT
 26   INTO names, sals LIMIT v_limit;
 27   EXIT WHEN names.COUNT = 0;
 28    print_results(names, sals);
 29  END LOOP;
 30  CLOSE c1;
 31  dbe_output.print_line('--- Fetching records rather than columns ---');
 32  OPEN c1;
 33  FETCH c1 BULK COLLECT
 34  INTO recs;
 35  FOR i IN recs.FIRST .. recs.LAST LOOP
 36   -- Now all columns from result set come from one record
 37   dbe_output.print_line(' Employee ' || recs(i).last_name || ': $' || recs(i)
 38                        .salary);
 39  END LOOP;
 40 END;
 41 /

--- Processing all results simultaneously ---
Result: 
 Employee Abel: $11000
 Employee Cambrault: $11000
 Employee De Haan: $17000
 Employee Errazuriz: $12000
 Employee Greenberg: $12000
 Employee Hartstein: $13000
 Employee Higgins: $12000
 Employee King: $24000
 Employee Kochhar: $17000
 Employee Ozer: $11500
 Employee Partners: $13500
 Employee Raphaely: $11000
 Employee Russell: $14000
 Employee Vishney: $10500
 Employee Zlotkey: $10500
--- Processing 10 rows at a time ---
Result: 
 Employee Abel: $11000
 Employee Cambrault: $11000
 Employee De Haan: $17000
 Employee Errazuriz: $12000
 Employee Greenberg: $12000
 Employee Hartstein: $13000
 Employee Higgins: $12000
 Employee King: $24000
 Employee Kochhar: $17000
 Employee Ozer: $11500
Result: 
 Employee Partners: $13500
 Employee Raphaely: $11000
 Employee Russell: $14000
 Employee Vishney: $10500
 Employee Zlotkey: $10500
--- Fetching records rather than columns ---
 Employee Abel: $11000
 Employee Cambrault: $11000
 Employee De Haan: $17000
 Employee Errazuriz: $12000
 Employee Greenberg: $12000
 Employee Hartstein: $13000
 Employee Higgins: $12000
 Employee King: $24000
 Employee Kochhar: $17000
 Employee Ozer: $11500
 Employee Partners: $13500
 Employee Raphaely: $11000
 Employee Russell: $14000
 Employee Vishney: $10500
 Employee Zlotkey: $10500

PL/SQL procedure successfully completed.

SQL> drop PROCEDURE print_results;

Succeed.

SQL> drop TYPE SalList force;

Succeed.

SQL> drop TYPE NameList force;

Succeed.

SQL> 
SQL> DECLARE
  2  CURSOR c1 IS
  3   SELECT first_name, last_name, hire_date FROM EMPLOYEES_UDT order by hire_date;
  4  TYPE NameSet IS TABLE OF c1%ROWTYPE;
  5  stock_managers NameSet; -- nested table of records
  6  TYPE cursor_var_type is REF CURSOR;
  7  cv cursor_var_type;
  8 BEGIN
  9  -- Assign values to nested table of records:
 10  OPEN cv FOR
 11   SELECT first_name, last_name, hire_date
 12     FROM EMPLOYEES_UDT
 13    WHERE job_id = 'ST_MAN'
 14    ORDER BY hire_date;
 15  FETCH cv BULK COLLECT
 16  INTO stock_managers;
 17  CLOSE cv;
 18  -- Print nested table of records:
 19  FOR i IN stock_managers.FIRST .. stock_managers.LAST LOOP
 20   dbe_output.print_line(stock_managers(i)
 21                        .hire_date || ' ' || stock_managers(i).last_name || ', ' || stock_managers(i)
 22                        .first_name);
 23  END LOOP;
 24 END;
 25 /

1995-05-01 00:00:00 Kaufling, Payam
1996-07-18 00:00:00 Weiss, Matthew
1997-04-10 00:00:00 Fripp, Adam
1997-10-10 00:00:00 Vollman, Shanta
1999-11-16 00:00:00 Mourgos, Kevin

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  TYPE numtab IS TABLE OF NUMBER;
  3  CURSOR c1 IS
  4   SELECT employee_id
  5     FROM EMPLOYEES_UDT
  6    WHERE department_id = 80
  7    ORDER BY employee_id;
  8  empids numtab;
  9 BEGIN
 10  OPEN c1;
 11  LOOP
 12   -- Fetch 10 rows or fewer in each iteration
 13   FETCH c1 BULK COLLECT
 14   INTO empids LIMIT 33;
 15   dbe_output.print_line('------- Results from One Bulk Fetch --------');
 16   FOR i IN 1 .. empids.COUNT LOOP
 17    dbe_output.print_line('Employee Id: ' || empids(i));
 18   END LOOP;
 19   EXIT WHEN c1%NOTFOUND;
 20  END LOOP;
 21  CLOSE c1;
 22 END;
 23 /

------- Results from One Bulk Fetch --------
Employee Id: 145
Employee Id: 146
Employee Id: 147
Employee Id: 148
Employee Id: 149
Employee Id: 150
Employee Id: 151
Employee Id: 152
Employee Id: 153
Employee Id: 154
Employee Id: 155
Employee Id: 156
Employee Id: 157
Employee Id: 158
Employee Id: 159
Employee Id: 160
Employee Id: 161
Employee Id: 162
Employee Id: 163
Employee Id: 164
Employee Id: 165
Employee Id: 166
Employee Id: 167
Employee Id: 168
Employee Id: 169
Employee Id: 170
Employee Id: 171
Employee Id: 172
Employee Id: 173
Employee Id: 174
Employee Id: 175
Employee Id: 176
Employee Id: 177
------- Results from One Bulk Fetch --------
Employee Id: 179

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2   x varchar(100) := 'SH_CLERK';
  3   y integer;
  4   query VARCHAR2(4000) := 'SELECT first_name, last_name, hire_date
  5     FROM EMPLOYEES_UDT
  6    WHERE job_id = :x and rownum <= :y
  7    ORDER BY hire_date';
  8   var_s1 EMPLOYEES_UDT.first_name%type;
  9   var_s2 EMPLOYEES_UDT.last_name%type;
 10   var_s3 EMPLOYEES_UDT.hire_date%type;
 11   cursor cv IS
 12   SELECT first_name, last_name, hire_date
 13     FROM EMPLOYEES_UDT
 14    WHERE job_id = 'ST_MAN'
 15    ORDER BY hire_date;
 16    var_rec cv%rowtype;
 17    TYPE c_r IS TABLE OF cv%rowtype;
 18    var_c_r c_r;
 19    type c_1 is table of EMPLOYEES_UDT.first_name%type;
 20    type c_2 is table of EMPLOYEES_UDT.last_name%type;
 21    type c_3 is table of EMPLOYEES_UDT.hire_date%type;
 22    var_c_1 c_1;
 23    var_c_2 c_2;
 24    var_c_3 c_3;
 25    
 26 BEGIN
 27   EXECUTE IMMEDIATE query INTO var_s1, var_s2, var_s3 USING x, 1;
 28   dbe_output.print_line('------------------------------------');
 29   dbe_output.print_line('Employee first_name = ' || var_s1 || ' last_name = ' || var_s2 || ' hire_date =' || var_s3);
 30   EXECUTE IMMEDIATE query INTO var_rec USING x, 1;
 31   dbe_output.print_line('Employee first_name = ' || var_rec.first_name || ' last_name = ' || var_rec.last_name || ' hire_date =' || var_rec.hire_date);
 32   dbe_output.print_line('------------------------------------');
 33   EXECUTE IMMEDIATE query BULK COLLECT INTO var_c_r USING x, 10;
 34   FOR i IN 1 .. var_c_r.COUNT LOOP
 35    dbe_output.print_line('Employee first_name: ' || var_c_r(i).first_name || 'Employee last_name: '|| var_c_r(i).first_name|| 'Employee hire_date: '|| var_c_r(i).first_name);
 36   END LOOP;
 37   dbe_output.print_line('------------------------------------');
 38 
 39   EXECUTE IMMEDIATE query BULK COLLECT INTO var_c_1, var_c_2, var_c_3 USING x, 100000000;
 40   FOR i IN 1 .. var_c_1.COUNT LOOP
 41    dbe_output.print_line('Employee first_name: ' || var_c_1(i) || 'Employee last_name: '|| var_c_2(i)|| 'Employee hire_date: '|| var_c_3(i));
 42   END LOOP;
 43 END;
 44 /

------------------------------------
Employee first_name = Donald last_name = OConnell hire_date =1999-06-21 00:00:00
Employee first_name = Donald last_name = OConnell hire_date =1999-06-21 00:00:00
------------------------------------
Employee first_name: NanditaEmployee last_name: NanditaEmployee hire_date: Nandita
Employee first_name: AlexisEmployee last_name: AlexisEmployee hire_date: Alexis
Employee first_name: WinstonEmployee last_name: WinstonEmployee hire_date: Winston
Employee first_name: JeanEmployee last_name: JeanEmployee hire_date: Jean
Employee first_name: JuliaEmployee last_name: JuliaEmployee hire_date: Julia
Employee first_name: AnthonyEmployee last_name: AnthonyEmployee hire_date: Anthony
Employee first_name: DonaldEmployee last_name: DonaldEmployee hire_date: Donald
Employee first_name: MarthaEmployee last_name: MarthaEmployee hire_date: Martha
Employee first_name: DouglasEmployee last_name: DouglasEmployee hire_date: Douglas
Employee first_name: GirardEmployee last_name: GirardEmployee hire_date: Girard
------------------------------------
Employee first_name: NanditaEmployee last_name: SarchandEmployee hire_date: 1996-01-27 00:00:00
Employee first_name: SarahEmployee last_name: BellEmployee hire_date: 1996-02-04 00:00:00
Employee first_name: AlexisEmployee last_name: BullEmployee hire_date: 1997-02-20 00:00:00
Employee first_name: BritneyEmployee last_name: EverettEmployee hire_date: 1997-03-03 00:00:00
Employee first_name: KellyEmployee last_name: ChungEmployee hire_date: 1997-06-14 00:00:00
Employee first_name: JenniferEmployee last_name: DillyEmployee hire_date: 1997-08-13 00:00:00
Employee first_name: WinstonEmployee last_name: TaylorEmployee hire_date: 1998-01-24 00:00:00
Employee first_name: JeanEmployee last_name: FleaurEmployee hire_date: 1998-02-23 00:00:00
Employee first_name: AlanaEmployee last_name: WalshEmployee hire_date: 1998-04-24 00:00:00
Employee first_name: KevinEmployee last_name: FeeneyEmployee hire_date: 1998-05-23 00:00:00
Employee first_name: JuliaEmployee last_name: DellingerEmployee hire_date: 1998-06-24 00:00:00
Employee first_name: SamuelEmployee last_name: McCainEmployee hire_date: 1998-07-01 00:00:00
Employee first_name: TimothyEmployee last_name: GatesEmployee hire_date: 1998-07-11 00:00:00
Employee first_name: AnthonyEmployee last_name: CabrioEmployee hire_date: 1999-02-07 00:00:00
Employee first_name: VanceEmployee last_name: JonesEmployee hire_date: 1999-03-17 00:00:00
Employee first_name: DonaldEmployee last_name: OConnellEmployee hire_date: 1999-06-21 00:00:00
Employee first_name: MarthaEmployee last_name: SullivanEmployee hire_date: 1999-06-21 00:00:00
Employee first_name: RandallEmployee last_name: PerkinsEmployee hire_date: 1999-12-19 00:00:00
Employee first_name: DouglasEmployee last_name: GrantEmployee hire_date: 2000-01-13 00:00:00
Employee first_name: GirardEmployee last_name: GeoniEmployee hire_date: 2000-02-03 00:00:00

PL/SQL procedure successfully completed.

SQL> 
SQL> DECLARE
  2  x      varchar(100) := 'SH_CLERK';
  3  var_s1 EMPLOYEES_UDT.first_name%type;
  4  var_s2 EMPLOYEES_UDT.last_name%type;
  5  var_s3 EMPLOYEES_UDT.hire_date%type;
  6  cursor cv IS
  7   SELECT first_name, last_name, hire_date
  8     FROM EMPLOYEES_UDT
  9    WHERE job_id = 'ST_MAN'
 10    ORDER BY hire_date;
 11  var_rec cv%rowtype;
 12  TYPE c_r IS TABLE OF cv%rowtype;
 13  var_c_r c_r;
 14  type c_1 is table of EMPLOYEES_UDT.first_name%type;
 15  type c_2 is table of EMPLOYEES_UDT.last_name%type;
 16  type c_3 is table of EMPLOYEES_UDT.hire_date%type;
 17  var_c_1 c_1;
 18  var_c_2 c_2;
 19  var_c_3 c_3;
 20 
 21 BEGIN
 22  SELECT first_name, last_name, hire_date
 23    INTO var_s1, var_s2, var_s3
 24    FROM EMPLOYEES_UDT
 25   WHERE job_id = x
 26     and rownum = 1
 27   ORDER BY hire_date;
 28 
 29  dbe_output.print_line('------------------------------------');
 30  dbe_output.print_line('Employee first_name = ' || var_s1 ||
 31                       ' last_name = ' || var_s2 || ' hire_date =' ||
 32                       var_s3);
 33  SELECT first_name, last_name, hire_date
 34    INTO var_rec
 35    FROM EMPLOYEES_UDT
 36   WHERE job_id = x
 37     and rownum = 1
 38   ORDER BY hire_date;
 39  dbe_output.print_line('Employee first_name = ' || var_rec.first_name ||
 40                       ' last_name = ' || var_rec.last_name ||
 41                       ' hire_date =' || var_rec.hire_date);
 42 
 43  dbe_output.print_line('------------------------------------');
 44 
 45  SELECT first_name, last_name, hire_date BULK COLLECT INTO var_c_r
 46    FROM EMPLOYEES_UDT
 47   WHERE job_id = x
 48   ORDER BY hire_date;
 49  FOR i IN 1 .. var_c_r.COUNT LOOP
 50   dbe_output.print_line('Employee first_name: ' || var_c_r(i).first_name ||
 51                        'Employee last_name: ' || var_c_r(i).first_name ||
 52                        'Employee hire_date: ' || var_c_r(i).first_name);
 53  END LOOP;
 54  dbe_output.print_line('------------------------------------');
 55 
 56  SELECT first_name,
 57         last_name,
 58         hire_date BULK COLLECT INTO var_c_1,
 59         var_c_2,
 60         var_c_3
 61    FROM EMPLOYEES_UDT
 62   WHERE job_id = x
 63   ORDER BY hire_date;
 64  FOR i IN 1 .. var_c_1.COUNT LOOP
 65   dbe_output.print_line('Employee first_name: ' || var_c_1(i) ||
 66                        'Employee last_name: ' || var_c_2(i) ||
 67                        'Employee hire_date: ' || var_c_3(i));
 68  END LOOP;
 69 END;
 70 /

------------------------------------
Employee first_name = Donald last_name = OConnell hire_date =1999-06-21 00:00:00
Employee first_name = Donald last_name = OConnell hire_date =1999-06-21 00:00:00
------------------------------------
Employee first_name: NanditaEmployee last_name: NanditaEmployee hire_date: Nandita
Employee first_name: SarahEmployee last_name: SarahEmployee hire_date: Sarah
Employee first_name: AlexisEmployee last_name: AlexisEmployee hire_date: Alexis
Employee first_name: BritneyEmployee last_name: BritneyEmployee hire_date: Britney
Employee first_name: KellyEmployee last_name: KellyEmployee hire_date: Kelly
Employee first_name: JenniferEmployee last_name: JenniferEmployee hire_date: Jennifer
Employee first_name: WinstonEmployee last_name: WinstonEmployee hire_date: Winston
Employee first_name: JeanEmployee last_name: JeanEmployee hire_date: Jean
Employee first_name: AlanaEmployee last_name: AlanaEmployee hire_date: Alana
Employee first_name: KevinEmployee last_name: KevinEmployee hire_date: Kevin
Employee first_name: JuliaEmployee last_name: JuliaEmployee hire_date: Julia
Employee first_name: SamuelEmployee last_name: SamuelEmployee hire_date: Samuel
Employee first_name: TimothyEmployee last_name: TimothyEmployee hire_date: Timothy
Employee first_name: AnthonyEmployee last_name: AnthonyEmployee hire_date: Anthony
Employee first_name: VanceEmployee last_name: VanceEmployee hire_date: Vance
Employee first_name: DonaldEmployee last_name: DonaldEmployee hire_date: Donald
Employee first_name: MarthaEmployee last_name: MarthaEmployee hire_date: Martha
Employee first_name: RandallEmployee last_name: RandallEmployee hire_date: Randall
Employee first_name: DouglasEmployee last_name: DouglasEmployee hire_date: Douglas
Employee first_name: GirardEmployee last_name: GirardEmployee hire_date: Girard
------------------------------------
Employee first_name: NanditaEmployee last_name: SarchandEmployee hire_date: 1996-01-27 00:00:00
Employee first_name: SarahEmployee last_name: BellEmployee hire_date: 1996-02-04 00:00:00
Employee first_name: AlexisEmployee last_name: BullEmployee hire_date: 1997-02-20 00:00:00
Employee first_name: BritneyEmployee last_name: EverettEmployee hire_date: 1997-03-03 00:00:00
Employee first_name: KellyEmployee last_name: ChungEmployee hire_date: 1997-06-14 00:00:00
Employee first_name: JenniferEmployee last_name: DillyEmployee hire_date: 1997-08-13 00:00:00
Employee first_name: WinstonEmployee last_name: TaylorEmployee hire_date: 1998-01-24 00:00:00
Employee first_name: JeanEmployee last_name: FleaurEmployee hire_date: 1998-02-23 00:00:00
Employee first_name: AlanaEmployee last_name: WalshEmployee hire_date: 1998-04-24 00:00:00
Employee first_name: KevinEmployee last_name: FeeneyEmployee hire_date: 1998-05-23 00:00:00
Employee first_name: JuliaEmployee last_name: DellingerEmployee hire_date: 1998-06-24 00:00:00
Employee first_name: SamuelEmployee last_name: McCainEmployee hire_date: 1998-07-01 00:00:00
Employee first_name: TimothyEmployee last_name: GatesEmployee hire_date: 1998-07-11 00:00:00
Employee first_name: AnthonyEmployee last_name: CabrioEmployee hire_date: 1999-02-07 00:00:00
Employee first_name: VanceEmployee last_name: JonesEmployee hire_date: 1999-03-17 00:00:00
Employee first_name: DonaldEmployee last_name: OConnellEmployee hire_date: 1999-06-21 00:00:00
Employee first_name: MarthaEmployee last_name: SullivanEmployee hire_date: 1999-06-21 00:00:00
Employee first_name: RandallEmployee last_name: PerkinsEmployee hire_date: 1999-12-19 00:00:00
Employee first_name: DouglasEmployee last_name: GrantEmployee hire_date: 2000-01-13 00:00:00
Employee first_name: GirardEmployee last_name: GeoniEmployee hire_date: 2000-02-03 00:00:00

PL/SQL procedure successfully completed.

SQL> DROP TABLE EMPLOYEES_UDT PURGE;

Succeed.

SQL> DROP TABLE JOBS PURGE;

Succeed.

SQL> 
SQL> --returning...bulk collect into
SQL> DROP TABLE if exists test_returning_bulkinto;

Succeed.

SQL> create table test_returning_bulkinto (a VARCHAR2(10), b VARCHAR2(10), c VARCHAR2(10));

Succeed.

SQL> insert into test_returning_bulkinto values ('a','a','a');

1 rows affected.

SQL> insert into test_returning_bulkinto values ('a','a','a');

1 rows affected.

SQL> insert into test_returning_bulkinto values ('a','b','a');

1 rows affected.

SQL> insert into test_returning_bulkinto values ('a','b','a');

1 rows affected.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      test_returning_bulkinto.a%TYPE,
  5      rb      test_returning_bulkinto.b%TYPE,
  6      rc   test_returning_bulkinto.c%TYPE
  7    );
  8    TYPE nested_emp_type1 IS TABLE OF emp_rec_type;
  9    emp_tab   nested_emp_type1;
 10 begin
 11   update test_returning_bulkinto set a='b' where a='a' returning a,b,c bulk collect into emp_tab;
 12   dbe_output.print_line('emp_tab');
 13   for i in 1..emp_tab.count loop
 14   dbe_output.print_line(emp_tab(i).ra||' '||emp_tab(i).rb||' '||emp_tab(i).rc);
 15   end loop;
 16 end;
 17 /

emp_tab
b a a
b a a
b b a
b b a

PL/SQL procedure successfully completed.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      test_returning_bulkinto.a%TYPE,
  5      rb      test_returning_bulkinto.b%TYPE,
  6      rc      test_returning_bulkinto.c%TYPE
  7    );
  8    TYPE nested_emp_type IS TABLE OF emp_rec_type;
  9    emp_tab   nested_emp_type;
 10 begin
 11   insert into test_returning_bulkinto (a, b ,c)
 12   values ('aa', 'bb','cc')
 13   returning a,b,c bulk collect into emp_tab;
 14   dbe_output.print_line('emp_tab');
 15   for i in 1..emp_tab.count loop
 16   dbe_output.print_line(emp_tab(i).ra||' '||emp_tab(i).rb||' '||emp_tab(i).rc);
 17   end loop;
 18 end;
 19 /

emp_tab
aa bb cc

PL/SQL procedure successfully completed.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      test_returning_bulkinto.a%TYPE,
  5      rb      test_returning_bulkinto.b%TYPE,
  6      rc      test_returning_bulkinto.c%TYPE
  7    );
  8    TYPE nested_emp_type IS TABLE OF emp_rec_type;
  9    emp_tab   nested_emp_type;
 10 begin
 11   delete from test_returning_bulkinto where b='b'
 12   returning a,b,c bulk collect into emp_tab;
 13   dbe_output.print_line('emp_tab');
 14   for i in 1..emp_tab.count loop
 15   dbe_output.print_line(emp_tab(i).ra||' '||emp_tab(i).rb||' '||emp_tab(i).rc);
 16   end loop;
 17 end;
 18 /

emp_tab
b b a
b b a

PL/SQL procedure successfully completed.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      test_returning_bulkinto.a%TYPE,
  5      rb      test_returning_bulkinto.b%TYPE,
  6      rc   test_returning_bulkinto.c%TYPE
  7    );
  8    TYPE nested_emp_type1 IS TABLE OF emp_rec_type;
  9    emp_tab   nested_emp_type1;
 10    CURSOR c1 IS SELECT a, b,c FROM test_returning_bulkinto;
 11 begin
 12   open c1;
 13   fetch c1 bulk collect into emp_tab;
 14   close c1;
 15   dbe_output.print_line('emp_tab');
 16   for i in 1..emp_tab.count loop
 17   dbe_output.print_line(emp_tab(i).ra||' '||emp_tab(i).rb||' '||emp_tab(i).rc);
 18   end loop;
 19 end;
 20 /

emp_tab
b a a
b a a
aa bb cc

PL/SQL procedure successfully completed.

SQL> DECLARE
  2    TYPE nested_emp_type1 IS TABLE OF VARCHAR2(10);
  3    emp_tab1   nested_emp_type1;
  4    emp_tab2   nested_emp_type1;
  5    TYPE nested_emp_type2 IS varray(10) OF VARCHAR2(10);
  6    emp_tab3   nested_emp_type2;
  7 begin
  8   update test_returning_bulkinto set a='a' where a='b' returning a,b,c bulk collect into emp_tab1,emp_tab2,emp_tab3;

  9   for i in 1..emp_tab1.count loop
 10   dbe_output.print_line(emp_tab1(i)||' '||emp_tab2(i)||' '||emp_tab3(i));
 11   end loop;
 12 end;
 13 /

a a a
a a a

PL/SQL procedure successfully completed.

SQL> DROP TABLE if exists test_returning_bulkinto;

Succeed.

SQL> create table test_returning_bulkinto (f1 int, f2 int, f3 int);

Succeed.

SQL> insert into test_returning_bulkinto values (1,1,1);

1 rows affected.

SQL> insert into test_returning_bulkinto values (1,1,2);

1 rows affected.

SQL> insert into test_returning_bulkinto values (1,1,2);

1 rows affected.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      test_returning_bulkinto.f1%TYPE,
  5      rb      test_returning_bulkinto.f2%TYPE,
  6      rc      test_returning_bulkinto.f3%TYPE
  7    );
  8    TYPE nested_emp_type1 IS TABLE OF emp_rec_type;
  9    emp_tab   nested_emp_type1;
 10 begin
 11   update test_returning_bulkinto set f1=2 where f1=1 returning f1+1,f2*f2,null bulk collect into emp_tab;
 12   dbe_output.print_line('count:' || emp_tab.count);
 13   dbe_output.print_line('emp_tab:  ' );
 14   FOR i IN emp_tab.FIRST .. emp_tab.LAST
 15    LOOP
 16       dbe_output.print_line(emp_tab(i).ra||'  '||emp_tab(i).rb||'  '||emp_tab(i).rc);
 17    END LOOP;
 18 end;
 19 /

count:3
emp_tab:
3  1
3  1
3  1

PL/SQL procedure successfully completed.

SQL> DECLARE
  2   sa int;
  3   sb int;
  4   sc int;
  5 begin
  6   update test_returning_bulkinto set f1=1 where f2=1 returning f1,f2,f3 into sa, sb, sc;
  7   dbe_output.print_line(sa||'  '||sb||'  '||sc);
  8 end;
  9 /

CT-00932, [6:3] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[6:3] CT-00613, Invalid operation, exact fetch returns more than requested number of rows

SQL> delete from test_returning_bulkinto where f3=2;

2 rows affected.

SQL> DECLARE
  2   sa int;
  3   sb int;
  4   sc int;
  5 begin
  6   update test_returning_bulkinto set f1=1 where f2=1 returning f1,f2,f3 into sa, sb, sc;
  7   dbe_output.print_line(sa||'  '||sb||'  '||sc);
  8 end;
  9 /

1  1  1

PL/SQL procedure successfully completed.

SQL> DECLARE
  2   sa int;
  3   sb int;
  4   sc int;
  5 begin
  6   insert into test_returning_bulkinto(f1,f2,f3) values (1,1,2) returning f1,f2,f3 into sa, sb, sc;
  7   dbe_output.print_line(sa||'  '||sb||'  '||sc);
  8 end;
  9 /

1  1  2

PL/SQL procedure successfully completed.

SQL> DECLARE
  2   sa int;
  3   sb int;
  4   sc int;
  5 begin
  6   delete from test_returning_bulkinto where f3=2 returning f1,f2,f3 into sa, sb, sc;
  7   dbe_output.print_line(sa||'  '||sb||'  '||sc);
  8 end;
  9 /

1  1  2

PL/SQL procedure successfully completed.

SQL> DECLARE
  2    TYPE emp_rec_type IS RECORD
  3    (
  4      ra      int,
  5      rb      int,
  6      rc      int
  7    );
  8    emp_tab   emp_rec_type;
  9 begin
 10   insert into test_returning_bulkinto(f1,f2,f3) values (1,1,2) returning f1,f2,f3 into emp_tab;
 11   dbe_output.print_line(emp_tab.ra||'  '||emp_tab.rb||'  '||emp_tab.rc);
 12 end;
 13 /

1  1  2

PL/SQL procedure successfully completed.

SQL> DROP TABLE test_returning_bulkinto;

Succeed.

SQL> 
SQL> --DTS2019111307418
SQL> drop table if exists fvt_0011;

Succeed.

SQL> create table fvt_0011(a int,b int,c int);

Succeed.

SQL> insert into fvt_0011 values(1,2,3);

1 rows affected.

SQL> drop table if exists fvt_11;

Succeed.

SQL> create table fvt_11(a int,b int);

Succeed.

SQL> insert into fvt_11 values(1,2);

1 rows affected.

SQL> declare
  2 red11 fvt_11%rowtype;
  3 red0011 fvt_0011%rowtype;
  4 begin
  5 for i in (select * from fvt_11) loop
  6 red11 := i;
  7 red0011 := red11;
  8 dbe_output.print_line(red0011.a);
  9 end loop;
 10 end;
 11 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:12] PLC-00965 Expression is of wrong type
[11:1] PLC-00954 more text expected but EOF found

SQL> drop table fvt_0011;

Succeed.

SQL> drop table fvt_11;

Succeed.

SQL> 
SQL> --DTS2019111414436
SQL> drop type if exists nt_type force;

Succeed.

SQL> create or replace type nt_type is varray(7) of varchar(10);
  2 /

Succeed.

SQL> declare
  2     nt nt_type := nt_type('a','s','null','w','e');
  3 BEGIN
  4     nt.trim(null);
  5     dbe_output.print_line(nt.count);
  6 end;
  7 /

5

PL/SQL procedure successfully completed.

SQL> declare
  2     nt nt_type := nt_type('a','s','null','w','e');
  3 BEGIN
  4     nt.extend(1, null);
  5     dbe_output.print_line(nt.count);
  6 end;
  7 /

5

PL/SQL procedure successfully completed.

SQL> drop type nt_type force;

Succeed.

SQL> declare
  2     TYPE nt_type IS TABLE OF varchar(10);
  3     nt nt_type := nt_type('a','s','null','w','e');
  4 BEGIN
  5     nt.delete(null, 2);
  6     dbe_output.print_line(nt.count) ;
  7 end;
  8 /

5

PL/SQL procedure successfully completed.

SQL> 
SQL> drop table if exists t_objects;

Succeed.

SQL> create table t_objects as select * from user_objects; 

Succeed.

SQL> 
SQL> declare
  2 type nt_object is table of t_objects%rowtype;
  3 vnt_object_bulk nt_object;
  4 begin
  5 select * bulk collect into vnt_object_bulk from t_objects;
  6 end;
  7 /

PL/SQL procedure successfully completed.

SQL> 
SQL> 
SQL> declare
  2   type nt_object is table of t_objects%rowtype;
  3   vnt_object_bulk nt_object;
  4   vnt_object      nt_object := nt_object();
  5   c_big_number    number := power(2, 31);
  6   l_start_time    number;
  7   cursor cur_object is
  8     select * from t_objects;
  9 begin
 10   dbe_output.print_line('========BULK COLLECT LIMIT==========');
 11   l_start_time := dbe_util.get_date_time;
 12   open cur_object;
 13   loop
 14     fetch cur_object bulk collect
 15       into vnt_object_bulk limit 100;
 16     exit when cur_object%notfound;
 17     for i in vnt_object_bulk.first .. vnt_object_bulk.last loop
 18       vnt_object.extend;
 19       vnt_object(vnt_object.last) := vnt_object_bulk(i);
 20     end loop;
 21   end loop;
 22   close cur_object;
 23 end;
 24 /

========BULK COLLECT LIMIT==========

PL/SQL procedure successfully completed.

SQL> drop table t_objects;

Succeed.

SQL> 
SQL> drop table if exists SHORT_TABLE;

Succeed.

SQL> CREATE  TABLE SHORT_TABLE(F1 INT,F2 INT);

Succeed.

SQL> create OR REPLACE procedure my_proc_5 
  2 is
  3 x int;
  4 begin
  5 FOR R IN 1..97 LOOP
  6 INSERT INTO SHORT_TABLE VALUES(R,R+1);
  7 END LOOP;
  8 END;
  9 /

Succeed.

SQL> call my_proc_5;

PL/SQL procedure successfully completed.

SQL> creATE OR REPLACE TYPE SHORT_OBJ IS OBJECT(F1 INT, f2 int);
  2 /

Succeed.

SQL> creATE OR REPLACE TYPE SHORT_ARR IS TABLE OF SHORT_OBJ;
  2 /

Succeed.

SQL> create or replace procedure my_proc_6 is
  2   xxx SHORT_ARR ;
  3     l_my_table_tab SHORT_ARR ;
  4     n integer := 0;
  5   begin
  6     l_my_table_tab := SHORT_ARR();
  7 	for r in (select f1,f2 from SHORT_TABLE)
  8     loop
  9 		l_my_table_tab.extend;
 10 		n := n + 1;
 11 		l_my_table_tab(n) := SHORT_OBJ(r.f1, r.f2);
 12 	end loop;
 13 	xxx :=l_my_table_tab;
 14 	dbe_output.print_line(xxx(97).f1);
 15   end;
 16   /

Succeed.

SQL> call my_proc_6;

97

PL/SQL procedure successfully completed.

SQL> drop TABLE SHORT_TABLE;

Succeed.
SQL> drop TYPE SHORT_OBJ force;

Succeed.

SQL> drop TYPE SHORT_ARR force;

Succeed.

SQL> drop procedure my_proc_6;

Succeed.

SQL> drop procedure my_proc_5;

Succeed.

SQL> 
SQL> --DTS2020011001606
SQL> create or replace type array_number is table of number(20);
  2 /

Succeed.

SQL> drop table if exists t_user;

Succeed.

SQL> create table t_user(userid number,phone varchar2(11));

Succeed.

SQL> declare 
  2   numarr_result array_number := array_number(1,1,1);
  3   v_count number;
  4 begin
  5   delete from t_user where userid = 1 
  6    returning userid bulk collect into  numarr_result;   
  7   dbe_output.print_line('numarr_result count:' ||numarr_result.count);
  8 end;
  9 /

numarr_result count:0

PL/SQL procedure successfully completed.

SQL> drop table t_user;

Succeed.

SQL>
SQL> create table t_user(userid number,phone varchar2(11));

Succeed.

SQL> insert into t_user values(1,'2');

1 rows affected.

SQL> declare
  2   v_count number;
  3 begin
  4    delete from t_user returning userid into v_count;
  5    dbe_output.print_line(v_count);
  6 end;
  7 /

1

PL/SQL procedure successfully completed.

SQL> drop table t_user;

Succeed.

SQL> 
SQL> 
SQL> --Uninitialized object--write error
SQL> CREATE OR REPLACE TYPE sdc Force as object(name varchar2(36));
  2 /

Succeed.

SQL> 
SQL> declare
  2 s sdc;
  3 begin
  4 s.name :=1;
  5 DBE_output.print_line(s.name || 1);
  6 end;
  7 /

CT-00932, [4:1] PL/SQL(SYS.ANONYMOUS BLOCK) terminated with execute errors
[4:1] CT-00901, The referenced object type was not initialized.

SQL> ---------read success
SQL> declare
  2 s sdc;
  3 begin
  4 DBE_output.print_line(s.name || 1);
  5 end;
  6 /

1

PL/SQL procedure successfully completed.

SQL> drop TYPE sdc;

Succeed.

SQL>
SQL> drop table if exists fvt_01;

Succeed.

SQL> create table fvt_01 (a varchar2(15),b int,c varchar2(15));

Succeed.

SQL> insert into fvt_01 values(' ',null,lpad('12',10,'ha'));

1 rows affected.

SQL> insert into fvt_01 values('null',123,lpad('12',10,'ha'));

1 rows affected.

SQL> insert into fvt_01 values(lpad('12',10,'ha'),'',lpad('12',10,'ha'));

1 rows affected.

SQL>
SQL> set serveroutput on;

ON
SQL> create or replace type varray2 is VARRAY(3) OF varchar2(15);
  2 /

Succeed.

SQL> create or replace type varray02 is varray(3) of int;
  2 /

Succeed.

SQL> declare
  2 var2 varray2;
  3 cursor cur_02 is select b from fvt_01;
  4 var02 varray02;
  5 begin
  6 select a bulk collect into var2  from fvt_01;
  7 for i in 1..var2.count loop
  8         dbe_output.print_line(var2(i));
  9         end loop;
 10
 11         begin
 12         open cur_02;
 13         fetch cur_02 bulk collect into var02;
 14         for i in var02.first..var02.last loop
 15                 dbe_output.print_line(var02(i));
 16         end loop;
 17         close cur_02;
 18         end;
 19 end;
 20 /


null
hahahaha12

123


PL/SQL procedure successfully completed.

SQL> 
SQL> set serveroutput off;

OFF
SQL> --DTS202104280ID10ZP1M00
SQL> CONN / AS SYSDBA

connected.

SQL> SET SERVEROUTPUT ON

ON
SQL> CREATE OR REPLACE TYPE TYPE_DTS202104280ID10ZP1M00 FORCE AS OBJECT(id int,name varchar(10));
  2 /

Succeed.

SQL> CREATE OR REPLACE SYNONYM TYPE_DTS202104280ID10ZP1M00_LOCAL FOR TYPE_DTS202104280ID10ZP1M00;

Succeed.

SQL> CREATE OR REPLACE PUBLIC SYNONYM TYPE_DTS202104280ID10ZP1M00_PUBLIC FOR TYPE_DTS202104280ID10ZP1M00;

Succeed.

SQL> DECLARE
  2  x TYPE_DTS202104280ID10ZP1M00;
  3  y TYPE_DTS202104280ID10ZP1M00_LOCAL;
  4  z TYPE_DTS202104280ID10ZP1M00_PUBLIC;
  5 BEGIN
  6  x := TYPE_DTS202104280ID10ZP1M00(1, 'xxx');
  7  y := TYPE_DTS202104280ID10ZP1M00_LOCAL(2, 'yyy');
  8  z := TYPE_DTS202104280ID10ZP1M00_PUBLIC(3, 'zzz');
  9  DBE_OUTPUT.PRINT_LINE('x:'||x.id||x.name);
 10  DBE_OUTPUT.PRINT_LINE('y:'||y.id||y.name);
 11  DBE_OUTPUT.PRINT_LINE('z:'||z.id||z.name);
 12 END;
 13 /

x:1xxx
y:2yyy
z:3zzz

PL/SQL procedure successfully completed.

SQL> DROP TYPE TYPE_DTS202104280ID10ZP1M00;

Succeed.

SQL> DROP SYNONYM TYPE_DTS202104280ID10ZP1M00_LOCAL;

Succeed.

SQL> DROP PUBLIC SYNONYM TYPE_DTS202104280ID10ZP1M00_PUBLIC;

Succeed.

SQL> set serveroutput off;

OFF
SQL> 
SQL> --DTS202104290PCME4P1H00
SQL> SET SERVEROUTPUT ON

ON
SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T1;

Succeed.

SQL> CREATE TABLE DTS202104290PCME4P1H00_T1(C1 INT);

Succeed.

SQL> DECLARE
  2   CURSOR CURSOR1 IS SELECT 20210429 FROM SYS_DUMMY;
  3   TYPE1 DTS202104290PCME4P1H00_T1%ROWTYPE;
  4 BEGIN
  5   OPEN CURSOR1;
  6   LOOP
  7     FETCH CURSOR1 INTO TYPE1;
  8     EXIT WHEN CURSOR1%NOTFOUND;
  9     DBE_OUTPUT.PRINT_LINE(TYPE1.C1);
 10     END LOOP;
 11   CLOSE CURSOR1;
 12 END;
 13 /

20210429

PL/SQL procedure successfully completed.

SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T1;

Succeed.

SQL> CREATE TABLE DTS202104290PCME4P1H00_T1(C1 INT,C2 INT);

Succeed.

SQL> DECLARE
  2   CURSOR CURSOR1 IS SELECT 20210429 FROM SYS_DUMMY;
  3   TYPE1 DTS202104290PCME4P1H00_T1%ROWTYPE;
  4 BEGIN
  5   OPEN CURSOR1;
  6   LOOP
  7     FETCH CURSOR1 INTO TYPE1;
  8     EXIT WHEN CURSOR1%NOTFOUND;
  9     DBE_OUTPUT.PRINT_LINE(TYPE1.C1);
 10   END LOOP;
 11   CLOSE CURSOR1;
 12 END;
 13 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[7:5] PLC-00926 PL/SQL: Return types of Result Set variables or query do not match

SQL> 
SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T2;

Succeed.

SQL> CREATE TABLE DTS202104290PCME4P1H00_T2(C1 INT);

Succeed.

SQL> DECLARE
  2   CURSOR CURSOR1 IS SELECT 20210429 FROM SYS_DUMMY;
  3   TYPE1 DTS202104290PCME4P1H00_T2%ROWTYPE;
  4   TYPE2 DTS202104290PCME4P1H00_T2.C1%TYPE;
  5 BEGIN
  6   OPEN CURSOR1;
  7   LOOP
  8     FETCH CURSOR1 INTO TYPE1;
  9     EXIT WHEN CURSOR1%NOTFOUND;
 10     DBE_OUTPUT.PRINT_LINE(TYPE1.C1);
 11     TYPE2 := TYPE1.C1;
 12     DBE_OUTPUT.PRINT_LINE(TYPE2);
 13   END LOOP;
 14   CLOSE CURSOR1;
 15 END;
 16 /

20210429
20210429

PL/SQL procedure successfully completed.

SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T2;

Succeed.

SQL> CREATE TABLE DTS202104290PCME4P1H00_T2(C1 INT,C2 INT);

Succeed.

SQL> DECLARE
  2   CURSOR CURSOR1 IS SELECT 20210429 FROM SYS_DUMMY;
  3   TYPE1 DTS202104290PCME4P1H00_T2%ROWTYPE;
  4   TYPE2 DTS202104290PCME4P1H00_T2.C1%TYPE;
  5 BEGIN
  6   OPEN CURSOR1;
  7   LOOP
  8     FETCH CURSOR1 INTO TYPE1;
  9     EXIT WHEN CURSOR1%NOTFOUND;
 10     DBE_OUTPUT.PRINT_LINE(TYPE1.C1);
 11     TYPE2 := TYPE1.C1;
 12     DBE_OUTPUT.PRINT_LINE(TYPE2);
 13   END LOOP;
 14   CLOSE CURSOR1;
 15 END;
 16 /

CT-00944, PL/SQL(SYS.ANONYMOUS BLOCK) terminated with compiling errors
[8:5] PLC-00926 PL/SQL: Return types of Result Set variables or query do not match

SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T1;

Succeed.

SQL> DROP TABLE IF EXISTS DTS202104290PCME4P1H00_T2;

Succeed.

SQL> SET SERVEROUTPUT OFF

OFF
SQL> 
SQL> --DTS202105220EVH0FP0D00 START plsql objects cannot rely on temporary tables
SQL> CONN / AS SYSDBA

connected.

SQL> ALTER SYSTEM SET LOCAL_TEMPORARY_TABLE_ENABLED = TRUE;

Succeed.

SQL> DROP TABLE IF EXISTS #DTS202105220EVH0FP0D00_T1;

Succeed.

SQL> CREATE TEMPORARY TABLE #DTS202105220EVH0FP0D00_T1(c1 int);

Succeed.

SQL> DECLARE
  2   TYPE1 #DTS202105220EVH0FP0D00_T1%ROWTYPE;
  3   TYPE2 #DTS202105220EVH0FP0D00_T1.C1%TYPE;
  4 BEGIN
  5  NULL;
  6 END;
  7 /

PL/SQL procedure successfully completed.

SQL> CONN / AS SYSDBA

connected.

SQL> SELECT SQL_TEXT FROM DV_ANONYMOUS WHERE SQL_TEXT LIKE '%DTS202105220EVH0FP0D00%' ORDER BY SQL_TEXT;

SQL_TEXT                                                        
----------------------------------------------------------------

0 rows fetched.

SQL> DROP TABLE IF EXISTS #DTS202105220EVH0FP0D00_T1;

Succeed.

SQL> DROP TABLE IF EXISTS DTS202105220EVH0FP0D00_T1;

Succeed.

SQL> CREATE TEMPORARY TABLE #DTS202105220EVH0FP0D00_T1(c1 int);

Succeed.

SQL> CREATE TABLE DTS202105220EVH0FP0D00_T1(c1 int);

Succeed.

SQL> CREATE OR REPLACE PROCEDURE DTS202105220EVH0FP0D00_PROC1(V1 INT) IS
  2   TYPE1 #DTS202105220EVH0FP0D00_T1%ROWTYPE;
  3   TYPE2 #DTS202105220EVH0FP0D00_T1.C1%TYPE;
  4   TYPE3 DTS202105220EVH0FP0D00_T1%ROWTYPE;
  5 BEGIN
  6   NULL;
  7 END;
  8 /

Succeed.

SQL> SELECT NAME, REFERENCED_NAME FROM MY_DEPENDENCIES WHERE NAME='DTS202105220EVH0FP0D00_PROC1';

NAME                                                             REFERENCED_NAME                                                 
---------------------------------------------------------------- ----------------------------------------------------------------
DTS202105220EVH0FP0D00_PROC1                                     DTS202105220EVH0FP0D00_T1                                       

1 rows fetched.

SQL> CALL DTS202105220EVH0FP0D00_PROC1(1);

PL/SQL procedure successfully completed.

SQL> SELECT SQL_TEXT FROM DV_ANONYMOUS WHERE SQL_TEXT LIKE '%DTS202105220EVH0FP0D00%' ORDER BY SQL_TEXT;

SQL_TEXT                                                        
----------------------------------------------------------------

0 rows fetched.

SQL> CONN / AS SYSDBA

connected.

SQL> DROP TABLE IF EXISTS #DTS202105220EVH0FP0D00_T1;

Succeed.

SQL> DROP TABLE IF EXISTS DTS202105220EVH0FP0D00_T1;

Succeed.

SQL> DROP PROCEDURE IF EXISTS DTS202105220EVH0FP0D00_PROC1;

Succeed.

SQL> --DTS202105220EVH0FP0D00 END


